import {
  computed,
  createCommentVNode,
  createElementBlock,
  inject,
  onMounted,
  onUnmounted,
  openBlock,
  provide,
  reactive,
  ref,
  renderSlot,
  toRefs,
  watch,
  watchEffect
} from "./chunk-QO6ZHO7P.js";

// node_modules/vue3-openlayers/dist/vue3-openlayers.es.js
var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a2, b2) => {
  for (var prop in b2 || (b2 = {}))
    if (__hasOwnProp.call(b2, prop))
      __defNormalProp(a2, prop, b2[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b2)) {
      if (__propIsEnum.call(b2, prop))
        __defNormalProp(a2, prop, b2[prop]);
    }
  return a2;
};
var __spreadProps = (a2, b2) => __defProps(a2, __getOwnPropDescs(b2));
var Disposable = function() {
  function Disposable2() {
    this.disposed = false;
  }
  Disposable2.prototype.dispose = function() {
    if (!this.disposed) {
      this.disposed = true;
      this.disposeInternal();
    }
  };
  Disposable2.prototype.disposeInternal = function() {
  };
  return Disposable2;
}();
var Disposable$1 = Disposable;
function binarySearch(haystack, needle, opt_comparator) {
  var mid, cmp;
  var comparator = opt_comparator || numberSafeCompareFunction;
  var low = 0;
  var high = haystack.length;
  var found = false;
  while (low < high) {
    mid = low + (high - low >> 1);
    cmp = +comparator(haystack[mid], needle);
    if (cmp < 0) {
      low = mid + 1;
    } else {
      high = mid;
      found = !cmp;
    }
  }
  return found ? low : ~low;
}
function numberSafeCompareFunction(a2, b2) {
  return a2 > b2 ? 1 : a2 < b2 ? -1 : 0;
}
function includes(arr, obj) {
  return arr.indexOf(obj) >= 0;
}
function linearFindNearest(arr, target, direction2) {
  var n2 = arr.length;
  if (arr[0] <= target) {
    return 0;
  } else if (target <= arr[n2 - 1]) {
    return n2 - 1;
  } else {
    var i2 = void 0;
    if (direction2 > 0) {
      for (i2 = 1; i2 < n2; ++i2) {
        if (arr[i2] < target) {
          return i2 - 1;
        }
      }
    } else if (direction2 < 0) {
      for (i2 = 1; i2 < n2; ++i2) {
        if (arr[i2] <= target) {
          return i2;
        }
      }
    } else {
      for (i2 = 1; i2 < n2; ++i2) {
        if (arr[i2] == target) {
          return i2;
        } else if (arr[i2] < target) {
          if (typeof direction2 === "function") {
            if (direction2(target, arr[i2 - 1], arr[i2]) > 0) {
              return i2 - 1;
            } else {
              return i2;
            }
          } else if (arr[i2 - 1] - target < target - arr[i2]) {
            return i2 - 1;
          } else {
            return i2;
          }
        }
      }
    }
    return n2 - 1;
  }
}
function reverseSubArray(arr, begin, end) {
  while (begin < end) {
    var tmp = arr[begin];
    arr[begin] = arr[end];
    arr[end] = tmp;
    ++begin;
    --end;
  }
}
function extend$3(arr, data2) {
  var extension = Array.isArray(data2) ? data2 : [data2];
  var length = extension.length;
  for (var i2 = 0; i2 < length; i2++) {
    arr[arr.length] = extension[i2];
  }
}
function equals$2(arr1, arr2) {
  var len1 = arr1.length;
  if (len1 !== arr2.length) {
    return false;
  }
  for (var i2 = 0; i2 < len1; i2++) {
    if (arr1[i2] !== arr2[i2]) {
      return false;
    }
  }
  return true;
}
function isSorted(arr, opt_func, opt_strict) {
  var compare = opt_func || numberSafeCompareFunction;
  return arr.every(function(currentVal, index2) {
    if (index2 === 0) {
      return true;
    }
    var res = compare(arr[index2 - 1], currentVal);
    return !(res > 0 || opt_strict && res === 0);
  });
}
function TRUE() {
  return true;
}
function FALSE() {
  return false;
}
function VOID() {
}
function memoizeOne(fn) {
  var called = false;
  var lastResult;
  var lastArgs;
  var lastThis;
  return function() {
    var nextArgs = Array.prototype.slice.call(arguments);
    if (!called || this !== lastThis || !equals$2(nextArgs, lastArgs)) {
      called = true;
      lastThis = this;
      lastArgs = nextArgs;
      lastResult = fn.apply(this, arguments);
    }
    return lastResult;
  };
}
function abstract() {
  return function() {
    throw new Error("Unimplemented abstract method.");
  }();
}
var uidCounter_ = 0;
function getUid(obj) {
  return obj.ol_uid || (obj.ol_uid = String(++uidCounter_));
}
var VERSION = "6.14.1";
var ua = typeof navigator !== "undefined" && typeof navigator.userAgent !== "undefined" ? navigator.userAgent.toLowerCase() : "";
var FIREFOX = ua.indexOf("firefox") !== -1;
var SAFARI = ua.indexOf("safari") !== -1 && ua.indexOf("chrom") == -1;
var SAFARI_BUG_237906 = SAFARI && !!(ua.indexOf("version/15.4") >= 0 || ua.match(/cpu (os|iphone os) 15_4 like mac os x/));
var WEBKIT = ua.indexOf("webkit") !== -1 && ua.indexOf("edge") == -1;
var MAC = ua.indexOf("macintosh") !== -1;
var DEVICE_PIXEL_RATIO = typeof devicePixelRatio !== "undefined" ? devicePixelRatio : 1;
var WORKER_OFFSCREEN_CANVAS = typeof WorkerGlobalScope !== "undefined" && typeof OffscreenCanvas !== "undefined" && self instanceof WorkerGlobalScope;
var IMAGE_DECODE = typeof Image !== "undefined" && Image.prototype.decode;
var PASSIVE_EVENT_LISTENERS = function() {
  var passive = false;
  try {
    var options = Object.defineProperty({}, "passive", {
      get: function() {
        passive = true;
      }
    });
    window.addEventListener("_", null, options);
    window.removeEventListener("_", null, options);
  } catch (error) {
  }
  return passive;
}();
var __extends$2e = globalThis && globalThis.__extends || function() {
  var extendStatics2 = function(d2, b2) {
    extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {
      d3.__proto__ = b3;
    } || function(d3, b3) {
      for (var p5 in b3)
        if (Object.prototype.hasOwnProperty.call(b3, p5))
          d3[p5] = b3[p5];
    };
    return extendStatics2(d2, b2);
  };
  return function(d2, b2) {
    if (typeof b2 !== "function" && b2 !== null)
      throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
    extendStatics2(d2, b2);
    function __() {
      this.constructor = d2;
    }
    d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
  };
}();
var AssertionError = function(_super) {
  __extends$2e(AssertionError2, _super);
  function AssertionError2(code) {
    var _this = this;
    var path = "v" + VERSION.split("-")[0];
    var message = "Assertion failed. See https://openlayers.org/en/" + path + "/doc/errors/#" + code + " for details.";
    _this = _super.call(this, message) || this;
    _this.code = code;
    _this.name = "AssertionError";
    _this.message = message;
    return _this;
  }
  return AssertionError2;
}(Error);
var AssertionError$1 = AssertionError;
function assert(assertion, errorCode) {
  if (!assertion) {
    throw new AssertionError$1(errorCode);
  }
}
var tmp_ = new Array(6);
function create$6() {
  return [1, 0, 0, 1, 0, 0];
}
function reset(transform2) {
  return set$2(transform2, 1, 0, 0, 1, 0, 0);
}
function multiply(transform1, transform2) {
  var a1 = transform1[0];
  var b1 = transform1[1];
  var c1 = transform1[2];
  var d1 = transform1[3];
  var e1 = transform1[4];
  var f1 = transform1[5];
  var a2 = transform2[0];
  var b2 = transform2[1];
  var c2 = transform2[2];
  var d2 = transform2[3];
  var e2 = transform2[4];
  var f2 = transform2[5];
  transform1[0] = a1 * a2 + c1 * b2;
  transform1[1] = b1 * a2 + d1 * b2;
  transform1[2] = a1 * c2 + c1 * d2;
  transform1[3] = b1 * c2 + d1 * d2;
  transform1[4] = a1 * e2 + c1 * f2 + e1;
  transform1[5] = b1 * e2 + d1 * f2 + f1;
  return transform1;
}
function set$2(transform2, a2, b2, c2, d2, e2, f2) {
  transform2[0] = a2;
  transform2[1] = b2;
  transform2[2] = c2;
  transform2[3] = d2;
  transform2[4] = e2;
  transform2[5] = f2;
  return transform2;
}
function setFromArray(transform1, transform2) {
  transform1[0] = transform2[0];
  transform1[1] = transform2[1];
  transform1[2] = transform2[2];
  transform1[3] = transform2[3];
  transform1[4] = transform2[4];
  transform1[5] = transform2[5];
  return transform1;
}
function apply$5(transform2, coordinate) {
  var x2 = coordinate[0];
  var y2 = coordinate[1];
  coordinate[0] = transform2[0] * x2 + transform2[2] * y2 + transform2[4];
  coordinate[1] = transform2[1] * x2 + transform2[3] * y2 + transform2[5];
  return coordinate;
}
function rotate$2(transform2, angle2) {
  var cos = Math.cos(angle2);
  var sin = Math.sin(angle2);
  return multiply(transform2, set$2(tmp_, cos, sin, -sin, cos, 0, 0));
}
function scale$3(transform2, x2, y2) {
  return multiply(transform2, set$2(tmp_, x2, 0, 0, y2, 0, 0));
}
function makeScale(target, x2, y2) {
  return set$2(target, x2, 0, 0, y2, 0, 0);
}
function translate$1(transform2, dx, dy) {
  return multiply(transform2, set$2(tmp_, 1, 0, 0, 1, dx, dy));
}
function compose(transform2, dx1, dy1, sx, sy, angle2, dx2, dy2) {
  var sin = Math.sin(angle2);
  var cos = Math.cos(angle2);
  transform2[0] = sx * cos;
  transform2[1] = sy * sin;
  transform2[2] = -sx * sin;
  transform2[3] = sy * cos;
  transform2[4] = dx2 * sx * cos - dy2 * sx * sin + dx1;
  transform2[5] = dx2 * sy * sin + dy2 * sy * cos + dy1;
  return transform2;
}
function makeInverse(target, source) {
  var det = determinant(source);
  assert(det !== 0, 32);
  var a2 = source[0];
  var b2 = source[1];
  var c2 = source[2];
  var d2 = source[3];
  var e2 = source[4];
  var f2 = source[5];
  target[0] = d2 / det;
  target[1] = -b2 / det;
  target[2] = -c2 / det;
  target[3] = a2 / det;
  target[4] = (c2 * f2 - d2 * e2) / det;
  target[5] = -(a2 * f2 - b2 * e2) / det;
  return target;
}
function determinant(mat) {
  return mat[0] * mat[3] - mat[1] * mat[2];
}
var transformStringDiv;
function toString$d(mat) {
  var transformString = "matrix(" + mat.join(", ") + ")";
  if (WORKER_OFFSCREEN_CANVAS) {
    return transformString;
  }
  var node2 = transformStringDiv || (transformStringDiv = document.createElement("div"));
  node2.style.transform = transformString;
  return node2.style.transform;
}
var Corner = {
  BOTTOM_LEFT: "bottom-left",
  BOTTOM_RIGHT: "bottom-right",
  TOP_LEFT: "top-left",
  TOP_RIGHT: "top-right"
};
var Relationship = {
  UNKNOWN: 0,
  INTERSECTING: 1,
  ABOVE: 2,
  RIGHT: 4,
  BELOW: 8,
  LEFT: 16
};
function boundingExtent(coordinates2) {
  var extent2 = createEmpty();
  for (var i2 = 0, ii = coordinates2.length; i2 < ii; ++i2) {
    extendCoordinate(extent2, coordinates2[i2]);
  }
  return extent2;
}
function _boundingExtentXYs(xs, ys, opt_extent) {
  var minX = Math.min.apply(null, xs);
  var minY = Math.min.apply(null, ys);
  var maxX = Math.max.apply(null, xs);
  var maxY = Math.max.apply(null, ys);
  return createOrUpdate$2(minX, minY, maxX, maxY, opt_extent);
}
function buffer$1(extent2, value, opt_extent) {
  if (opt_extent) {
    opt_extent[0] = extent2[0] - value;
    opt_extent[1] = extent2[1] - value;
    opt_extent[2] = extent2[2] + value;
    opt_extent[3] = extent2[3] + value;
    return opt_extent;
  } else {
    return [
      extent2[0] - value,
      extent2[1] - value,
      extent2[2] + value,
      extent2[3] + value
    ];
  }
}
function clone$1(extent2, opt_extent) {
  if (opt_extent) {
    opt_extent[0] = extent2[0];
    opt_extent[1] = extent2[1];
    opt_extent[2] = extent2[2];
    opt_extent[3] = extent2[3];
    return opt_extent;
  } else {
    return extent2.slice();
  }
}
function closestSquaredDistanceXY(extent2, x2, y2) {
  var dx, dy;
  if (x2 < extent2[0]) {
    dx = extent2[0] - x2;
  } else if (extent2[2] < x2) {
    dx = x2 - extent2[2];
  } else {
    dx = 0;
  }
  if (y2 < extent2[1]) {
    dy = extent2[1] - y2;
  } else if (extent2[3] < y2) {
    dy = y2 - extent2[3];
  } else {
    dy = 0;
  }
  return dx * dx + dy * dy;
}
function containsCoordinate(extent2, coordinate) {
  return containsXY(extent2, coordinate[0], coordinate[1]);
}
function containsExtent(extent1, extent2) {
  return extent1[0] <= extent2[0] && extent2[2] <= extent1[2] && extent1[1] <= extent2[1] && extent2[3] <= extent1[3];
}
function containsXY(extent2, x2, y2) {
  return extent2[0] <= x2 && x2 <= extent2[2] && extent2[1] <= y2 && y2 <= extent2[3];
}
function coordinateRelationship(extent2, coordinate) {
  var minX = extent2[0];
  var minY = extent2[1];
  var maxX = extent2[2];
  var maxY = extent2[3];
  var x2 = coordinate[0];
  var y2 = coordinate[1];
  var relationship = Relationship.UNKNOWN;
  if (x2 < minX) {
    relationship = relationship | Relationship.LEFT;
  } else if (x2 > maxX) {
    relationship = relationship | Relationship.RIGHT;
  }
  if (y2 < minY) {
    relationship = relationship | Relationship.BELOW;
  } else if (y2 > maxY) {
    relationship = relationship | Relationship.ABOVE;
  }
  if (relationship === Relationship.UNKNOWN) {
    relationship = Relationship.INTERSECTING;
  }
  return relationship;
}
function createEmpty() {
  return [Infinity, Infinity, -Infinity, -Infinity];
}
function createOrUpdate$2(minX, minY, maxX, maxY, opt_extent) {
  if (opt_extent) {
    opt_extent[0] = minX;
    opt_extent[1] = minY;
    opt_extent[2] = maxX;
    opt_extent[3] = maxY;
    return opt_extent;
  } else {
    return [minX, minY, maxX, maxY];
  }
}
function createOrUpdateEmpty(opt_extent) {
  return createOrUpdate$2(Infinity, Infinity, -Infinity, -Infinity, opt_extent);
}
function createOrUpdateFromCoordinate(coordinate, opt_extent) {
  var x2 = coordinate[0];
  var y2 = coordinate[1];
  return createOrUpdate$2(x2, y2, x2, y2, opt_extent);
}
function createOrUpdateFromCoordinates(coordinates2, opt_extent) {
  var extent2 = createOrUpdateEmpty(opt_extent);
  return extendCoordinates(extent2, coordinates2);
}
function createOrUpdateFromFlatCoordinates(flatCoordinates, offset2, end, stride, opt_extent) {
  var extent2 = createOrUpdateEmpty(opt_extent);
  return extendFlatCoordinates(extent2, flatCoordinates, offset2, end, stride);
}
function createOrUpdateFromRings(rings, opt_extent) {
  var extent2 = createOrUpdateEmpty(opt_extent);
  return extendRings(extent2, rings);
}
function equals$1(extent1, extent2) {
  return extent1[0] == extent2[0] && extent1[2] == extent2[2] && extent1[1] == extent2[1] && extent1[3] == extent2[3];
}
function approximatelyEquals(extent1, extent2, tolerance) {
  return Math.abs(extent1[0] - extent2[0]) < tolerance && Math.abs(extent1[2] - extent2[2]) < tolerance && Math.abs(extent1[1] - extent2[1]) < tolerance && Math.abs(extent1[3] - extent2[3]) < tolerance;
}
function extend$2(extent1, extent2) {
  if (extent2[0] < extent1[0]) {
    extent1[0] = extent2[0];
  }
  if (extent2[2] > extent1[2]) {
    extent1[2] = extent2[2];
  }
  if (extent2[1] < extent1[1]) {
    extent1[1] = extent2[1];
  }
  if (extent2[3] > extent1[3]) {
    extent1[3] = extent2[3];
  }
  return extent1;
}
function extendCoordinate(extent2, coordinate) {
  if (coordinate[0] < extent2[0]) {
    extent2[0] = coordinate[0];
  }
  if (coordinate[0] > extent2[2]) {
    extent2[2] = coordinate[0];
  }
  if (coordinate[1] < extent2[1]) {
    extent2[1] = coordinate[1];
  }
  if (coordinate[1] > extent2[3]) {
    extent2[3] = coordinate[1];
  }
}
function extendCoordinates(extent2, coordinates2) {
  for (var i2 = 0, ii = coordinates2.length; i2 < ii; ++i2) {
    extendCoordinate(extent2, coordinates2[i2]);
  }
  return extent2;
}
function extendFlatCoordinates(extent2, flatCoordinates, offset2, end, stride) {
  for (; offset2 < end; offset2 += stride) {
    extendXY(extent2, flatCoordinates[offset2], flatCoordinates[offset2 + 1]);
  }
  return extent2;
}
function extendRings(extent2, rings) {
  for (var i2 = 0, ii = rings.length; i2 < ii; ++i2) {
    extendCoordinates(extent2, rings[i2]);
  }
  return extent2;
}
function extendXY(extent2, x2, y2) {
  extent2[0] = Math.min(extent2[0], x2);
  extent2[1] = Math.min(extent2[1], y2);
  extent2[2] = Math.max(extent2[2], x2);
  extent2[3] = Math.max(extent2[3], y2);
}
function forEachCorner(extent2, callback) {
  var val;
  val = callback(getBottomLeft(extent2));
  if (val) {
    return val;
  }
  val = callback(getBottomRight(extent2));
  if (val) {
    return val;
  }
  val = callback(getTopRight(extent2));
  if (val) {
    return val;
  }
  val = callback(getTopLeft(extent2));
  if (val) {
    return val;
  }
  return false;
}
function getArea(extent2) {
  var area = 0;
  if (!isEmpty$1(extent2)) {
    area = getWidth(extent2) * getHeight(extent2);
  }
  return area;
}
function getBottomLeft(extent2) {
  return [extent2[0], extent2[1]];
}
function getBottomRight(extent2) {
  return [extent2[2], extent2[1]];
}
function getCenter(extent2) {
  return [(extent2[0] + extent2[2]) / 2, (extent2[1] + extent2[3]) / 2];
}
function getCorner(extent2, corner) {
  var coordinate;
  if (corner === Corner.BOTTOM_LEFT) {
    coordinate = getBottomLeft(extent2);
  } else if (corner === Corner.BOTTOM_RIGHT) {
    coordinate = getBottomRight(extent2);
  } else if (corner === Corner.TOP_LEFT) {
    coordinate = getTopLeft(extent2);
  } else if (corner === Corner.TOP_RIGHT) {
    coordinate = getTopRight(extent2);
  } else {
    assert(false, 13);
  }
  return coordinate;
}
function getEnlargedArea(extent1, extent2) {
  var minX = Math.min(extent1[0], extent2[0]);
  var minY = Math.min(extent1[1], extent2[1]);
  var maxX = Math.max(extent1[2], extent2[2]);
  var maxY = Math.max(extent1[3], extent2[3]);
  return (maxX - minX) * (maxY - minY);
}
function getForViewAndSize(center, resolution, rotation, size, opt_extent) {
  var dx = resolution * size[0] / 2;
  var dy = resolution * size[1] / 2;
  var cosRotation = Math.cos(rotation);
  var sinRotation = Math.sin(rotation);
  var xCos = dx * cosRotation;
  var xSin = dx * sinRotation;
  var yCos = dy * cosRotation;
  var ySin = dy * sinRotation;
  var x2 = center[0];
  var y2 = center[1];
  var x0 = x2 - xCos + ySin;
  var x1 = x2 - xCos - ySin;
  var x22 = x2 + xCos - ySin;
  var x3 = x2 + xCos + ySin;
  var y0 = y2 - xSin - yCos;
  var y1 = y2 - xSin + yCos;
  var y22 = y2 + xSin + yCos;
  var y3 = y2 + xSin - yCos;
  return createOrUpdate$2(Math.min(x0, x1, x22, x3), Math.min(y0, y1, y22, y3), Math.max(x0, x1, x22, x3), Math.max(y0, y1, y22, y3), opt_extent);
}
function getHeight(extent2) {
  return extent2[3] - extent2[1];
}
function getIntersectionArea(extent1, extent2) {
  var intersection = getIntersection(extent1, extent2);
  return getArea(intersection);
}
function getIntersection(extent1, extent2, opt_extent) {
  var intersection = opt_extent ? opt_extent : createEmpty();
  if (intersects$1(extent1, extent2)) {
    if (extent1[0] > extent2[0]) {
      intersection[0] = extent1[0];
    } else {
      intersection[0] = extent2[0];
    }
    if (extent1[1] > extent2[1]) {
      intersection[1] = extent1[1];
    } else {
      intersection[1] = extent2[1];
    }
    if (extent1[2] < extent2[2]) {
      intersection[2] = extent1[2];
    } else {
      intersection[2] = extent2[2];
    }
    if (extent1[3] < extent2[3]) {
      intersection[3] = extent1[3];
    } else {
      intersection[3] = extent2[3];
    }
  } else {
    createOrUpdateEmpty(intersection);
  }
  return intersection;
}
function getMargin(extent2) {
  return getWidth(extent2) + getHeight(extent2);
}
function getSize(extent2) {
  return [extent2[2] - extent2[0], extent2[3] - extent2[1]];
}
function getTopLeft(extent2) {
  return [extent2[0], extent2[3]];
}
function getTopRight(extent2) {
  return [extent2[2], extent2[3]];
}
function getWidth(extent2) {
  return extent2[2] - extent2[0];
}
function intersects$1(extent1, extent2) {
  return extent1[0] <= extent2[2] && extent1[2] >= extent2[0] && extent1[1] <= extent2[3] && extent1[3] >= extent2[1];
}
function isEmpty$1(extent2) {
  return extent2[2] < extent2[0] || extent2[3] < extent2[1];
}
function returnOrUpdate(extent2, opt_extent) {
  if (opt_extent) {
    opt_extent[0] = extent2[0];
    opt_extent[1] = extent2[1];
    opt_extent[2] = extent2[2];
    opt_extent[3] = extent2[3];
    return opt_extent;
  } else {
    return extent2;
  }
}
function scaleFromCenter(extent2, value) {
  var deltaX = (extent2[2] - extent2[0]) / 2 * (value - 1);
  var deltaY = (extent2[3] - extent2[1]) / 2 * (value - 1);
  extent2[0] -= deltaX;
  extent2[2] += deltaX;
  extent2[1] -= deltaY;
  extent2[3] += deltaY;
}
function intersectsSegment(extent2, start2, end) {
  var intersects2 = false;
  var startRel = coordinateRelationship(extent2, start2);
  var endRel = coordinateRelationship(extent2, end);
  if (startRel === Relationship.INTERSECTING || endRel === Relationship.INTERSECTING) {
    intersects2 = true;
  } else {
    var minX = extent2[0];
    var minY = extent2[1];
    var maxX = extent2[2];
    var maxY = extent2[3];
    var startX = start2[0];
    var startY = start2[1];
    var endX = end[0];
    var endY = end[1];
    var slope = (endY - startY) / (endX - startX);
    var x2 = void 0, y2 = void 0;
    if (!!(endRel & Relationship.ABOVE) && !(startRel & Relationship.ABOVE)) {
      x2 = endX - (endY - maxY) / slope;
      intersects2 = x2 >= minX && x2 <= maxX;
    }
    if (!intersects2 && !!(endRel & Relationship.RIGHT) && !(startRel & Relationship.RIGHT)) {
      y2 = endY - (endX - maxX) * slope;
      intersects2 = y2 >= minY && y2 <= maxY;
    }
    if (!intersects2 && !!(endRel & Relationship.BELOW) && !(startRel & Relationship.BELOW)) {
      x2 = endX - (endY - minY) / slope;
      intersects2 = x2 >= minX && x2 <= maxX;
    }
    if (!intersects2 && !!(endRel & Relationship.LEFT) && !(startRel & Relationship.LEFT)) {
      y2 = endY - (endX - minX) * slope;
      intersects2 = y2 >= minY && y2 <= maxY;
    }
  }
  return intersects2;
}
function applyTransform(extent2, transformFn, opt_extent, opt_stops) {
  var coordinates2 = [];
  if (opt_stops > 1) {
    var width = extent2[2] - extent2[0];
    var height = extent2[3] - extent2[1];
    for (var i2 = 0; i2 < opt_stops; ++i2) {
      coordinates2.push(extent2[0] + width * i2 / opt_stops, extent2[1], extent2[2], extent2[1] + height * i2 / opt_stops, extent2[2] - width * i2 / opt_stops, extent2[3], extent2[0], extent2[3] - height * i2 / opt_stops);
    }
  } else {
    coordinates2 = [
      extent2[0],
      extent2[1],
      extent2[2],
      extent2[1],
      extent2[2],
      extent2[3],
      extent2[0],
      extent2[3]
    ];
  }
  transformFn(coordinates2, coordinates2, 2);
  var xs = [];
  var ys = [];
  for (var i2 = 0, l2 = coordinates2.length; i2 < l2; i2 += 2) {
    xs.push(coordinates2[i2]);
    ys.push(coordinates2[i2 + 1]);
  }
  return _boundingExtentXYs(xs, ys, opt_extent);
}
function wrapX$2(extent2, projection) {
  var projectionExtent = projection.getExtent();
  var center = getCenter(extent2);
  if (projection.canWrapX() && (center[0] < projectionExtent[0] || center[0] >= projectionExtent[2])) {
    var worldWidth = getWidth(projectionExtent);
    var worldsAway = Math.floor((center[0] - projectionExtent[0]) / worldWidth);
    var offset2 = worldsAway * worldWidth;
    extent2[0] -= offset2;
    extent2[2] -= offset2;
  }
  return extent2;
}
var extent = Object.freeze(Object.defineProperty({
  __proto__: null,
  boundingExtent,
  buffer: buffer$1,
  clone: clone$1,
  closestSquaredDistanceXY,
  containsCoordinate,
  containsExtent,
  containsXY,
  coordinateRelationship,
  createEmpty,
  createOrUpdate: createOrUpdate$2,
  createOrUpdateEmpty,
  createOrUpdateFromCoordinate,
  createOrUpdateFromCoordinates,
  createOrUpdateFromFlatCoordinates,
  createOrUpdateFromRings,
  equals: equals$1,
  approximatelyEquals,
  extend: extend$2,
  extendCoordinate,
  extendCoordinates,
  extendFlatCoordinates,
  extendRings,
  extendXY,
  forEachCorner,
  getArea,
  getBottomLeft,
  getBottomRight,
  getCenter,
  getCorner,
  getEnlargedArea,
  getForViewAndSize,
  getHeight,
  getIntersectionArea,
  getIntersection,
  getMargin,
  getSize,
  getTopLeft,
  getTopRight,
  getWidth,
  intersects: intersects$1,
  isEmpty: isEmpty$1,
  returnOrUpdate,
  scaleFromCenter,
  intersectsSegment,
  applyTransform,
  wrapX: wrapX$2
}, Symbol.toStringTag, { value: "Module" }));
function clamp(value, min2, max2) {
  return Math.min(Math.max(value, min2), max2);
}
var cosh$1 = function() {
  var cosh2;
  if ("cosh" in Math) {
    cosh2 = Math.cosh;
  } else {
    cosh2 = function(x2) {
      var y2 = Math.exp(x2);
      return (y2 + 1 / y2) / 2;
    };
  }
  return cosh2;
}();
var log2 = function() {
  var log22;
  if ("log2" in Math) {
    log22 = Math.log2;
  } else {
    log22 = function(x2) {
      return Math.log(x2) * Math.LOG2E;
    };
  }
  return log22;
}();
function squaredSegmentDistance(x2, y2, x1, y1, x22, y22) {
  var dx = x22 - x1;
  var dy = y22 - y1;
  if (dx !== 0 || dy !== 0) {
    var t3 = ((x2 - x1) * dx + (y2 - y1) * dy) / (dx * dx + dy * dy);
    if (t3 > 1) {
      x1 = x22;
      y1 = y22;
    } else if (t3 > 0) {
      x1 += dx * t3;
      y1 += dy * t3;
    }
  }
  return squaredDistance$1(x2, y2, x1, y1);
}
function squaredDistance$1(x1, y1, x2, y2) {
  var dx = x2 - x1;
  var dy = y2 - y1;
  return dx * dx + dy * dy;
}
function solveLinearSystem(mat) {
  var n2 = mat.length;
  for (var i2 = 0; i2 < n2; i2++) {
    var maxRow = i2;
    var maxEl = Math.abs(mat[i2][i2]);
    for (var r2 = i2 + 1; r2 < n2; r2++) {
      var absValue = Math.abs(mat[r2][i2]);
      if (absValue > maxEl) {
        maxEl = absValue;
        maxRow = r2;
      }
    }
    if (maxEl === 0) {
      return null;
    }
    var tmp = mat[maxRow];
    mat[maxRow] = mat[i2];
    mat[i2] = tmp;
    for (var j2 = i2 + 1; j2 < n2; j2++) {
      var coef = -mat[j2][i2] / mat[i2][i2];
      for (var k2 = i2; k2 < n2 + 1; k2++) {
        if (i2 == k2) {
          mat[j2][k2] = 0;
        } else {
          mat[j2][k2] += coef * mat[i2][k2];
        }
      }
    }
  }
  var x2 = new Array(n2);
  for (var l2 = n2 - 1; l2 >= 0; l2--) {
    x2[l2] = mat[l2][n2] / mat[l2][l2];
    for (var m2 = l2 - 1; m2 >= 0; m2--) {
      mat[m2][n2] -= mat[m2][l2] * x2[l2];
    }
  }
  return x2;
}
function toDegrees(angleInRadians) {
  return angleInRadians * 180 / Math.PI;
}
function toRadians(angleInDegrees) {
  return angleInDegrees * Math.PI / 180;
}
function modulo(a2, b2) {
  var r2 = a2 % b2;
  return r2 * b2 < 0 ? r2 + b2 : r2;
}
function lerp$1(a2, b2, x2) {
  return a2 + x2 * (b2 - a2);
}
function toFixed(n2, decimals) {
  var factor = Math.pow(10, decimals);
  return Math.round(n2 * factor) / factor;
}
function round(n2, decimals) {
  return Math.round(toFixed(n2, decimals));
}
function floor$2(n2, decimals) {
  return Math.floor(toFixed(n2, decimals));
}
function ceil$1(n2, decimals) {
  return Math.ceil(toFixed(n2, decimals));
}
var HEX_COLOR_RE_ = /^#([a-f0-9]{3}|[a-f0-9]{4}(?:[a-f0-9]{2}){0,2})$/i;
var NAMED_COLOR_RE_ = /^([a-z]*)$|^hsla?\(.*\)$/i;
function asString$1(color2) {
  if (typeof color2 === "string") {
    return color2;
  } else {
    return toString$c(color2);
  }
}
function fromNamed(color2) {
  var el = document.createElement("div");
  el.style.color = color2;
  if (el.style.color !== "") {
    document.body.appendChild(el);
    var rgb2 = getComputedStyle(el).color;
    document.body.removeChild(el);
    return rgb2;
  } else {
    return "";
  }
}
var fromString = function() {
  var MAX_CACHE_SIZE = 1024;
  var cache2 = {};
  var cacheSize = 0;
  return function(s2) {
    var color2;
    if (cache2.hasOwnProperty(s2)) {
      color2 = cache2[s2];
    } else {
      if (cacheSize >= MAX_CACHE_SIZE) {
        var i2 = 0;
        for (var key in cache2) {
          if ((i2++ & 3) === 0) {
            delete cache2[key];
            --cacheSize;
          }
        }
      }
      color2 = fromStringInternal_(s2);
      cache2[s2] = color2;
      ++cacheSize;
    }
    return color2;
  };
}();
function asArray(color2) {
  if (Array.isArray(color2)) {
    return color2;
  } else {
    return fromString(color2);
  }
}
function fromStringInternal_(s2) {
  var r2, g2, b2, a2, color2;
  if (NAMED_COLOR_RE_.exec(s2)) {
    s2 = fromNamed(s2);
  }
  if (HEX_COLOR_RE_.exec(s2)) {
    var n2 = s2.length - 1;
    var d2 = void 0;
    if (n2 <= 4) {
      d2 = 1;
    } else {
      d2 = 2;
    }
    var hasAlpha = n2 === 4 || n2 === 8;
    r2 = parseInt(s2.substr(1 + 0 * d2, d2), 16);
    g2 = parseInt(s2.substr(1 + 1 * d2, d2), 16);
    b2 = parseInt(s2.substr(1 + 2 * d2, d2), 16);
    if (hasAlpha) {
      a2 = parseInt(s2.substr(1 + 3 * d2, d2), 16);
    } else {
      a2 = 255;
    }
    if (d2 == 1) {
      r2 = (r2 << 4) + r2;
      g2 = (g2 << 4) + g2;
      b2 = (b2 << 4) + b2;
      if (hasAlpha) {
        a2 = (a2 << 4) + a2;
      }
    }
    color2 = [r2, g2, b2, a2 / 255];
  } else if (s2.indexOf("rgba(") == 0) {
    color2 = s2.slice(5, -1).split(",").map(Number);
    normalize$1(color2);
  } else if (s2.indexOf("rgb(") == 0) {
    color2 = s2.slice(4, -1).split(",").map(Number);
    color2.push(1);
    normalize$1(color2);
  } else {
    assert(false, 14);
  }
  return color2;
}
function normalize$1(color2) {
  color2[0] = clamp(color2[0] + 0.5 | 0, 0, 255);
  color2[1] = clamp(color2[1] + 0.5 | 0, 0, 255);
  color2[2] = clamp(color2[2] + 0.5 | 0, 0, 255);
  color2[3] = clamp(color2[3], 0, 1);
  return color2;
}
function toString$c(color2) {
  var r2 = color2[0];
  if (r2 != (r2 | 0)) {
    r2 = r2 + 0.5 | 0;
  }
  var g2 = color2[1];
  if (g2 != (g2 | 0)) {
    g2 = g2 + 0.5 | 0;
  }
  var b2 = color2[2];
  if (b2 != (b2 | 0)) {
    b2 = b2 + 0.5 | 0;
  }
  var a2 = color2[3] === void 0 ? 1 : Math.round(color2[3] * 100) / 100;
  return "rgba(" + r2 + "," + g2 + "," + b2 + "," + a2 + ")";
}
function isStringColor(s2) {
  if (NAMED_COLOR_RE_.test(s2)) {
    s2 = fromNamed(s2);
  }
  return HEX_COLOR_RE_.test(s2) || s2.indexOf("rgba(") === 0 || s2.indexOf("rgb(") === 0;
}
var IconImageCache = function() {
  function IconImageCache2() {
    this.cache_ = {};
    this.cacheSize_ = 0;
    this.maxCacheSize_ = 32;
  }
  IconImageCache2.prototype.clear = function() {
    this.cache_ = {};
    this.cacheSize_ = 0;
  };
  IconImageCache2.prototype.canExpireCache = function() {
    return this.cacheSize_ > this.maxCacheSize_;
  };
  IconImageCache2.prototype.expire = function() {
    if (this.canExpireCache()) {
      var i2 = 0;
      for (var key in this.cache_) {
        var iconImage = this.cache_[key];
        if ((i2++ & 3) === 0 && !iconImage.hasListener()) {
          delete this.cache_[key];
          --this.cacheSize_;
        }
      }
    }
  };
  IconImageCache2.prototype.get = function(src, crossOrigin, color2) {
    var key = getKey$1(src, crossOrigin, color2);
    return key in this.cache_ ? this.cache_[key] : null;
  };
  IconImageCache2.prototype.set = function(src, crossOrigin, color2, iconImage) {
    var key = getKey$1(src, crossOrigin, color2);
    this.cache_[key] = iconImage;
    ++this.cacheSize_;
  };
  IconImageCache2.prototype.setSize = function(maxCacheSize) {
    this.maxCacheSize_ = maxCacheSize;
    this.expire();
  };
  return IconImageCache2;
}();
function getKey$1(src, crossOrigin, color2) {
  var colorString = color2 ? asString$1(color2) : "null";
  return crossOrigin + ":" + src + ":" + colorString;
}
var shared$5 = new IconImageCache();
var BaseEvent = function() {
  function BaseEvent2(type) {
    this.propagationStopped;
    this.defaultPrevented;
    this.type = type;
    this.target = null;
  }
  BaseEvent2.prototype.preventDefault = function() {
    this.defaultPrevented = true;
  };
  BaseEvent2.prototype.stopPropagation = function() {
    this.propagationStopped = true;
  };
  return BaseEvent2;
}();
function stopPropagation(evt) {
  evt.stopPropagation();
}
var Event$1 = BaseEvent;
var ObjectEventType = {
  PROPERTYCHANGE: "propertychange"
};
var assign = typeof Object.assign === "function" ? Object.assign : function(target, var_sources) {
  if (target === void 0 || target === null) {
    throw new TypeError("Cannot convert undefined or null to object");
  }
  var output = Object(target);
  for (var i2 = 1, ii = arguments.length; i2 < ii; ++i2) {
    var source = arguments[i2];
    if (source !== void 0 && source !== null) {
      for (var key in source) {
        if (source.hasOwnProperty(key)) {
          output[key] = source[key];
        }
      }
    }
  }
  return output;
};
function clear$1(object) {
  for (var property in object) {
    delete object[property];
  }
}
var getValues = typeof Object.values === "function" ? Object.values : function(object) {
  var values2 = [];
  for (var property in object) {
    values2.push(object[property]);
  }
  return values2;
};
function isEmpty(object) {
  var property;
  for (property in object) {
    return false;
  }
  return !property;
}
var __extends$2d = globalThis && globalThis.__extends || function() {
  var extendStatics2 = function(d2, b2) {
    extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {
      d3.__proto__ = b3;
    } || function(d3, b3) {
      for (var p5 in b3)
        if (Object.prototype.hasOwnProperty.call(b3, p5))
          d3[p5] = b3[p5];
    };
    return extendStatics2(d2, b2);
  };
  return function(d2, b2) {
    if (typeof b2 !== "function" && b2 !== null)
      throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
    extendStatics2(d2, b2);
    function __() {
      this.constructor = d2;
    }
    d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
  };
}();
var Target = function(_super) {
  __extends$2d(Target2, _super);
  function Target2(opt_target) {
    var _this = _super.call(this) || this;
    _this.eventTarget_ = opt_target;
    _this.pendingRemovals_ = null;
    _this.dispatching_ = null;
    _this.listeners_ = null;
    return _this;
  }
  Target2.prototype.addEventListener = function(type, listener2) {
    if (!type || !listener2) {
      return;
    }
    var listeners = this.listeners_ || (this.listeners_ = {});
    var listenersForType = listeners[type] || (listeners[type] = []);
    if (listenersForType.indexOf(listener2) === -1) {
      listenersForType.push(listener2);
    }
  };
  Target2.prototype.dispatchEvent = function(event) {
    var isString = typeof event === "string";
    var type = isString ? event : event.type;
    var listeners = this.listeners_ && this.listeners_[type];
    if (!listeners) {
      return;
    }
    var evt = isString ? new Event$1(event) : event;
    if (!evt.target) {
      evt.target = this.eventTarget_ || this;
    }
    var dispatching = this.dispatching_ || (this.dispatching_ = {});
    var pendingRemovals = this.pendingRemovals_ || (this.pendingRemovals_ = {});
    if (!(type in dispatching)) {
      dispatching[type] = 0;
      pendingRemovals[type] = 0;
    }
    ++dispatching[type];
    var propagate;
    for (var i2 = 0, ii = listeners.length; i2 < ii; ++i2) {
      if ("handleEvent" in listeners[i2]) {
        propagate = listeners[i2].handleEvent(evt);
      } else {
        propagate = listeners[i2].call(this, evt);
      }
      if (propagate === false || evt.propagationStopped) {
        propagate = false;
        break;
      }
    }
    if (--dispatching[type] === 0) {
      var pr = pendingRemovals[type];
      delete pendingRemovals[type];
      while (pr--) {
        this.removeEventListener(type, VOID);
      }
      delete dispatching[type];
    }
    return propagate;
  };
  Target2.prototype.disposeInternal = function() {
    this.listeners_ && clear$1(this.listeners_);
  };
  Target2.prototype.getListeners = function(type) {
    return this.listeners_ && this.listeners_[type] || void 0;
  };
  Target2.prototype.hasListener = function(opt_type) {
    if (!this.listeners_) {
      return false;
    }
    return opt_type ? opt_type in this.listeners_ : Object.keys(this.listeners_).length > 0;
  };
  Target2.prototype.removeEventListener = function(type, listener2) {
    var listeners = this.listeners_ && this.listeners_[type];
    if (listeners) {
      var index2 = listeners.indexOf(listener2);
      if (index2 !== -1) {
        if (this.pendingRemovals_ && type in this.pendingRemovals_) {
          listeners[index2] = VOID;
          ++this.pendingRemovals_[type];
        } else {
          listeners.splice(index2, 1);
          if (listeners.length === 0) {
            delete this.listeners_[type];
          }
        }
      }
    }
  };
  return Target2;
}(Disposable$1);
var EventTarget = Target;
var EventType = {
  CHANGE: "change",
  ERROR: "error",
  BLUR: "blur",
  CLEAR: "clear",
  CONTEXTMENU: "contextmenu",
  CLICK: "click",
  DBLCLICK: "dblclick",
  DRAGENTER: "dragenter",
  DRAGOVER: "dragover",
  DROP: "drop",
  FOCUS: "focus",
  KEYDOWN: "keydown",
  KEYPRESS: "keypress",
  LOAD: "load",
  RESIZE: "resize",
  TOUCHMOVE: "touchmove",
  WHEEL: "wheel"
};
function listen(target, type, listener2, opt_this, opt_once) {
  if (opt_this && opt_this !== target) {
    listener2 = listener2.bind(opt_this);
  }
  if (opt_once) {
    var originalListener_1 = listener2;
    listener2 = function() {
      target.removeEventListener(type, listener2);
      originalListener_1.apply(this, arguments);
    };
  }
  var eventsKey = {
    target,
    type,
    listener: listener2
  };
  target.addEventListener(type, listener2);
  return eventsKey;
}
function listenOnce(target, type, listener2, opt_this) {
  return listen(target, type, listener2, opt_this, true);
}
function unlistenByKey(key) {
  if (key && key.target) {
    key.target.removeEventListener(key.type, key.listener);
    clear$1(key);
  }
}
var __extends$2c = globalThis && globalThis.__extends || function() {
  var extendStatics2 = function(d2, b2) {
    extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {
      d3.__proto__ = b3;
    } || function(d3, b3) {
      for (var p5 in b3)
        if (Object.prototype.hasOwnProperty.call(b3, p5))
          d3[p5] = b3[p5];
    };
    return extendStatics2(d2, b2);
  };
  return function(d2, b2) {
    if (typeof b2 !== "function" && b2 !== null)
      throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
    extendStatics2(d2, b2);
    function __() {
      this.constructor = d2;
    }
    d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
  };
}();
var Observable = function(_super) {
  __extends$2c(Observable2, _super);
  function Observable2() {
    var _this = _super.call(this) || this;
    _this.on = _this.onInternal;
    _this.once = _this.onceInternal;
    _this.un = _this.unInternal;
    _this.revision_ = 0;
    return _this;
  }
  Observable2.prototype.changed = function() {
    ++this.revision_;
    this.dispatchEvent(EventType.CHANGE);
  };
  Observable2.prototype.getRevision = function() {
    return this.revision_;
  };
  Observable2.prototype.onInternal = function(type, listener2) {
    if (Array.isArray(type)) {
      var len = type.length;
      var keys3 = new Array(len);
      for (var i2 = 0; i2 < len; ++i2) {
        keys3[i2] = listen(this, type[i2], listener2);
      }
      return keys3;
    } else {
      return listen(this, type, listener2);
    }
  };
  Observable2.prototype.onceInternal = function(type, listener2) {
    var key;
    if (Array.isArray(type)) {
      var len = type.length;
      key = new Array(len);
      for (var i2 = 0; i2 < len; ++i2) {
        key[i2] = listenOnce(this, type[i2], listener2);
      }
    } else {
      key = listenOnce(this, type, listener2);
    }
    listener2.ol_key = key;
    return key;
  };
  Observable2.prototype.unInternal = function(type, listener2) {
    var key = listener2.ol_key;
    if (key) {
      unByKey(key);
    } else if (Array.isArray(type)) {
      for (var i2 = 0, ii = type.length; i2 < ii; ++i2) {
        this.removeEventListener(type[i2], listener2);
      }
    } else {
      this.removeEventListener(type, listener2);
    }
  };
  return Observable2;
}(EventTarget);
Observable.prototype.on;
Observable.prototype.once;
Observable.prototype.un;
function unByKey(key) {
  if (Array.isArray(key)) {
    for (var i2 = 0, ii = key.length; i2 < ii; ++i2) {
      unlistenByKey(key[i2]);
    }
  } else {
    unlistenByKey(key);
  }
}
var __extends$2b = globalThis && globalThis.__extends || function() {
  var extendStatics2 = function(d2, b2) {
    extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {
      d3.__proto__ = b3;
    } || function(d3, b3) {
      for (var p5 in b3)
        if (Object.prototype.hasOwnProperty.call(b3, p5))
          d3[p5] = b3[p5];
    };
    return extendStatics2(d2, b2);
  };
  return function(d2, b2) {
    if (typeof b2 !== "function" && b2 !== null)
      throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
    extendStatics2(d2, b2);
    function __() {
      this.constructor = d2;
    }
    d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
  };
}();
var ObjectEvent = function(_super) {
  __extends$2b(ObjectEvent2, _super);
  function ObjectEvent2(type, key, oldValue) {
    var _this = _super.call(this, type) || this;
    _this.key = key;
    _this.oldValue = oldValue;
    return _this;
  }
  return ObjectEvent2;
}(Event$1);
var BaseObject = function(_super) {
  __extends$2b(BaseObject2, _super);
  function BaseObject2(opt_values) {
    var _this = _super.call(this) || this;
    _this.on;
    _this.once;
    _this.un;
    getUid(_this);
    _this.values_ = null;
    if (opt_values !== void 0) {
      _this.setProperties(opt_values);
    }
    return _this;
  }
  BaseObject2.prototype.get = function(key) {
    var value;
    if (this.values_ && this.values_.hasOwnProperty(key)) {
      value = this.values_[key];
    }
    return value;
  };
  BaseObject2.prototype.getKeys = function() {
    return this.values_ && Object.keys(this.values_) || [];
  };
  BaseObject2.prototype.getProperties = function() {
    return this.values_ && assign({}, this.values_) || {};
  };
  BaseObject2.prototype.hasProperties = function() {
    return !!this.values_;
  };
  BaseObject2.prototype.notify = function(key, oldValue) {
    var eventType;
    eventType = "change:".concat(key);
    if (this.hasListener(eventType)) {
      this.dispatchEvent(new ObjectEvent(eventType, key, oldValue));
    }
    eventType = ObjectEventType.PROPERTYCHANGE;
    if (this.hasListener(eventType)) {
      this.dispatchEvent(new ObjectEvent(eventType, key, oldValue));
    }
  };
  BaseObject2.prototype.addChangeListener = function(key, listener2) {
    this.addEventListener("change:".concat(key), listener2);
  };
  BaseObject2.prototype.removeChangeListener = function(key, listener2) {
    this.removeEventListener("change:".concat(key), listener2);
  };
  BaseObject2.prototype.set = function(key, value, opt_silent) {
    var values2 = this.values_ || (this.values_ = {});
    if (opt_silent) {
      values2[key] = value;
    } else {
      var oldValue = values2[key];
      values2[key] = value;
      if (oldValue !== value) {
        this.notify(key, oldValue);
      }
    }
  };
  BaseObject2.prototype.setProperties = function(values2, opt_silent) {
    for (var key in values2) {
      this.set(key, values2[key], opt_silent);
    }
  };
  BaseObject2.prototype.applyProperties = function(source) {
    if (!source.values_) {
      return;
    }
    assign(this.values_ || (this.values_ = {}), source.values_);
  };
  BaseObject2.prototype.unset = function(key, opt_silent) {
    if (this.values_ && key in this.values_) {
      var oldValue = this.values_[key];
      delete this.values_[key];
      if (isEmpty(this.values_)) {
        this.values_ = null;
      }
      if (!opt_silent) {
        this.notify(key, oldValue);
      }
    }
  };
  return BaseObject2;
}(Observable);
var ol_Object = BaseObject;
var LayerProperty = {
  OPACITY: "opacity",
  VISIBLE: "visible",
  EXTENT: "extent",
  Z_INDEX: "zIndex",
  MAX_RESOLUTION: "maxResolution",
  MIN_RESOLUTION: "minResolution",
  MAX_ZOOM: "maxZoom",
  MIN_ZOOM: "minZoom",
  SOURCE: "source",
  MAP: "map"
};
var __extends$2a = globalThis && globalThis.__extends || function() {
  var extendStatics2 = function(d2, b2) {
    extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {
      d3.__proto__ = b3;
    } || function(d3, b3) {
      for (var p5 in b3)
        if (Object.prototype.hasOwnProperty.call(b3, p5))
          d3[p5] = b3[p5];
    };
    return extendStatics2(d2, b2);
  };
  return function(d2, b2) {
    if (typeof b2 !== "function" && b2 !== null)
      throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
    extendStatics2(d2, b2);
    function __() {
      this.constructor = d2;
    }
    d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
  };
}();
var BaseLayer$1 = function(_super) {
  __extends$2a(BaseLayer2, _super);
  function BaseLayer2(options) {
    var _this = _super.call(this) || this;
    _this.on;
    _this.once;
    _this.un;
    _this.background_ = options.background;
    var properties = assign({}, options);
    if (typeof options.properties === "object") {
      delete properties.properties;
      assign(properties, options.properties);
    }
    properties[LayerProperty.OPACITY] = options.opacity !== void 0 ? options.opacity : 1;
    assert(typeof properties[LayerProperty.OPACITY] === "number", 64);
    properties[LayerProperty.VISIBLE] = options.visible !== void 0 ? options.visible : true;
    properties[LayerProperty.Z_INDEX] = options.zIndex;
    properties[LayerProperty.MAX_RESOLUTION] = options.maxResolution !== void 0 ? options.maxResolution : Infinity;
    properties[LayerProperty.MIN_RESOLUTION] = options.minResolution !== void 0 ? options.minResolution : 0;
    properties[LayerProperty.MIN_ZOOM] = options.minZoom !== void 0 ? options.minZoom : -Infinity;
    properties[LayerProperty.MAX_ZOOM] = options.maxZoom !== void 0 ? options.maxZoom : Infinity;
    _this.className_ = properties.className !== void 0 ? properties.className : "ol-layer";
    delete properties.className;
    _this.setProperties(properties);
    _this.state_ = null;
    return _this;
  }
  BaseLayer2.prototype.getBackground = function() {
    return this.background_;
  };
  BaseLayer2.prototype.getClassName = function() {
    return this.className_;
  };
  BaseLayer2.prototype.getLayerState = function(opt_managed) {
    var state = this.state_ || {
      layer: this,
      managed: opt_managed === void 0 ? true : opt_managed
    };
    var zIndex2 = this.getZIndex();
    state.opacity = clamp(Math.round(this.getOpacity() * 100) / 100, 0, 1);
    state.visible = this.getVisible();
    state.extent = this.getExtent();
    state.zIndex = zIndex2 === void 0 && !state.managed ? Infinity : zIndex2;
    state.maxResolution = this.getMaxResolution();
    state.minResolution = Math.max(this.getMinResolution(), 0);
    state.minZoom = this.getMinZoom();
    state.maxZoom = this.getMaxZoom();
    this.state_ = state;
    return state;
  };
  BaseLayer2.prototype.getLayersArray = function(opt_array) {
    return abstract();
  };
  BaseLayer2.prototype.getLayerStatesArray = function(opt_states) {
    return abstract();
  };
  BaseLayer2.prototype.getExtent = function() {
    return this.get(LayerProperty.EXTENT);
  };
  BaseLayer2.prototype.getMaxResolution = function() {
    return this.get(LayerProperty.MAX_RESOLUTION);
  };
  BaseLayer2.prototype.getMinResolution = function() {
    return this.get(LayerProperty.MIN_RESOLUTION);
  };
  BaseLayer2.prototype.getMinZoom = function() {
    return this.get(LayerProperty.MIN_ZOOM);
  };
  BaseLayer2.prototype.getMaxZoom = function() {
    return this.get(LayerProperty.MAX_ZOOM);
  };
  BaseLayer2.prototype.getOpacity = function() {
    return this.get(LayerProperty.OPACITY);
  };
  BaseLayer2.prototype.getSourceState = function() {
    return abstract();
  };
  BaseLayer2.prototype.getVisible = function() {
    return this.get(LayerProperty.VISIBLE);
  };
  BaseLayer2.prototype.getZIndex = function() {
    return this.get(LayerProperty.Z_INDEX);
  };
  BaseLayer2.prototype.setBackground = function(opt_background) {
    this.background_ = opt_background;
    this.changed();
  };
  BaseLayer2.prototype.setExtent = function(extent2) {
    this.set(LayerProperty.EXTENT, extent2);
  };
  BaseLayer2.prototype.setMaxResolution = function(maxResolution) {
    this.set(LayerProperty.MAX_RESOLUTION, maxResolution);
  };
  BaseLayer2.prototype.setMinResolution = function(minResolution) {
    this.set(LayerProperty.MIN_RESOLUTION, minResolution);
  };
  BaseLayer2.prototype.setMaxZoom = function(maxZoom) {
    this.set(LayerProperty.MAX_ZOOM, maxZoom);
  };
  BaseLayer2.prototype.setMinZoom = function(minZoom) {
    this.set(LayerProperty.MIN_ZOOM, minZoom);
  };
  BaseLayer2.prototype.setOpacity = function(opacity2) {
    assert(typeof opacity2 === "number", 64);
    this.set(LayerProperty.OPACITY, opacity2);
  };
  BaseLayer2.prototype.setVisible = function(visible) {
    this.set(LayerProperty.VISIBLE, visible);
  };
  BaseLayer2.prototype.setZIndex = function(zindex) {
    this.set(LayerProperty.Z_INDEX, zindex);
  };
  BaseLayer2.prototype.disposeInternal = function() {
    if (this.state_) {
      this.state_.layer = null;
      this.state_ = null;
    }
    _super.prototype.disposeInternal.call(this);
  };
  return BaseLayer2;
}(ol_Object);
var ol_layer_Base$1 = BaseLayer$1;
var RenderEventType = {
  PRERENDER: "prerender",
  POSTRENDER: "postrender",
  PRECOMPOSE: "precompose",
  POSTCOMPOSE: "postcompose",
  RENDERCOMPLETE: "rendercomplete"
};
var SourceState = {
  UNDEFINED: "undefined",
  LOADING: "loading",
  READY: "ready",
  ERROR: "error"
};
var __extends$29 = globalThis && globalThis.__extends || function() {
  var extendStatics2 = function(d2, b2) {
    extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {
      d3.__proto__ = b3;
    } || function(d3, b3) {
      for (var p5 in b3)
        if (Object.prototype.hasOwnProperty.call(b3, p5))
          d3[p5] = b3[p5];
    };
    return extendStatics2(d2, b2);
  };
  return function(d2, b2) {
    if (typeof b2 !== "function" && b2 !== null)
      throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
    extendStatics2(d2, b2);
    function __() {
      this.constructor = d2;
    }
    d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
  };
}();
var Layer = function(_super) {
  __extends$29(Layer2, _super);
  function Layer2(options) {
    var _this = this;
    var baseOptions = assign({}, options);
    delete baseOptions.source;
    _this = _super.call(this, baseOptions) || this;
    _this.on;
    _this.once;
    _this.un;
    _this.mapPrecomposeKey_ = null;
    _this.mapRenderKey_ = null;
    _this.sourceChangeKey_ = null;
    _this.renderer_ = null;
    _this.rendered = false;
    if (options.render) {
      _this.render = options.render;
    }
    if (options.map) {
      _this.setMap(options.map);
    }
    _this.addChangeListener(LayerProperty.SOURCE, _this.handleSourcePropertyChange_);
    var source = options.source ? options.source : null;
    _this.setSource(source);
    return _this;
  }
  Layer2.prototype.getLayersArray = function(opt_array) {
    var array = opt_array ? opt_array : [];
    array.push(this);
    return array;
  };
  Layer2.prototype.getLayerStatesArray = function(opt_states) {
    var states = opt_states ? opt_states : [];
    states.push(this.getLayerState());
    return states;
  };
  Layer2.prototype.getSource = function() {
    return this.get(LayerProperty.SOURCE) || null;
  };
  Layer2.prototype.getRenderSource = function() {
    return this.getSource();
  };
  Layer2.prototype.getSourceState = function() {
    var source = this.getSource();
    return !source ? SourceState.UNDEFINED : source.getState();
  };
  Layer2.prototype.handleSourceChange_ = function() {
    this.changed();
  };
  Layer2.prototype.handleSourcePropertyChange_ = function() {
    if (this.sourceChangeKey_) {
      unlistenByKey(this.sourceChangeKey_);
      this.sourceChangeKey_ = null;
    }
    var source = this.getSource();
    if (source) {
      this.sourceChangeKey_ = listen(source, EventType.CHANGE, this.handleSourceChange_, this);
    }
    this.changed();
  };
  Layer2.prototype.getFeatures = function(pixel) {
    if (!this.renderer_) {
      return new Promise(function(resolve2) {
        return resolve2([]);
      });
    }
    return this.renderer_.getFeatures(pixel);
  };
  Layer2.prototype.getData = function(pixel) {
    if (!this.renderer_ || !this.rendered) {
      return null;
    }
    return this.renderer_.getData(pixel);
  };
  Layer2.prototype.render = function(frameState, target) {
    var layerRenderer = this.getRenderer();
    if (layerRenderer.prepareFrame(frameState)) {
      this.rendered = true;
      return layerRenderer.renderFrame(frameState, target);
    }
  };
  Layer2.prototype.unrender = function() {
    this.rendered = false;
  };
  Layer2.prototype.setMapInternal = function(map) {
    if (!map) {
      this.unrender();
    }
    this.set(LayerProperty.MAP, map);
  };
  Layer2.prototype.getMapInternal = function() {
    return this.get(LayerProperty.MAP);
  };
  Layer2.prototype.setMap = function(map) {
    if (this.mapPrecomposeKey_) {
      unlistenByKey(this.mapPrecomposeKey_);
      this.mapPrecomposeKey_ = null;
    }
    if (!map) {
      this.changed();
    }
    if (this.mapRenderKey_) {
      unlistenByKey(this.mapRenderKey_);
      this.mapRenderKey_ = null;
    }
    if (map) {
      this.mapPrecomposeKey_ = listen(map, RenderEventType.PRECOMPOSE, function(evt) {
        var renderEvent = evt;
        var layerStatesArray = renderEvent.frameState.layerStatesArray;
        var layerState = this.getLayerState(false);
        assert(!layerStatesArray.some(function(arrayLayerState) {
          return arrayLayerState.layer === layerState.layer;
        }), 67);
        layerStatesArray.push(layerState);
      }, this);
      this.mapRenderKey_ = listen(this, EventType.CHANGE, map.render, map);
      this.changed();
    }
  };
  Layer2.prototype.setSource = function(source) {
    this.set(LayerProperty.SOURCE, source);
  };
  Layer2.prototype.getRenderer = function() {
    if (!this.renderer_) {
      this.renderer_ = this.createRenderer();
    }
    return this.renderer_;
  };
  Layer2.prototype.hasRenderer = function() {
    return !!this.renderer_;
  };
  Layer2.prototype.createRenderer = function() {
    return null;
  };
  Layer2.prototype.disposeInternal = function() {
    if (this.renderer_) {
      this.renderer_.dispose();
      delete this.renderer_;
    }
    this.setSource(null);
    _super.prototype.disposeInternal.call(this);
  };
  return Layer2;
}(ol_layer_Base$1);
function inView(layerState, viewState) {
  if (!layerState.visible) {
    return false;
  }
  var resolution = viewState.resolution;
  if (resolution < layerState.minResolution || resolution >= layerState.maxResolution) {
    return false;
  }
  var zoom = viewState.zoom;
  return zoom > layerState.minZoom && zoom <= layerState.maxZoom;
}
var ol_layer_Base = Layer;
function padNumber(number, width, opt_precision) {
  var numberString = opt_precision !== void 0 ? number.toFixed(opt_precision) : "" + number;
  var decimal = numberString.indexOf(".");
  decimal = decimal === -1 ? numberString.length : decimal;
  return decimal > width ? numberString : new Array(1 + width - decimal).join("0") + numberString;
}
function compareVersions(v1, v2) {
  var s1 = ("" + v1).split(".");
  var s2 = ("" + v2).split(".");
  for (var i2 = 0; i2 < Math.max(s1.length, s2.length); i2++) {
    var n1 = parseInt(s1[i2] || "0", 10);
    var n2 = parseInt(s2[i2] || "0", 10);
    if (n1 > n2) {
      return 1;
    }
    if (n2 > n1) {
      return -1;
    }
  }
  return 0;
}
function add$3(coordinate, delta) {
  coordinate[0] += +delta[0];
  coordinate[1] += +delta[1];
  return coordinate;
}
function closestOnCircle(coordinate, circle) {
  var r2 = circle.getRadius();
  var center = circle.getCenter();
  var x0 = center[0];
  var y0 = center[1];
  var x1 = coordinate[0];
  var y1 = coordinate[1];
  var dx = x1 - x0;
  var dy = y1 - y0;
  if (dx === 0 && dy === 0) {
    dx = 1;
  }
  var d2 = Math.sqrt(dx * dx + dy * dy);
  var x2 = x0 + r2 * dx / d2;
  var y2 = y0 + r2 * dy / d2;
  return [x2, y2];
}
function closestOnSegment(coordinate, segment) {
  var x0 = coordinate[0];
  var y0 = coordinate[1];
  var start2 = segment[0];
  var end = segment[1];
  var x1 = start2[0];
  var y1 = start2[1];
  var x2 = end[0];
  var y2 = end[1];
  var dx = x2 - x1;
  var dy = y2 - y1;
  var along = dx === 0 && dy === 0 ? 0 : (dx * (x0 - x1) + dy * (y0 - y1)) / (dx * dx + dy * dy || 0);
  var x3, y3;
  if (along <= 0) {
    x3 = x1;
    y3 = y1;
  } else if (along >= 1) {
    x3 = x2;
    y3 = y2;
  } else {
    x3 = x1 + along * dx;
    y3 = y1 + along * dy;
  }
  return [x3, y3];
}
function equals(coordinate1, coordinate2) {
  var equals2 = true;
  for (var i2 = coordinate1.length - 1; i2 >= 0; --i2) {
    if (coordinate1[i2] != coordinate2[i2]) {
      equals2 = false;
      break;
    }
  }
  return equals2;
}
function rotate$1(coordinate, angle2) {
  var cosAngle = Math.cos(angle2);
  var sinAngle = Math.sin(angle2);
  var x2 = coordinate[0] * cosAngle - coordinate[1] * sinAngle;
  var y2 = coordinate[1] * cosAngle + coordinate[0] * sinAngle;
  coordinate[0] = x2;
  coordinate[1] = y2;
  return coordinate;
}
function scale$2(coordinate, scale2) {
  coordinate[0] *= scale2;
  coordinate[1] *= scale2;
  return coordinate;
}
function squaredDistance(coord1, coord2) {
  var dx = coord1[0] - coord2[0];
  var dy = coord1[1] - coord2[1];
  return dx * dx + dy * dy;
}
function distance$1(coord1, coord2) {
  return Math.sqrt(squaredDistance(coord1, coord2));
}
function squaredDistanceToSegment(coordinate, segment) {
  return squaredDistance(coordinate, closestOnSegment(coordinate, segment));
}
function wrapX$1(coordinate, projection) {
  if (projection.canWrapX()) {
    var worldWidth = getWidth(projection.getExtent());
    var worldsAway = getWorldsAway(coordinate, projection, worldWidth);
    if (worldsAway) {
      coordinate[0] -= worldsAway * worldWidth;
    }
  }
  return coordinate;
}
function getWorldsAway(coordinate, projection, opt_sourceExtentWidth) {
  var projectionExtent = projection.getExtent();
  var worldsAway = 0;
  if (projection.canWrapX() && (coordinate[0] < projectionExtent[0] || coordinate[0] > projectionExtent[2])) {
    var sourceExtentWidth = opt_sourceExtentWidth || getWidth(projectionExtent);
    worldsAway = Math.floor((coordinate[0] - projectionExtent[0]) / sourceExtentWidth);
  }
  return worldsAway;
}
var __extends$28 = globalThis && globalThis.__extends || function() {
  var extendStatics2 = function(d2, b2) {
    extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {
      d3.__proto__ = b3;
    } || function(d3, b3) {
      for (var p5 in b3)
        if (Object.prototype.hasOwnProperty.call(b3, p5))
          d3[p5] = b3[p5];
    };
    return extendStatics2(d2, b2);
  };
  return function(d2, b2) {
    if (typeof b2 !== "function" && b2 !== null)
      throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
    extendStatics2(d2, b2);
    function __() {
      this.constructor = d2;
    }
    d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
  };
}();
var MapRenderer = function(_super) {
  __extends$28(MapRenderer2, _super);
  function MapRenderer2(map) {
    var _this = _super.call(this) || this;
    _this.map_ = map;
    return _this;
  }
  MapRenderer2.prototype.dispatchRenderEvent = function(type, frameState) {
    abstract();
  };
  MapRenderer2.prototype.calculateMatrices2D = function(frameState) {
    var viewState = frameState.viewState;
    var coordinateToPixelTransform = frameState.coordinateToPixelTransform;
    var pixelToCoordinateTransform = frameState.pixelToCoordinateTransform;
    compose(coordinateToPixelTransform, frameState.size[0] / 2, frameState.size[1] / 2, 1 / viewState.resolution, -1 / viewState.resolution, -viewState.rotation, -viewState.center[0], -viewState.center[1]);
    makeInverse(pixelToCoordinateTransform, coordinateToPixelTransform);
  };
  MapRenderer2.prototype.forEachFeatureAtCoordinate = function(coordinate, frameState, hitTolerance, checkWrapped, callback, thisArg, layerFilter, thisArg2) {
    var result;
    var viewState = frameState.viewState;
    function forEachFeatureAtCoordinate(managed, feature2, layer2, geometry) {
      return callback.call(thisArg, feature2, managed ? layer2 : null, geometry);
    }
    var projection = viewState.projection;
    var translatedCoordinate = wrapX$1(coordinate.slice(), projection);
    var offsets = [[0, 0]];
    if (projection.canWrapX() && checkWrapped) {
      var projectionExtent = projection.getExtent();
      var worldWidth = getWidth(projectionExtent);
      offsets.push([-worldWidth, 0], [worldWidth, 0]);
    }
    var layerStates = frameState.layerStatesArray;
    var numLayers = layerStates.length;
    var matches = [];
    var tmpCoord = [];
    for (var i2 = 0; i2 < offsets.length; i2++) {
      for (var j2 = numLayers - 1; j2 >= 0; --j2) {
        var layerState = layerStates[j2];
        var layer = layerState.layer;
        if (layer.hasRenderer() && inView(layerState, viewState) && layerFilter.call(thisArg2, layer)) {
          var layerRenderer = layer.getRenderer();
          var source = layer.getSource();
          if (layerRenderer && source) {
            var coordinates2 = source.getWrapX() ? translatedCoordinate : coordinate;
            var callback_1 = forEachFeatureAtCoordinate.bind(null, layerState.managed);
            tmpCoord[0] = coordinates2[0] + offsets[i2][0];
            tmpCoord[1] = coordinates2[1] + offsets[i2][1];
            result = layerRenderer.forEachFeatureAtCoordinate(tmpCoord, frameState, hitTolerance, callback_1, matches);
          }
          if (result) {
            return result;
          }
        }
      }
    }
    if (matches.length === 0) {
      return void 0;
    }
    var order = 1 / matches.length;
    matches.forEach(function(m2, i3) {
      return m2.distanceSq += i3 * order;
    });
    matches.sort(function(a2, b2) {
      return a2.distanceSq - b2.distanceSq;
    });
    matches.some(function(m2) {
      return result = m2.callback(m2.feature, m2.layer, m2.geometry);
    });
    return result;
  };
  MapRenderer2.prototype.forEachLayerAtPixel = function(pixel, frameState, hitTolerance, callback, layerFilter) {
    return abstract();
  };
  MapRenderer2.prototype.hasFeatureAtCoordinate = function(coordinate, frameState, hitTolerance, checkWrapped, layerFilter, thisArg) {
    var hasFeature = this.forEachFeatureAtCoordinate(coordinate, frameState, hitTolerance, checkWrapped, TRUE, this, layerFilter, thisArg);
    return hasFeature !== void 0;
  };
  MapRenderer2.prototype.getMap = function() {
    return this.map_;
  };
  MapRenderer2.prototype.renderFrame = function(frameState) {
    abstract();
  };
  MapRenderer2.prototype.scheduleExpireIconCache = function(frameState) {
    if (shared$5.canExpireCache()) {
      frameState.postRenderFunctions.push(expireIconCache);
    }
  };
  return MapRenderer2;
}(Disposable$1);
function expireIconCache(map, frameState) {
  shared$5.expire();
}
var MapRenderer$1 = MapRenderer;
var __extends$27 = globalThis && globalThis.__extends || function() {
  var extendStatics2 = function(d2, b2) {
    extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {
      d3.__proto__ = b3;
    } || function(d3, b3) {
      for (var p5 in b3)
        if (Object.prototype.hasOwnProperty.call(b3, p5))
          d3[p5] = b3[p5];
    };
    return extendStatics2(d2, b2);
  };
  return function(d2, b2) {
    if (typeof b2 !== "function" && b2 !== null)
      throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
    extendStatics2(d2, b2);
    function __() {
      this.constructor = d2;
    }
    d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
  };
}();
var RenderEvent = function(_super) {
  __extends$27(RenderEvent2, _super);
  function RenderEvent2(type, opt_inversePixelTransform, opt_frameState, opt_context) {
    var _this = _super.call(this, type) || this;
    _this.inversePixelTransform = opt_inversePixelTransform;
    _this.frameState = opt_frameState;
    _this.context = opt_context;
    return _this;
  }
  return RenderEvent2;
}(Event$1);
var RenderEvent$1 = RenderEvent;
var CLASS_HIDDEN = "ol-hidden";
var CLASS_SELECTABLE = "ol-selectable";
var CLASS_UNSELECTABLE = "ol-unselectable";
var CLASS_UNSUPPORTED = "ol-unsupported";
var CLASS_CONTROL = "ol-control";
var CLASS_COLLAPSED = "ol-collapsed";
var fontRegEx = new RegExp([
  "^\\s*(?=(?:(?:[-a-z]+\\s*){0,2}(italic|oblique))?)",
  "(?=(?:(?:[-a-z]+\\s*){0,2}(small-caps))?)",
  "(?=(?:(?:[-a-z]+\\s*){0,2}(bold(?:er)?|lighter|[1-9]00 ))?)",
  "(?:(?:normal|\\1|\\2|\\3)\\s*){0,3}((?:xx?-)?",
  "(?:small|large)|medium|smaller|larger|[\\.\\d]+(?:\\%|in|[cem]m|ex|p[ctx]))",
  "(?:\\s*\\/\\s*(normal|[\\.\\d]+(?:\\%|in|[cem]m|ex|p[ctx])?))",
  `?\\s*([-,\\"\\'\\sa-z]+?)\\s*$`
].join(""), "i");
var fontRegExMatchIndex = [
  "style",
  "variant",
  "weight",
  "size",
  "lineHeight",
  "family"
];
var getFontParameters = function(fontSpec) {
  var match2 = fontSpec.match(fontRegEx);
  if (!match2) {
    return null;
  }
  var style2 = {
    lineHeight: "normal",
    size: "1.2em",
    style: "normal",
    weight: "normal",
    variant: "normal"
  };
  for (var i2 = 0, ii = fontRegExMatchIndex.length; i2 < ii; ++i2) {
    var value = match2[i2 + 1];
    if (value !== void 0) {
      style2[fontRegExMatchIndex[i2]] = value;
    }
  }
  style2.families = style2.family.split(/,\s?/);
  return style2;
};
function cssOpacity(opacity2) {
  return opacity2 === 1 ? "" : String(Math.round(opacity2 * 100) / 100);
}
function createCanvasContext2D(opt_width, opt_height, opt_canvasPool, opt_Context2DSettings) {
  var canvas;
  if (opt_canvasPool && opt_canvasPool.length) {
    canvas = opt_canvasPool.shift();
  } else if (WORKER_OFFSCREEN_CANVAS) {
    canvas = new OffscreenCanvas(opt_width || 300, opt_height || 300);
  } else {
    canvas = document.createElement("canvas");
  }
  if (opt_width) {
    canvas.width = opt_width;
  }
  if (opt_height) {
    canvas.height = opt_height;
  }
  return canvas.getContext("2d", opt_Context2DSettings);
}
function outerWidth(element) {
  var width = element.offsetWidth;
  var style2 = getComputedStyle(element);
  width += parseInt(style2.marginLeft, 10) + parseInt(style2.marginRight, 10);
  return width;
}
function outerHeight(element) {
  var height = element.offsetHeight;
  var style2 = getComputedStyle(element);
  height += parseInt(style2.marginTop, 10) + parseInt(style2.marginBottom, 10);
  return height;
}
function replaceNode(newNode, oldNode) {
  var parent = oldNode.parentNode;
  if (parent) {
    parent.replaceChild(newNode, oldNode);
  }
}
function removeNode(node2) {
  return node2 && node2.parentNode ? node2.parentNode.removeChild(node2) : null;
}
function removeChildren(node2) {
  while (node2.lastChild) {
    node2.removeChild(node2.lastChild);
  }
}
function replaceChildren(node2, children) {
  var oldChildren = node2.childNodes;
  for (var i2 = 0; true; ++i2) {
    var oldChild = oldChildren[i2];
    var newChild = children[i2];
    if (!oldChild && !newChild) {
      break;
    }
    if (oldChild === newChild) {
      continue;
    }
    if (!oldChild) {
      node2.appendChild(newChild);
      continue;
    }
    if (!newChild) {
      node2.removeChild(oldChild);
      --i2;
      continue;
    }
    node2.insertBefore(newChild, oldChild);
  }
}
var defaultFont = "10px sans-serif";
var defaultFillStyle = "#000";
var defaultLineCap = "round";
var defaultLineDash = [];
var defaultLineDashOffset = 0;
var defaultLineJoin = "round";
var defaultMiterLimit = 10;
var defaultStrokeStyle = "#000";
var defaultTextAlign = "center";
var defaultTextBaseline = "middle";
var defaultPadding = [0, 0, 0, 0];
var defaultLineWidth = 1;
var checkedFonts = new ol_Object();
var labelCache = new EventTarget();
labelCache.setSize = function() {
  console.warn("labelCache is deprecated.");
};
var measureContext = null;
var measureFont;
var textHeights = {};
var registerFont = function() {
  var retries = 100;
  var size = "32px ";
  var referenceFonts = ["monospace", "serif"];
  var len = referenceFonts.length;
  var text2 = "wmytzilWMYTZIL@#/&?$%10\uF013";
  var interval, referenceWidth;
  function isAvailable(fontStyle2, fontWeight2, fontFamily2) {
    var available = true;
    for (var i2 = 0; i2 < len; ++i2) {
      var referenceFont = referenceFonts[i2];
      referenceWidth = measureTextWidth(fontStyle2 + " " + fontWeight2 + " " + size + referenceFont, text2);
      if (fontFamily2 != referenceFont) {
        var width = measureTextWidth(fontStyle2 + " " + fontWeight2 + " " + size + fontFamily2 + "," + referenceFont, text2);
        available = available && width != referenceWidth;
      }
    }
    if (available) {
      return true;
    }
    return false;
  }
  function check2() {
    var done = true;
    var fonts = checkedFonts.getKeys();
    for (var i2 = 0, ii = fonts.length; i2 < ii; ++i2) {
      var font = fonts[i2];
      if (checkedFonts.get(font) < retries) {
        if (isAvailable.apply(this, font.split("\n"))) {
          clear$1(textHeights);
          measureContext = null;
          measureFont = void 0;
          checkedFonts.set(font, retries);
        } else {
          checkedFonts.set(font, checkedFonts.get(font) + 1, true);
          done = false;
        }
      }
    }
    if (done) {
      clearInterval(interval);
      interval = void 0;
    }
  }
  return function(fontSpec) {
    var font = getFontParameters(fontSpec);
    if (!font) {
      return;
    }
    var families = font.families;
    for (var i2 = 0, ii = families.length; i2 < ii; ++i2) {
      var family = families[i2];
      var key = font.style + "\n" + font.weight + "\n" + family;
      if (checkedFonts.get(key) === void 0) {
        checkedFonts.set(key, retries, true);
        if (!isAvailable(font.style, font.weight, family)) {
          checkedFonts.set(key, 0, true);
          if (interval === void 0) {
            interval = setInterval(check2, 32);
          }
        }
      }
    }
  };
}();
var measureTextHeight = function() {
  var measureElement;
  return function(fontSpec) {
    var height = textHeights[fontSpec];
    if (height == void 0) {
      if (WORKER_OFFSCREEN_CANVAS) {
        var font = getFontParameters(fontSpec);
        var metrics = measureText(fontSpec, "\u017Dg");
        var lineHeight2 = isNaN(Number(font.lineHeight)) ? 1.2 : Number(font.lineHeight);
        height = lineHeight2 * (metrics.actualBoundingBoxAscent + metrics.actualBoundingBoxDescent);
      } else {
        if (!measureElement) {
          measureElement = document.createElement("div");
          measureElement.innerHTML = "M";
          measureElement.style.minHeight = "0";
          measureElement.style.maxHeight = "none";
          measureElement.style.height = "auto";
          measureElement.style.padding = "0";
          measureElement.style.border = "none";
          measureElement.style.position = "absolute";
          measureElement.style.display = "block";
          measureElement.style.left = "-99999px";
        }
        measureElement.style.font = fontSpec;
        document.body.appendChild(measureElement);
        height = measureElement.offsetHeight;
        document.body.removeChild(measureElement);
      }
      textHeights[fontSpec] = height;
    }
    return height;
  };
}();
function measureText(font, text2) {
  if (!measureContext) {
    measureContext = createCanvasContext2D(1, 1);
  }
  if (font != measureFont) {
    measureContext.font = font;
    measureFont = measureContext.font;
  }
  return measureContext.measureText(text2);
}
function measureTextWidth(font, text2) {
  return measureText(font, text2).width;
}
function measureAndCacheTextWidth(font, text2, cache2) {
  if (text2 in cache2) {
    return cache2[text2];
  }
  var width = measureTextWidth(font, text2);
  cache2[text2] = width;
  return width;
}
function getTextDimensions(baseStyle, chunks) {
  var widths = [];
  var heights = [];
  var lineWidths = [];
  var width = 0;
  var lineWidth = 0;
  var height = 0;
  var lineHeight2 = 0;
  for (var i2 = 0, ii = chunks.length; i2 <= ii; i2 += 2) {
    var text2 = chunks[i2];
    if (text2 === "\n" || i2 === ii) {
      width = Math.max(width, lineWidth);
      lineWidths.push(lineWidth);
      lineWidth = 0;
      height += lineHeight2;
      continue;
    }
    var font = chunks[i2 + 1] || baseStyle.font;
    var currentWidth = measureTextWidth(font, text2);
    widths.push(currentWidth);
    lineWidth += currentWidth;
    var currentHeight = measureTextHeight(font);
    heights.push(currentHeight);
    lineHeight2 = Math.max(lineHeight2, currentHeight);
  }
  return { width, height, widths, heights, lineWidths };
}
function drawImageOrLabel(context, transform2, opacity2, labelOrImage, originX, originY, w2, h2, x2, y2, scale2) {
  context.save();
  if (opacity2 !== 1) {
    context.globalAlpha *= opacity2;
  }
  if (transform2) {
    context.setTransform.apply(context, transform2);
  }
  if (labelOrImage.contextInstructions) {
    context.translate(x2, y2);
    context.scale(scale2[0], scale2[1]);
    executeLabelInstructions(labelOrImage, context);
  } else if (scale2[0] < 0 || scale2[1] < 0) {
    context.translate(x2, y2);
    context.scale(scale2[0], scale2[1]);
    context.drawImage(labelOrImage, originX, originY, w2, h2, 0, 0, w2, h2);
  } else {
    context.drawImage(labelOrImage, originX, originY, w2, h2, x2, y2, w2 * scale2[0], h2 * scale2[1]);
  }
  context.restore();
}
function executeLabelInstructions(label, context) {
  var contextInstructions = label.contextInstructions;
  for (var i2 = 0, ii = contextInstructions.length; i2 < ii; i2 += 2) {
    if (Array.isArray(contextInstructions[i2 + 1])) {
      context[contextInstructions[i2]].apply(context, contextInstructions[i2 + 1]);
    } else {
      context[contextInstructions[i2]] = contextInstructions[i2 + 1];
    }
  }
}
var __extends$26 = globalThis && globalThis.__extends || function() {
  var extendStatics2 = function(d2, b2) {
    extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {
      d3.__proto__ = b3;
    } || function(d3, b3) {
      for (var p5 in b3)
        if (Object.prototype.hasOwnProperty.call(b3, p5))
          d3[p5] = b3[p5];
    };
    return extendStatics2(d2, b2);
  };
  return function(d2, b2) {
    if (typeof b2 !== "function" && b2 !== null)
      throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
    extendStatics2(d2, b2);
    function __() {
      this.constructor = d2;
    }
    d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
  };
}();
var CompositeMapRenderer = function(_super) {
  __extends$26(CompositeMapRenderer2, _super);
  function CompositeMapRenderer2(map) {
    var _this = _super.call(this, map) || this;
    _this.fontChangeListenerKey_ = listen(checkedFonts, ObjectEventType.PROPERTYCHANGE, map.redrawText.bind(map));
    _this.element_ = document.createElement("div");
    var style2 = _this.element_.style;
    style2.position = "absolute";
    style2.width = "100%";
    style2.height = "100%";
    style2.zIndex = "0";
    _this.element_.className = CLASS_UNSELECTABLE + " ol-layers";
    var container = map.getViewport();
    container.insertBefore(_this.element_, container.firstChild || null);
    _this.children_ = [];
    _this.renderedVisible_ = true;
    return _this;
  }
  CompositeMapRenderer2.prototype.dispatchRenderEvent = function(type, frameState) {
    var map = this.getMap();
    if (map.hasListener(type)) {
      var event_1 = new RenderEvent$1(type, void 0, frameState);
      map.dispatchEvent(event_1);
    }
  };
  CompositeMapRenderer2.prototype.disposeInternal = function() {
    unlistenByKey(this.fontChangeListenerKey_);
    this.element_.parentNode.removeChild(this.element_);
    _super.prototype.disposeInternal.call(this);
  };
  CompositeMapRenderer2.prototype.renderFrame = function(frameState) {
    if (!frameState) {
      if (this.renderedVisible_) {
        this.element_.style.display = "none";
        this.renderedVisible_ = false;
      }
      return;
    }
    this.calculateMatrices2D(frameState);
    this.dispatchRenderEvent(RenderEventType.PRECOMPOSE, frameState);
    var layerStatesArray = frameState.layerStatesArray.sort(function(a2, b2) {
      return a2.zIndex - b2.zIndex;
    });
    var viewState = frameState.viewState;
    this.children_.length = 0;
    var declutterLayers = [];
    var previousElement = null;
    for (var i2 = 0, ii = layerStatesArray.length; i2 < ii; ++i2) {
      var layerState = layerStatesArray[i2];
      frameState.layerIndex = i2;
      var layer = layerState.layer;
      var sourceState = layer.getSourceState();
      if (!inView(layerState, viewState) || sourceState != SourceState.READY && sourceState != SourceState.UNDEFINED) {
        layer.unrender();
        continue;
      }
      var element = layer.render(frameState, previousElement);
      if (!element) {
        continue;
      }
      if (element !== previousElement) {
        this.children_.push(element);
        previousElement = element;
      }
      if ("getDeclutter" in layer) {
        declutterLayers.push(layer);
      }
    }
    for (var i2 = declutterLayers.length - 1; i2 >= 0; --i2) {
      declutterLayers[i2].renderDeclutter(frameState);
    }
    replaceChildren(this.element_, this.children_);
    this.dispatchRenderEvent(RenderEventType.POSTCOMPOSE, frameState);
    if (!this.renderedVisible_) {
      this.element_.style.display = "";
      this.renderedVisible_ = true;
    }
    this.scheduleExpireIconCache(frameState);
  };
  CompositeMapRenderer2.prototype.forEachLayerAtPixel = function(pixel, frameState, hitTolerance, callback, layerFilter) {
    var viewState = frameState.viewState;
    var layerStates = frameState.layerStatesArray;
    var numLayers = layerStates.length;
    for (var i2 = numLayers - 1; i2 >= 0; --i2) {
      var layerState = layerStates[i2];
      var layer = layerState.layer;
      if (layer.hasRenderer() && inView(layerState, viewState) && layerFilter(layer)) {
        var layerRenderer = layer.getRenderer();
        var data2 = layerRenderer.getDataAtPixel(pixel, frameState, hitTolerance);
        if (data2) {
          var result = callback(layer, data2);
          if (result) {
            return result;
          }
        }
      }
    }
    return void 0;
  };
  return CompositeMapRenderer2;
}(MapRenderer$1);
var CompositeMapRenderer$1 = CompositeMapRenderer;
var CollectionEventType = {
  ADD: "add",
  REMOVE: "remove"
};
var __extends$25 = globalThis && globalThis.__extends || function() {
  var extendStatics2 = function(d2, b2) {
    extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {
      d3.__proto__ = b3;
    } || function(d3, b3) {
      for (var p5 in b3)
        if (Object.prototype.hasOwnProperty.call(b3, p5))
          d3[p5] = b3[p5];
    };
    return extendStatics2(d2, b2);
  };
  return function(d2, b2) {
    if (typeof b2 !== "function" && b2 !== null)
      throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
    extendStatics2(d2, b2);
    function __() {
      this.constructor = d2;
    }
    d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
  };
}();
var Property$6 = {
  LENGTH: "length"
};
var CollectionEvent = function(_super) {
  __extends$25(CollectionEvent2, _super);
  function CollectionEvent2(type, opt_element, opt_index) {
    var _this = _super.call(this, type) || this;
    _this.element = opt_element;
    _this.index = opt_index;
    return _this;
  }
  return CollectionEvent2;
}(Event$1);
var Collection = function(_super) {
  __extends$25(Collection2, _super);
  function Collection2(opt_array, opt_options) {
    var _this = _super.call(this) || this;
    _this.on;
    _this.once;
    _this.un;
    var options = opt_options || {};
    _this.unique_ = !!options.unique;
    _this.array_ = opt_array ? opt_array : [];
    if (_this.unique_) {
      for (var i2 = 0, ii = _this.array_.length; i2 < ii; ++i2) {
        _this.assertUnique_(_this.array_[i2], i2);
      }
    }
    _this.updateLength_();
    return _this;
  }
  Collection2.prototype.clear = function() {
    while (this.getLength() > 0) {
      this.pop();
    }
  };
  Collection2.prototype.extend = function(arr) {
    for (var i2 = 0, ii = arr.length; i2 < ii; ++i2) {
      this.push(arr[i2]);
    }
    return this;
  };
  Collection2.prototype.forEach = function(f2) {
    var array = this.array_;
    for (var i2 = 0, ii = array.length; i2 < ii; ++i2) {
      f2(array[i2], i2, array);
    }
  };
  Collection2.prototype.getArray = function() {
    return this.array_;
  };
  Collection2.prototype.item = function(index2) {
    return this.array_[index2];
  };
  Collection2.prototype.getLength = function() {
    return this.get(Property$6.LENGTH);
  };
  Collection2.prototype.insertAt = function(index2, elem) {
    if (this.unique_) {
      this.assertUnique_(elem);
    }
    this.array_.splice(index2, 0, elem);
    this.updateLength_();
    this.dispatchEvent(new CollectionEvent(CollectionEventType.ADD, elem, index2));
  };
  Collection2.prototype.pop = function() {
    return this.removeAt(this.getLength() - 1);
  };
  Collection2.prototype.push = function(elem) {
    if (this.unique_) {
      this.assertUnique_(elem);
    }
    var n2 = this.getLength();
    this.insertAt(n2, elem);
    return this.getLength();
  };
  Collection2.prototype.remove = function(elem) {
    var arr = this.array_;
    for (var i2 = 0, ii = arr.length; i2 < ii; ++i2) {
      if (arr[i2] === elem) {
        return this.removeAt(i2);
      }
    }
    return void 0;
  };
  Collection2.prototype.removeAt = function(index2) {
    var prev = this.array_[index2];
    this.array_.splice(index2, 1);
    this.updateLength_();
    this.dispatchEvent(new CollectionEvent(CollectionEventType.REMOVE, prev, index2));
    return prev;
  };
  Collection2.prototype.setAt = function(index2, elem) {
    var n2 = this.getLength();
    if (index2 < n2) {
      if (this.unique_) {
        this.assertUnique_(elem, index2);
      }
      var prev = this.array_[index2];
      this.array_[index2] = elem;
      this.dispatchEvent(new CollectionEvent(CollectionEventType.REMOVE, prev, index2));
      this.dispatchEvent(new CollectionEvent(CollectionEventType.ADD, elem, index2));
    } else {
      for (var j2 = n2; j2 < index2; ++j2) {
        this.insertAt(j2, void 0);
      }
      this.insertAt(index2, elem);
    }
  };
  Collection2.prototype.updateLength_ = function() {
    this.set(Property$6.LENGTH, this.array_.length);
  };
  Collection2.prototype.assertUnique_ = function(elem, opt_except) {
    for (var i2 = 0, ii = this.array_.length; i2 < ii; ++i2) {
      if (this.array_[i2] === elem && i2 !== opt_except) {
        throw new AssertionError$1(58);
      }
    }
  };
  return Collection2;
}(ol_Object);
var ol_Collection = Collection;
var __extends$24 = globalThis && globalThis.__extends || function() {
  var extendStatics2 = function(d2, b2) {
    extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {
      d3.__proto__ = b3;
    } || function(d3, b3) {
      for (var p5 in b3)
        if (Object.prototype.hasOwnProperty.call(b3, p5))
          d3[p5] = b3[p5];
    };
    return extendStatics2(d2, b2);
  };
  return function(d2, b2) {
    if (typeof b2 !== "function" && b2 !== null)
      throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
    extendStatics2(d2, b2);
    function __() {
      this.constructor = d2;
    }
    d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
  };
}();
var GroupEvent = function(_super) {
  __extends$24(GroupEvent2, _super);
  function GroupEvent2(type, layer) {
    var _this = _super.call(this, type) || this;
    _this.layer = layer;
    return _this;
  }
  return GroupEvent2;
}(Event$1);
var Property$5 = {
  LAYERS: "layers"
};
var LayerGroup = function(_super) {
  __extends$24(LayerGroup2, _super);
  function LayerGroup2(opt_options) {
    var _this = this;
    var options = opt_options || {};
    var baseOptions = assign({}, options);
    delete baseOptions.layers;
    var layers = options.layers;
    _this = _super.call(this, baseOptions) || this;
    _this.on;
    _this.once;
    _this.un;
    _this.layersListenerKeys_ = [];
    _this.listenerKeys_ = {};
    _this.addChangeListener(Property$5.LAYERS, _this.handleLayersChanged_);
    if (layers) {
      if (Array.isArray(layers)) {
        layers = new ol_Collection(layers.slice(), { unique: true });
      } else {
        assert(typeof layers.getArray === "function", 43);
      }
    } else {
      layers = new ol_Collection(void 0, { unique: true });
    }
    _this.setLayers(layers);
    return _this;
  }
  LayerGroup2.prototype.handleLayerChange_ = function() {
    this.changed();
  };
  LayerGroup2.prototype.handleLayersChanged_ = function() {
    this.layersListenerKeys_.forEach(unlistenByKey);
    this.layersListenerKeys_.length = 0;
    var layers = this.getLayers();
    this.layersListenerKeys_.push(listen(layers, CollectionEventType.ADD, this.handleLayersAdd_, this), listen(layers, CollectionEventType.REMOVE, this.handleLayersRemove_, this));
    for (var id in this.listenerKeys_) {
      this.listenerKeys_[id].forEach(unlistenByKey);
    }
    clear$1(this.listenerKeys_);
    var layersArray = layers.getArray();
    for (var i2 = 0, ii = layersArray.length; i2 < ii; i2++) {
      var layer = layersArray[i2];
      this.registerLayerListeners_(layer);
      this.dispatchEvent(new GroupEvent("addlayer", layer));
    }
    this.changed();
  };
  LayerGroup2.prototype.registerLayerListeners_ = function(layer) {
    var listenerKeys = [
      listen(layer, ObjectEventType.PROPERTYCHANGE, this.handleLayerChange_, this),
      listen(layer, EventType.CHANGE, this.handleLayerChange_, this)
    ];
    if (layer instanceof LayerGroup2) {
      listenerKeys.push(listen(layer, "addlayer", this.handleLayerGroupAdd_, this), listen(layer, "removelayer", this.handleLayerGroupRemove_, this));
    }
    this.listenerKeys_[getUid(layer)] = listenerKeys;
  };
  LayerGroup2.prototype.handleLayerGroupAdd_ = function(event) {
    this.dispatchEvent(new GroupEvent("addlayer", event.layer));
  };
  LayerGroup2.prototype.handleLayerGroupRemove_ = function(event) {
    this.dispatchEvent(new GroupEvent("removelayer", event.layer));
  };
  LayerGroup2.prototype.handleLayersAdd_ = function(collectionEvent) {
    var layer = collectionEvent.element;
    this.registerLayerListeners_(layer);
    this.dispatchEvent(new GroupEvent("addlayer", layer));
    this.changed();
  };
  LayerGroup2.prototype.handleLayersRemove_ = function(collectionEvent) {
    var layer = collectionEvent.element;
    var key = getUid(layer);
    this.listenerKeys_[key].forEach(unlistenByKey);
    delete this.listenerKeys_[key];
    this.dispatchEvent(new GroupEvent("removelayer", layer));
    this.changed();
  };
  LayerGroup2.prototype.getLayers = function() {
    return this.get(Property$5.LAYERS);
  };
  LayerGroup2.prototype.setLayers = function(layers) {
    var collection = this.getLayers();
    if (collection) {
      var currentLayers = collection.getArray();
      for (var i2 = 0, ii = currentLayers.length; i2 < ii; ++i2) {
        this.dispatchEvent(new GroupEvent("removelayer", currentLayers[i2]));
      }
    }
    this.set(Property$5.LAYERS, layers);
  };
  LayerGroup2.prototype.getLayersArray = function(opt_array) {
    var array = opt_array !== void 0 ? opt_array : [];
    this.getLayers().forEach(function(layer) {
      layer.getLayersArray(array);
    });
    return array;
  };
  LayerGroup2.prototype.getLayerStatesArray = function(opt_states) {
    var states = opt_states !== void 0 ? opt_states : [];
    var pos = states.length;
    this.getLayers().forEach(function(layer) {
      layer.getLayerStatesArray(states);
    });
    var ownLayerState = this.getLayerState();
    var defaultZIndex = ownLayerState.zIndex;
    if (!opt_states && ownLayerState.zIndex === void 0) {
      defaultZIndex = 0;
    }
    for (var i2 = pos, ii = states.length; i2 < ii; i2++) {
      var layerState = states[i2];
      layerState.opacity *= ownLayerState.opacity;
      layerState.visible = layerState.visible && ownLayerState.visible;
      layerState.maxResolution = Math.min(layerState.maxResolution, ownLayerState.maxResolution);
      layerState.minResolution = Math.max(layerState.minResolution, ownLayerState.minResolution);
      layerState.minZoom = Math.max(layerState.minZoom, ownLayerState.minZoom);
      layerState.maxZoom = Math.min(layerState.maxZoom, ownLayerState.maxZoom);
      if (ownLayerState.extent !== void 0) {
        if (layerState.extent !== void 0) {
          layerState.extent = getIntersection(layerState.extent, ownLayerState.extent);
        } else {
          layerState.extent = ownLayerState.extent;
        }
      }
      if (layerState.zIndex === void 0) {
        layerState.zIndex = defaultZIndex;
      }
    }
    return states;
  };
  LayerGroup2.prototype.getSourceState = function() {
    return SourceState.READY;
  };
  return LayerGroup2;
}(ol_layer_Base$1);
var ol_layer_Group = LayerGroup;
var __extends$23 = globalThis && globalThis.__extends || function() {
  var extendStatics2 = function(d2, b2) {
    extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {
      d3.__proto__ = b3;
    } || function(d3, b3) {
      for (var p5 in b3)
        if (Object.prototype.hasOwnProperty.call(b3, p5))
          d3[p5] = b3[p5];
    };
    return extendStatics2(d2, b2);
  };
  return function(d2, b2) {
    if (typeof b2 !== "function" && b2 !== null)
      throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
    extendStatics2(d2, b2);
    function __() {
      this.constructor = d2;
    }
    d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
  };
}();
var MapEvent = function(_super) {
  __extends$23(MapEvent2, _super);
  function MapEvent2(type, map, opt_frameState) {
    var _this = _super.call(this, type) || this;
    _this.map = map;
    _this.frameState = opt_frameState !== void 0 ? opt_frameState : null;
    return _this;
  }
  return MapEvent2;
}(Event$1);
var MapEvent$1 = MapEvent;
var __extends$22 = globalThis && globalThis.__extends || function() {
  var extendStatics2 = function(d2, b2) {
    extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {
      d3.__proto__ = b3;
    } || function(d3, b3) {
      for (var p5 in b3)
        if (Object.prototype.hasOwnProperty.call(b3, p5))
          d3[p5] = b3[p5];
    };
    return extendStatics2(d2, b2);
  };
  return function(d2, b2) {
    if (typeof b2 !== "function" && b2 !== null)
      throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
    extendStatics2(d2, b2);
    function __() {
      this.constructor = d2;
    }
    d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
  };
}();
var MapBrowserEvent = function(_super) {
  __extends$22(MapBrowserEvent2, _super);
  function MapBrowserEvent2(type, map, originalEvent, opt_dragging, opt_frameState) {
    var _this = _super.call(this, type, map, opt_frameState) || this;
    _this.originalEvent = originalEvent;
    _this.pixel_ = null;
    _this.coordinate_ = null;
    _this.dragging = opt_dragging !== void 0 ? opt_dragging : false;
    return _this;
  }
  Object.defineProperty(MapBrowserEvent2.prototype, "pixel", {
    get: function() {
      if (!this.pixel_) {
        this.pixel_ = this.map.getEventPixel(this.originalEvent);
      }
      return this.pixel_;
    },
    set: function(pixel) {
      this.pixel_ = pixel;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(MapBrowserEvent2.prototype, "coordinate", {
    get: function() {
      if (!this.coordinate_) {
        this.coordinate_ = this.map.getCoordinateFromPixel(this.pixel);
      }
      return this.coordinate_;
    },
    set: function(coordinate) {
      this.coordinate_ = coordinate;
    },
    enumerable: false,
    configurable: true
  });
  MapBrowserEvent2.prototype.preventDefault = function() {
    _super.prototype.preventDefault.call(this);
    if ("preventDefault" in this.originalEvent) {
      this.originalEvent.preventDefault();
    }
  };
  MapBrowserEvent2.prototype.stopPropagation = function() {
    _super.prototype.stopPropagation.call(this);
    if ("stopPropagation" in this.originalEvent) {
      this.originalEvent.stopPropagation();
    }
  };
  return MapBrowserEvent2;
}(MapEvent$1);
var MapBrowserEvent$1 = MapBrowserEvent;
var MapBrowserEventType = {
  SINGLECLICK: "singleclick",
  CLICK: EventType.CLICK,
  DBLCLICK: EventType.DBLCLICK,
  POINTERDRAG: "pointerdrag",
  POINTERMOVE: "pointermove",
  POINTERDOWN: "pointerdown",
  POINTERUP: "pointerup",
  POINTEROVER: "pointerover",
  POINTEROUT: "pointerout",
  POINTERENTER: "pointerenter",
  POINTERLEAVE: "pointerleave",
  POINTERCANCEL: "pointercancel"
};
var PointerEventType = {
  POINTERMOVE: "pointermove",
  POINTERDOWN: "pointerdown",
  POINTERUP: "pointerup",
  POINTEROVER: "pointerover",
  POINTEROUT: "pointerout",
  POINTERENTER: "pointerenter",
  POINTERLEAVE: "pointerleave",
  POINTERCANCEL: "pointercancel"
};
var __extends$21 = globalThis && globalThis.__extends || function() {
  var extendStatics2 = function(d2, b2) {
    extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {
      d3.__proto__ = b3;
    } || function(d3, b3) {
      for (var p5 in b3)
        if (Object.prototype.hasOwnProperty.call(b3, p5))
          d3[p5] = b3[p5];
    };
    return extendStatics2(d2, b2);
  };
  return function(d2, b2) {
    if (typeof b2 !== "function" && b2 !== null)
      throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
    extendStatics2(d2, b2);
    function __() {
      this.constructor = d2;
    }
    d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
  };
}();
var MapBrowserEventHandler = function(_super) {
  __extends$21(MapBrowserEventHandler2, _super);
  function MapBrowserEventHandler2(map, moveTolerance) {
    var _this = _super.call(this, map) || this;
    _this.map_ = map;
    _this.clickTimeoutId_;
    _this.emulateClicks_ = false;
    _this.dragging_ = false;
    _this.dragListenerKeys_ = [];
    _this.moveTolerance_ = moveTolerance === void 0 ? 1 : moveTolerance;
    _this.down_ = null;
    var element = _this.map_.getViewport();
    _this.activePointers_ = 0;
    _this.trackedTouches_ = {};
    _this.element_ = element;
    _this.pointerdownListenerKey_ = listen(element, PointerEventType.POINTERDOWN, _this.handlePointerDown_, _this);
    _this.originalPointerMoveEvent_;
    _this.relayedListenerKey_ = listen(element, PointerEventType.POINTERMOVE, _this.relayEvent_, _this);
    _this.boundHandleTouchMove_ = _this.handleTouchMove_.bind(_this);
    _this.element_.addEventListener(EventType.TOUCHMOVE, _this.boundHandleTouchMove_, PASSIVE_EVENT_LISTENERS ? { passive: false } : false);
    return _this;
  }
  MapBrowserEventHandler2.prototype.emulateClick_ = function(pointerEvent) {
    var newEvent = new MapBrowserEvent$1(MapBrowserEventType.CLICK, this.map_, pointerEvent);
    this.dispatchEvent(newEvent);
    if (this.clickTimeoutId_ !== void 0) {
      clearTimeout(this.clickTimeoutId_);
      this.clickTimeoutId_ = void 0;
      newEvent = new MapBrowserEvent$1(MapBrowserEventType.DBLCLICK, this.map_, pointerEvent);
      this.dispatchEvent(newEvent);
    } else {
      this.clickTimeoutId_ = setTimeout(function() {
        this.clickTimeoutId_ = void 0;
        var newEvent2 = new MapBrowserEvent$1(MapBrowserEventType.SINGLECLICK, this.map_, pointerEvent);
        this.dispatchEvent(newEvent2);
      }.bind(this), 250);
    }
  };
  MapBrowserEventHandler2.prototype.updateActivePointers_ = function(pointerEvent) {
    var event = pointerEvent;
    if (event.type == MapBrowserEventType.POINTERUP || event.type == MapBrowserEventType.POINTERCANCEL) {
      delete this.trackedTouches_[event.pointerId];
    } else if (event.type == MapBrowserEventType.POINTERDOWN) {
      this.trackedTouches_[event.pointerId] = true;
    }
    this.activePointers_ = Object.keys(this.trackedTouches_).length;
  };
  MapBrowserEventHandler2.prototype.handlePointerUp_ = function(pointerEvent) {
    this.updateActivePointers_(pointerEvent);
    var newEvent = new MapBrowserEvent$1(MapBrowserEventType.POINTERUP, this.map_, pointerEvent);
    this.dispatchEvent(newEvent);
    if (this.emulateClicks_ && !newEvent.defaultPrevented && !this.dragging_ && this.isMouseActionButton_(pointerEvent)) {
      this.emulateClick_(this.down_);
    }
    if (this.activePointers_ === 0) {
      this.dragListenerKeys_.forEach(unlistenByKey);
      this.dragListenerKeys_.length = 0;
      this.dragging_ = false;
      this.down_ = null;
    }
  };
  MapBrowserEventHandler2.prototype.isMouseActionButton_ = function(pointerEvent) {
    return pointerEvent.button === 0;
  };
  MapBrowserEventHandler2.prototype.handlePointerDown_ = function(pointerEvent) {
    this.emulateClicks_ = this.activePointers_ === 0;
    this.updateActivePointers_(pointerEvent);
    var newEvent = new MapBrowserEvent$1(MapBrowserEventType.POINTERDOWN, this.map_, pointerEvent);
    this.dispatchEvent(newEvent);
    this.down_ = {};
    for (var property in pointerEvent) {
      var value = pointerEvent[property];
      this.down_[property] = typeof value === "function" ? VOID : value;
    }
    if (this.dragListenerKeys_.length === 0) {
      var doc = this.map_.getOwnerDocument();
      this.dragListenerKeys_.push(listen(doc, MapBrowserEventType.POINTERMOVE, this.handlePointerMove_, this), listen(doc, MapBrowserEventType.POINTERUP, this.handlePointerUp_, this), listen(this.element_, MapBrowserEventType.POINTERCANCEL, this.handlePointerUp_, this));
      if (this.element_.getRootNode && this.element_.getRootNode() !== doc) {
        this.dragListenerKeys_.push(listen(this.element_.getRootNode(), MapBrowserEventType.POINTERUP, this.handlePointerUp_, this));
      }
    }
  };
  MapBrowserEventHandler2.prototype.handlePointerMove_ = function(pointerEvent) {
    if (this.isMoving_(pointerEvent)) {
      this.dragging_ = true;
      var newEvent = new MapBrowserEvent$1(MapBrowserEventType.POINTERDRAG, this.map_, pointerEvent, this.dragging_);
      this.dispatchEvent(newEvent);
    }
  };
  MapBrowserEventHandler2.prototype.relayEvent_ = function(pointerEvent) {
    this.originalPointerMoveEvent_ = pointerEvent;
    var dragging = !!(this.down_ && this.isMoving_(pointerEvent));
    this.dispatchEvent(new MapBrowserEvent$1(pointerEvent.type, this.map_, pointerEvent, dragging));
  };
  MapBrowserEventHandler2.prototype.handleTouchMove_ = function(event) {
    var originalEvent = this.originalPointerMoveEvent_;
    if ((!originalEvent || originalEvent.defaultPrevented) && (typeof event.cancelable !== "boolean" || event.cancelable === true)) {
      event.preventDefault();
    }
  };
  MapBrowserEventHandler2.prototype.isMoving_ = function(pointerEvent) {
    return this.dragging_ || Math.abs(pointerEvent.clientX - this.down_.clientX) > this.moveTolerance_ || Math.abs(pointerEvent.clientY - this.down_.clientY) > this.moveTolerance_;
  };
  MapBrowserEventHandler2.prototype.disposeInternal = function() {
    if (this.relayedListenerKey_) {
      unlistenByKey(this.relayedListenerKey_);
      this.relayedListenerKey_ = null;
    }
    this.element_.removeEventListener(EventType.TOUCHMOVE, this.boundHandleTouchMove_);
    if (this.pointerdownListenerKey_) {
      unlistenByKey(this.pointerdownListenerKey_);
      this.pointerdownListenerKey_ = null;
    }
    this.dragListenerKeys_.forEach(unlistenByKey);
    this.dragListenerKeys_.length = 0;
    this.element_ = null;
    _super.prototype.disposeInternal.call(this);
  };
  return MapBrowserEventHandler2;
}(EventTarget);
var MapBrowserEventHandler$1 = MapBrowserEventHandler;
var MapEventType = {
  POSTRENDER: "postrender",
  MOVESTART: "movestart",
  MOVEEND: "moveend",
  LOADSTART: "loadstart",
  LOADEND: "loadend"
};
var MapProperty = {
  LAYERGROUP: "layergroup",
  SIZE: "size",
  TARGET: "target",
  VIEW: "view"
};
var DROP = Infinity;
var PriorityQueue = function() {
  function PriorityQueue2(priorityFunction, keyFunction) {
    this.priorityFunction_ = priorityFunction;
    this.keyFunction_ = keyFunction;
    this.elements_ = [];
    this.priorities_ = [];
    this.queuedElements_ = {};
  }
  PriorityQueue2.prototype.clear = function() {
    this.elements_.length = 0;
    this.priorities_.length = 0;
    clear$1(this.queuedElements_);
  };
  PriorityQueue2.prototype.dequeue = function() {
    var elements2 = this.elements_;
    var priorities = this.priorities_;
    var element = elements2[0];
    if (elements2.length == 1) {
      elements2.length = 0;
      priorities.length = 0;
    } else {
      elements2[0] = elements2.pop();
      priorities[0] = priorities.pop();
      this.siftUp_(0);
    }
    var elementKey = this.keyFunction_(element);
    delete this.queuedElements_[elementKey];
    return element;
  };
  PriorityQueue2.prototype.enqueue = function(element) {
    assert(!(this.keyFunction_(element) in this.queuedElements_), 31);
    var priority = this.priorityFunction_(element);
    if (priority != DROP) {
      this.elements_.push(element);
      this.priorities_.push(priority);
      this.queuedElements_[this.keyFunction_(element)] = true;
      this.siftDown_(0, this.elements_.length - 1);
      return true;
    }
    return false;
  };
  PriorityQueue2.prototype.getCount = function() {
    return this.elements_.length;
  };
  PriorityQueue2.prototype.getLeftChildIndex_ = function(index2) {
    return index2 * 2 + 1;
  };
  PriorityQueue2.prototype.getRightChildIndex_ = function(index2) {
    return index2 * 2 + 2;
  };
  PriorityQueue2.prototype.getParentIndex_ = function(index2) {
    return index2 - 1 >> 1;
  };
  PriorityQueue2.prototype.heapify_ = function() {
    var i2;
    for (i2 = (this.elements_.length >> 1) - 1; i2 >= 0; i2--) {
      this.siftUp_(i2);
    }
  };
  PriorityQueue2.prototype.isEmpty = function() {
    return this.elements_.length === 0;
  };
  PriorityQueue2.prototype.isKeyQueued = function(key) {
    return key in this.queuedElements_;
  };
  PriorityQueue2.prototype.isQueued = function(element) {
    return this.isKeyQueued(this.keyFunction_(element));
  };
  PriorityQueue2.prototype.siftUp_ = function(index2) {
    var elements2 = this.elements_;
    var priorities = this.priorities_;
    var count = elements2.length;
    var element = elements2[index2];
    var priority = priorities[index2];
    var startIndex = index2;
    while (index2 < count >> 1) {
      var lIndex = this.getLeftChildIndex_(index2);
      var rIndex = this.getRightChildIndex_(index2);
      var smallerChildIndex = rIndex < count && priorities[rIndex] < priorities[lIndex] ? rIndex : lIndex;
      elements2[index2] = elements2[smallerChildIndex];
      priorities[index2] = priorities[smallerChildIndex];
      index2 = smallerChildIndex;
    }
    elements2[index2] = element;
    priorities[index2] = priority;
    this.siftDown_(startIndex, index2);
  };
  PriorityQueue2.prototype.siftDown_ = function(startIndex, index2) {
    var elements2 = this.elements_;
    var priorities = this.priorities_;
    var element = elements2[index2];
    var priority = priorities[index2];
    while (index2 > startIndex) {
      var parentIndex = this.getParentIndex_(index2);
      if (priorities[parentIndex] > priority) {
        elements2[index2] = elements2[parentIndex];
        priorities[index2] = priorities[parentIndex];
        index2 = parentIndex;
      } else {
        break;
      }
    }
    elements2[index2] = element;
    priorities[index2] = priority;
  };
  PriorityQueue2.prototype.reprioritize = function() {
    var priorityFunction = this.priorityFunction_;
    var elements2 = this.elements_;
    var priorities = this.priorities_;
    var index2 = 0;
    var n2 = elements2.length;
    var element, i2, priority;
    for (i2 = 0; i2 < n2; ++i2) {
      element = elements2[i2];
      priority = priorityFunction(element);
      if (priority == DROP) {
        delete this.queuedElements_[this.keyFunction_(element)];
      } else {
        priorities[index2] = priority;
        elements2[index2++] = element;
      }
    }
    elements2.length = index2;
    priorities.length = index2;
    this.heapify_();
  };
  return PriorityQueue2;
}();
var PriorityQueue$1 = PriorityQueue;
var TileState = {
  IDLE: 0,
  LOADING: 1,
  LOADED: 2,
  ERROR: 3,
  EMPTY: 4
};
var __extends$20 = globalThis && globalThis.__extends || function() {
  var extendStatics2 = function(d2, b2) {
    extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {
      d3.__proto__ = b3;
    } || function(d3, b3) {
      for (var p5 in b3)
        if (Object.prototype.hasOwnProperty.call(b3, p5))
          d3[p5] = b3[p5];
    };
    return extendStatics2(d2, b2);
  };
  return function(d2, b2) {
    if (typeof b2 !== "function" && b2 !== null)
      throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
    extendStatics2(d2, b2);
    function __() {
      this.constructor = d2;
    }
    d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
  };
}();
var TileQueue = function(_super) {
  __extends$20(TileQueue2, _super);
  function TileQueue2(tilePriorityFunction, tileChangeCallback) {
    var _this = _super.call(this, function(element) {
      return tilePriorityFunction.apply(null, element);
    }, function(element) {
      return element[0].getKey();
    }) || this;
    _this.boundHandleTileChange_ = _this.handleTileChange.bind(_this);
    _this.tileChangeCallback_ = tileChangeCallback;
    _this.tilesLoading_ = 0;
    _this.tilesLoadingKeys_ = {};
    return _this;
  }
  TileQueue2.prototype.enqueue = function(element) {
    var added = _super.prototype.enqueue.call(this, element);
    if (added) {
      var tile2 = element[0];
      tile2.addEventListener(EventType.CHANGE, this.boundHandleTileChange_);
    }
    return added;
  };
  TileQueue2.prototype.getTilesLoading = function() {
    return this.tilesLoading_;
  };
  TileQueue2.prototype.handleTileChange = function(event) {
    var tile2 = event.target;
    var state = tile2.getState();
    if (state === TileState.LOADED || state === TileState.ERROR || state === TileState.EMPTY) {
      tile2.removeEventListener(EventType.CHANGE, this.boundHandleTileChange_);
      var tileKey = tile2.getKey();
      if (tileKey in this.tilesLoadingKeys_) {
        delete this.tilesLoadingKeys_[tileKey];
        --this.tilesLoading_;
      }
      this.tileChangeCallback_();
    }
  };
  TileQueue2.prototype.loadMoreTiles = function(maxTotalLoading, maxNewLoads) {
    var newLoads = 0;
    var state, tile2, tileKey;
    while (this.tilesLoading_ < maxTotalLoading && newLoads < maxNewLoads && this.getCount() > 0) {
      tile2 = this.dequeue()[0];
      tileKey = tile2.getKey();
      state = tile2.getState();
      if (state === TileState.IDLE && !(tileKey in this.tilesLoadingKeys_)) {
        this.tilesLoadingKeys_[tileKey] = true;
        ++this.tilesLoading_;
        ++newLoads;
        tile2.load();
      }
    }
  };
  return TileQueue2;
}(PriorityQueue$1);
var TileQueue$1 = TileQueue;
function getTilePriority(frameState, tile2, tileSourceKey, tileCenter, tileResolution) {
  if (!frameState || !(tileSourceKey in frameState.wantedTiles)) {
    return DROP;
  }
  if (!frameState.wantedTiles[tileSourceKey][tile2.getKey()]) {
    return DROP;
  }
  var center = frameState.viewState.center;
  var deltaX = tileCenter[0] - center[0];
  var deltaY = tileCenter[1] - center[1];
  return 65536 * Math.log(tileResolution) + Math.sqrt(deltaX * deltaX + deltaY * deltaY) / tileResolution;
}
var GeometryType = {
  POINT: "Point",
  LINE_STRING: "LineString",
  LINEAR_RING: "LinearRing",
  POLYGON: "Polygon",
  MULTI_POINT: "MultiPoint",
  MULTI_LINE_STRING: "MultiLineString",
  MULTI_POLYGON: "MultiPolygon",
  GEOMETRY_COLLECTION: "GeometryCollection",
  CIRCLE: "Circle"
};
var Units$1 = {
  RADIANS: "radians",
  DEGREES: "degrees",
  FEET: "ft",
  METERS: "m",
  PIXELS: "pixels",
  TILE_PIXELS: "tile-pixels",
  USFEET: "us-ft"
};
var METERS_PER_UNIT$1 = {};
METERS_PER_UNIT$1[Units$1.RADIANS] = 6370997 / (2 * Math.PI);
METERS_PER_UNIT$1[Units$1.DEGREES] = 2 * Math.PI * 6370997 / 360;
METERS_PER_UNIT$1[Units$1.FEET] = 0.3048;
METERS_PER_UNIT$1[Units$1.METERS] = 1;
METERS_PER_UNIT$1[Units$1.USFEET] = 1200 / 3937;
var Units$2 = Units$1;
var ViewHint = {
  ANIMATING: 0,
  INTERACTING: 1
};
var ViewProperty = {
  CENTER: "center",
  RESOLUTION: "resolution",
  ROTATION: "rotation"
};
var DEFAULT_MAX_ZOOM = 42;
var DEFAULT_TILE_SIZE = 256;
var Projection$2 = function() {
  function Projection2(options) {
    this.code_ = options.code;
    this.units_ = options.units;
    this.extent_ = options.extent !== void 0 ? options.extent : null;
    this.worldExtent_ = options.worldExtent !== void 0 ? options.worldExtent : null;
    this.axisOrientation_ = options.axisOrientation !== void 0 ? options.axisOrientation : "enu";
    this.global_ = options.global !== void 0 ? options.global : false;
    this.canWrapX_ = !!(this.global_ && this.extent_);
    this.getPointResolutionFunc_ = options.getPointResolution;
    this.defaultTileGrid_ = null;
    this.metersPerUnit_ = options.metersPerUnit;
  }
  Projection2.prototype.canWrapX = function() {
    return this.canWrapX_;
  };
  Projection2.prototype.getCode = function() {
    return this.code_;
  };
  Projection2.prototype.getExtent = function() {
    return this.extent_;
  };
  Projection2.prototype.getUnits = function() {
    return this.units_;
  };
  Projection2.prototype.getMetersPerUnit = function() {
    return this.metersPerUnit_ || METERS_PER_UNIT$1[this.units_];
  };
  Projection2.prototype.getWorldExtent = function() {
    return this.worldExtent_;
  };
  Projection2.prototype.getAxisOrientation = function() {
    return this.axisOrientation_;
  };
  Projection2.prototype.isGlobal = function() {
    return this.global_;
  };
  Projection2.prototype.setGlobal = function(global2) {
    this.global_ = global2;
    this.canWrapX_ = !!(global2 && this.extent_);
  };
  Projection2.prototype.getDefaultTileGrid = function() {
    return this.defaultTileGrid_;
  };
  Projection2.prototype.setDefaultTileGrid = function(tileGrid) {
    this.defaultTileGrid_ = tileGrid;
  };
  Projection2.prototype.setExtent = function(extent2) {
    this.extent_ = extent2;
    this.canWrapX_ = !!(this.global_ && extent2);
  };
  Projection2.prototype.setWorldExtent = function(worldExtent) {
    this.worldExtent_ = worldExtent;
  };
  Projection2.prototype.setGetPointResolution = function(func) {
    this.getPointResolutionFunc_ = func;
  };
  Projection2.prototype.getPointResolutionFunc = function() {
    return this.getPointResolutionFunc_;
  };
  return Projection2;
}();
var Projection$3 = Projection$2;
var __extends$1$ = globalThis && globalThis.__extends || function() {
  var extendStatics2 = function(d2, b2) {
    extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {
      d3.__proto__ = b3;
    } || function(d3, b3) {
      for (var p5 in b3)
        if (Object.prototype.hasOwnProperty.call(b3, p5))
          d3[p5] = b3[p5];
    };
    return extendStatics2(d2, b2);
  };
  return function(d2, b2) {
    if (typeof b2 !== "function" && b2 !== null)
      throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
    extendStatics2(d2, b2);
    function __() {
      this.constructor = d2;
    }
    d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
  };
}();
var RADIUS$1 = 6378137;
var HALF_SIZE = Math.PI * RADIUS$1;
var EXTENT$1 = [-HALF_SIZE, -HALF_SIZE, HALF_SIZE, HALF_SIZE];
var WORLD_EXTENT = [-180, -85, 180, 85];
var MAX_SAFE_Y = RADIUS$1 * Math.log(Math.tan(Math.PI / 2));
var EPSG3857Projection = function(_super) {
  __extends$1$(EPSG3857Projection2, _super);
  function EPSG3857Projection2(code) {
    return _super.call(this, {
      code,
      units: Units$2.METERS,
      extent: EXTENT$1,
      global: true,
      worldExtent: WORLD_EXTENT,
      getPointResolution: function(resolution, point) {
        return resolution / cosh$1(point[1] / RADIUS$1);
      }
    }) || this;
  }
  return EPSG3857Projection2;
}(Projection$3);
var PROJECTIONS$1 = [
  new EPSG3857Projection("EPSG:3857"),
  new EPSG3857Projection("EPSG:102100"),
  new EPSG3857Projection("EPSG:102113"),
  new EPSG3857Projection("EPSG:900913"),
  new EPSG3857Projection("http://www.opengis.net/def/crs/EPSG/0/3857"),
  new EPSG3857Projection("http://www.opengis.net/gml/srs/epsg.xml#3857")
];
function fromEPSG4326(input, opt_output, opt_dimension) {
  var length = input.length;
  var dimension = opt_dimension > 1 ? opt_dimension : 2;
  var output = opt_output;
  if (output === void 0) {
    if (dimension > 2) {
      output = input.slice();
    } else {
      output = new Array(length);
    }
  }
  for (var i2 = 0; i2 < length; i2 += dimension) {
    output[i2] = HALF_SIZE * input[i2] / 180;
    var y2 = RADIUS$1 * Math.log(Math.tan(Math.PI * (+input[i2 + 1] + 90) / 360));
    if (y2 > MAX_SAFE_Y) {
      y2 = MAX_SAFE_Y;
    } else if (y2 < -MAX_SAFE_Y) {
      y2 = -MAX_SAFE_Y;
    }
    output[i2 + 1] = y2;
  }
  return output;
}
function toEPSG4326(input, opt_output, opt_dimension) {
  var length = input.length;
  var dimension = opt_dimension > 1 ? opt_dimension : 2;
  var output = opt_output;
  if (output === void 0) {
    if (dimension > 2) {
      output = input.slice();
    } else {
      output = new Array(length);
    }
  }
  for (var i2 = 0; i2 < length; i2 += dimension) {
    output[i2] = 180 * input[i2] / HALF_SIZE;
    output[i2 + 1] = 360 * Math.atan(Math.exp(input[i2 + 1] / RADIUS$1)) / Math.PI - 90;
  }
  return output;
}
var __extends$1_ = globalThis && globalThis.__extends || function() {
  var extendStatics2 = function(d2, b2) {
    extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {
      d3.__proto__ = b3;
    } || function(d3, b3) {
      for (var p5 in b3)
        if (Object.prototype.hasOwnProperty.call(b3, p5))
          d3[p5] = b3[p5];
    };
    return extendStatics2(d2, b2);
  };
  return function(d2, b2) {
    if (typeof b2 !== "function" && b2 !== null)
      throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
    extendStatics2(d2, b2);
    function __() {
      this.constructor = d2;
    }
    d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
  };
}();
var RADIUS = 6378137;
var EXTENT = [-180, -90, 180, 90];
var METERS_PER_UNIT = Math.PI * RADIUS / 180;
var EPSG4326Projection = function(_super) {
  __extends$1_(EPSG4326Projection2, _super);
  function EPSG4326Projection2(code, opt_axisOrientation) {
    return _super.call(this, {
      code,
      units: Units$2.DEGREES,
      extent: EXTENT,
      axisOrientation: opt_axisOrientation,
      global: true,
      metersPerUnit: METERS_PER_UNIT,
      worldExtent: EXTENT
    }) || this;
  }
  return EPSG4326Projection2;
}(Projection$3);
var PROJECTIONS = [
  new EPSG4326Projection("CRS:84"),
  new EPSG4326Projection("EPSG:4326", "neu"),
  new EPSG4326Projection("urn:ogc:def:crs:OGC:1.3:CRS84"),
  new EPSG4326Projection("urn:ogc:def:crs:OGC:2:84"),
  new EPSG4326Projection("http://www.opengis.net/def/crs/OGC/1.3/CRS84"),
  new EPSG4326Projection("http://www.opengis.net/gml/srs/epsg.xml#4326", "neu"),
  new EPSG4326Projection("http://www.opengis.net/def/crs/EPSG/0/4326", "neu")
];
var cache = {};
function get$5(code) {
  return cache[code] || cache[code.replace(/urn:(x-)?ogc:def:crs:EPSG:(.*:)?(\w+)$/, "EPSG:$3")] || null;
}
function add$2(code, projection) {
  cache[code] = projection;
}
var transforms = {};
function add$1(source, destination, transformFn) {
  var sourceCode = source.getCode();
  var destinationCode = destination.getCode();
  if (!(sourceCode in transforms)) {
    transforms[sourceCode] = {};
  }
  transforms[sourceCode][destinationCode] = transformFn;
}
function get$4(sourceCode, destinationCode) {
  var transform2;
  if (sourceCode in transforms && destinationCode in transforms[sourceCode]) {
    transform2 = transforms[sourceCode][destinationCode];
  }
  return transform2;
}
var DEFAULT_RADIUS = 63710088e-1;
function getDistance(c1, c2, opt_radius) {
  var radius = opt_radius || DEFAULT_RADIUS;
  var lat1 = toRadians(c1[1]);
  var lat2 = toRadians(c2[1]);
  var deltaLatBy2 = (lat2 - lat1) / 2;
  var deltaLonBy2 = toRadians(c2[0] - c1[0]) / 2;
  var a2 = Math.sin(deltaLatBy2) * Math.sin(deltaLatBy2) + Math.sin(deltaLonBy2) * Math.sin(deltaLonBy2) * Math.cos(lat1) * Math.cos(lat2);
  return 2 * radius * Math.atan2(Math.sqrt(a2), Math.sqrt(1 - a2));
}
function offset(c1, distance2, bearing, opt_radius) {
  var radius = opt_radius || DEFAULT_RADIUS;
  var lat1 = toRadians(c1[1]);
  var lon1 = toRadians(c1[0]);
  var dByR = distance2 / radius;
  var lat = Math.asin(Math.sin(lat1) * Math.cos(dByR) + Math.cos(lat1) * Math.sin(dByR) * Math.cos(bearing));
  var lon = lon1 + Math.atan2(Math.sin(bearing) * Math.sin(dByR) * Math.cos(lat1), Math.cos(dByR) - Math.sin(lat1) * Math.sin(lat));
  return [toDegrees(lon), toDegrees(lat)];
}
var showCoordinateWarning = true;
function disableCoordinateWarning(opt_disable) {
  var hide = opt_disable === void 0 ? true : opt_disable;
  showCoordinateWarning = !hide;
}
function cloneTransform(input, opt_output, opt_dimension) {
  var output;
  if (opt_output !== void 0) {
    for (var i2 = 0, ii = input.length; i2 < ii; ++i2) {
      opt_output[i2] = input[i2];
    }
    output = opt_output;
  } else {
    output = input.slice();
  }
  return output;
}
function identityTransform(input, opt_output, opt_dimension) {
  if (opt_output !== void 0 && input !== opt_output) {
    for (var i2 = 0, ii = input.length; i2 < ii; ++i2) {
      opt_output[i2] = input[i2];
    }
    input = opt_output;
  }
  return input;
}
function addProjection(projection) {
  add$2(projection.getCode(), projection);
  add$1(projection, projection, cloneTransform);
}
function addProjections(projections2) {
  projections2.forEach(addProjection);
}
function get$3(projectionLike) {
  return typeof projectionLike === "string" ? get$5(projectionLike) : projectionLike || null;
}
function getPointResolution(projection, resolution, point, opt_units) {
  projection = get$3(projection);
  var pointResolution;
  var getter = projection.getPointResolutionFunc();
  if (getter) {
    pointResolution = getter(resolution, point);
    if (opt_units && opt_units !== projection.getUnits()) {
      var metersPerUnit = projection.getMetersPerUnit();
      if (metersPerUnit) {
        pointResolution = pointResolution * metersPerUnit / METERS_PER_UNIT$1[opt_units];
      }
    }
  } else {
    var units2 = projection.getUnits();
    if (units2 == Units$2.DEGREES && !opt_units || opt_units == Units$2.DEGREES) {
      pointResolution = resolution;
    } else {
      var toEPSG4326_1 = getTransformFromProjections(projection, get$3("EPSG:4326"));
      if (toEPSG4326_1 === identityTransform && units2 !== Units$2.DEGREES) {
        pointResolution = resolution * projection.getMetersPerUnit();
      } else {
        var vertices = [
          point[0] - resolution / 2,
          point[1],
          point[0] + resolution / 2,
          point[1],
          point[0],
          point[1] - resolution / 2,
          point[0],
          point[1] + resolution / 2
        ];
        vertices = toEPSG4326_1(vertices, vertices, 2);
        var width = getDistance(vertices.slice(0, 2), vertices.slice(2, 4));
        var height = getDistance(vertices.slice(4, 6), vertices.slice(6, 8));
        pointResolution = (width + height) / 2;
      }
      var metersPerUnit = opt_units ? METERS_PER_UNIT$1[opt_units] : projection.getMetersPerUnit();
      if (metersPerUnit !== void 0) {
        pointResolution /= metersPerUnit;
      }
    }
  }
  return pointResolution;
}
function addEquivalentProjections(projections2) {
  addProjections(projections2);
  projections2.forEach(function(source) {
    projections2.forEach(function(destination) {
      if (source !== destination) {
        add$1(source, destination, cloneTransform);
      }
    });
  });
}
function addEquivalentTransforms(projections1, projections2, forwardTransform, inverseTransform) {
  projections1.forEach(function(projection1) {
    projections2.forEach(function(projection2) {
      add$1(projection1, projection2, forwardTransform);
      add$1(projection2, projection1, inverseTransform);
    });
  });
}
function createProjection(projection, defaultCode) {
  if (!projection) {
    return get$3(defaultCode);
  } else if (typeof projection === "string") {
    return get$3(projection);
  } else {
    return projection;
  }
}
function createTransformFromCoordinateTransform(coordTransform) {
  return function(input, opt_output, opt_dimension) {
    var length = input.length;
    var dimension = opt_dimension !== void 0 ? opt_dimension : 2;
    var output = opt_output !== void 0 ? opt_output : new Array(length);
    for (var i2 = 0; i2 < length; i2 += dimension) {
      var point = coordTransform([input[i2], input[i2 + 1]]);
      output[i2] = point[0];
      output[i2 + 1] = point[1];
      for (var j2 = dimension - 1; j2 >= 2; --j2) {
        output[i2 + j2] = input[i2 + j2];
      }
    }
    return output;
  };
}
function addCoordinateTransforms(source, destination, forward2, inverse2) {
  var sourceProj = get$3(source);
  var destProj = get$3(destination);
  add$1(sourceProj, destProj, createTransformFromCoordinateTransform(forward2));
  add$1(destProj, sourceProj, createTransformFromCoordinateTransform(inverse2));
}
function equivalent(projection1, projection2) {
  if (projection1 === projection2) {
    return true;
  }
  var equalUnits = projection1.getUnits() === projection2.getUnits();
  if (projection1.getCode() === projection2.getCode()) {
    return equalUnits;
  } else {
    var transformFunc = getTransformFromProjections(projection1, projection2);
    return transformFunc === cloneTransform && equalUnits;
  }
}
function getTransformFromProjections(sourceProjection, destinationProjection) {
  var sourceCode = sourceProjection.getCode();
  var destinationCode = destinationProjection.getCode();
  var transformFunc = get$4(sourceCode, destinationCode);
  if (!transformFunc) {
    transformFunc = identityTransform;
  }
  return transformFunc;
}
function getTransform(source, destination) {
  var sourceProjection = get$3(source);
  var destinationProjection = get$3(destination);
  return getTransformFromProjections(sourceProjection, destinationProjection);
}
function transform$3(coordinate, source, destination) {
  var transformFunc = getTransform(source, destination);
  return transformFunc(coordinate, void 0, coordinate.length);
}
function transformExtent(extent2, source, destination, opt_stops) {
  var transformFunc = getTransform(source, destination);
  return applyTransform(extent2, transformFunc, void 0, opt_stops);
}
var userProjection = null;
function getUserProjection() {
  return userProjection;
}
function toUserCoordinate(coordinate, sourceProjection) {
  {
    return coordinate;
  }
}
function fromUserCoordinate(coordinate, destProjection) {
  {
    if (showCoordinateWarning && !equals(coordinate, [0, 0]) && coordinate[0] >= -180 && coordinate[0] <= 180 && coordinate[1] >= -90 && coordinate[1] <= 90) {
      showCoordinateWarning = false;
      console.warn("Call useGeographic() from ol/proj once to work with [longitude, latitude] coordinates.");
    }
    return coordinate;
  }
}
function toUserExtent(extent2, sourceProjection) {
  {
    return extent2;
  }
}
function fromUserExtent(extent2, destProjection) {
  {
    return extent2;
  }
}
function fromUserResolution(resolution, destProjection) {
  {
    return resolution;
  }
}
function createSafeCoordinateTransform(sourceProj, destProj, transform2) {
  return function(coord) {
    var sourceX = coord[0];
    var sourceY = coord[1];
    var transformed, worldsAway;
    if (sourceProj.canWrapX()) {
      var sourceExtent = sourceProj.getExtent();
      var sourceExtentWidth = getWidth(sourceExtent);
      worldsAway = getWorldsAway(coord, sourceProj, sourceExtentWidth);
      if (worldsAway) {
        sourceX = sourceX - worldsAway * sourceExtentWidth;
      }
      sourceX = clamp(sourceX, sourceExtent[0], sourceExtent[2]);
      sourceY = clamp(sourceY, sourceExtent[1], sourceExtent[3]);
      transformed = transform2([sourceX, sourceY]);
    } else {
      transformed = transform2(coord);
    }
    if (worldsAway && destProj.canWrapX()) {
      transformed[0] += worldsAway * getWidth(destProj.getExtent());
    }
    return transformed;
  };
}
function addCommon() {
  addEquivalentProjections(PROJECTIONS$1);
  addEquivalentProjections(PROJECTIONS);
  addEquivalentTransforms(PROJECTIONS, PROJECTIONS$1, fromEPSG4326, toEPSG4326);
}
addCommon();
function createExtent(extent2, onlyCenter, smooth) {
  return function(center, resolution, size, opt_isMoving, opt_centerShift) {
    if (!center) {
      return void 0;
    }
    if (!resolution && !onlyCenter) {
      return center;
    }
    var viewWidth = onlyCenter ? 0 : size[0] * resolution;
    var viewHeight = onlyCenter ? 0 : size[1] * resolution;
    var shiftX = opt_centerShift ? opt_centerShift[0] : 0;
    var shiftY = opt_centerShift ? opt_centerShift[1] : 0;
    var minX = extent2[0] + viewWidth / 2 + shiftX;
    var maxX = extent2[2] - viewWidth / 2 + shiftX;
    var minY = extent2[1] + viewHeight / 2 + shiftY;
    var maxY = extent2[3] - viewHeight / 2 + shiftY;
    if (minX > maxX) {
      minX = (maxX + minX) / 2;
      maxX = minX;
    }
    if (minY > maxY) {
      minY = (maxY + minY) / 2;
      maxY = minY;
    }
    var x2 = clamp(center[0], minX, maxX);
    var y2 = clamp(center[1], minY, maxY);
    if (opt_isMoving && smooth && resolution) {
      var ratio = 30 * resolution;
      x2 += -ratio * Math.log(1 + Math.max(0, minX - center[0]) / ratio) + ratio * Math.log(1 + Math.max(0, center[0] - maxX) / ratio);
      y2 += -ratio * Math.log(1 + Math.max(0, minY - center[1]) / ratio) + ratio * Math.log(1 + Math.max(0, center[1] - maxY) / ratio);
    }
    return [x2, y2];
  };
}
function none$1(center) {
  return center;
}
function getViewportClampedResolution(resolution, maxExtent, viewportSize, showFullExtent) {
  var xResolution = getWidth(maxExtent) / viewportSize[0];
  var yResolution = getHeight(maxExtent) / viewportSize[1];
  if (showFullExtent) {
    return Math.min(resolution, Math.max(xResolution, yResolution));
  }
  return Math.min(resolution, Math.min(xResolution, yResolution));
}
function getSmoothClampedResolution(resolution, maxResolution, minResolution) {
  var result = Math.min(resolution, maxResolution);
  var ratio = 50;
  result *= Math.log(1 + ratio * Math.max(0, resolution / maxResolution - 1)) / ratio + 1;
  if (minResolution) {
    result = Math.max(result, minResolution);
    result /= Math.log(1 + ratio * Math.max(0, minResolution / resolution - 1)) / ratio + 1;
  }
  return clamp(result, minResolution / 2, maxResolution * 2);
}
function createSnapToResolutions(resolutions, opt_smooth, opt_maxExtent, opt_showFullExtent) {
  return function(resolution, direction2, size, opt_isMoving) {
    if (resolution !== void 0) {
      var maxResolution = resolutions[0];
      var minResolution = resolutions[resolutions.length - 1];
      var cappedMaxRes = opt_maxExtent ? getViewportClampedResolution(maxResolution, opt_maxExtent, size, opt_showFullExtent) : maxResolution;
      if (opt_isMoving) {
        var smooth = opt_smooth !== void 0 ? opt_smooth : true;
        if (!smooth) {
          return clamp(resolution, minResolution, cappedMaxRes);
        }
        return getSmoothClampedResolution(resolution, cappedMaxRes, minResolution);
      }
      var capped = Math.min(cappedMaxRes, resolution);
      var z2 = Math.floor(linearFindNearest(resolutions, capped, direction2));
      if (resolutions[z2] > cappedMaxRes && z2 < resolutions.length - 1) {
        return resolutions[z2 + 1];
      }
      return resolutions[z2];
    } else {
      return void 0;
    }
  };
}
function createSnapToPower(power, maxResolution, opt_minResolution, opt_smooth, opt_maxExtent, opt_showFullExtent) {
  return function(resolution, direction2, size, opt_isMoving) {
    if (resolution !== void 0) {
      var cappedMaxRes = opt_maxExtent ? getViewportClampedResolution(maxResolution, opt_maxExtent, size, opt_showFullExtent) : maxResolution;
      var minResolution = opt_minResolution !== void 0 ? opt_minResolution : 0;
      if (opt_isMoving) {
        var smooth = opt_smooth !== void 0 ? opt_smooth : true;
        if (!smooth) {
          return clamp(resolution, minResolution, cappedMaxRes);
        }
        return getSmoothClampedResolution(resolution, cappedMaxRes, minResolution);
      }
      var tolerance = 1e-9;
      var minZoomLevel = Math.ceil(Math.log(maxResolution / cappedMaxRes) / Math.log(power) - tolerance);
      var offset2 = -direction2 * (0.5 - tolerance) + 0.5;
      var capped = Math.min(cappedMaxRes, resolution);
      var cappedZoomLevel = Math.floor(Math.log(maxResolution / capped) / Math.log(power) + offset2);
      var zoomLevel = Math.max(minZoomLevel, cappedZoomLevel);
      var newResolution = maxResolution / Math.pow(power, zoomLevel);
      return clamp(newResolution, minResolution, cappedMaxRes);
    } else {
      return void 0;
    }
  };
}
function createMinMaxResolution(maxResolution, minResolution, opt_smooth, opt_maxExtent, opt_showFullExtent) {
  return function(resolution, direction2, size, opt_isMoving) {
    if (resolution !== void 0) {
      var cappedMaxRes = opt_maxExtent ? getViewportClampedResolution(maxResolution, opt_maxExtent, size, opt_showFullExtent) : maxResolution;
      var smooth = opt_smooth !== void 0 ? opt_smooth : true;
      if (!smooth || !opt_isMoving) {
        return clamp(resolution, minResolution, cappedMaxRes);
      }
      return getSmoothClampedResolution(resolution, cappedMaxRes, minResolution);
    } else {
      return void 0;
    }
  };
}
function disable(rotation) {
  if (rotation !== void 0) {
    return 0;
  } else {
    return void 0;
  }
}
function none(rotation) {
  if (rotation !== void 0) {
    return rotation;
  } else {
    return void 0;
  }
}
function createSnapToN(n2) {
  var theta = 2 * Math.PI / n2;
  return function(rotation, opt_isMoving) {
    if (opt_isMoving) {
      return rotation;
    }
    if (rotation !== void 0) {
      rotation = Math.floor(rotation / theta + 0.5) * theta;
      return rotation;
    } else {
      return void 0;
    }
  };
}
function createSnapToZero(opt_tolerance) {
  var tolerance = opt_tolerance || toRadians(5);
  return function(rotation, opt_isMoving) {
    if (opt_isMoving) {
      return rotation;
    }
    if (rotation !== void 0) {
      if (Math.abs(rotation) <= tolerance) {
        return 0;
      } else {
        return rotation;
      }
    } else {
      return void 0;
    }
  };
}
function easeIn(t3) {
  return Math.pow(t3, 3);
}
function easeOut(t3) {
  return 1 - easeIn(1 - t3);
}
function inAndOut(t3) {
  return 3 * t3 * t3 - 2 * t3 * t3 * t3;
}
function linear(t3) {
  return t3;
}
function upAndDown(t3) {
  if (t3 < 0.5) {
    return inAndOut(2 * t3);
  } else {
    return 1 - inAndOut(2 * (t3 - 0.5));
  }
}
var animations = Object.freeze(Object.defineProperty({
  __proto__: null,
  easeIn,
  easeOut,
  inAndOut,
  linear,
  upAndDown
}, Symbol.toStringTag, { value: "Module" }));
var GeometryLayout = {
  XY: "XY",
  XYZ: "XYZ",
  XYM: "XYM",
  XYZM: "XYZM"
};
function transform2D(flatCoordinates, offset2, end, stride, transform2, opt_dest) {
  var dest = opt_dest ? opt_dest : [];
  var i2 = 0;
  for (var j2 = offset2; j2 < end; j2 += stride) {
    var x2 = flatCoordinates[j2];
    var y2 = flatCoordinates[j2 + 1];
    dest[i2++] = transform2[0] * x2 + transform2[2] * y2 + transform2[4];
    dest[i2++] = transform2[1] * x2 + transform2[3] * y2 + transform2[5];
  }
  if (opt_dest && dest.length != i2) {
    dest.length = i2;
  }
  return dest;
}
function rotate(flatCoordinates, offset2, end, stride, angle2, anchor, opt_dest) {
  var dest = opt_dest ? opt_dest : [];
  var cos = Math.cos(angle2);
  var sin = Math.sin(angle2);
  var anchorX = anchor[0];
  var anchorY = anchor[1];
  var i2 = 0;
  for (var j2 = offset2; j2 < end; j2 += stride) {
    var deltaX = flatCoordinates[j2] - anchorX;
    var deltaY = flatCoordinates[j2 + 1] - anchorY;
    dest[i2++] = anchorX + deltaX * cos - deltaY * sin;
    dest[i2++] = anchorY + deltaX * sin + deltaY * cos;
    for (var k2 = j2 + 2; k2 < j2 + stride; ++k2) {
      dest[i2++] = flatCoordinates[k2];
    }
  }
  if (opt_dest && dest.length != i2) {
    dest.length = i2;
  }
  return dest;
}
function scale$1(flatCoordinates, offset2, end, stride, sx, sy, anchor, opt_dest) {
  var dest = opt_dest ? opt_dest : [];
  var anchorX = anchor[0];
  var anchorY = anchor[1];
  var i2 = 0;
  for (var j2 = offset2; j2 < end; j2 += stride) {
    var deltaX = flatCoordinates[j2] - anchorX;
    var deltaY = flatCoordinates[j2 + 1] - anchorY;
    dest[i2++] = anchorX + sx * deltaX;
    dest[i2++] = anchorY + sy * deltaY;
    for (var k2 = j2 + 2; k2 < j2 + stride; ++k2) {
      dest[i2++] = flatCoordinates[k2];
    }
  }
  if (opt_dest && dest.length != i2) {
    dest.length = i2;
  }
  return dest;
}
function translate(flatCoordinates, offset2, end, stride, deltaX, deltaY, opt_dest) {
  var dest = opt_dest ? opt_dest : [];
  var i2 = 0;
  for (var j2 = offset2; j2 < end; j2 += stride) {
    dest[i2++] = flatCoordinates[j2] + deltaX;
    dest[i2++] = flatCoordinates[j2 + 1] + deltaY;
    for (var k2 = j2 + 2; k2 < j2 + stride; ++k2) {
      dest[i2++] = flatCoordinates[k2];
    }
  }
  if (opt_dest && dest.length != i2) {
    dest.length = i2;
  }
  return dest;
}
var __extends$1Z = globalThis && globalThis.__extends || function() {
  var extendStatics2 = function(d2, b2) {
    extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {
      d3.__proto__ = b3;
    } || function(d3, b3) {
      for (var p5 in b3)
        if (Object.prototype.hasOwnProperty.call(b3, p5))
          d3[p5] = b3[p5];
    };
    return extendStatics2(d2, b2);
  };
  return function(d2, b2) {
    if (typeof b2 !== "function" && b2 !== null)
      throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
    extendStatics2(d2, b2);
    function __() {
      this.constructor = d2;
    }
    d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
  };
}();
var tmpTransform$1 = create$6();
var Geometry = function(_super) {
  __extends$1Z(Geometry2, _super);
  function Geometry2() {
    var _this = _super.call(this) || this;
    _this.extent_ = createEmpty();
    _this.extentRevision_ = -1;
    _this.simplifiedGeometryMaxMinSquaredTolerance = 0;
    _this.simplifiedGeometryRevision = 0;
    _this.simplifyTransformedInternal = memoizeOne(function(revision, squaredTolerance, opt_transform) {
      if (!opt_transform) {
        return this.getSimplifiedGeometry(squaredTolerance);
      }
      var clone2 = this.clone();
      clone2.applyTransform(opt_transform);
      return clone2.getSimplifiedGeometry(squaredTolerance);
    });
    return _this;
  }
  Geometry2.prototype.simplifyTransformed = function(squaredTolerance, opt_transform) {
    return this.simplifyTransformedInternal(this.getRevision(), squaredTolerance, opt_transform);
  };
  Geometry2.prototype.clone = function() {
    return abstract();
  };
  Geometry2.prototype.closestPointXY = function(x2, y2, closestPoint, minSquaredDistance) {
    return abstract();
  };
  Geometry2.prototype.containsXY = function(x2, y2) {
    var coord = this.getClosestPoint([x2, y2]);
    return coord[0] === x2 && coord[1] === y2;
  };
  Geometry2.prototype.getClosestPoint = function(point, opt_closestPoint) {
    var closestPoint = opt_closestPoint ? opt_closestPoint : [NaN, NaN];
    this.closestPointXY(point[0], point[1], closestPoint, Infinity);
    return closestPoint;
  };
  Geometry2.prototype.intersectsCoordinate = function(coordinate) {
    return this.containsXY(coordinate[0], coordinate[1]);
  };
  Geometry2.prototype.computeExtent = function(extent2) {
    return abstract();
  };
  Geometry2.prototype.getExtent = function(opt_extent) {
    if (this.extentRevision_ != this.getRevision()) {
      var extent2 = this.computeExtent(this.extent_);
      if (isNaN(extent2[0]) || isNaN(extent2[1])) {
        createOrUpdateEmpty(extent2);
      }
      this.extentRevision_ = this.getRevision();
    }
    return returnOrUpdate(this.extent_, opt_extent);
  };
  Geometry2.prototype.rotate = function(angle2, anchor) {
    abstract();
  };
  Geometry2.prototype.scale = function(sx, opt_sy, opt_anchor) {
    abstract();
  };
  Geometry2.prototype.simplify = function(tolerance) {
    return this.getSimplifiedGeometry(tolerance * tolerance);
  };
  Geometry2.prototype.getSimplifiedGeometry = function(squaredTolerance) {
    return abstract();
  };
  Geometry2.prototype.getType = function() {
    return abstract();
  };
  Geometry2.prototype.applyTransform = function(transformFn) {
    abstract();
  };
  Geometry2.prototype.intersectsExtent = function(extent2) {
    return abstract();
  };
  Geometry2.prototype.translate = function(deltaX, deltaY) {
    abstract();
  };
  Geometry2.prototype.transform = function(source, destination) {
    var sourceProj = get$3(source);
    var transformFn = sourceProj.getUnits() == Units$2.TILE_PIXELS ? function(inCoordinates, outCoordinates, stride) {
      var pixelExtent = sourceProj.getExtent();
      var projectedExtent = sourceProj.getWorldExtent();
      var scale2 = getHeight(projectedExtent) / getHeight(pixelExtent);
      compose(tmpTransform$1, projectedExtent[0], projectedExtent[3], scale2, -scale2, 0, 0, 0);
      transform2D(inCoordinates, 0, inCoordinates.length, stride, tmpTransform$1, outCoordinates);
      return getTransform(sourceProj, destination)(inCoordinates, outCoordinates, stride);
    } : getTransform(sourceProj, destination);
    this.applyTransform(transformFn);
    return this;
  };
  return Geometry2;
}(ol_Object);
var Geometry$1 = Geometry;
var __extends$1Y = globalThis && globalThis.__extends || function() {
  var extendStatics2 = function(d2, b2) {
    extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {
      d3.__proto__ = b3;
    } || function(d3, b3) {
      for (var p5 in b3)
        if (Object.prototype.hasOwnProperty.call(b3, p5))
          d3[p5] = b3[p5];
    };
    return extendStatics2(d2, b2);
  };
  return function(d2, b2) {
    if (typeof b2 !== "function" && b2 !== null)
      throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
    extendStatics2(d2, b2);
    function __() {
      this.constructor = d2;
    }
    d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
  };
}();
var SimpleGeometry = function(_super) {
  __extends$1Y(SimpleGeometry2, _super);
  function SimpleGeometry2() {
    var _this = _super.call(this) || this;
    _this.layout = GeometryLayout.XY;
    _this.stride = 2;
    _this.flatCoordinates = null;
    return _this;
  }
  SimpleGeometry2.prototype.computeExtent = function(extent2) {
    return createOrUpdateFromFlatCoordinates(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, extent2);
  };
  SimpleGeometry2.prototype.getCoordinates = function() {
    return abstract();
  };
  SimpleGeometry2.prototype.getFirstCoordinate = function() {
    return this.flatCoordinates.slice(0, this.stride);
  };
  SimpleGeometry2.prototype.getFlatCoordinates = function() {
    return this.flatCoordinates;
  };
  SimpleGeometry2.prototype.getLastCoordinate = function() {
    return this.flatCoordinates.slice(this.flatCoordinates.length - this.stride);
  };
  SimpleGeometry2.prototype.getLayout = function() {
    return this.layout;
  };
  SimpleGeometry2.prototype.getSimplifiedGeometry = function(squaredTolerance) {
    if (this.simplifiedGeometryRevision !== this.getRevision()) {
      this.simplifiedGeometryMaxMinSquaredTolerance = 0;
      this.simplifiedGeometryRevision = this.getRevision();
    }
    if (squaredTolerance < 0 || this.simplifiedGeometryMaxMinSquaredTolerance !== 0 && squaredTolerance <= this.simplifiedGeometryMaxMinSquaredTolerance) {
      return this;
    }
    var simplifiedGeometry = this.getSimplifiedGeometryInternal(squaredTolerance);
    var simplifiedFlatCoordinates = simplifiedGeometry.getFlatCoordinates();
    if (simplifiedFlatCoordinates.length < this.flatCoordinates.length) {
      return simplifiedGeometry;
    } else {
      this.simplifiedGeometryMaxMinSquaredTolerance = squaredTolerance;
      return this;
    }
  };
  SimpleGeometry2.prototype.getSimplifiedGeometryInternal = function(squaredTolerance) {
    return this;
  };
  SimpleGeometry2.prototype.getStride = function() {
    return this.stride;
  };
  SimpleGeometry2.prototype.setFlatCoordinates = function(layout, flatCoordinates) {
    this.stride = getStrideForLayout(layout);
    this.layout = layout;
    this.flatCoordinates = flatCoordinates;
  };
  SimpleGeometry2.prototype.setCoordinates = function(coordinates2, opt_layout) {
    abstract();
  };
  SimpleGeometry2.prototype.setLayout = function(layout, coordinates2, nesting) {
    var stride;
    if (layout) {
      stride = getStrideForLayout(layout);
    } else {
      for (var i2 = 0; i2 < nesting; ++i2) {
        if (coordinates2.length === 0) {
          this.layout = GeometryLayout.XY;
          this.stride = 2;
          return;
        } else {
          coordinates2 = coordinates2[0];
        }
      }
      stride = coordinates2.length;
      layout = getLayoutForStride(stride);
    }
    this.layout = layout;
    this.stride = stride;
  };
  SimpleGeometry2.prototype.applyTransform = function(transformFn) {
    if (this.flatCoordinates) {
      transformFn(this.flatCoordinates, this.flatCoordinates, this.stride);
      this.changed();
    }
  };
  SimpleGeometry2.prototype.rotate = function(angle2, anchor) {
    var flatCoordinates = this.getFlatCoordinates();
    if (flatCoordinates) {
      var stride = this.getStride();
      rotate(flatCoordinates, 0, flatCoordinates.length, stride, angle2, anchor, flatCoordinates);
      this.changed();
    }
  };
  SimpleGeometry2.prototype.scale = function(sx, opt_sy, opt_anchor) {
    var sy = opt_sy;
    if (sy === void 0) {
      sy = sx;
    }
    var anchor = opt_anchor;
    if (!anchor) {
      anchor = getCenter(this.getExtent());
    }
    var flatCoordinates = this.getFlatCoordinates();
    if (flatCoordinates) {
      var stride = this.getStride();
      scale$1(flatCoordinates, 0, flatCoordinates.length, stride, sx, sy, anchor, flatCoordinates);
      this.changed();
    }
  };
  SimpleGeometry2.prototype.translate = function(deltaX, deltaY) {
    var flatCoordinates = this.getFlatCoordinates();
    if (flatCoordinates) {
      var stride = this.getStride();
      translate(flatCoordinates, 0, flatCoordinates.length, stride, deltaX, deltaY, flatCoordinates);
      this.changed();
    }
  };
  return SimpleGeometry2;
}(Geometry$1);
function getLayoutForStride(stride) {
  var layout;
  if (stride == 2) {
    layout = GeometryLayout.XY;
  } else if (stride == 3) {
    layout = GeometryLayout.XYZ;
  } else if (stride == 4) {
    layout = GeometryLayout.XYZM;
  }
  return layout;
}
function getStrideForLayout(layout) {
  var stride;
  if (layout == GeometryLayout.XY) {
    stride = 2;
  } else if (layout == GeometryLayout.XYZ || layout == GeometryLayout.XYM) {
    stride = 3;
  } else if (layout == GeometryLayout.XYZM) {
    stride = 4;
  }
  return stride;
}
function transformGeom2D(simpleGeometry, transform2, opt_dest) {
  var flatCoordinates = simpleGeometry.getFlatCoordinates();
  if (!flatCoordinates) {
    return null;
  } else {
    var stride = simpleGeometry.getStride();
    return transform2D(flatCoordinates, 0, flatCoordinates.length, stride, transform2, opt_dest);
  }
}
var SimpleGeometry$1 = SimpleGeometry;
function assignClosest(flatCoordinates, offset1, offset2, stride, x2, y2, closestPoint) {
  var x1 = flatCoordinates[offset1];
  var y1 = flatCoordinates[offset1 + 1];
  var dx = flatCoordinates[offset2] - x1;
  var dy = flatCoordinates[offset2 + 1] - y1;
  var offset3;
  if (dx === 0 && dy === 0) {
    offset3 = offset1;
  } else {
    var t3 = ((x2 - x1) * dx + (y2 - y1) * dy) / (dx * dx + dy * dy);
    if (t3 > 1) {
      offset3 = offset2;
    } else if (t3 > 0) {
      for (var i2 = 0; i2 < stride; ++i2) {
        closestPoint[i2] = lerp$1(flatCoordinates[offset1 + i2], flatCoordinates[offset2 + i2], t3);
      }
      closestPoint.length = stride;
      return;
    } else {
      offset3 = offset1;
    }
  }
  for (var i2 = 0; i2 < stride; ++i2) {
    closestPoint[i2] = flatCoordinates[offset3 + i2];
  }
  closestPoint.length = stride;
}
function maxSquaredDelta(flatCoordinates, offset2, end, stride, max2) {
  var x1 = flatCoordinates[offset2];
  var y1 = flatCoordinates[offset2 + 1];
  for (offset2 += stride; offset2 < end; offset2 += stride) {
    var x2 = flatCoordinates[offset2];
    var y2 = flatCoordinates[offset2 + 1];
    var squaredDelta = squaredDistance$1(x1, y1, x2, y2);
    if (squaredDelta > max2) {
      max2 = squaredDelta;
    }
    x1 = x2;
    y1 = y2;
  }
  return max2;
}
function arrayMaxSquaredDelta(flatCoordinates, offset2, ends, stride, max2) {
  for (var i2 = 0, ii = ends.length; i2 < ii; ++i2) {
    var end = ends[i2];
    max2 = maxSquaredDelta(flatCoordinates, offset2, end, stride, max2);
    offset2 = end;
  }
  return max2;
}
function multiArrayMaxSquaredDelta(flatCoordinates, offset2, endss, stride, max2) {
  for (var i2 = 0, ii = endss.length; i2 < ii; ++i2) {
    var ends = endss[i2];
    max2 = arrayMaxSquaredDelta(flatCoordinates, offset2, ends, stride, max2);
    offset2 = ends[ends.length - 1];
  }
  return max2;
}
function assignClosestPoint(flatCoordinates, offset2, end, stride, maxDelta, isRing, x2, y2, closestPoint, minSquaredDistance, opt_tmpPoint) {
  if (offset2 == end) {
    return minSquaredDistance;
  }
  var i2, squaredDistance2;
  if (maxDelta === 0) {
    squaredDistance2 = squaredDistance$1(x2, y2, flatCoordinates[offset2], flatCoordinates[offset2 + 1]);
    if (squaredDistance2 < minSquaredDistance) {
      for (i2 = 0; i2 < stride; ++i2) {
        closestPoint[i2] = flatCoordinates[offset2 + i2];
      }
      closestPoint.length = stride;
      return squaredDistance2;
    } else {
      return minSquaredDistance;
    }
  }
  var tmpPoint = opt_tmpPoint ? opt_tmpPoint : [NaN, NaN];
  var index2 = offset2 + stride;
  while (index2 < end) {
    assignClosest(flatCoordinates, index2 - stride, index2, stride, x2, y2, tmpPoint);
    squaredDistance2 = squaredDistance$1(x2, y2, tmpPoint[0], tmpPoint[1]);
    if (squaredDistance2 < minSquaredDistance) {
      minSquaredDistance = squaredDistance2;
      for (i2 = 0; i2 < stride; ++i2) {
        closestPoint[i2] = tmpPoint[i2];
      }
      closestPoint.length = stride;
      index2 += stride;
    } else {
      index2 += stride * Math.max((Math.sqrt(squaredDistance2) - Math.sqrt(minSquaredDistance)) / maxDelta | 0, 1);
    }
  }
  if (isRing) {
    assignClosest(flatCoordinates, end - stride, offset2, stride, x2, y2, tmpPoint);
    squaredDistance2 = squaredDistance$1(x2, y2, tmpPoint[0], tmpPoint[1]);
    if (squaredDistance2 < minSquaredDistance) {
      minSquaredDistance = squaredDistance2;
      for (i2 = 0; i2 < stride; ++i2) {
        closestPoint[i2] = tmpPoint[i2];
      }
      closestPoint.length = stride;
    }
  }
  return minSquaredDistance;
}
function assignClosestArrayPoint(flatCoordinates, offset2, ends, stride, maxDelta, isRing, x2, y2, closestPoint, minSquaredDistance, opt_tmpPoint) {
  var tmpPoint = opt_tmpPoint ? opt_tmpPoint : [NaN, NaN];
  for (var i2 = 0, ii = ends.length; i2 < ii; ++i2) {
    var end = ends[i2];
    minSquaredDistance = assignClosestPoint(flatCoordinates, offset2, end, stride, maxDelta, isRing, x2, y2, closestPoint, minSquaredDistance, tmpPoint);
    offset2 = end;
  }
  return minSquaredDistance;
}
function assignClosestMultiArrayPoint(flatCoordinates, offset2, endss, stride, maxDelta, isRing, x2, y2, closestPoint, minSquaredDistance, opt_tmpPoint) {
  var tmpPoint = opt_tmpPoint ? opt_tmpPoint : [NaN, NaN];
  for (var i2 = 0, ii = endss.length; i2 < ii; ++i2) {
    var ends = endss[i2];
    minSquaredDistance = assignClosestArrayPoint(flatCoordinates, offset2, ends, stride, maxDelta, isRing, x2, y2, closestPoint, minSquaredDistance, tmpPoint);
    offset2 = ends[ends.length - 1];
  }
  return minSquaredDistance;
}
function deflateCoordinate(flatCoordinates, offset2, coordinate, stride) {
  for (var i2 = 0, ii = coordinate.length; i2 < ii; ++i2) {
    flatCoordinates[offset2++] = coordinate[i2];
  }
  return offset2;
}
function deflateCoordinates(flatCoordinates, offset2, coordinates2, stride) {
  for (var i2 = 0, ii = coordinates2.length; i2 < ii; ++i2) {
    var coordinate = coordinates2[i2];
    for (var j2 = 0; j2 < stride; ++j2) {
      flatCoordinates[offset2++] = coordinate[j2];
    }
  }
  return offset2;
}
function deflateCoordinatesArray(flatCoordinates, offset2, coordinatess, stride, opt_ends) {
  var ends = opt_ends ? opt_ends : [];
  var i2 = 0;
  for (var j2 = 0, jj = coordinatess.length; j2 < jj; ++j2) {
    var end = deflateCoordinates(flatCoordinates, offset2, coordinatess[j2], stride);
    ends[i2++] = end;
    offset2 = end;
  }
  ends.length = i2;
  return ends;
}
function deflateMultiCoordinatesArray(flatCoordinates, offset2, coordinatesss, stride, opt_endss) {
  var endss = opt_endss ? opt_endss : [];
  var i2 = 0;
  for (var j2 = 0, jj = coordinatesss.length; j2 < jj; ++j2) {
    var ends = deflateCoordinatesArray(flatCoordinates, offset2, coordinatesss[j2], stride, endss[i2]);
    endss[i2++] = ends;
    offset2 = ends[ends.length - 1];
  }
  endss.length = i2;
  return endss;
}
function douglasPeucker(flatCoordinates, offset2, end, stride, squaredTolerance, simplifiedFlatCoordinates, simplifiedOffset) {
  var n2 = (end - offset2) / stride;
  if (n2 < 3) {
    for (; offset2 < end; offset2 += stride) {
      simplifiedFlatCoordinates[simplifiedOffset++] = flatCoordinates[offset2];
      simplifiedFlatCoordinates[simplifiedOffset++] = flatCoordinates[offset2 + 1];
    }
    return simplifiedOffset;
  }
  var markers = new Array(n2);
  markers[0] = 1;
  markers[n2 - 1] = 1;
  var stack = [offset2, end - stride];
  var index2 = 0;
  while (stack.length > 0) {
    var last = stack.pop();
    var first = stack.pop();
    var maxSquaredDistance = 0;
    var x1 = flatCoordinates[first];
    var y1 = flatCoordinates[first + 1];
    var x2 = flatCoordinates[last];
    var y2 = flatCoordinates[last + 1];
    for (var i2 = first + stride; i2 < last; i2 += stride) {
      var x3 = flatCoordinates[i2];
      var y3 = flatCoordinates[i2 + 1];
      var squaredDistance_1 = squaredSegmentDistance(x3, y3, x1, y1, x2, y2);
      if (squaredDistance_1 > maxSquaredDistance) {
        index2 = i2;
        maxSquaredDistance = squaredDistance_1;
      }
    }
    if (maxSquaredDistance > squaredTolerance) {
      markers[(index2 - offset2) / stride] = 1;
      if (first + stride < index2) {
        stack.push(first, index2);
      }
      if (index2 + stride < last) {
        stack.push(index2, last);
      }
    }
  }
  for (var i2 = 0; i2 < n2; ++i2) {
    if (markers[i2]) {
      simplifiedFlatCoordinates[simplifiedOffset++] = flatCoordinates[offset2 + i2 * stride];
      simplifiedFlatCoordinates[simplifiedOffset++] = flatCoordinates[offset2 + i2 * stride + 1];
    }
  }
  return simplifiedOffset;
}
function douglasPeuckerArray(flatCoordinates, offset2, ends, stride, squaredTolerance, simplifiedFlatCoordinates, simplifiedOffset, simplifiedEnds) {
  for (var i2 = 0, ii = ends.length; i2 < ii; ++i2) {
    var end = ends[i2];
    simplifiedOffset = douglasPeucker(flatCoordinates, offset2, end, stride, squaredTolerance, simplifiedFlatCoordinates, simplifiedOffset);
    simplifiedEnds.push(simplifiedOffset);
    offset2 = end;
  }
  return simplifiedOffset;
}
function snap(value, tolerance) {
  return tolerance * Math.round(value / tolerance);
}
function quantize(flatCoordinates, offset2, end, stride, tolerance, simplifiedFlatCoordinates, simplifiedOffset) {
  if (offset2 == end) {
    return simplifiedOffset;
  }
  var x1 = snap(flatCoordinates[offset2], tolerance);
  var y1 = snap(flatCoordinates[offset2 + 1], tolerance);
  offset2 += stride;
  simplifiedFlatCoordinates[simplifiedOffset++] = x1;
  simplifiedFlatCoordinates[simplifiedOffset++] = y1;
  var x2, y2;
  do {
    x2 = snap(flatCoordinates[offset2], tolerance);
    y2 = snap(flatCoordinates[offset2 + 1], tolerance);
    offset2 += stride;
    if (offset2 == end) {
      simplifiedFlatCoordinates[simplifiedOffset++] = x2;
      simplifiedFlatCoordinates[simplifiedOffset++] = y2;
      return simplifiedOffset;
    }
  } while (x2 == x1 && y2 == y1);
  while (offset2 < end) {
    var x3 = snap(flatCoordinates[offset2], tolerance);
    var y3 = snap(flatCoordinates[offset2 + 1], tolerance);
    offset2 += stride;
    if (x3 == x2 && y3 == y2) {
      continue;
    }
    var dx1 = x2 - x1;
    var dy1 = y2 - y1;
    var dx2 = x3 - x1;
    var dy2 = y3 - y1;
    if (dx1 * dy2 == dy1 * dx2 && (dx1 < 0 && dx2 < dx1 || dx1 == dx2 || dx1 > 0 && dx2 > dx1) && (dy1 < 0 && dy2 < dy1 || dy1 == dy2 || dy1 > 0 && dy2 > dy1)) {
      x2 = x3;
      y2 = y3;
      continue;
    }
    simplifiedFlatCoordinates[simplifiedOffset++] = x2;
    simplifiedFlatCoordinates[simplifiedOffset++] = y2;
    x1 = x2;
    y1 = y2;
    x2 = x3;
    y2 = y3;
  }
  simplifiedFlatCoordinates[simplifiedOffset++] = x2;
  simplifiedFlatCoordinates[simplifiedOffset++] = y2;
  return simplifiedOffset;
}
function quantizeArray(flatCoordinates, offset2, ends, stride, tolerance, simplifiedFlatCoordinates, simplifiedOffset, simplifiedEnds) {
  for (var i2 = 0, ii = ends.length; i2 < ii; ++i2) {
    var end = ends[i2];
    simplifiedOffset = quantize(flatCoordinates, offset2, end, stride, tolerance, simplifiedFlatCoordinates, simplifiedOffset);
    simplifiedEnds.push(simplifiedOffset);
    offset2 = end;
  }
  return simplifiedOffset;
}
function quantizeMultiArray(flatCoordinates, offset2, endss, stride, tolerance, simplifiedFlatCoordinates, simplifiedOffset, simplifiedEndss) {
  for (var i2 = 0, ii = endss.length; i2 < ii; ++i2) {
    var ends = endss[i2];
    var simplifiedEnds = [];
    simplifiedOffset = quantizeArray(flatCoordinates, offset2, ends, stride, tolerance, simplifiedFlatCoordinates, simplifiedOffset, simplifiedEnds);
    simplifiedEndss.push(simplifiedEnds);
    offset2 = ends[ends.length - 1];
  }
  return simplifiedOffset;
}
function inflateCoordinates(flatCoordinates, offset2, end, stride, opt_coordinates) {
  var coordinates2 = opt_coordinates !== void 0 ? opt_coordinates : [];
  var i2 = 0;
  for (var j2 = offset2; j2 < end; j2 += stride) {
    coordinates2[i2++] = flatCoordinates.slice(j2, j2 + stride);
  }
  coordinates2.length = i2;
  return coordinates2;
}
function inflateCoordinatesArray(flatCoordinates, offset2, ends, stride, opt_coordinatess) {
  var coordinatess = opt_coordinatess !== void 0 ? opt_coordinatess : [];
  var i2 = 0;
  for (var j2 = 0, jj = ends.length; j2 < jj; ++j2) {
    var end = ends[j2];
    coordinatess[i2++] = inflateCoordinates(flatCoordinates, offset2, end, stride, coordinatess[i2]);
    offset2 = end;
  }
  coordinatess.length = i2;
  return coordinatess;
}
function inflateMultiCoordinatesArray(flatCoordinates, offset2, endss, stride, opt_coordinatesss) {
  var coordinatesss = opt_coordinatesss !== void 0 ? opt_coordinatesss : [];
  var i2 = 0;
  for (var j2 = 0, jj = endss.length; j2 < jj; ++j2) {
    var ends = endss[j2];
    coordinatesss[i2++] = inflateCoordinatesArray(flatCoordinates, offset2, ends, stride, coordinatesss[i2]);
    offset2 = ends[ends.length - 1];
  }
  coordinatesss.length = i2;
  return coordinatesss;
}
function linearRing(flatCoordinates, offset2, end, stride) {
  var twiceArea = 0;
  var x1 = flatCoordinates[end - stride];
  var y1 = flatCoordinates[end - stride + 1];
  for (; offset2 < end; offset2 += stride) {
    var x2 = flatCoordinates[offset2];
    var y2 = flatCoordinates[offset2 + 1];
    twiceArea += y1 * x2 - x1 * y2;
    x1 = x2;
    y1 = y2;
  }
  return twiceArea / 2;
}
function linearRings(flatCoordinates, offset2, ends, stride) {
  var area = 0;
  for (var i2 = 0, ii = ends.length; i2 < ii; ++i2) {
    var end = ends[i2];
    area += linearRing(flatCoordinates, offset2, end, stride);
    offset2 = end;
  }
  return area;
}
function linearRingss$1(flatCoordinates, offset2, endss, stride) {
  var area = 0;
  for (var i2 = 0, ii = endss.length; i2 < ii; ++i2) {
    var ends = endss[i2];
    area += linearRings(flatCoordinates, offset2, ends, stride);
    offset2 = ends[ends.length - 1];
  }
  return area;
}
var __extends$1X = globalThis && globalThis.__extends || function() {
  var extendStatics2 = function(d2, b2) {
    extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {
      d3.__proto__ = b3;
    } || function(d3, b3) {
      for (var p5 in b3)
        if (Object.prototype.hasOwnProperty.call(b3, p5))
          d3[p5] = b3[p5];
    };
    return extendStatics2(d2, b2);
  };
  return function(d2, b2) {
    if (typeof b2 !== "function" && b2 !== null)
      throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
    extendStatics2(d2, b2);
    function __() {
      this.constructor = d2;
    }
    d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
  };
}();
var LinearRing = function(_super) {
  __extends$1X(LinearRing2, _super);
  function LinearRing2(coordinates2, opt_layout) {
    var _this = _super.call(this) || this;
    _this.maxDelta_ = -1;
    _this.maxDeltaRevision_ = -1;
    if (opt_layout !== void 0 && !Array.isArray(coordinates2[0])) {
      _this.setFlatCoordinates(opt_layout, coordinates2);
    } else {
      _this.setCoordinates(coordinates2, opt_layout);
    }
    return _this;
  }
  LinearRing2.prototype.clone = function() {
    return new LinearRing2(this.flatCoordinates.slice(), this.layout);
  };
  LinearRing2.prototype.closestPointXY = function(x2, y2, closestPoint, minSquaredDistance) {
    if (minSquaredDistance < closestSquaredDistanceXY(this.getExtent(), x2, y2)) {
      return minSquaredDistance;
    }
    if (this.maxDeltaRevision_ != this.getRevision()) {
      this.maxDelta_ = Math.sqrt(maxSquaredDelta(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, 0));
      this.maxDeltaRevision_ = this.getRevision();
    }
    return assignClosestPoint(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, this.maxDelta_, true, x2, y2, closestPoint, minSquaredDistance);
  };
  LinearRing2.prototype.getArea = function() {
    return linearRing(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride);
  };
  LinearRing2.prototype.getCoordinates = function() {
    return inflateCoordinates(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride);
  };
  LinearRing2.prototype.getSimplifiedGeometryInternal = function(squaredTolerance) {
    var simplifiedFlatCoordinates = [];
    simplifiedFlatCoordinates.length = douglasPeucker(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, squaredTolerance, simplifiedFlatCoordinates, 0);
    return new LinearRing2(simplifiedFlatCoordinates, GeometryLayout.XY);
  };
  LinearRing2.prototype.getType = function() {
    return GeometryType.LINEAR_RING;
  };
  LinearRing2.prototype.intersectsExtent = function(extent2) {
    return false;
  };
  LinearRing2.prototype.setCoordinates = function(coordinates2, opt_layout) {
    this.setLayout(opt_layout, coordinates2, 1);
    if (!this.flatCoordinates) {
      this.flatCoordinates = [];
    }
    this.flatCoordinates.length = deflateCoordinates(this.flatCoordinates, 0, coordinates2, this.stride);
    this.changed();
  };
  return LinearRing2;
}(SimpleGeometry$1);
var LinearRing$1 = LinearRing;
var __extends$1W = globalThis && globalThis.__extends || function() {
  var extendStatics2 = function(d2, b2) {
    extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {
      d3.__proto__ = b3;
    } || function(d3, b3) {
      for (var p5 in b3)
        if (Object.prototype.hasOwnProperty.call(b3, p5))
          d3[p5] = b3[p5];
    };
    return extendStatics2(d2, b2);
  };
  return function(d2, b2) {
    if (typeof b2 !== "function" && b2 !== null)
      throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
    extendStatics2(d2, b2);
    function __() {
      this.constructor = d2;
    }
    d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
  };
}();
var Point$3 = function(_super) {
  __extends$1W(Point2, _super);
  function Point2(coordinates2, opt_layout) {
    var _this = _super.call(this) || this;
    _this.setCoordinates(coordinates2, opt_layout);
    return _this;
  }
  Point2.prototype.clone = function() {
    var point = new Point2(this.flatCoordinates.slice(), this.layout);
    point.applyProperties(this);
    return point;
  };
  Point2.prototype.closestPointXY = function(x2, y2, closestPoint, minSquaredDistance) {
    var flatCoordinates = this.flatCoordinates;
    var squaredDistance2 = squaredDistance$1(x2, y2, flatCoordinates[0], flatCoordinates[1]);
    if (squaredDistance2 < minSquaredDistance) {
      var stride = this.stride;
      for (var i2 = 0; i2 < stride; ++i2) {
        closestPoint[i2] = flatCoordinates[i2];
      }
      closestPoint.length = stride;
      return squaredDistance2;
    } else {
      return minSquaredDistance;
    }
  };
  Point2.prototype.getCoordinates = function() {
    return !this.flatCoordinates ? [] : this.flatCoordinates.slice();
  };
  Point2.prototype.computeExtent = function(extent2) {
    return createOrUpdateFromCoordinate(this.flatCoordinates, extent2);
  };
  Point2.prototype.getType = function() {
    return GeometryType.POINT;
  };
  Point2.prototype.intersectsExtent = function(extent2) {
    return containsXY(extent2, this.flatCoordinates[0], this.flatCoordinates[1]);
  };
  Point2.prototype.setCoordinates = function(coordinates2, opt_layout) {
    this.setLayout(opt_layout, coordinates2, 0);
    if (!this.flatCoordinates) {
      this.flatCoordinates = [];
    }
    this.flatCoordinates.length = deflateCoordinate(this.flatCoordinates, 0, coordinates2, this.stride);
    this.changed();
  };
  return Point2;
}(SimpleGeometry$1);
var Point$4 = Point$3;
function linearRingContainsExtent(flatCoordinates, offset2, end, stride, extent2) {
  var outside = forEachCorner(extent2, function(coordinate) {
    return !linearRingContainsXY(flatCoordinates, offset2, end, stride, coordinate[0], coordinate[1]);
  });
  return !outside;
}
function linearRingContainsXY(flatCoordinates, offset2, end, stride, x2, y2) {
  var wn = 0;
  var x1 = flatCoordinates[end - stride];
  var y1 = flatCoordinates[end - stride + 1];
  for (; offset2 < end; offset2 += stride) {
    var x22 = flatCoordinates[offset2];
    var y22 = flatCoordinates[offset2 + 1];
    if (y1 <= y2) {
      if (y22 > y2 && (x22 - x1) * (y2 - y1) - (x2 - x1) * (y22 - y1) > 0) {
        wn++;
      }
    } else if (y22 <= y2 && (x22 - x1) * (y2 - y1) - (x2 - x1) * (y22 - y1) < 0) {
      wn--;
    }
    x1 = x22;
    y1 = y22;
  }
  return wn !== 0;
}
function linearRingsContainsXY(flatCoordinates, offset2, ends, stride, x2, y2) {
  if (ends.length === 0) {
    return false;
  }
  if (!linearRingContainsXY(flatCoordinates, offset2, ends[0], stride, x2, y2)) {
    return false;
  }
  for (var i2 = 1, ii = ends.length; i2 < ii; ++i2) {
    if (linearRingContainsXY(flatCoordinates, ends[i2 - 1], ends[i2], stride, x2, y2)) {
      return false;
    }
  }
  return true;
}
function linearRingssContainsXY(flatCoordinates, offset2, endss, stride, x2, y2) {
  if (endss.length === 0) {
    return false;
  }
  for (var i2 = 0, ii = endss.length; i2 < ii; ++i2) {
    var ends = endss[i2];
    if (linearRingsContainsXY(flatCoordinates, offset2, ends, stride, x2, y2)) {
      return true;
    }
    offset2 = ends[ends.length - 1];
  }
  return false;
}
function getInteriorPointOfArray(flatCoordinates, offset2, ends, stride, flatCenters, flatCentersOffset, opt_dest) {
  var i2, ii, x2, x1, x22, y1, y2;
  var y3 = flatCenters[flatCentersOffset + 1];
  var intersections = [];
  for (var r2 = 0, rr = ends.length; r2 < rr; ++r2) {
    var end = ends[r2];
    x1 = flatCoordinates[end - stride];
    y1 = flatCoordinates[end - stride + 1];
    for (i2 = offset2; i2 < end; i2 += stride) {
      x22 = flatCoordinates[i2];
      y2 = flatCoordinates[i2 + 1];
      if (y3 <= y1 && y2 <= y3 || y1 <= y3 && y3 <= y2) {
        x2 = (y3 - y1) / (y2 - y1) * (x22 - x1) + x1;
        intersections.push(x2);
      }
      x1 = x22;
      y1 = y2;
    }
  }
  var pointX = NaN;
  var maxSegmentLength = -Infinity;
  intersections.sort(numberSafeCompareFunction);
  x1 = intersections[0];
  for (i2 = 1, ii = intersections.length; i2 < ii; ++i2) {
    x22 = intersections[i2];
    var segmentLength = Math.abs(x22 - x1);
    if (segmentLength > maxSegmentLength) {
      x2 = (x1 + x22) / 2;
      if (linearRingsContainsXY(flatCoordinates, offset2, ends, stride, x2, y3)) {
        pointX = x2;
        maxSegmentLength = segmentLength;
      }
    }
    x1 = x22;
  }
  if (isNaN(pointX)) {
    pointX = flatCenters[flatCentersOffset];
  }
  if (opt_dest) {
    opt_dest.push(pointX, y3, maxSegmentLength);
    return opt_dest;
  } else {
    return [pointX, y3, maxSegmentLength];
  }
}
function getInteriorPointsOfMultiArray(flatCoordinates, offset2, endss, stride, flatCenters) {
  var interiorPoints = [];
  for (var i2 = 0, ii = endss.length; i2 < ii; ++i2) {
    var ends = endss[i2];
    interiorPoints = getInteriorPointOfArray(flatCoordinates, offset2, ends, stride, flatCenters, 2 * i2, interiorPoints);
    offset2 = ends[ends.length - 1];
  }
  return interiorPoints;
}
function forEach(flatCoordinates, offset2, end, stride, callback) {
  var ret;
  offset2 += stride;
  for (; offset2 < end; offset2 += stride) {
    ret = callback(flatCoordinates.slice(offset2 - stride, offset2), flatCoordinates.slice(offset2, offset2 + stride));
    if (ret) {
      return ret;
    }
  }
  return false;
}
function intersectsLineString(flatCoordinates, offset2, end, stride, extent2) {
  var coordinatesExtent = extendFlatCoordinates(createEmpty(), flatCoordinates, offset2, end, stride);
  if (!intersects$1(extent2, coordinatesExtent)) {
    return false;
  }
  if (containsExtent(extent2, coordinatesExtent)) {
    return true;
  }
  if (coordinatesExtent[0] >= extent2[0] && coordinatesExtent[2] <= extent2[2]) {
    return true;
  }
  if (coordinatesExtent[1] >= extent2[1] && coordinatesExtent[3] <= extent2[3]) {
    return true;
  }
  return forEach(flatCoordinates, offset2, end, stride, function(point1, point2) {
    return intersectsSegment(extent2, point1, point2);
  });
}
function intersectsLineStringArray(flatCoordinates, offset2, ends, stride, extent2) {
  for (var i2 = 0, ii = ends.length; i2 < ii; ++i2) {
    if (intersectsLineString(flatCoordinates, offset2, ends[i2], stride, extent2)) {
      return true;
    }
    offset2 = ends[i2];
  }
  return false;
}
function intersectsLinearRing(flatCoordinates, offset2, end, stride, extent2) {
  if (intersectsLineString(flatCoordinates, offset2, end, stride, extent2)) {
    return true;
  }
  if (linearRingContainsXY(flatCoordinates, offset2, end, stride, extent2[0], extent2[1])) {
    return true;
  }
  if (linearRingContainsXY(flatCoordinates, offset2, end, stride, extent2[0], extent2[3])) {
    return true;
  }
  if (linearRingContainsXY(flatCoordinates, offset2, end, stride, extent2[2], extent2[1])) {
    return true;
  }
  if (linearRingContainsXY(flatCoordinates, offset2, end, stride, extent2[2], extent2[3])) {
    return true;
  }
  return false;
}
function intersectsLinearRingArray(flatCoordinates, offset2, ends, stride, extent2) {
  if (!intersectsLinearRing(flatCoordinates, offset2, ends[0], stride, extent2)) {
    return false;
  }
  if (ends.length === 1) {
    return true;
  }
  for (var i2 = 1, ii = ends.length; i2 < ii; ++i2) {
    if (linearRingContainsExtent(flatCoordinates, ends[i2 - 1], ends[i2], stride, extent2)) {
      if (!intersectsLineString(flatCoordinates, ends[i2 - 1], ends[i2], stride, extent2)) {
        return false;
      }
    }
  }
  return true;
}
function intersectsLinearRingMultiArray(flatCoordinates, offset2, endss, stride, extent2) {
  for (var i2 = 0, ii = endss.length; i2 < ii; ++i2) {
    var ends = endss[i2];
    if (intersectsLinearRingArray(flatCoordinates, offset2, ends, stride, extent2)) {
      return true;
    }
    offset2 = ends[ends.length - 1];
  }
  return false;
}
function coordinates(flatCoordinates, offset2, end, stride) {
  while (offset2 < end - stride) {
    for (var i2 = 0; i2 < stride; ++i2) {
      var tmp = flatCoordinates[offset2 + i2];
      flatCoordinates[offset2 + i2] = flatCoordinates[end - stride + i2];
      flatCoordinates[end - stride + i2] = tmp;
    }
    offset2 += stride;
    end -= stride;
  }
}
function linearRingIsClockwise(flatCoordinates, offset2, end, stride) {
  var edge = 0;
  var x1 = flatCoordinates[end - stride];
  var y1 = flatCoordinates[end - stride + 1];
  for (; offset2 < end; offset2 += stride) {
    var x2 = flatCoordinates[offset2];
    var y2 = flatCoordinates[offset2 + 1];
    edge += (x2 - x1) * (y2 + y1);
    x1 = x2;
    y1 = y2;
  }
  return edge === 0 ? void 0 : edge > 0;
}
function linearRingsAreOriented(flatCoordinates, offset2, ends, stride, opt_right) {
  var right = opt_right !== void 0 ? opt_right : false;
  for (var i2 = 0, ii = ends.length; i2 < ii; ++i2) {
    var end = ends[i2];
    var isClockwise = linearRingIsClockwise(flatCoordinates, offset2, end, stride);
    if (i2 === 0) {
      if (right && isClockwise || !right && !isClockwise) {
        return false;
      }
    } else {
      if (right && !isClockwise || !right && isClockwise) {
        return false;
      }
    }
    offset2 = end;
  }
  return true;
}
function linearRingssAreOriented(flatCoordinates, offset2, endss, stride, opt_right) {
  for (var i2 = 0, ii = endss.length; i2 < ii; ++i2) {
    var ends = endss[i2];
    if (!linearRingsAreOriented(flatCoordinates, offset2, ends, stride, opt_right)) {
      return false;
    }
    if (ends.length) {
      offset2 = ends[ends.length - 1];
    }
  }
  return true;
}
function orientLinearRings(flatCoordinates, offset2, ends, stride, opt_right) {
  var right = opt_right !== void 0 ? opt_right : false;
  for (var i2 = 0, ii = ends.length; i2 < ii; ++i2) {
    var end = ends[i2];
    var isClockwise = linearRingIsClockwise(flatCoordinates, offset2, end, stride);
    var reverse2 = i2 === 0 ? right && isClockwise || !right && !isClockwise : right && !isClockwise || !right && isClockwise;
    if (reverse2) {
      coordinates(flatCoordinates, offset2, end, stride);
    }
    offset2 = end;
  }
  return offset2;
}
function orientLinearRingsArray(flatCoordinates, offset2, endss, stride, opt_right) {
  for (var i2 = 0, ii = endss.length; i2 < ii; ++i2) {
    offset2 = orientLinearRings(flatCoordinates, offset2, endss[i2], stride, opt_right);
  }
  return offset2;
}
function inflateEnds(flatCoordinates, ends) {
  var endss = [];
  var offset2 = 0;
  var prevEndIndex = 0;
  for (var i2 = 0, ii = ends.length; i2 < ii; ++i2) {
    var end = ends[i2];
    if (!linearRingIsClockwise(flatCoordinates, offset2, end, 2)) {
      endss.push(ends.slice(prevEndIndex, i2 + 1));
    } else {
      if (endss.length === 0) {
        continue;
      }
      endss[endss.length - 1].push(ends[prevEndIndex]);
    }
    prevEndIndex = i2 + 1;
    offset2 = end;
  }
  return endss;
}
var __extends$1V = globalThis && globalThis.__extends || function() {
  var extendStatics2 = function(d2, b2) {
    extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {
      d3.__proto__ = b3;
    } || function(d3, b3) {
      for (var p5 in b3)
        if (Object.prototype.hasOwnProperty.call(b3, p5))
          d3[p5] = b3[p5];
    };
    return extendStatics2(d2, b2);
  };
  return function(d2, b2) {
    if (typeof b2 !== "function" && b2 !== null)
      throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
    extendStatics2(d2, b2);
    function __() {
      this.constructor = d2;
    }
    d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
  };
}();
var Polygon$1 = function(_super) {
  __extends$1V(Polygon2, _super);
  function Polygon2(coordinates2, opt_layout, opt_ends) {
    var _this = _super.call(this) || this;
    _this.ends_ = [];
    _this.flatInteriorPointRevision_ = -1;
    _this.flatInteriorPoint_ = null;
    _this.maxDelta_ = -1;
    _this.maxDeltaRevision_ = -1;
    _this.orientedRevision_ = -1;
    _this.orientedFlatCoordinates_ = null;
    if (opt_layout !== void 0 && opt_ends) {
      _this.setFlatCoordinates(opt_layout, coordinates2);
      _this.ends_ = opt_ends;
    } else {
      _this.setCoordinates(coordinates2, opt_layout);
    }
    return _this;
  }
  Polygon2.prototype.appendLinearRing = function(linearRing2) {
    if (!this.flatCoordinates) {
      this.flatCoordinates = linearRing2.getFlatCoordinates().slice();
    } else {
      extend$3(this.flatCoordinates, linearRing2.getFlatCoordinates());
    }
    this.ends_.push(this.flatCoordinates.length);
    this.changed();
  };
  Polygon2.prototype.clone = function() {
    var polygon = new Polygon2(this.flatCoordinates.slice(), this.layout, this.ends_.slice());
    polygon.applyProperties(this);
    return polygon;
  };
  Polygon2.prototype.closestPointXY = function(x2, y2, closestPoint, minSquaredDistance) {
    if (minSquaredDistance < closestSquaredDistanceXY(this.getExtent(), x2, y2)) {
      return minSquaredDistance;
    }
    if (this.maxDeltaRevision_ != this.getRevision()) {
      this.maxDelta_ = Math.sqrt(arrayMaxSquaredDelta(this.flatCoordinates, 0, this.ends_, this.stride, 0));
      this.maxDeltaRevision_ = this.getRevision();
    }
    return assignClosestArrayPoint(this.flatCoordinates, 0, this.ends_, this.stride, this.maxDelta_, true, x2, y2, closestPoint, minSquaredDistance);
  };
  Polygon2.prototype.containsXY = function(x2, y2) {
    return linearRingsContainsXY(this.getOrientedFlatCoordinates(), 0, this.ends_, this.stride, x2, y2);
  };
  Polygon2.prototype.getArea = function() {
    return linearRings(this.getOrientedFlatCoordinates(), 0, this.ends_, this.stride);
  };
  Polygon2.prototype.getCoordinates = function(opt_right) {
    var flatCoordinates;
    if (opt_right !== void 0) {
      flatCoordinates = this.getOrientedFlatCoordinates().slice();
      orientLinearRings(flatCoordinates, 0, this.ends_, this.stride, opt_right);
    } else {
      flatCoordinates = this.flatCoordinates;
    }
    return inflateCoordinatesArray(flatCoordinates, 0, this.ends_, this.stride);
  };
  Polygon2.prototype.getEnds = function() {
    return this.ends_;
  };
  Polygon2.prototype.getFlatInteriorPoint = function() {
    if (this.flatInteriorPointRevision_ != this.getRevision()) {
      var flatCenter = getCenter(this.getExtent());
      this.flatInteriorPoint_ = getInteriorPointOfArray(this.getOrientedFlatCoordinates(), 0, this.ends_, this.stride, flatCenter, 0);
      this.flatInteriorPointRevision_ = this.getRevision();
    }
    return this.flatInteriorPoint_;
  };
  Polygon2.prototype.getInteriorPoint = function() {
    return new Point$4(this.getFlatInteriorPoint(), GeometryLayout.XYM);
  };
  Polygon2.prototype.getLinearRingCount = function() {
    return this.ends_.length;
  };
  Polygon2.prototype.getLinearRing = function(index2) {
    if (index2 < 0 || this.ends_.length <= index2) {
      return null;
    }
    return new LinearRing$1(this.flatCoordinates.slice(index2 === 0 ? 0 : this.ends_[index2 - 1], this.ends_[index2]), this.layout);
  };
  Polygon2.prototype.getLinearRings = function() {
    var layout = this.layout;
    var flatCoordinates = this.flatCoordinates;
    var ends = this.ends_;
    var linearRings2 = [];
    var offset2 = 0;
    for (var i2 = 0, ii = ends.length; i2 < ii; ++i2) {
      var end = ends[i2];
      var linearRing2 = new LinearRing$1(flatCoordinates.slice(offset2, end), layout);
      linearRings2.push(linearRing2);
      offset2 = end;
    }
    return linearRings2;
  };
  Polygon2.prototype.getOrientedFlatCoordinates = function() {
    if (this.orientedRevision_ != this.getRevision()) {
      var flatCoordinates = this.flatCoordinates;
      if (linearRingsAreOriented(flatCoordinates, 0, this.ends_, this.stride)) {
        this.orientedFlatCoordinates_ = flatCoordinates;
      } else {
        this.orientedFlatCoordinates_ = flatCoordinates.slice();
        this.orientedFlatCoordinates_.length = orientLinearRings(this.orientedFlatCoordinates_, 0, this.ends_, this.stride);
      }
      this.orientedRevision_ = this.getRevision();
    }
    return this.orientedFlatCoordinates_;
  };
  Polygon2.prototype.getSimplifiedGeometryInternal = function(squaredTolerance) {
    var simplifiedFlatCoordinates = [];
    var simplifiedEnds = [];
    simplifiedFlatCoordinates.length = quantizeArray(this.flatCoordinates, 0, this.ends_, this.stride, Math.sqrt(squaredTolerance), simplifiedFlatCoordinates, 0, simplifiedEnds);
    return new Polygon2(simplifiedFlatCoordinates, GeometryLayout.XY, simplifiedEnds);
  };
  Polygon2.prototype.getType = function() {
    return GeometryType.POLYGON;
  };
  Polygon2.prototype.intersectsExtent = function(extent2) {
    return intersectsLinearRingArray(this.getOrientedFlatCoordinates(), 0, this.ends_, this.stride, extent2);
  };
  Polygon2.prototype.setCoordinates = function(coordinates2, opt_layout) {
    this.setLayout(opt_layout, coordinates2, 2);
    if (!this.flatCoordinates) {
      this.flatCoordinates = [];
    }
    var ends = deflateCoordinatesArray(this.flatCoordinates, 0, coordinates2, this.stride, this.ends_);
    this.flatCoordinates.length = ends.length === 0 ? 0 : ends[ends.length - 1];
    this.changed();
  };
  return Polygon2;
}(SimpleGeometry$1);
var Polygon$2 = Polygon$1;
function circular(center, radius, opt_n, opt_sphereRadius) {
  var n2 = opt_n ? opt_n : 32;
  var flatCoordinates = [];
  for (var i2 = 0; i2 < n2; ++i2) {
    extend$3(flatCoordinates, offset(center, radius, 2 * Math.PI * i2 / n2, opt_sphereRadius));
  }
  flatCoordinates.push(flatCoordinates[0], flatCoordinates[1]);
  return new Polygon$1(flatCoordinates, GeometryLayout.XY, [
    flatCoordinates.length
  ]);
}
function fromExtent(extent2) {
  var minX = extent2[0];
  var minY = extent2[1];
  var maxX = extent2[2];
  var maxY = extent2[3];
  var flatCoordinates = [
    minX,
    minY,
    minX,
    maxY,
    maxX,
    maxY,
    maxX,
    minY,
    minX,
    minY
  ];
  return new Polygon$1(flatCoordinates, GeometryLayout.XY, [
    flatCoordinates.length
  ]);
}
function fromCircle(circle, opt_sides, opt_angle) {
  var sides = opt_sides ? opt_sides : 32;
  var stride = circle.getStride();
  var layout = circle.getLayout();
  var center = circle.getCenter();
  var arrayLength = stride * (sides + 1);
  var flatCoordinates = new Array(arrayLength);
  for (var i2 = 0; i2 < arrayLength; i2 += stride) {
    flatCoordinates[i2] = 0;
    flatCoordinates[i2 + 1] = 0;
    for (var j2 = 2; j2 < stride; j2++) {
      flatCoordinates[i2 + j2] = center[j2];
    }
  }
  var ends = [flatCoordinates.length];
  var polygon = new Polygon$1(flatCoordinates, layout, ends);
  makeRegular(polygon, center, circle.getRadius(), opt_angle);
  return polygon;
}
function makeRegular(polygon, center, radius, opt_angle) {
  var flatCoordinates = polygon.getFlatCoordinates();
  var stride = polygon.getStride();
  var sides = flatCoordinates.length / stride - 1;
  var startAngle = opt_angle ? opt_angle : 0;
  for (var i2 = 0; i2 <= sides; ++i2) {
    var offset2 = i2 * stride;
    var angle2 = startAngle + modulo(i2, sides) * 2 * Math.PI / sides;
    flatCoordinates[offset2] = center[0] + radius * Math.cos(angle2);
    flatCoordinates[offset2 + 1] = center[1] + radius * Math.sin(angle2);
  }
  polygon.changed();
}
var __extends$1U = globalThis && globalThis.__extends || function() {
  var extendStatics2 = function(d2, b2) {
    extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {
      d3.__proto__ = b3;
    } || function(d3, b3) {
      for (var p5 in b3)
        if (Object.prototype.hasOwnProperty.call(b3, p5))
          d3[p5] = b3[p5];
    };
    return extendStatics2(d2, b2);
  };
  return function(d2, b2) {
    if (typeof b2 !== "function" && b2 !== null)
      throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
    extendStatics2(d2, b2);
    function __() {
      this.constructor = d2;
    }
    d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
  };
}();
var DEFAULT_MIN_ZOOM = 0;
var View$1 = function(_super) {
  __extends$1U(View2, _super);
  function View2(opt_options) {
    var _this = _super.call(this) || this;
    _this.on;
    _this.once;
    _this.un;
    var options = assign({}, opt_options);
    _this.hints_ = [0, 0];
    _this.animations_ = [];
    _this.updateAnimationKey_;
    _this.projection_ = createProjection(options.projection, "EPSG:3857");
    _this.viewportSize_ = [100, 100];
    _this.targetCenter_ = null;
    _this.targetResolution_;
    _this.targetRotation_;
    _this.nextCenter_ = null;
    _this.nextResolution_;
    _this.nextRotation_;
    _this.cancelAnchor_ = void 0;
    if (options.projection) {
      disableCoordinateWarning();
    }
    if (options.center) {
      options.center = fromUserCoordinate(options.center, _this.projection_);
    }
    if (options.extent) {
      options.extent = fromUserExtent(options.extent, _this.projection_);
    }
    _this.applyOptions_(options);
    return _this;
  }
  View2.prototype.applyOptions_ = function(options) {
    var properties = assign({}, options);
    for (var key in ViewProperty) {
      delete properties[key];
    }
    this.setProperties(properties, true);
    var resolutionConstraintInfo = createResolutionConstraint(options);
    this.maxResolution_ = resolutionConstraintInfo.maxResolution;
    this.minResolution_ = resolutionConstraintInfo.minResolution;
    this.zoomFactor_ = resolutionConstraintInfo.zoomFactor;
    this.resolutions_ = options.resolutions;
    this.padding_ = options.padding;
    this.minZoom_ = resolutionConstraintInfo.minZoom;
    var centerConstraint = createCenterConstraint(options);
    var resolutionConstraint = resolutionConstraintInfo.constraint;
    var rotationConstraint = createRotationConstraint(options);
    this.constraints_ = {
      center: centerConstraint,
      resolution: resolutionConstraint,
      rotation: rotationConstraint
    };
    this.setRotation(options.rotation !== void 0 ? options.rotation : 0);
    this.setCenterInternal(options.center !== void 0 ? options.center : null);
    if (options.resolution !== void 0) {
      this.setResolution(options.resolution);
    } else if (options.zoom !== void 0) {
      this.setZoom(options.zoom);
    }
  };
  Object.defineProperty(View2.prototype, "padding", {
    get: function() {
      return this.padding_;
    },
    set: function(padding) {
      var oldPadding = this.padding_;
      this.padding_ = padding;
      var center = this.getCenter();
      if (center) {
        var newPadding = padding || [0, 0, 0, 0];
        oldPadding = oldPadding || [0, 0, 0, 0];
        var resolution = this.getResolution();
        var offsetX = resolution / 2 * (newPadding[3] - oldPadding[3] + oldPadding[1] - newPadding[1]);
        var offsetY = resolution / 2 * (newPadding[0] - oldPadding[0] + oldPadding[2] - newPadding[2]);
        this.setCenterInternal([center[0] + offsetX, center[1] - offsetY]);
      }
    },
    enumerable: false,
    configurable: true
  });
  View2.prototype.getUpdatedOptions_ = function(newOptions) {
    var options = this.getProperties();
    if (options.resolution !== void 0) {
      options.resolution = this.getResolution();
    } else {
      options.zoom = this.getZoom();
    }
    options.center = this.getCenterInternal();
    options.rotation = this.getRotation();
    return assign({}, options, newOptions);
  };
  View2.prototype.animate = function(var_args) {
    if (this.isDef() && !this.getAnimating()) {
      this.resolveConstraints(0);
    }
    var args = new Array(arguments.length);
    for (var i2 = 0; i2 < args.length; ++i2) {
      var options = arguments[i2];
      if (options.center) {
        options = assign({}, options);
        options.center = fromUserCoordinate(options.center, this.getProjection());
      }
      if (options.anchor) {
        options = assign({}, options);
        options.anchor = fromUserCoordinate(options.anchor, this.getProjection());
      }
      args[i2] = options;
    }
    this.animateInternal.apply(this, args);
  };
  View2.prototype.animateInternal = function(var_args) {
    var animationCount = arguments.length;
    var callback;
    if (animationCount > 1 && typeof arguments[animationCount - 1] === "function") {
      callback = arguments[animationCount - 1];
      --animationCount;
    }
    var i2 = 0;
    for (; i2 < animationCount && !this.isDef(); ++i2) {
      var state = arguments[i2];
      if (state.center) {
        this.setCenterInternal(state.center);
      }
      if (state.zoom !== void 0) {
        this.setZoom(state.zoom);
      } else if (state.resolution) {
        this.setResolution(state.resolution);
      }
      if (state.rotation !== void 0) {
        this.setRotation(state.rotation);
      }
    }
    if (i2 === animationCount) {
      if (callback) {
        animationCallback(callback, true);
      }
      return;
    }
    var start2 = Date.now();
    var center = this.targetCenter_.slice();
    var resolution = this.targetResolution_;
    var rotation = this.targetRotation_;
    var series = [];
    for (; i2 < animationCount; ++i2) {
      var options = arguments[i2];
      var animation = {
        start: start2,
        complete: false,
        anchor: options.anchor,
        duration: options.duration !== void 0 ? options.duration : 1e3,
        easing: options.easing || inAndOut,
        callback
      };
      if (options.center) {
        animation.sourceCenter = center;
        animation.targetCenter = options.center.slice();
        center = animation.targetCenter;
      }
      if (options.zoom !== void 0) {
        animation.sourceResolution = resolution;
        animation.targetResolution = this.getResolutionForZoom(options.zoom);
        resolution = animation.targetResolution;
      } else if (options.resolution) {
        animation.sourceResolution = resolution;
        animation.targetResolution = options.resolution;
        resolution = animation.targetResolution;
      }
      if (options.rotation !== void 0) {
        animation.sourceRotation = rotation;
        var delta = modulo(options.rotation - rotation + Math.PI, 2 * Math.PI) - Math.PI;
        animation.targetRotation = rotation + delta;
        rotation = animation.targetRotation;
      }
      if (isNoopAnimation(animation)) {
        animation.complete = true;
      } else {
        start2 += animation.duration;
      }
      series.push(animation);
    }
    this.animations_.push(series);
    this.setHint(ViewHint.ANIMATING, 1);
    this.updateAnimations_();
  };
  View2.prototype.getAnimating = function() {
    return this.hints_[ViewHint.ANIMATING] > 0;
  };
  View2.prototype.getInteracting = function() {
    return this.hints_[ViewHint.INTERACTING] > 0;
  };
  View2.prototype.cancelAnimations = function() {
    this.setHint(ViewHint.ANIMATING, -this.hints_[ViewHint.ANIMATING]);
    var anchor;
    for (var i2 = 0, ii = this.animations_.length; i2 < ii; ++i2) {
      var series = this.animations_[i2];
      if (series[0].callback) {
        animationCallback(series[0].callback, false);
      }
      if (!anchor) {
        for (var j2 = 0, jj = series.length; j2 < jj; ++j2) {
          var animation = series[j2];
          if (!animation.complete) {
            anchor = animation.anchor;
            break;
          }
        }
      }
    }
    this.animations_.length = 0;
    this.cancelAnchor_ = anchor;
    this.nextCenter_ = null;
    this.nextResolution_ = NaN;
    this.nextRotation_ = NaN;
  };
  View2.prototype.updateAnimations_ = function() {
    if (this.updateAnimationKey_ !== void 0) {
      cancelAnimationFrame(this.updateAnimationKey_);
      this.updateAnimationKey_ = void 0;
    }
    if (!this.getAnimating()) {
      return;
    }
    var now2 = Date.now();
    var more = false;
    for (var i2 = this.animations_.length - 1; i2 >= 0; --i2) {
      var series = this.animations_[i2];
      var seriesComplete = true;
      for (var j2 = 0, jj = series.length; j2 < jj; ++j2) {
        var animation = series[j2];
        if (animation.complete) {
          continue;
        }
        var elapsed = now2 - animation.start;
        var fraction = animation.duration > 0 ? elapsed / animation.duration : 1;
        if (fraction >= 1) {
          animation.complete = true;
          fraction = 1;
        } else {
          seriesComplete = false;
        }
        var progress = animation.easing(fraction);
        if (animation.sourceCenter) {
          var x0 = animation.sourceCenter[0];
          var y0 = animation.sourceCenter[1];
          var x1 = animation.targetCenter[0];
          var y1 = animation.targetCenter[1];
          this.nextCenter_ = animation.targetCenter;
          var x2 = x0 + progress * (x1 - x0);
          var y2 = y0 + progress * (y1 - y0);
          this.targetCenter_ = [x2, y2];
        }
        if (animation.sourceResolution && animation.targetResolution) {
          var resolution = progress === 1 ? animation.targetResolution : animation.sourceResolution + progress * (animation.targetResolution - animation.sourceResolution);
          if (animation.anchor) {
            var size = this.getViewportSize_(this.getRotation());
            var constrainedResolution = this.constraints_.resolution(resolution, 0, size, true);
            this.targetCenter_ = this.calculateCenterZoom(constrainedResolution, animation.anchor);
          }
          this.nextResolution_ = animation.targetResolution;
          this.targetResolution_ = resolution;
          this.applyTargetState_(true);
        }
        if (animation.sourceRotation !== void 0 && animation.targetRotation !== void 0) {
          var rotation = progress === 1 ? modulo(animation.targetRotation + Math.PI, 2 * Math.PI) - Math.PI : animation.sourceRotation + progress * (animation.targetRotation - animation.sourceRotation);
          if (animation.anchor) {
            var constrainedRotation = this.constraints_.rotation(rotation, true);
            this.targetCenter_ = this.calculateCenterRotate(constrainedRotation, animation.anchor);
          }
          this.nextRotation_ = animation.targetRotation;
          this.targetRotation_ = rotation;
        }
        this.applyTargetState_(true);
        more = true;
        if (!animation.complete) {
          break;
        }
      }
      if (seriesComplete) {
        this.animations_[i2] = null;
        this.setHint(ViewHint.ANIMATING, -1);
        this.nextCenter_ = null;
        this.nextResolution_ = NaN;
        this.nextRotation_ = NaN;
        var callback = series[0].callback;
        if (callback) {
          animationCallback(callback, true);
        }
      }
    }
    this.animations_ = this.animations_.filter(Boolean);
    if (more && this.updateAnimationKey_ === void 0) {
      this.updateAnimationKey_ = requestAnimationFrame(this.updateAnimations_.bind(this));
    }
  };
  View2.prototype.calculateCenterRotate = function(rotation, anchor) {
    var center;
    var currentCenter = this.getCenterInternal();
    if (currentCenter !== void 0) {
      center = [currentCenter[0] - anchor[0], currentCenter[1] - anchor[1]];
      rotate$1(center, rotation - this.getRotation());
      add$3(center, anchor);
    }
    return center;
  };
  View2.prototype.calculateCenterZoom = function(resolution, anchor) {
    var center;
    var currentCenter = this.getCenterInternal();
    var currentResolution = this.getResolution();
    if (currentCenter !== void 0 && currentResolution !== void 0) {
      var x2 = anchor[0] - resolution * (anchor[0] - currentCenter[0]) / currentResolution;
      var y2 = anchor[1] - resolution * (anchor[1] - currentCenter[1]) / currentResolution;
      center = [x2, y2];
    }
    return center;
  };
  View2.prototype.getViewportSize_ = function(opt_rotation) {
    var size = this.viewportSize_;
    if (opt_rotation) {
      var w2 = size[0];
      var h2 = size[1];
      return [
        Math.abs(w2 * Math.cos(opt_rotation)) + Math.abs(h2 * Math.sin(opt_rotation)),
        Math.abs(w2 * Math.sin(opt_rotation)) + Math.abs(h2 * Math.cos(opt_rotation))
      ];
    } else {
      return size;
    }
  };
  View2.prototype.setViewportSize = function(opt_size) {
    this.viewportSize_ = Array.isArray(opt_size) ? opt_size.slice() : [100, 100];
    if (!this.getAnimating()) {
      this.resolveConstraints(0);
    }
  };
  View2.prototype.getCenter = function() {
    var center = this.getCenterInternal();
    if (!center) {
      return center;
    }
    return toUserCoordinate(center, this.getProjection());
  };
  View2.prototype.getCenterInternal = function() {
    return this.get(ViewProperty.CENTER);
  };
  View2.prototype.getConstraints = function() {
    return this.constraints_;
  };
  View2.prototype.getConstrainResolution = function() {
    return this.get("constrainResolution");
  };
  View2.prototype.getHints = function(opt_hints) {
    if (opt_hints !== void 0) {
      opt_hints[0] = this.hints_[0];
      opt_hints[1] = this.hints_[1];
      return opt_hints;
    } else {
      return this.hints_.slice();
    }
  };
  View2.prototype.calculateExtent = function(opt_size) {
    var extent2 = this.calculateExtentInternal(opt_size);
    return toUserExtent(extent2, this.getProjection());
  };
  View2.prototype.calculateExtentInternal = function(opt_size) {
    var size = opt_size || this.getViewportSizeMinusPadding_();
    var center = this.getCenterInternal();
    assert(center, 1);
    var resolution = this.getResolution();
    assert(resolution !== void 0, 2);
    var rotation = this.getRotation();
    assert(rotation !== void 0, 3);
    return getForViewAndSize(center, resolution, rotation, size);
  };
  View2.prototype.getMaxResolution = function() {
    return this.maxResolution_;
  };
  View2.prototype.getMinResolution = function() {
    return this.minResolution_;
  };
  View2.prototype.getMaxZoom = function() {
    return this.getZoomForResolution(this.minResolution_);
  };
  View2.prototype.setMaxZoom = function(zoom) {
    this.applyOptions_(this.getUpdatedOptions_({ maxZoom: zoom }));
  };
  View2.prototype.getMinZoom = function() {
    return this.getZoomForResolution(this.maxResolution_);
  };
  View2.prototype.setMinZoom = function(zoom) {
    this.applyOptions_(this.getUpdatedOptions_({ minZoom: zoom }));
  };
  View2.prototype.setConstrainResolution = function(enabled) {
    this.applyOptions_(this.getUpdatedOptions_({ constrainResolution: enabled }));
  };
  View2.prototype.getProjection = function() {
    return this.projection_;
  };
  View2.prototype.getResolution = function() {
    return this.get(ViewProperty.RESOLUTION);
  };
  View2.prototype.getResolutions = function() {
    return this.resolutions_;
  };
  View2.prototype.getResolutionForExtent = function(extent2, opt_size) {
    return this.getResolutionForExtentInternal(fromUserExtent(extent2, this.getProjection()), opt_size);
  };
  View2.prototype.getResolutionForExtentInternal = function(extent2, opt_size) {
    var size = opt_size || this.getViewportSizeMinusPadding_();
    var xResolution = getWidth(extent2) / size[0];
    var yResolution = getHeight(extent2) / size[1];
    return Math.max(xResolution, yResolution);
  };
  View2.prototype.getResolutionForValueFunction = function(opt_power) {
    var power = opt_power || 2;
    var maxResolution = this.getConstrainedResolution(this.maxResolution_);
    var minResolution = this.minResolution_;
    var max2 = Math.log(maxResolution / minResolution) / Math.log(power);
    return function(value) {
      var resolution = maxResolution / Math.pow(power, value * max2);
      return resolution;
    };
  };
  View2.prototype.getRotation = function() {
    return this.get(ViewProperty.ROTATION);
  };
  View2.prototype.getValueForResolutionFunction = function(opt_power) {
    var logPower = Math.log(opt_power || 2);
    var maxResolution = this.getConstrainedResolution(this.maxResolution_);
    var minResolution = this.minResolution_;
    var max2 = Math.log(maxResolution / minResolution) / logPower;
    return function(resolution) {
      var value = Math.log(maxResolution / resolution) / logPower / max2;
      return value;
    };
  };
  View2.prototype.getViewportSizeMinusPadding_ = function(opt_rotation) {
    var size = this.getViewportSize_(opt_rotation);
    var padding = this.padding_;
    if (padding) {
      size = [
        size[0] - padding[1] - padding[3],
        size[1] - padding[0] - padding[2]
      ];
    }
    return size;
  };
  View2.prototype.getState = function() {
    var projection = this.getProjection();
    var resolution = this.getResolution();
    var rotation = this.getRotation();
    var center = this.getCenterInternal();
    var padding = this.padding_;
    if (padding) {
      var reducedSize = this.getViewportSizeMinusPadding_();
      center = calculateCenterOn(center, this.getViewportSize_(), [reducedSize[0] / 2 + padding[3], reducedSize[1] / 2 + padding[0]], resolution, rotation);
    }
    return {
      center: center.slice(0),
      projection: projection !== void 0 ? projection : null,
      resolution,
      nextCenter: this.nextCenter_,
      nextResolution: this.nextResolution_,
      nextRotation: this.nextRotation_,
      rotation,
      zoom: this.getZoom()
    };
  };
  View2.prototype.getZoom = function() {
    var zoom;
    var resolution = this.getResolution();
    if (resolution !== void 0) {
      zoom = this.getZoomForResolution(resolution);
    }
    return zoom;
  };
  View2.prototype.getZoomForResolution = function(resolution) {
    var offset2 = this.minZoom_ || 0;
    var max2, zoomFactor;
    if (this.resolutions_) {
      var nearest = linearFindNearest(this.resolutions_, resolution, 1);
      offset2 = nearest;
      max2 = this.resolutions_[nearest];
      if (nearest == this.resolutions_.length - 1) {
        zoomFactor = 2;
      } else {
        zoomFactor = max2 / this.resolutions_[nearest + 1];
      }
    } else {
      max2 = this.maxResolution_;
      zoomFactor = this.zoomFactor_;
    }
    return offset2 + Math.log(max2 / resolution) / Math.log(zoomFactor);
  };
  View2.prototype.getResolutionForZoom = function(zoom) {
    if (this.resolutions_) {
      if (this.resolutions_.length <= 1) {
        return 0;
      }
      var baseLevel = clamp(Math.floor(zoom), 0, this.resolutions_.length - 2);
      var zoomFactor = this.resolutions_[baseLevel] / this.resolutions_[baseLevel + 1];
      return this.resolutions_[baseLevel] / Math.pow(zoomFactor, clamp(zoom - baseLevel, 0, 1));
    } else {
      return this.maxResolution_ / Math.pow(this.zoomFactor_, zoom - this.minZoom_);
    }
  };
  View2.prototype.fit = function(geometryOrExtent, opt_options) {
    var geometry;
    assert(Array.isArray(geometryOrExtent) || typeof geometryOrExtent.getSimplifiedGeometry === "function", 24);
    if (Array.isArray(geometryOrExtent)) {
      assert(!isEmpty$1(geometryOrExtent), 25);
      var extent2 = fromUserExtent(geometryOrExtent, this.getProjection());
      geometry = fromExtent(extent2);
    } else if (geometryOrExtent.getType() === GeometryType.CIRCLE) {
      var extent2 = fromUserExtent(geometryOrExtent.getExtent(), this.getProjection());
      geometry = fromExtent(extent2);
      geometry.rotate(this.getRotation(), getCenter(extent2));
    } else {
      var userProjection2 = getUserProjection();
      if (userProjection2) {
        geometry = geometryOrExtent.clone().transform(userProjection2, this.getProjection());
      } else {
        geometry = geometryOrExtent;
      }
    }
    this.fitInternal(geometry, opt_options);
  };
  View2.prototype.rotatedExtentForGeometry = function(geometry) {
    var rotation = this.getRotation();
    var cosAngle = Math.cos(rotation);
    var sinAngle = Math.sin(-rotation);
    var coords = geometry.getFlatCoordinates();
    var stride = geometry.getStride();
    var minRotX = Infinity;
    var minRotY = Infinity;
    var maxRotX = -Infinity;
    var maxRotY = -Infinity;
    for (var i2 = 0, ii = coords.length; i2 < ii; i2 += stride) {
      var rotX = coords[i2] * cosAngle - coords[i2 + 1] * sinAngle;
      var rotY = coords[i2] * sinAngle + coords[i2 + 1] * cosAngle;
      minRotX = Math.min(minRotX, rotX);
      minRotY = Math.min(minRotY, rotY);
      maxRotX = Math.max(maxRotX, rotX);
      maxRotY = Math.max(maxRotY, rotY);
    }
    return [minRotX, minRotY, maxRotX, maxRotY];
  };
  View2.prototype.fitInternal = function(geometry, opt_options) {
    var options = opt_options || {};
    var size = options.size;
    if (!size) {
      size = this.getViewportSizeMinusPadding_();
    }
    var padding = options.padding !== void 0 ? options.padding : [0, 0, 0, 0];
    var nearest = options.nearest !== void 0 ? options.nearest : false;
    var minResolution;
    if (options.minResolution !== void 0) {
      minResolution = options.minResolution;
    } else if (options.maxZoom !== void 0) {
      minResolution = this.getResolutionForZoom(options.maxZoom);
    } else {
      minResolution = 0;
    }
    var rotatedExtent = this.rotatedExtentForGeometry(geometry);
    var resolution = this.getResolutionForExtentInternal(rotatedExtent, [
      size[0] - padding[1] - padding[3],
      size[1] - padding[0] - padding[2]
    ]);
    resolution = isNaN(resolution) ? minResolution : Math.max(resolution, minResolution);
    resolution = this.getConstrainedResolution(resolution, nearest ? 0 : 1);
    var rotation = this.getRotation();
    var sinAngle = Math.sin(rotation);
    var cosAngle = Math.cos(rotation);
    var centerRot = getCenter(rotatedExtent);
    centerRot[0] += (padding[1] - padding[3]) / 2 * resolution;
    centerRot[1] += (padding[0] - padding[2]) / 2 * resolution;
    var centerX = centerRot[0] * cosAngle - centerRot[1] * sinAngle;
    var centerY = centerRot[1] * cosAngle + centerRot[0] * sinAngle;
    var center = this.getConstrainedCenter([centerX, centerY], resolution);
    var callback = options.callback ? options.callback : VOID;
    if (options.duration !== void 0) {
      this.animateInternal({
        resolution,
        center,
        duration: options.duration,
        easing: options.easing
      }, callback);
    } else {
      this.targetResolution_ = resolution;
      this.targetCenter_ = center;
      this.applyTargetState_(false, true);
      animationCallback(callback, true);
    }
  };
  View2.prototype.centerOn = function(coordinate, size, position2) {
    this.centerOnInternal(fromUserCoordinate(coordinate, this.getProjection()), size, position2);
  };
  View2.prototype.centerOnInternal = function(coordinate, size, position2) {
    this.setCenterInternal(calculateCenterOn(coordinate, size, position2, this.getResolution(), this.getRotation()));
  };
  View2.prototype.calculateCenterShift = function(center, resolution, rotation, size) {
    var centerShift;
    var padding = this.padding_;
    if (padding && center) {
      var reducedSize = this.getViewportSizeMinusPadding_(-rotation);
      var shiftedCenter = calculateCenterOn(center, size, [reducedSize[0] / 2 + padding[3], reducedSize[1] / 2 + padding[0]], resolution, rotation);
      centerShift = [
        center[0] - shiftedCenter[0],
        center[1] - shiftedCenter[1]
      ];
    }
    return centerShift;
  };
  View2.prototype.isDef = function() {
    return !!this.getCenterInternal() && this.getResolution() !== void 0;
  };
  View2.prototype.adjustCenter = function(deltaCoordinates) {
    var center = toUserCoordinate(this.targetCenter_, this.getProjection());
    this.setCenter([
      center[0] + deltaCoordinates[0],
      center[1] + deltaCoordinates[1]
    ]);
  };
  View2.prototype.adjustCenterInternal = function(deltaCoordinates) {
    var center = this.targetCenter_;
    this.setCenterInternal([
      center[0] + deltaCoordinates[0],
      center[1] + deltaCoordinates[1]
    ]);
  };
  View2.prototype.adjustResolution = function(ratio, opt_anchor) {
    var anchor = opt_anchor && fromUserCoordinate(opt_anchor, this.getProjection());
    this.adjustResolutionInternal(ratio, anchor);
  };
  View2.prototype.adjustResolutionInternal = function(ratio, opt_anchor) {
    var isMoving = this.getAnimating() || this.getInteracting();
    var size = this.getViewportSize_(this.getRotation());
    var newResolution = this.constraints_.resolution(this.targetResolution_ * ratio, 0, size, isMoving);
    if (opt_anchor) {
      this.targetCenter_ = this.calculateCenterZoom(newResolution, opt_anchor);
    }
    this.targetResolution_ *= ratio;
    this.applyTargetState_();
  };
  View2.prototype.adjustZoom = function(delta, opt_anchor) {
    this.adjustResolution(Math.pow(this.zoomFactor_, -delta), opt_anchor);
  };
  View2.prototype.adjustRotation = function(delta, opt_anchor) {
    if (opt_anchor) {
      opt_anchor = fromUserCoordinate(opt_anchor, this.getProjection());
    }
    this.adjustRotationInternal(delta, opt_anchor);
  };
  View2.prototype.adjustRotationInternal = function(delta, opt_anchor) {
    var isMoving = this.getAnimating() || this.getInteracting();
    var newRotation = this.constraints_.rotation(this.targetRotation_ + delta, isMoving);
    if (opt_anchor) {
      this.targetCenter_ = this.calculateCenterRotate(newRotation, opt_anchor);
    }
    this.targetRotation_ += delta;
    this.applyTargetState_();
  };
  View2.prototype.setCenter = function(center) {
    this.setCenterInternal(center ? fromUserCoordinate(center, this.getProjection()) : center);
  };
  View2.prototype.setCenterInternal = function(center) {
    this.targetCenter_ = center;
    this.applyTargetState_();
  };
  View2.prototype.setHint = function(hint, delta) {
    this.hints_[hint] += delta;
    this.changed();
    return this.hints_[hint];
  };
  View2.prototype.setResolution = function(resolution) {
    this.targetResolution_ = resolution;
    this.applyTargetState_();
  };
  View2.prototype.setRotation = function(rotation) {
    this.targetRotation_ = rotation;
    this.applyTargetState_();
  };
  View2.prototype.setZoom = function(zoom) {
    this.setResolution(this.getResolutionForZoom(zoom));
  };
  View2.prototype.applyTargetState_ = function(opt_doNotCancelAnims, opt_forceMoving) {
    var isMoving = this.getAnimating() || this.getInteracting() || opt_forceMoving;
    var newRotation = this.constraints_.rotation(this.targetRotation_, isMoving);
    var size = this.getViewportSize_(newRotation);
    var newResolution = this.constraints_.resolution(this.targetResolution_, 0, size, isMoving);
    var newCenter = this.constraints_.center(this.targetCenter_, newResolution, size, isMoving, this.calculateCenterShift(this.targetCenter_, newResolution, newRotation, size));
    if (this.get(ViewProperty.ROTATION) !== newRotation) {
      this.set(ViewProperty.ROTATION, newRotation);
    }
    if (this.get(ViewProperty.RESOLUTION) !== newResolution) {
      this.set(ViewProperty.RESOLUTION, newResolution);
      this.set("zoom", this.getZoom(), true);
    }
    if (!newCenter || !this.get(ViewProperty.CENTER) || !equals(this.get(ViewProperty.CENTER), newCenter)) {
      this.set(ViewProperty.CENTER, newCenter);
    }
    if (this.getAnimating() && !opt_doNotCancelAnims) {
      this.cancelAnimations();
    }
    this.cancelAnchor_ = void 0;
  };
  View2.prototype.resolveConstraints = function(opt_duration, opt_resolutionDirection, opt_anchor) {
    var duration2 = opt_duration !== void 0 ? opt_duration : 200;
    var direction2 = opt_resolutionDirection || 0;
    var newRotation = this.constraints_.rotation(this.targetRotation_);
    var size = this.getViewportSize_(newRotation);
    var newResolution = this.constraints_.resolution(this.targetResolution_, direction2, size);
    var newCenter = this.constraints_.center(this.targetCenter_, newResolution, size, false, this.calculateCenterShift(this.targetCenter_, newResolution, newRotation, size));
    if (duration2 === 0 && !this.cancelAnchor_) {
      this.targetResolution_ = newResolution;
      this.targetRotation_ = newRotation;
      this.targetCenter_ = newCenter;
      this.applyTargetState_();
      return;
    }
    var anchor = opt_anchor || (duration2 === 0 ? this.cancelAnchor_ : void 0);
    this.cancelAnchor_ = void 0;
    if (this.getResolution() !== newResolution || this.getRotation() !== newRotation || !this.getCenterInternal() || !equals(this.getCenterInternal(), newCenter)) {
      if (this.getAnimating()) {
        this.cancelAnimations();
      }
      this.animateInternal({
        rotation: newRotation,
        center: newCenter,
        resolution: newResolution,
        duration: duration2,
        easing: easeOut,
        anchor
      });
    }
  };
  View2.prototype.beginInteraction = function() {
    this.resolveConstraints(0);
    this.setHint(ViewHint.INTERACTING, 1);
  };
  View2.prototype.endInteraction = function(opt_duration, opt_resolutionDirection, opt_anchor) {
    var anchor = opt_anchor && fromUserCoordinate(opt_anchor, this.getProjection());
    this.endInteractionInternal(opt_duration, opt_resolutionDirection, anchor);
  };
  View2.prototype.endInteractionInternal = function(opt_duration, opt_resolutionDirection, opt_anchor) {
    this.setHint(ViewHint.INTERACTING, -1);
    this.resolveConstraints(opt_duration, opt_resolutionDirection, opt_anchor);
  };
  View2.prototype.getConstrainedCenter = function(targetCenter, opt_targetResolution) {
    var size = this.getViewportSize_(this.getRotation());
    return this.constraints_.center(targetCenter, opt_targetResolution || this.getResolution(), size);
  };
  View2.prototype.getConstrainedZoom = function(targetZoom, opt_direction) {
    var targetRes = this.getResolutionForZoom(targetZoom);
    return this.getZoomForResolution(this.getConstrainedResolution(targetRes, opt_direction));
  };
  View2.prototype.getConstrainedResolution = function(targetResolution, opt_direction) {
    var direction2 = opt_direction || 0;
    var size = this.getViewportSize_(this.getRotation());
    return this.constraints_.resolution(targetResolution, direction2, size);
  };
  return View2;
}(ol_Object);
function animationCallback(callback, returnValue) {
  setTimeout(function() {
    callback(returnValue);
  }, 0);
}
function createCenterConstraint(options) {
  if (options.extent !== void 0) {
    var smooth = options.smoothExtentConstraint !== void 0 ? options.smoothExtentConstraint : true;
    return createExtent(options.extent, options.constrainOnlyCenter, smooth);
  }
  var projection = createProjection(options.projection, "EPSG:3857");
  if (options.multiWorld !== true && projection.isGlobal()) {
    var extent2 = projection.getExtent().slice();
    extent2[0] = -Infinity;
    extent2[2] = Infinity;
    return createExtent(extent2, false, false);
  }
  return none$1;
}
function createResolutionConstraint(options) {
  var resolutionConstraint;
  var maxResolution;
  var minResolution;
  var defaultMaxZoom = 28;
  var defaultZoomFactor = 2;
  var minZoom = options.minZoom !== void 0 ? options.minZoom : DEFAULT_MIN_ZOOM;
  var maxZoom = options.maxZoom !== void 0 ? options.maxZoom : defaultMaxZoom;
  var zoomFactor = options.zoomFactor !== void 0 ? options.zoomFactor : defaultZoomFactor;
  var multiWorld = options.multiWorld !== void 0 ? options.multiWorld : false;
  var smooth = options.smoothResolutionConstraint !== void 0 ? options.smoothResolutionConstraint : true;
  var showFullExtent = options.showFullExtent !== void 0 ? options.showFullExtent : false;
  var projection = createProjection(options.projection, "EPSG:3857");
  var projExtent = projection.getExtent();
  var constrainOnlyCenter = options.constrainOnlyCenter;
  var extent2 = options.extent;
  if (!multiWorld && !extent2 && projection.isGlobal()) {
    constrainOnlyCenter = false;
    extent2 = projExtent;
  }
  if (options.resolutions !== void 0) {
    var resolutions = options.resolutions;
    maxResolution = resolutions[minZoom];
    minResolution = resolutions[maxZoom] !== void 0 ? resolutions[maxZoom] : resolutions[resolutions.length - 1];
    if (options.constrainResolution) {
      resolutionConstraint = createSnapToResolutions(resolutions, smooth, !constrainOnlyCenter && extent2, showFullExtent);
    } else {
      resolutionConstraint = createMinMaxResolution(maxResolution, minResolution, smooth, !constrainOnlyCenter && extent2, showFullExtent);
    }
  } else {
    var size = !projExtent ? 360 * METERS_PER_UNIT$1[Units$2.DEGREES] / projection.getMetersPerUnit() : Math.max(getWidth(projExtent), getHeight(projExtent));
    var defaultMaxResolution = size / DEFAULT_TILE_SIZE / Math.pow(defaultZoomFactor, DEFAULT_MIN_ZOOM);
    var defaultMinResolution = defaultMaxResolution / Math.pow(defaultZoomFactor, defaultMaxZoom - DEFAULT_MIN_ZOOM);
    maxResolution = options.maxResolution;
    if (maxResolution !== void 0) {
      minZoom = 0;
    } else {
      maxResolution = defaultMaxResolution / Math.pow(zoomFactor, minZoom);
    }
    minResolution = options.minResolution;
    if (minResolution === void 0) {
      if (options.maxZoom !== void 0) {
        if (options.maxResolution !== void 0) {
          minResolution = maxResolution / Math.pow(zoomFactor, maxZoom);
        } else {
          minResolution = defaultMaxResolution / Math.pow(zoomFactor, maxZoom);
        }
      } else {
        minResolution = defaultMinResolution;
      }
    }
    maxZoom = minZoom + Math.floor(Math.log(maxResolution / minResolution) / Math.log(zoomFactor));
    minResolution = maxResolution / Math.pow(zoomFactor, maxZoom - minZoom);
    if (options.constrainResolution) {
      resolutionConstraint = createSnapToPower(zoomFactor, maxResolution, minResolution, smooth, !constrainOnlyCenter && extent2, showFullExtent);
    } else {
      resolutionConstraint = createMinMaxResolution(maxResolution, minResolution, smooth, !constrainOnlyCenter && extent2, showFullExtent);
    }
  }
  return {
    constraint: resolutionConstraint,
    maxResolution,
    minResolution,
    minZoom,
    zoomFactor
  };
}
function createRotationConstraint(options) {
  var enableRotation = options.enableRotation !== void 0 ? options.enableRotation : true;
  if (enableRotation) {
    var constrainRotation = options.constrainRotation;
    if (constrainRotation === void 0 || constrainRotation === true) {
      return createSnapToZero();
    } else if (constrainRotation === false) {
      return none;
    } else if (typeof constrainRotation === "number") {
      return createSnapToN(constrainRotation);
    } else {
      return none;
    }
  } else {
    return disable;
  }
}
function isNoopAnimation(animation) {
  if (animation.sourceCenter && animation.targetCenter) {
    if (!equals(animation.sourceCenter, animation.targetCenter)) {
      return false;
    }
  }
  if (animation.sourceResolution !== animation.targetResolution) {
    return false;
  }
  if (animation.sourceRotation !== animation.targetRotation) {
    return false;
  }
  return true;
}
function calculateCenterOn(coordinate, size, position2, resolution, rotation) {
  var cosAngle = Math.cos(-rotation);
  var sinAngle = Math.sin(-rotation);
  var rotX = coordinate[0] * cosAngle - coordinate[1] * sinAngle;
  var rotY = coordinate[1] * cosAngle + coordinate[0] * sinAngle;
  rotX += (size[0] / 2 - position2[0]) * resolution;
  rotY += (position2[1] - size[1] / 2) * resolution;
  sinAngle = -sinAngle;
  var centerX = rotX * cosAngle - rotY * sinAngle;
  var centerY = rotY * cosAngle + rotX * sinAngle;
  return [centerX, centerY];
}
var ol_View = View$1;
function buffer(size, num, opt_size) {
  if (opt_size === void 0) {
    opt_size = [0, 0];
  }
  opt_size[0] = size[0] + 2 * num;
  opt_size[1] = size[1] + 2 * num;
  return opt_size;
}
function hasArea(size) {
  return size[0] > 0 && size[1] > 0;
}
function scale(size, ratio, opt_size) {
  if (opt_size === void 0) {
    opt_size = [0, 0];
  }
  opt_size[0] = size[0] * ratio + 0.5 | 0;
  opt_size[1] = size[1] * ratio + 0.5 | 0;
  return opt_size;
}
function toSize(size, opt_size) {
  if (Array.isArray(size)) {
    return size;
  } else {
    if (opt_size === void 0) {
      opt_size = [size, size];
    } else {
      opt_size[0] = size;
      opt_size[1] = size;
    }
    return opt_size;
  }
}
var __extends$1T = globalThis && globalThis.__extends || function() {
  var extendStatics2 = function(d2, b2) {
    extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {
      d3.__proto__ = b3;
    } || function(d3, b3) {
      for (var p5 in b3)
        if (Object.prototype.hasOwnProperty.call(b3, p5))
          d3[p5] = b3[p5];
    };
    return extendStatics2(d2, b2);
  };
  return function(d2, b2) {
    if (typeof b2 !== "function" && b2 !== null)
      throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
    extendStatics2(d2, b2);
    function __() {
      this.constructor = d2;
    }
    d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
  };
}();
function removeLayerMapProperty(layer) {
  if (layer instanceof ol_layer_Base) {
    layer.setMapInternal(null);
    return;
  }
  if (layer instanceof ol_layer_Group) {
    layer.getLayers().forEach(removeLayerMapProperty);
  }
}
function setLayerMapProperty(layer, map) {
  if (layer instanceof ol_layer_Base) {
    layer.setMapInternal(map);
    return;
  }
  if (layer instanceof ol_layer_Group) {
    var layers = layer.getLayers().getArray();
    for (var i2 = 0, ii = layers.length; i2 < ii; ++i2) {
      setLayerMapProperty(layers[i2], map);
    }
  }
}
var PluggableMap = function(_super) {
  __extends$1T(PluggableMap2, _super);
  function PluggableMap2(options) {
    var _this = _super.call(this) || this;
    _this.on;
    _this.once;
    _this.un;
    var optionsInternal = createOptionsInternal(options);
    _this.renderComplete_;
    _this.loaded_ = true;
    _this.boundHandleBrowserEvent_ = _this.handleBrowserEvent.bind(_this);
    _this.maxTilesLoading_ = options.maxTilesLoading !== void 0 ? options.maxTilesLoading : 16;
    _this.pixelRatio_ = options.pixelRatio !== void 0 ? options.pixelRatio : DEVICE_PIXEL_RATIO;
    _this.postRenderTimeoutHandle_;
    _this.animationDelayKey_;
    _this.animationDelay_ = function() {
      this.animationDelayKey_ = void 0;
      this.renderFrame_(Date.now());
    }.bind(_this);
    _this.coordinateToPixelTransform_ = create$6();
    _this.pixelToCoordinateTransform_ = create$6();
    _this.frameIndex_ = 0;
    _this.frameState_ = null;
    _this.previousExtent_ = null;
    _this.viewPropertyListenerKey_ = null;
    _this.viewChangeListenerKey_ = null;
    _this.layerGroupPropertyListenerKeys_ = null;
    _this.viewport_ = document.createElement("div");
    _this.viewport_.className = "ol-viewport" + ("ontouchstart" in window ? " ol-touch" : "");
    _this.viewport_.style.position = "relative";
    _this.viewport_.style.overflow = "hidden";
    _this.viewport_.style.width = "100%";
    _this.viewport_.style.height = "100%";
    _this.overlayContainer_ = document.createElement("div");
    _this.overlayContainer_.style.position = "absolute";
    _this.overlayContainer_.style.zIndex = "0";
    _this.overlayContainer_.style.width = "100%";
    _this.overlayContainer_.style.height = "100%";
    _this.overlayContainer_.style.pointerEvents = "none";
    _this.overlayContainer_.className = "ol-overlaycontainer";
    _this.viewport_.appendChild(_this.overlayContainer_);
    _this.overlayContainerStopEvent_ = document.createElement("div");
    _this.overlayContainerStopEvent_.style.position = "absolute";
    _this.overlayContainerStopEvent_.style.zIndex = "0";
    _this.overlayContainerStopEvent_.style.width = "100%";
    _this.overlayContainerStopEvent_.style.height = "100%";
    _this.overlayContainerStopEvent_.style.pointerEvents = "none";
    _this.overlayContainerStopEvent_.className = "ol-overlaycontainer-stopevent";
    _this.viewport_.appendChild(_this.overlayContainerStopEvent_);
    _this.mapBrowserEventHandler_ = null;
    _this.moveTolerance_ = options.moveTolerance;
    _this.keyboardEventTarget_ = optionsInternal.keyboardEventTarget;
    _this.targetChangeHandlerKeys_ = null;
    _this.controls = optionsInternal.controls || new ol_Collection();
    _this.interactions = optionsInternal.interactions || new ol_Collection();
    _this.overlays_ = optionsInternal.overlays;
    _this.overlayIdIndex_ = {};
    _this.renderer_ = null;
    _this.postRenderFunctions_ = [];
    _this.tileQueue_ = new TileQueue$1(_this.getTilePriority.bind(_this), _this.handleTileChange_.bind(_this));
    _this.addChangeListener(MapProperty.LAYERGROUP, _this.handleLayerGroupChanged_);
    _this.addChangeListener(MapProperty.VIEW, _this.handleViewChanged_);
    _this.addChangeListener(MapProperty.SIZE, _this.handleSizeChanged_);
    _this.addChangeListener(MapProperty.TARGET, _this.handleTargetChanged_);
    _this.setProperties(optionsInternal.values);
    var map = _this;
    if (options.view && !(options.view instanceof ol_View)) {
      options.view.then(function(viewOptions) {
        map.setView(new ol_View(viewOptions));
      });
    }
    _this.controls.addEventListener(CollectionEventType.ADD, function(event) {
      event.element.setMap(this);
    }.bind(_this));
    _this.controls.addEventListener(CollectionEventType.REMOVE, function(event) {
      event.element.setMap(null);
    }.bind(_this));
    _this.interactions.addEventListener(CollectionEventType.ADD, function(event) {
      event.element.setMap(this);
    }.bind(_this));
    _this.interactions.addEventListener(CollectionEventType.REMOVE, function(event) {
      event.element.setMap(null);
    }.bind(_this));
    _this.overlays_.addEventListener(CollectionEventType.ADD, function(event) {
      this.addOverlayInternal_(event.element);
    }.bind(_this));
    _this.overlays_.addEventListener(CollectionEventType.REMOVE, function(event) {
      var overlay = event.element;
      var id = overlay.getId();
      if (id !== void 0) {
        delete this.overlayIdIndex_[id.toString()];
      }
      event.element.setMap(null);
    }.bind(_this));
    _this.controls.forEach(function(control) {
      control.setMap(this);
    }.bind(_this));
    _this.interactions.forEach(function(interaction) {
      interaction.setMap(this);
    }.bind(_this));
    _this.overlays_.forEach(_this.addOverlayInternal_.bind(_this));
    return _this;
  }
  PluggableMap2.prototype.createRenderer = function() {
    throw new Error("Use a map type that has a createRenderer method");
  };
  PluggableMap2.prototype.addControl = function(control) {
    this.getControls().push(control);
  };
  PluggableMap2.prototype.addInteraction = function(interaction) {
    this.getInteractions().push(interaction);
  };
  PluggableMap2.prototype.addLayer = function(layer) {
    var layers = this.getLayerGroup().getLayers();
    layers.push(layer);
  };
  PluggableMap2.prototype.handleLayerAdd_ = function(event) {
    setLayerMapProperty(event.layer, this);
  };
  PluggableMap2.prototype.addOverlay = function(overlay) {
    this.getOverlays().push(overlay);
  };
  PluggableMap2.prototype.addOverlayInternal_ = function(overlay) {
    var id = overlay.getId();
    if (id !== void 0) {
      this.overlayIdIndex_[id.toString()] = overlay;
    }
    overlay.setMap(this);
  };
  PluggableMap2.prototype.disposeInternal = function() {
    this.setTarget(null);
    _super.prototype.disposeInternal.call(this);
  };
  PluggableMap2.prototype.forEachFeatureAtPixel = function(pixel, callback, opt_options) {
    if (!this.frameState_ || !this.renderer_) {
      return;
    }
    var coordinate = this.getCoordinateFromPixelInternal(pixel);
    opt_options = opt_options !== void 0 ? opt_options : {};
    var hitTolerance = opt_options.hitTolerance !== void 0 ? opt_options.hitTolerance : 0;
    var layerFilter = opt_options.layerFilter !== void 0 ? opt_options.layerFilter : TRUE;
    var checkWrapped = opt_options.checkWrapped !== false;
    return this.renderer_.forEachFeatureAtCoordinate(coordinate, this.frameState_, hitTolerance, checkWrapped, callback, null, layerFilter, null);
  };
  PluggableMap2.prototype.getFeaturesAtPixel = function(pixel, opt_options) {
    var features = [];
    this.forEachFeatureAtPixel(pixel, function(feature2) {
      features.push(feature2);
    }, opt_options);
    return features;
  };
  PluggableMap2.prototype.getAllLayers = function() {
    var layers = [];
    function addLayersFrom(layerGroup) {
      layerGroup.forEach(function(layer) {
        if (layer instanceof ol_layer_Group) {
          addLayersFrom(layer.getLayers());
        } else {
          layers.push(layer);
        }
      });
    }
    addLayersFrom(this.getLayers());
    return layers;
  };
  PluggableMap2.prototype.forEachLayerAtPixel = function(pixel, callback, opt_options) {
    if (!this.frameState_ || !this.renderer_) {
      return;
    }
    var options = opt_options || {};
    var hitTolerance = options.hitTolerance !== void 0 ? options.hitTolerance : 0;
    var layerFilter = options.layerFilter || TRUE;
    return this.renderer_.forEachLayerAtPixel(pixel, this.frameState_, hitTolerance, callback, layerFilter);
  };
  PluggableMap2.prototype.hasFeatureAtPixel = function(pixel, opt_options) {
    if (!this.frameState_ || !this.renderer_) {
      return false;
    }
    var coordinate = this.getCoordinateFromPixelInternal(pixel);
    opt_options = opt_options !== void 0 ? opt_options : {};
    var layerFilter = opt_options.layerFilter !== void 0 ? opt_options.layerFilter : TRUE;
    var hitTolerance = opt_options.hitTolerance !== void 0 ? opt_options.hitTolerance : 0;
    var checkWrapped = opt_options.checkWrapped !== false;
    return this.renderer_.hasFeatureAtCoordinate(coordinate, this.frameState_, hitTolerance, checkWrapped, layerFilter, null);
  };
  PluggableMap2.prototype.getEventCoordinate = function(event) {
    return this.getCoordinateFromPixel(this.getEventPixel(event));
  };
  PluggableMap2.prototype.getEventCoordinateInternal = function(event) {
    return this.getCoordinateFromPixelInternal(this.getEventPixel(event));
  };
  PluggableMap2.prototype.getEventPixel = function(event) {
    var viewportPosition = this.viewport_.getBoundingClientRect();
    var eventPosition = "changedTouches" in event ? event.changedTouches[0] : event;
    return [
      eventPosition.clientX - viewportPosition.left,
      eventPosition.clientY - viewportPosition.top
    ];
  };
  PluggableMap2.prototype.getTarget = function() {
    return this.get(MapProperty.TARGET);
  };
  PluggableMap2.prototype.getTargetElement = function() {
    var target = this.getTarget();
    if (target !== void 0) {
      return typeof target === "string" ? document.getElementById(target) : target;
    } else {
      return null;
    }
  };
  PluggableMap2.prototype.getCoordinateFromPixel = function(pixel) {
    return toUserCoordinate(this.getCoordinateFromPixelInternal(pixel), this.getView().getProjection());
  };
  PluggableMap2.prototype.getCoordinateFromPixelInternal = function(pixel) {
    var frameState = this.frameState_;
    if (!frameState) {
      return null;
    } else {
      return apply$5(frameState.pixelToCoordinateTransform, pixel.slice());
    }
  };
  PluggableMap2.prototype.getControls = function() {
    return this.controls;
  };
  PluggableMap2.prototype.getOverlays = function() {
    return this.overlays_;
  };
  PluggableMap2.prototype.getOverlayById = function(id) {
    var overlay = this.overlayIdIndex_[id.toString()];
    return overlay !== void 0 ? overlay : null;
  };
  PluggableMap2.prototype.getInteractions = function() {
    return this.interactions;
  };
  PluggableMap2.prototype.getLayerGroup = function() {
    return this.get(MapProperty.LAYERGROUP);
  };
  PluggableMap2.prototype.setLayers = function(layers) {
    var group = this.getLayerGroup();
    if (layers instanceof ol_Collection) {
      group.setLayers(layers);
      return;
    }
    var collection = group.getLayers();
    collection.clear();
    collection.extend(layers);
  };
  PluggableMap2.prototype.getLayers = function() {
    var layers = this.getLayerGroup().getLayers();
    return layers;
  };
  PluggableMap2.prototype.getLoadingOrNotReady = function() {
    var layerStatesArray = this.getLayerGroup().getLayerStatesArray();
    for (var i2 = 0, ii = layerStatesArray.length; i2 < ii; ++i2) {
      var state = layerStatesArray[i2];
      if (!state.visible) {
        continue;
      }
      var renderer = state.layer.getRenderer();
      if (renderer && !renderer.ready) {
        return true;
      }
      var source = state.layer.getSource();
      if (source && source.loading) {
        return true;
      }
    }
    return false;
  };
  PluggableMap2.prototype.getPixelFromCoordinate = function(coordinate) {
    var viewCoordinate = fromUserCoordinate(coordinate, this.getView().getProjection());
    return this.getPixelFromCoordinateInternal(viewCoordinate);
  };
  PluggableMap2.prototype.getPixelFromCoordinateInternal = function(coordinate) {
    var frameState = this.frameState_;
    if (!frameState) {
      return null;
    } else {
      return apply$5(frameState.coordinateToPixelTransform, coordinate.slice(0, 2));
    }
  };
  PluggableMap2.prototype.getRenderer = function() {
    return this.renderer_;
  };
  PluggableMap2.prototype.getSize = function() {
    return this.get(MapProperty.SIZE);
  };
  PluggableMap2.prototype.getView = function() {
    return this.get(MapProperty.VIEW);
  };
  PluggableMap2.prototype.getViewport = function() {
    return this.viewport_;
  };
  PluggableMap2.prototype.getOverlayContainer = function() {
    return this.overlayContainer_;
  };
  PluggableMap2.prototype.getOverlayContainerStopEvent = function() {
    return this.overlayContainerStopEvent_;
  };
  PluggableMap2.prototype.getOwnerDocument = function() {
    var targetElement = this.getTargetElement();
    return targetElement ? targetElement.ownerDocument : document;
  };
  PluggableMap2.prototype.getTilePriority = function(tile2, tileSourceKey, tileCenter, tileResolution) {
    return getTilePriority(this.frameState_, tile2, tileSourceKey, tileCenter, tileResolution);
  };
  PluggableMap2.prototype.handleBrowserEvent = function(browserEvent, opt_type) {
    var type = opt_type || browserEvent.type;
    var mapBrowserEvent = new MapBrowserEvent$1(type, this, browserEvent);
    this.handleMapBrowserEvent(mapBrowserEvent);
  };
  PluggableMap2.prototype.handleMapBrowserEvent = function(mapBrowserEvent) {
    if (!this.frameState_) {
      return;
    }
    var originalEvent = mapBrowserEvent.originalEvent;
    var eventType = originalEvent.type;
    if (eventType === PointerEventType.POINTERDOWN || eventType === EventType.WHEEL || eventType === EventType.KEYDOWN) {
      var doc = this.getOwnerDocument();
      var rootNode = this.viewport_.getRootNode ? this.viewport_.getRootNode() : doc;
      var target = originalEvent.target;
      if (this.overlayContainerStopEvent_.contains(target) || !(rootNode === doc ? doc.documentElement : rootNode).contains(target)) {
        return;
      }
    }
    mapBrowserEvent.frameState = this.frameState_;
    if (this.dispatchEvent(mapBrowserEvent) !== false) {
      var interactionsArray = this.getInteractions().getArray().slice();
      for (var i2 = interactionsArray.length - 1; i2 >= 0; i2--) {
        var interaction = interactionsArray[i2];
        if (interaction.getMap() !== this || !interaction.getActive() || !this.getTargetElement()) {
          continue;
        }
        var cont = interaction.handleEvent(mapBrowserEvent);
        if (!cont || mapBrowserEvent.propagationStopped) {
          break;
        }
      }
    }
  };
  PluggableMap2.prototype.handlePostRender = function() {
    var frameState = this.frameState_;
    var tileQueue = this.tileQueue_;
    if (!tileQueue.isEmpty()) {
      var maxTotalLoading = this.maxTilesLoading_;
      var maxNewLoads = maxTotalLoading;
      if (frameState) {
        var hints = frameState.viewHints;
        if (hints[ViewHint.ANIMATING] || hints[ViewHint.INTERACTING]) {
          var lowOnFrameBudget = Date.now() - frameState.time > 8;
          maxTotalLoading = lowOnFrameBudget ? 0 : 8;
          maxNewLoads = lowOnFrameBudget ? 0 : 2;
        }
      }
      if (tileQueue.getTilesLoading() < maxTotalLoading) {
        tileQueue.reprioritize();
        tileQueue.loadMoreTiles(maxTotalLoading, maxNewLoads);
      }
    }
    if (frameState && this.renderer_ && !frameState.animate) {
      if (this.renderComplete_ === true) {
        if (this.hasListener(RenderEventType.RENDERCOMPLETE)) {
          this.renderer_.dispatchRenderEvent(RenderEventType.RENDERCOMPLETE, frameState);
        }
        if (this.loaded_ === false) {
          this.loaded_ = true;
          this.dispatchEvent(new MapEvent$1(MapEventType.LOADEND, this, frameState));
        }
      } else if (this.loaded_ === true) {
        this.loaded_ = false;
        this.dispatchEvent(new MapEvent$1(MapEventType.LOADSTART, this, frameState));
      }
    }
    var postRenderFunctions = this.postRenderFunctions_;
    for (var i2 = 0, ii = postRenderFunctions.length; i2 < ii; ++i2) {
      postRenderFunctions[i2](this, frameState);
    }
    postRenderFunctions.length = 0;
  };
  PluggableMap2.prototype.handleSizeChanged_ = function() {
    if (this.getView() && !this.getView().getAnimating()) {
      this.getView().resolveConstraints(0);
    }
    this.render();
  };
  PluggableMap2.prototype.handleTargetChanged_ = function() {
    if (this.mapBrowserEventHandler_) {
      for (var i2 = 0, ii = this.targetChangeHandlerKeys_.length; i2 < ii; ++i2) {
        unlistenByKey(this.targetChangeHandlerKeys_[i2]);
      }
      this.targetChangeHandlerKeys_ = null;
      this.viewport_.removeEventListener(EventType.CONTEXTMENU, this.boundHandleBrowserEvent_);
      this.viewport_.removeEventListener(EventType.WHEEL, this.boundHandleBrowserEvent_);
      this.mapBrowserEventHandler_.dispose();
      this.mapBrowserEventHandler_ = null;
      removeNode(this.viewport_);
    }
    var targetElement = this.getTargetElement();
    if (!targetElement) {
      if (this.renderer_) {
        clearTimeout(this.postRenderTimeoutHandle_);
        this.postRenderTimeoutHandle_ = void 0;
        this.postRenderFunctions_.length = 0;
        this.renderer_.dispose();
        this.renderer_ = null;
      }
      if (this.animationDelayKey_) {
        cancelAnimationFrame(this.animationDelayKey_);
        this.animationDelayKey_ = void 0;
      }
    } else {
      targetElement.appendChild(this.viewport_);
      if (!this.renderer_) {
        this.renderer_ = this.createRenderer();
      }
      this.mapBrowserEventHandler_ = new MapBrowserEventHandler$1(this, this.moveTolerance_);
      for (var key in MapBrowserEventType) {
        this.mapBrowserEventHandler_.addEventListener(MapBrowserEventType[key], this.handleMapBrowserEvent.bind(this));
      }
      this.viewport_.addEventListener(EventType.CONTEXTMENU, this.boundHandleBrowserEvent_, false);
      this.viewport_.addEventListener(EventType.WHEEL, this.boundHandleBrowserEvent_, PASSIVE_EVENT_LISTENERS ? { passive: false } : false);
      var defaultView = this.getOwnerDocument().defaultView;
      var keyboardEventTarget = !this.keyboardEventTarget_ ? targetElement : this.keyboardEventTarget_;
      this.targetChangeHandlerKeys_ = [
        listen(keyboardEventTarget, EventType.KEYDOWN, this.handleBrowserEvent, this),
        listen(keyboardEventTarget, EventType.KEYPRESS, this.handleBrowserEvent, this),
        listen(defaultView, EventType.RESIZE, this.updateSize, this)
      ];
    }
    this.updateSize();
  };
  PluggableMap2.prototype.handleTileChange_ = function() {
    this.render();
  };
  PluggableMap2.prototype.handleViewPropertyChanged_ = function() {
    this.render();
  };
  PluggableMap2.prototype.handleViewChanged_ = function() {
    if (this.viewPropertyListenerKey_) {
      unlistenByKey(this.viewPropertyListenerKey_);
      this.viewPropertyListenerKey_ = null;
    }
    if (this.viewChangeListenerKey_) {
      unlistenByKey(this.viewChangeListenerKey_);
      this.viewChangeListenerKey_ = null;
    }
    var view = this.getView();
    if (view) {
      this.updateViewportSize_();
      this.viewPropertyListenerKey_ = listen(view, ObjectEventType.PROPERTYCHANGE, this.handleViewPropertyChanged_, this);
      this.viewChangeListenerKey_ = listen(view, EventType.CHANGE, this.handleViewPropertyChanged_, this);
      view.resolveConstraints(0);
    }
    this.render();
  };
  PluggableMap2.prototype.handleLayerGroupChanged_ = function() {
    if (this.layerGroupPropertyListenerKeys_) {
      this.layerGroupPropertyListenerKeys_.forEach(unlistenByKey);
      this.layerGroupPropertyListenerKeys_ = null;
    }
    var layerGroup = this.getLayerGroup();
    if (layerGroup) {
      this.handleLayerAdd_(new GroupEvent("addlayer", layerGroup));
      this.layerGroupPropertyListenerKeys_ = [
        listen(layerGroup, ObjectEventType.PROPERTYCHANGE, this.render, this),
        listen(layerGroup, EventType.CHANGE, this.render, this),
        listen(layerGroup, "addlayer", this.handleLayerAdd_, this),
        listen(layerGroup, "removelayer", this.handleLayerRemove_, this)
      ];
    }
    this.render();
  };
  PluggableMap2.prototype.isRendered = function() {
    return !!this.frameState_;
  };
  PluggableMap2.prototype.renderSync = function() {
    if (this.animationDelayKey_) {
      cancelAnimationFrame(this.animationDelayKey_);
    }
    this.animationDelay_();
  };
  PluggableMap2.prototype.redrawText = function() {
    var layerStates = this.getLayerGroup().getLayerStatesArray();
    for (var i2 = 0, ii = layerStates.length; i2 < ii; ++i2) {
      var layer = layerStates[i2].layer;
      if (layer.hasRenderer()) {
        layer.getRenderer().handleFontsChanged();
      }
    }
  };
  PluggableMap2.prototype.render = function() {
    if (this.renderer_ && this.animationDelayKey_ === void 0) {
      this.animationDelayKey_ = requestAnimationFrame(this.animationDelay_);
    }
  };
  PluggableMap2.prototype.removeControl = function(control) {
    return this.getControls().remove(control);
  };
  PluggableMap2.prototype.removeInteraction = function(interaction) {
    return this.getInteractions().remove(interaction);
  };
  PluggableMap2.prototype.removeLayer = function(layer) {
    var layers = this.getLayerGroup().getLayers();
    return layers.remove(layer);
  };
  PluggableMap2.prototype.handleLayerRemove_ = function(event) {
    removeLayerMapProperty(event.layer);
  };
  PluggableMap2.prototype.removeOverlay = function(overlay) {
    return this.getOverlays().remove(overlay);
  };
  PluggableMap2.prototype.renderFrame_ = function(time2) {
    var _this = this;
    var size = this.getSize();
    var view = this.getView();
    var previousFrameState = this.frameState_;
    var frameState = null;
    if (size !== void 0 && hasArea(size) && view && view.isDef()) {
      var viewHints = view.getHints(this.frameState_ ? this.frameState_.viewHints : void 0);
      var viewState = view.getState();
      frameState = {
        animate: false,
        coordinateToPixelTransform: this.coordinateToPixelTransform_,
        declutterTree: null,
        extent: getForViewAndSize(viewState.center, viewState.resolution, viewState.rotation, size),
        index: this.frameIndex_++,
        layerIndex: 0,
        layerStatesArray: this.getLayerGroup().getLayerStatesArray(),
        pixelRatio: this.pixelRatio_,
        pixelToCoordinateTransform: this.pixelToCoordinateTransform_,
        postRenderFunctions: [],
        size,
        tileQueue: this.tileQueue_,
        time: time2,
        usedTiles: {},
        viewState,
        viewHints,
        wantedTiles: {},
        mapId: getUid(this),
        renderTargets: {}
      };
      if (viewState.nextCenter && viewState.nextResolution) {
        var rotation = isNaN(viewState.nextRotation) ? viewState.rotation : viewState.nextRotation;
        frameState.nextExtent = getForViewAndSize(viewState.nextCenter, viewState.nextResolution, rotation, size);
      }
    }
    this.frameState_ = frameState;
    this.renderer_.renderFrame(frameState);
    if (frameState) {
      if (frameState.animate) {
        this.render();
      }
      Array.prototype.push.apply(this.postRenderFunctions_, frameState.postRenderFunctions);
      if (previousFrameState) {
        var moveStart = !this.previousExtent_ || !isEmpty$1(this.previousExtent_) && !equals$1(frameState.extent, this.previousExtent_);
        if (moveStart) {
          this.dispatchEvent(new MapEvent$1(MapEventType.MOVESTART, this, previousFrameState));
          this.previousExtent_ = createOrUpdateEmpty(this.previousExtent_);
        }
      }
      var idle = this.previousExtent_ && !frameState.viewHints[ViewHint.ANIMATING] && !frameState.viewHints[ViewHint.INTERACTING] && !equals$1(frameState.extent, this.previousExtent_);
      if (idle) {
        this.dispatchEvent(new MapEvent$1(MapEventType.MOVEEND, this, frameState));
        clone$1(frameState.extent, this.previousExtent_);
      }
    }
    this.dispatchEvent(new MapEvent$1(MapEventType.POSTRENDER, this, frameState));
    this.renderComplete_ = this.hasListener(MapEventType.LOADSTART) || this.hasListener(MapEventType.LOADEND) || this.hasListener(RenderEventType.RENDERCOMPLETE) ? !this.tileQueue_.getTilesLoading() && !this.tileQueue_.getCount() && !this.getLoadingOrNotReady() : void 0;
    if (!this.postRenderTimeoutHandle_) {
      this.postRenderTimeoutHandle_ = setTimeout(function() {
        _this.postRenderTimeoutHandle_ = void 0;
        _this.handlePostRender();
      }, 0);
    }
  };
  PluggableMap2.prototype.setLayerGroup = function(layerGroup) {
    var oldLayerGroup = this.getLayerGroup();
    if (oldLayerGroup) {
      this.handleLayerRemove_(new GroupEvent("removelayer", oldLayerGroup));
    }
    this.set(MapProperty.LAYERGROUP, layerGroup);
  };
  PluggableMap2.prototype.setSize = function(size) {
    this.set(MapProperty.SIZE, size);
  };
  PluggableMap2.prototype.setTarget = function(target) {
    this.set(MapProperty.TARGET, target);
  };
  PluggableMap2.prototype.setView = function(view) {
    if (!view || view instanceof ol_View) {
      this.set(MapProperty.VIEW, view);
      return;
    }
    this.set(MapProperty.VIEW, new ol_View());
    var map = this;
    view.then(function(viewOptions) {
      map.setView(new ol_View(viewOptions));
    });
  };
  PluggableMap2.prototype.updateSize = function() {
    var targetElement = this.getTargetElement();
    var size = void 0;
    if (targetElement) {
      var computedStyle = getComputedStyle(targetElement);
      var width = targetElement.offsetWidth - parseFloat(computedStyle["borderLeftWidth"]) - parseFloat(computedStyle["paddingLeft"]) - parseFloat(computedStyle["paddingRight"]) - parseFloat(computedStyle["borderRightWidth"]);
      var height = targetElement.offsetHeight - parseFloat(computedStyle["borderTopWidth"]) - parseFloat(computedStyle["paddingTop"]) - parseFloat(computedStyle["paddingBottom"]) - parseFloat(computedStyle["borderBottomWidth"]);
      if (!isNaN(width) && !isNaN(height)) {
        size = [width, height];
        if (!hasArea(size) && !!(targetElement.offsetWidth || targetElement.offsetHeight || targetElement.getClientRects().length)) {
          console.warn("No map visible because the map container's width or height are 0.");
        }
      }
    }
    this.setSize(size);
    this.updateViewportSize_();
  };
  PluggableMap2.prototype.updateViewportSize_ = function() {
    var view = this.getView();
    if (view) {
      var size = void 0;
      var computedStyle = getComputedStyle(this.viewport_);
      if (computedStyle.width && computedStyle.height) {
        size = [
          parseInt(computedStyle.width, 10),
          parseInt(computedStyle.height, 10)
        ];
      }
      view.setViewportSize(size);
    }
  };
  return PluggableMap2;
}(ol_Object);
function createOptionsInternal(options) {
  var keyboardEventTarget = null;
  if (options.keyboardEventTarget !== void 0) {
    keyboardEventTarget = typeof options.keyboardEventTarget === "string" ? document.getElementById(options.keyboardEventTarget) : options.keyboardEventTarget;
  }
  var values2 = {};
  var layerGroup = options.layers && typeof options.layers.getLayers === "function" ? options.layers : new ol_layer_Group({ layers: options.layers });
  values2[MapProperty.LAYERGROUP] = layerGroup;
  values2[MapProperty.TARGET] = options.target;
  values2[MapProperty.VIEW] = options.view instanceof ol_View ? options.view : new ol_View();
  var controls;
  if (options.controls !== void 0) {
    if (Array.isArray(options.controls)) {
      controls = new ol_Collection(options.controls.slice());
    } else {
      assert(typeof options.controls.getArray === "function", 47);
      controls = options.controls;
    }
  }
  var interactions;
  if (options.interactions !== void 0) {
    if (Array.isArray(options.interactions)) {
      interactions = new ol_Collection(options.interactions.slice());
    } else {
      assert(typeof options.interactions.getArray === "function", 48);
      interactions = options.interactions;
    }
  }
  var overlays;
  if (options.overlays !== void 0) {
    if (Array.isArray(options.overlays)) {
      overlays = new ol_Collection(options.overlays.slice());
    } else {
      assert(typeof options.overlays.getArray === "function", 49);
      overlays = options.overlays;
    }
  } else {
    overlays = new ol_Collection();
  }
  return {
    controls,
    interactions,
    keyboardEventTarget,
    overlays,
    values: values2
  };
}
var PluggableMap$1 = PluggableMap;
var __extends$1S = globalThis && globalThis.__extends || function() {
  var extendStatics2 = function(d2, b2) {
    extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {
      d3.__proto__ = b3;
    } || function(d3, b3) {
      for (var p5 in b3)
        if (Object.prototype.hasOwnProperty.call(b3, p5))
          d3[p5] = b3[p5];
    };
    return extendStatics2(d2, b2);
  };
  return function(d2, b2) {
    if (typeof b2 !== "function" && b2 !== null)
      throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
    extendStatics2(d2, b2);
    function __() {
      this.constructor = d2;
    }
    d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
  };
}();
var Control$1 = function(_super) {
  __extends$1S(Control2, _super);
  function Control2(options) {
    var _this = _super.call(this) || this;
    var element = options.element;
    if (element && !options.target && !element.style.pointerEvents) {
      element.style.pointerEvents = "auto";
    }
    _this.element = element ? element : null;
    _this.target_ = null;
    _this.map_ = null;
    _this.listenerKeys = [];
    if (options.render) {
      _this.render = options.render;
    }
    if (options.target) {
      _this.setTarget(options.target);
    }
    return _this;
  }
  Control2.prototype.disposeInternal = function() {
    removeNode(this.element);
    _super.prototype.disposeInternal.call(this);
  };
  Control2.prototype.getMap = function() {
    return this.map_;
  };
  Control2.prototype.setMap = function(map) {
    if (this.map_) {
      removeNode(this.element);
    }
    for (var i2 = 0, ii = this.listenerKeys.length; i2 < ii; ++i2) {
      unlistenByKey(this.listenerKeys[i2]);
    }
    this.listenerKeys.length = 0;
    this.map_ = map;
    if (map) {
      var target = this.target_ ? this.target_ : map.getOverlayContainerStopEvent();
      target.appendChild(this.element);
      if (this.render !== VOID) {
        this.listenerKeys.push(listen(map, MapEventType.POSTRENDER, this.render, this));
      }
      map.render();
    }
  };
  Control2.prototype.render = function(mapEvent) {
  };
  Control2.prototype.setTarget = function(target) {
    this.target_ = typeof target === "string" ? document.getElementById(target) : target;
  };
  return Control2;
}(ol_Object);
var ol_control_Control = Control$1;
var Control$2 = Object.freeze(Object.defineProperty({
  __proto__: null,
  "default": ol_control_Control
}, Symbol.toStringTag, { value: "Module" }));
var __extends$1R = globalThis && globalThis.__extends || function() {
  var extendStatics2 = function(d2, b2) {
    extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {
      d3.__proto__ = b3;
    } || function(d3, b3) {
      for (var p5 in b3)
        if (Object.prototype.hasOwnProperty.call(b3, p5))
          d3[p5] = b3[p5];
    };
    return extendStatics2(d2, b2);
  };
  return function(d2, b2) {
    if (typeof b2 !== "function" && b2 !== null)
      throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
    extendStatics2(d2, b2);
    function __() {
      this.constructor = d2;
    }
    d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
  };
}();
var Attribution = function(_super) {
  __extends$1R(Attribution2, _super);
  function Attribution2(opt_options) {
    var _this = this;
    var options = opt_options ? opt_options : {};
    _this = _super.call(this, {
      element: document.createElement("div"),
      render: options.render,
      target: options.target
    }) || this;
    _this.ulElement_ = document.createElement("ul");
    _this.collapsed_ = options.collapsed !== void 0 ? options.collapsed : true;
    _this.userCollapsed_ = _this.collapsed_;
    _this.overrideCollapsible_ = options.collapsible !== void 0;
    _this.collapsible_ = options.collapsible !== void 0 ? options.collapsible : true;
    if (!_this.collapsible_) {
      _this.collapsed_ = false;
    }
    var className = options.className !== void 0 ? options.className : "ol-attribution";
    var tipLabel = options.tipLabel !== void 0 ? options.tipLabel : "Attributions";
    var expandClassName = options.expandClassName !== void 0 ? options.expandClassName : className + "-expand";
    var collapseLabel = options.collapseLabel !== void 0 ? options.collapseLabel : "\u203A";
    var collapseClassName = options.collapseClassName !== void 0 ? options.collapseClassName : className + "-collapse";
    if (typeof collapseLabel === "string") {
      _this.collapseLabel_ = document.createElement("span");
      _this.collapseLabel_.textContent = collapseLabel;
      _this.collapseLabel_.className = collapseClassName;
    } else {
      _this.collapseLabel_ = collapseLabel;
    }
    var label = options.label !== void 0 ? options.label : "i";
    if (typeof label === "string") {
      _this.label_ = document.createElement("span");
      _this.label_.textContent = label;
      _this.label_.className = expandClassName;
    } else {
      _this.label_ = label;
    }
    var activeLabel = _this.collapsible_ && !_this.collapsed_ ? _this.collapseLabel_ : _this.label_;
    _this.toggleButton_ = document.createElement("button");
    _this.toggleButton_.setAttribute("type", "button");
    _this.toggleButton_.setAttribute("aria-expanded", String(!_this.collapsed_));
    _this.toggleButton_.title = tipLabel;
    _this.toggleButton_.appendChild(activeLabel);
    _this.toggleButton_.addEventListener(EventType.CLICK, _this.handleClick_.bind(_this), false);
    var cssClasses = className + " " + CLASS_UNSELECTABLE + " " + CLASS_CONTROL + (_this.collapsed_ && _this.collapsible_ ? " " + CLASS_COLLAPSED : "") + (_this.collapsible_ ? "" : " ol-uncollapsible");
    var element = _this.element;
    element.className = cssClasses;
    element.appendChild(_this.toggleButton_);
    element.appendChild(_this.ulElement_);
    _this.renderedAttributions_ = [];
    _this.renderedVisible_ = true;
    return _this;
  }
  Attribution2.prototype.collectSourceAttributions_ = function(frameState) {
    var lookup2 = {};
    var visibleAttributions = [];
    var collapsible = true;
    var layerStatesArray = frameState.layerStatesArray;
    for (var i2 = 0, ii = layerStatesArray.length; i2 < ii; ++i2) {
      var layerState = layerStatesArray[i2];
      if (!inView(layerState, frameState.viewState)) {
        continue;
      }
      var source = layerState.layer.getSource();
      if (!source) {
        continue;
      }
      var attributionGetter = source.getAttributions();
      if (!attributionGetter) {
        continue;
      }
      var attributions = attributionGetter(frameState);
      if (!attributions) {
        continue;
      }
      collapsible = collapsible && source.getAttributionsCollapsible() !== false;
      if (Array.isArray(attributions)) {
        for (var j2 = 0, jj = attributions.length; j2 < jj; ++j2) {
          if (!(attributions[j2] in lookup2)) {
            visibleAttributions.push(attributions[j2]);
            lookup2[attributions[j2]] = true;
          }
        }
      } else {
        if (!(attributions in lookup2)) {
          visibleAttributions.push(attributions);
          lookup2[attributions] = true;
        }
      }
    }
    if (!this.overrideCollapsible_) {
      this.setCollapsible(collapsible);
    }
    return visibleAttributions;
  };
  Attribution2.prototype.updateElement_ = function(frameState) {
    if (!frameState) {
      if (this.renderedVisible_) {
        this.element.style.display = "none";
        this.renderedVisible_ = false;
      }
      return;
    }
    var attributions = this.collectSourceAttributions_(frameState);
    var visible = attributions.length > 0;
    if (this.renderedVisible_ != visible) {
      this.element.style.display = visible ? "" : "none";
      this.renderedVisible_ = visible;
    }
    if (equals$2(attributions, this.renderedAttributions_)) {
      return;
    }
    removeChildren(this.ulElement_);
    for (var i2 = 0, ii = attributions.length; i2 < ii; ++i2) {
      var element = document.createElement("li");
      element.innerHTML = attributions[i2];
      this.ulElement_.appendChild(element);
    }
    this.renderedAttributions_ = attributions;
  };
  Attribution2.prototype.handleClick_ = function(event) {
    event.preventDefault();
    this.handleToggle_();
    this.userCollapsed_ = this.collapsed_;
  };
  Attribution2.prototype.handleToggle_ = function() {
    this.element.classList.toggle(CLASS_COLLAPSED);
    if (this.collapsed_) {
      replaceNode(this.collapseLabel_, this.label_);
    } else {
      replaceNode(this.label_, this.collapseLabel_);
    }
    this.collapsed_ = !this.collapsed_;
    this.toggleButton_.setAttribute("aria-expanded", String(!this.collapsed_));
  };
  Attribution2.prototype.getCollapsible = function() {
    return this.collapsible_;
  };
  Attribution2.prototype.setCollapsible = function(collapsible) {
    if (this.collapsible_ === collapsible) {
      return;
    }
    this.collapsible_ = collapsible;
    this.element.classList.toggle("ol-uncollapsible");
    if (this.userCollapsed_) {
      this.handleToggle_();
    }
  };
  Attribution2.prototype.setCollapsed = function(collapsed) {
    this.userCollapsed_ = collapsed;
    if (!this.collapsible_ || this.collapsed_ === collapsed) {
      return;
    }
    this.handleToggle_();
  };
  Attribution2.prototype.getCollapsed = function() {
    return this.collapsed_;
  };
  Attribution2.prototype.render = function(mapEvent) {
    this.updateElement_(mapEvent.frameState);
  };
  return Attribution2;
}(ol_control_Control);
var Attribution$1 = Attribution;
var __extends$1Q = globalThis && globalThis.__extends || function() {
  var extendStatics2 = function(d2, b2) {
    extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {
      d3.__proto__ = b3;
    } || function(d3, b3) {
      for (var p5 in b3)
        if (Object.prototype.hasOwnProperty.call(b3, p5))
          d3[p5] = b3[p5];
    };
    return extendStatics2(d2, b2);
  };
  return function(d2, b2) {
    if (typeof b2 !== "function" && b2 !== null)
      throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
    extendStatics2(d2, b2);
    function __() {
      this.constructor = d2;
    }
    d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
  };
}();
var Rotate$1 = function(_super) {
  __extends$1Q(Rotate2, _super);
  function Rotate2(opt_options) {
    var _this = this;
    var options = opt_options ? opt_options : {};
    _this = _super.call(this, {
      element: document.createElement("div"),
      render: options.render,
      target: options.target
    }) || this;
    var className = options.className !== void 0 ? options.className : "ol-rotate";
    var label = options.label !== void 0 ? options.label : "\u21E7";
    var compassClassName = options.compassClassName !== void 0 ? options.compassClassName : "ol-compass";
    _this.label_ = null;
    if (typeof label === "string") {
      _this.label_ = document.createElement("span");
      _this.label_.className = compassClassName;
      _this.label_.textContent = label;
    } else {
      _this.label_ = label;
      _this.label_.classList.add(compassClassName);
    }
    var tipLabel = options.tipLabel ? options.tipLabel : "Reset rotation";
    var button = document.createElement("button");
    button.className = className + "-reset";
    button.setAttribute("type", "button");
    button.title = tipLabel;
    button.appendChild(_this.label_);
    button.addEventListener(EventType.CLICK, _this.handleClick_.bind(_this), false);
    var cssClasses = className + " " + CLASS_UNSELECTABLE + " " + CLASS_CONTROL;
    var element = _this.element;
    element.className = cssClasses;
    element.appendChild(button);
    _this.callResetNorth_ = options.resetNorth ? options.resetNorth : void 0;
    _this.duration_ = options.duration !== void 0 ? options.duration : 250;
    _this.autoHide_ = options.autoHide !== void 0 ? options.autoHide : true;
    _this.rotation_ = void 0;
    if (_this.autoHide_) {
      _this.element.classList.add(CLASS_HIDDEN);
    }
    return _this;
  }
  Rotate2.prototype.handleClick_ = function(event) {
    event.preventDefault();
    if (this.callResetNorth_ !== void 0) {
      this.callResetNorth_();
    } else {
      this.resetNorth_();
    }
  };
  Rotate2.prototype.resetNorth_ = function() {
    var map = this.getMap();
    var view = map.getView();
    if (!view) {
      return;
    }
    var rotation = view.getRotation();
    if (rotation !== void 0) {
      if (this.duration_ > 0 && rotation % (2 * Math.PI) !== 0) {
        view.animate({
          rotation: 0,
          duration: this.duration_,
          easing: easeOut
        });
      } else {
        view.setRotation(0);
      }
    }
  };
  Rotate2.prototype.render = function(mapEvent) {
    var frameState = mapEvent.frameState;
    if (!frameState) {
      return;
    }
    var rotation = frameState.viewState.rotation;
    if (rotation != this.rotation_) {
      var transform2 = "rotate(" + rotation + "rad)";
      if (this.autoHide_) {
        var contains2 = this.element.classList.contains(CLASS_HIDDEN);
        if (!contains2 && rotation === 0) {
          this.element.classList.add(CLASS_HIDDEN);
        } else if (contains2 && rotation !== 0) {
          this.element.classList.remove(CLASS_HIDDEN);
        }
      }
      this.label_.style.transform = transform2;
    }
    this.rotation_ = rotation;
  };
  return Rotate2;
}(ol_control_Control);
var Rotate$2 = Rotate$1;
var __extends$1P = globalThis && globalThis.__extends || function() {
  var extendStatics2 = function(d2, b2) {
    extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {
      d3.__proto__ = b3;
    } || function(d3, b3) {
      for (var p5 in b3)
        if (Object.prototype.hasOwnProperty.call(b3, p5))
          d3[p5] = b3[p5];
    };
    return extendStatics2(d2, b2);
  };
  return function(d2, b2) {
    if (typeof b2 !== "function" && b2 !== null)
      throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
    extendStatics2(d2, b2);
    function __() {
      this.constructor = d2;
    }
    d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
  };
}();
var Zoom = function(_super) {
  __extends$1P(Zoom2, _super);
  function Zoom2(opt_options) {
    var _this = this;
    var options = opt_options ? opt_options : {};
    _this = _super.call(this, {
      element: document.createElement("div"),
      target: options.target
    }) || this;
    var className = options.className !== void 0 ? options.className : "ol-zoom";
    var delta = options.delta !== void 0 ? options.delta : 1;
    var zoomInClassName = options.zoomInClassName !== void 0 ? options.zoomInClassName : className + "-in";
    var zoomOutClassName = options.zoomOutClassName !== void 0 ? options.zoomOutClassName : className + "-out";
    var zoomInLabel = options.zoomInLabel !== void 0 ? options.zoomInLabel : "+";
    var zoomOutLabel = options.zoomOutLabel !== void 0 ? options.zoomOutLabel : "\u2013";
    var zoomInTipLabel = options.zoomInTipLabel !== void 0 ? options.zoomInTipLabel : "Zoom in";
    var zoomOutTipLabel = options.zoomOutTipLabel !== void 0 ? options.zoomOutTipLabel : "Zoom out";
    var inElement = document.createElement("button");
    inElement.className = zoomInClassName;
    inElement.setAttribute("type", "button");
    inElement.title = zoomInTipLabel;
    inElement.appendChild(typeof zoomInLabel === "string" ? document.createTextNode(zoomInLabel) : zoomInLabel);
    inElement.addEventListener(EventType.CLICK, _this.handleClick_.bind(_this, delta), false);
    var outElement = document.createElement("button");
    outElement.className = zoomOutClassName;
    outElement.setAttribute("type", "button");
    outElement.title = zoomOutTipLabel;
    outElement.appendChild(typeof zoomOutLabel === "string" ? document.createTextNode(zoomOutLabel) : zoomOutLabel);
    outElement.addEventListener(EventType.CLICK, _this.handleClick_.bind(_this, -delta), false);
    var cssClasses = className + " " + CLASS_UNSELECTABLE + " " + CLASS_CONTROL;
    var element = _this.element;
    element.className = cssClasses;
    element.appendChild(inElement);
    element.appendChild(outElement);
    _this.duration_ = options.duration !== void 0 ? options.duration : 250;
    return _this;
  }
  Zoom2.prototype.handleClick_ = function(delta, event) {
    event.preventDefault();
    this.zoomByDelta_(delta);
  };
  Zoom2.prototype.zoomByDelta_ = function(delta) {
    var map = this.getMap();
    var view = map.getView();
    if (!view) {
      return;
    }
    var currentZoom = view.getZoom();
    if (currentZoom !== void 0) {
      var newZoom = view.getConstrainedZoom(currentZoom + delta);
      if (this.duration_ > 0) {
        if (view.getAnimating()) {
          view.cancelAnimations();
        }
        view.animate({
          zoom: newZoom,
          duration: this.duration_,
          easing: easeOut
        });
      } else {
        view.setZoom(newZoom);
      }
    }
  };
  return Zoom2;
}(ol_control_Control);
var Zoom$1 = Zoom;
var __extends$1O = globalThis && globalThis.__extends || function() {
  var extendStatics2 = function(d2, b2) {
    extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {
      d3.__proto__ = b3;
    } || function(d3, b3) {
      for (var p5 in b3)
        if (Object.prototype.hasOwnProperty.call(b3, p5))
          d3[p5] = b3[p5];
    };
    return extendStatics2(d2, b2);
  };
  return function(d2, b2) {
    if (typeof b2 !== "function" && b2 !== null)
      throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
    extendStatics2(d2, b2);
    function __() {
      this.constructor = d2;
    }
    d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
  };
}();
var events = [
  "fullscreenchange",
  "webkitfullscreenchange",
  "MSFullscreenChange"
];
var FullScreenEventType = {
  ENTERFULLSCREEN: "enterfullscreen",
  LEAVEFULLSCREEN: "leavefullscreen"
};
var FullScreen = function(_super) {
  __extends$1O(FullScreen2, _super);
  function FullScreen2(opt_options) {
    var _this = this;
    var options = opt_options ? opt_options : {};
    _this = _super.call(this, {
      element: document.createElement("div"),
      target: options.target
    }) || this;
    _this.on;
    _this.once;
    _this.un;
    _this.keys_ = options.keys !== void 0 ? options.keys : false;
    _this.source_ = options.source;
    _this.isInFullscreen_ = false;
    _this.boundHandleMapTargetChange_ = _this.handleMapTargetChange_.bind(_this);
    _this.cssClassName_ = options.className !== void 0 ? options.className : "ol-full-screen";
    _this.documentListeners_ = [];
    _this.activeClassName_ = options.activeClassName !== void 0 ? options.activeClassName.split(" ") : [_this.cssClassName_ + "-true"];
    _this.inactiveClassName_ = options.inactiveClassName !== void 0 ? options.inactiveClassName.split(" ") : [_this.cssClassName_ + "-false"];
    var label = options.label !== void 0 ? options.label : "\u2922";
    _this.labelNode_ = typeof label === "string" ? document.createTextNode(label) : label;
    var labelActive = options.labelActive !== void 0 ? options.labelActive : "\xD7";
    _this.labelActiveNode_ = typeof labelActive === "string" ? document.createTextNode(labelActive) : labelActive;
    var tipLabel = options.tipLabel ? options.tipLabel : "Toggle full-screen";
    _this.button_ = document.createElement("button");
    _this.button_.title = tipLabel;
    _this.button_.setAttribute("type", "button");
    _this.button_.appendChild(_this.labelNode_);
    _this.button_.addEventListener(EventType.CLICK, _this.handleClick_.bind(_this), false);
    _this.setClassName_(_this.button_, _this.isInFullscreen_);
    _this.element.className = "".concat(_this.cssClassName_, " ").concat(CLASS_UNSELECTABLE, " ").concat(CLASS_CONTROL);
    _this.element.appendChild(_this.button_);
    return _this;
  }
  FullScreen2.prototype.handleClick_ = function(event) {
    event.preventDefault();
    this.handleFullScreen_();
  };
  FullScreen2.prototype.handleFullScreen_ = function() {
    var map = this.getMap();
    if (!map) {
      return;
    }
    var doc = map.getOwnerDocument();
    if (!isFullScreenSupported(doc)) {
      return;
    }
    if (isFullScreen(doc)) {
      exitFullScreen(doc);
    } else {
      var element = void 0;
      if (this.source_) {
        element = typeof this.source_ === "string" ? doc.getElementById(this.source_) : this.source_;
      } else {
        element = map.getTargetElement();
      }
      if (this.keys_) {
        requestFullScreenWithKeys(element);
      } else {
        requestFullScreen(element);
      }
    }
  };
  FullScreen2.prototype.handleFullScreenChange_ = function() {
    var map = this.getMap();
    if (!map) {
      return;
    }
    var wasInFullscreen = this.isInFullscreen_;
    this.isInFullscreen_ = isFullScreen(map.getOwnerDocument());
    if (wasInFullscreen !== this.isInFullscreen_) {
      this.setClassName_(this.button_, this.isInFullscreen_);
      if (this.isInFullscreen_) {
        replaceNode(this.labelActiveNode_, this.labelNode_);
        this.dispatchEvent(FullScreenEventType.ENTERFULLSCREEN);
      } else {
        replaceNode(this.labelNode_, this.labelActiveNode_);
        this.dispatchEvent(FullScreenEventType.LEAVEFULLSCREEN);
      }
      map.updateSize();
    }
  };
  FullScreen2.prototype.setClassName_ = function(element, fullscreen) {
    var _a2, _b2, _c, _d;
    if (fullscreen) {
      (_a2 = element.classList).remove.apply(_a2, this.inactiveClassName_);
      (_b2 = element.classList).add.apply(_b2, this.activeClassName_);
    } else {
      (_c = element.classList).remove.apply(_c, this.activeClassName_);
      (_d = element.classList).add.apply(_d, this.inactiveClassName_);
    }
  };
  FullScreen2.prototype.setMap = function(map) {
    var oldMap = this.getMap();
    if (oldMap) {
      oldMap.removeChangeListener(MapProperty.TARGET, this.boundHandleMapTargetChange_);
    }
    _super.prototype.setMap.call(this, map);
    this.handleMapTargetChange_();
    if (map) {
      map.addChangeListener(MapProperty.TARGET, this.boundHandleMapTargetChange_);
    }
  };
  FullScreen2.prototype.handleMapTargetChange_ = function() {
    var listeners = this.documentListeners_;
    for (var i2 = 0, ii = listeners.length; i2 < ii; ++i2) {
      unlistenByKey(listeners[i2]);
    }
    listeners.length = 0;
    var map = this.getMap();
    if (map) {
      var doc = map.getOwnerDocument();
      if (isFullScreenSupported(doc)) {
        this.element.classList.remove(CLASS_UNSUPPORTED);
      } else {
        this.element.classList.add(CLASS_UNSUPPORTED);
      }
      for (var i2 = 0, ii = events.length; i2 < ii; ++i2) {
        listeners.push(listen(doc, events[i2], this.handleFullScreenChange_, this));
      }
      this.handleFullScreenChange_();
    }
  };
  return FullScreen2;
}(ol_control_Control);
function isFullScreenSupported(doc) {
  var body = doc.body;
  return !!(body["webkitRequestFullscreen"] || body["msRequestFullscreen"] && doc["msFullscreenEnabled"] || body.requestFullscreen && doc.fullscreenEnabled);
}
function isFullScreen(doc) {
  return !!(doc["webkitIsFullScreen"] || doc["msFullscreenElement"] || doc.fullscreenElement);
}
function requestFullScreen(element) {
  if (element.requestFullscreen) {
    element.requestFullscreen();
  } else if (element["msRequestFullscreen"]) {
    element["msRequestFullscreen"]();
  } else if (element["webkitRequestFullscreen"]) {
    element["webkitRequestFullscreen"]();
  }
}
function requestFullScreenWithKeys(element) {
  if (element["webkitRequestFullscreen"]) {
    element["webkitRequestFullscreen"]();
  } else {
    requestFullScreen(element);
  }
}
function exitFullScreen(doc) {
  if (doc.exitFullscreen) {
    doc.exitFullscreen();
  } else if (doc["msExitFullscreen"]) {
    doc["msExitFullscreen"]();
  } else if (doc["webkitExitFullscreen"]) {
    doc["webkitExitFullscreen"]();
  }
}
var FullScreen$1 = FullScreen;
var __extends$1N = globalThis && globalThis.__extends || function() {
  var extendStatics2 = function(d2, b2) {
    extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {
      d3.__proto__ = b3;
    } || function(d3, b3) {
      for (var p5 in b3)
        if (Object.prototype.hasOwnProperty.call(b3, p5))
          d3[p5] = b3[p5];
    };
    return extendStatics2(d2, b2);
  };
  return function(d2, b2) {
    if (typeof b2 !== "function" && b2 !== null)
      throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
    extendStatics2(d2, b2);
    function __() {
      this.constructor = d2;
    }
    d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
  };
}();
var PROJECTION = "projection";
var COORDINATE_FORMAT = "coordinateFormat";
var MousePosition = function(_super) {
  __extends$1N(MousePosition2, _super);
  function MousePosition2(opt_options) {
    var _this = this;
    var options = opt_options ? opt_options : {};
    var element = document.createElement("div");
    element.className = options.className !== void 0 ? options.className : "ol-mouse-position";
    _this = _super.call(this, {
      element,
      render: options.render,
      target: options.target
    }) || this;
    _this.on;
    _this.once;
    _this.un;
    _this.addChangeListener(PROJECTION, _this.handleProjectionChanged_);
    if (options.coordinateFormat) {
      _this.setCoordinateFormat(options.coordinateFormat);
    }
    if (options.projection) {
      _this.setProjection(options.projection);
    }
    var renderOnMouseOut = true;
    var placeholder = "&#160;";
    if ("undefinedHTML" in options) {
      if (options.undefinedHTML !== void 0) {
        placeholder = options.undefinedHTML;
      }
      renderOnMouseOut = !!placeholder;
    } else if ("placeholder" in options) {
      if (options.placeholder === false) {
        renderOnMouseOut = false;
      } else {
        placeholder = String(options.placeholder);
      }
    }
    _this.placeholder_ = placeholder;
    _this.renderOnMouseOut_ = renderOnMouseOut;
    _this.renderedHTML_ = element.innerHTML;
    _this.mapProjection_ = null;
    _this.transform_ = null;
    return _this;
  }
  MousePosition2.prototype.handleProjectionChanged_ = function() {
    this.transform_ = null;
  };
  MousePosition2.prototype.getCoordinateFormat = function() {
    return this.get(COORDINATE_FORMAT);
  };
  MousePosition2.prototype.getProjection = function() {
    return this.get(PROJECTION);
  };
  MousePosition2.prototype.handleMouseMove = function(event) {
    var map = this.getMap();
    this.updateHTML_(map.getEventPixel(event));
  };
  MousePosition2.prototype.handleMouseOut = function(event) {
    this.updateHTML_(null);
  };
  MousePosition2.prototype.setMap = function(map) {
    _super.prototype.setMap.call(this, map);
    if (map) {
      var viewport = map.getViewport();
      this.listenerKeys.push(listen(viewport, PointerEventType.POINTERMOVE, this.handleMouseMove, this));
      if (this.renderOnMouseOut_) {
        this.listenerKeys.push(listen(viewport, PointerEventType.POINTEROUT, this.handleMouseOut, this));
      }
      this.updateHTML_(null);
    }
  };
  MousePosition2.prototype.setCoordinateFormat = function(format2) {
    this.set(COORDINATE_FORMAT, format2);
  };
  MousePosition2.prototype.setProjection = function(projection) {
    this.set(PROJECTION, get$3(projection));
  };
  MousePosition2.prototype.updateHTML_ = function(pixel) {
    var html2 = this.placeholder_;
    if (pixel && this.mapProjection_) {
      if (!this.transform_) {
        var projection = this.getProjection();
        if (projection) {
          this.transform_ = getTransformFromProjections(this.mapProjection_, projection);
        } else {
          this.transform_ = identityTransform;
        }
      }
      var map = this.getMap();
      var coordinate = map.getCoordinateFromPixelInternal(pixel);
      if (coordinate) {
        var userProjection2 = getUserProjection();
        if (userProjection2) {
          this.transform_ = getTransformFromProjections(this.mapProjection_, userProjection2);
        }
        this.transform_(coordinate, coordinate);
        var coordinateFormat = this.getCoordinateFormat();
        if (coordinateFormat) {
          html2 = coordinateFormat(coordinate);
        } else {
          html2 = coordinate.toString();
        }
      }
    }
    if (!this.renderedHTML_ || html2 !== this.renderedHTML_) {
      this.element.innerHTML = html2;
      this.renderedHTML_ = html2;
    }
  };
  MousePosition2.prototype.render = function(mapEvent) {
    var frameState = mapEvent.frameState;
    if (!frameState) {
      this.mapProjection_ = null;
    } else {
      if (this.mapProjection_ != frameState.viewState.projection) {
        this.mapProjection_ = frameState.viewState.projection;
        this.transform_ = null;
      }
    }
  };
  return MousePosition2;
}(ol_control_Control);
var MousePosition$1 = MousePosition;
var OverlayPositioning = {
  BOTTOM_LEFT: "bottom-left",
  BOTTOM_CENTER: "bottom-center",
  BOTTOM_RIGHT: "bottom-right",
  CENTER_LEFT: "center-left",
  CENTER_CENTER: "center-center",
  CENTER_RIGHT: "center-right",
  TOP_LEFT: "top-left",
  TOP_CENTER: "top-center",
  TOP_RIGHT: "top-right"
};
var __extends$1M = globalThis && globalThis.__extends || function() {
  var extendStatics2 = function(d2, b2) {
    extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {
      d3.__proto__ = b3;
    } || function(d3, b3) {
      for (var p5 in b3)
        if (Object.prototype.hasOwnProperty.call(b3, p5))
          d3[p5] = b3[p5];
    };
    return extendStatics2(d2, b2);
  };
  return function(d2, b2) {
    if (typeof b2 !== "function" && b2 !== null)
      throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
    extendStatics2(d2, b2);
    function __() {
      this.constructor = d2;
    }
    d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
  };
}();
var Property$4 = {
  ELEMENT: "element",
  MAP: "map",
  OFFSET: "offset",
  POSITION: "position",
  POSITIONING: "positioning"
};
var Overlay$1 = function(_super) {
  __extends$1M(Overlay2, _super);
  function Overlay2(options) {
    var _this = _super.call(this) || this;
    _this.on;
    _this.once;
    _this.un;
    _this.options = options;
    _this.id = options.id;
    _this.insertFirst = options.insertFirst !== void 0 ? options.insertFirst : true;
    _this.stopEvent = options.stopEvent !== void 0 ? options.stopEvent : true;
    _this.element = document.createElement("div");
    _this.element.className = options.className !== void 0 ? options.className : "ol-overlay-container " + CLASS_SELECTABLE;
    _this.element.style.position = "absolute";
    _this.element.style.pointerEvents = "auto";
    var autoPan = options.autoPan;
    if (autoPan && typeof autoPan !== "object") {
      autoPan = {
        animation: options.autoPanAnimation,
        margin: options.autoPanMargin
      };
    }
    _this.autoPan = autoPan || false;
    _this.rendered = {
      transform_: "",
      visible: true
    };
    _this.mapPostrenderListenerKey = null;
    _this.addChangeListener(Property$4.ELEMENT, _this.handleElementChanged);
    _this.addChangeListener(Property$4.MAP, _this.handleMapChanged);
    _this.addChangeListener(Property$4.OFFSET, _this.handleOffsetChanged);
    _this.addChangeListener(Property$4.POSITION, _this.handlePositionChanged);
    _this.addChangeListener(Property$4.POSITIONING, _this.handlePositioningChanged);
    if (options.element !== void 0) {
      _this.setElement(options.element);
    }
    _this.setOffset(options.offset !== void 0 ? options.offset : [0, 0]);
    _this.setPositioning(options.positioning !== void 0 ? options.positioning : OverlayPositioning.TOP_LEFT);
    if (options.position !== void 0) {
      _this.setPosition(options.position);
    }
    return _this;
  }
  Overlay2.prototype.getElement = function() {
    return this.get(Property$4.ELEMENT);
  };
  Overlay2.prototype.getId = function() {
    return this.id;
  };
  Overlay2.prototype.getMap = function() {
    return this.get(Property$4.MAP) || null;
  };
  Overlay2.prototype.getOffset = function() {
    return this.get(Property$4.OFFSET);
  };
  Overlay2.prototype.getPosition = function() {
    return this.get(Property$4.POSITION);
  };
  Overlay2.prototype.getPositioning = function() {
    return this.get(Property$4.POSITIONING);
  };
  Overlay2.prototype.handleElementChanged = function() {
    removeChildren(this.element);
    var element = this.getElement();
    if (element) {
      this.element.appendChild(element);
    }
  };
  Overlay2.prototype.handleMapChanged = function() {
    if (this.mapPostrenderListenerKey) {
      removeNode(this.element);
      unlistenByKey(this.mapPostrenderListenerKey);
      this.mapPostrenderListenerKey = null;
    }
    var map = this.getMap();
    if (map) {
      this.mapPostrenderListenerKey = listen(map, MapEventType.POSTRENDER, this.render, this);
      this.updatePixelPosition();
      var container = this.stopEvent ? map.getOverlayContainerStopEvent() : map.getOverlayContainer();
      if (this.insertFirst) {
        container.insertBefore(this.element, container.childNodes[0] || null);
      } else {
        container.appendChild(this.element);
      }
      this.performAutoPan();
    }
  };
  Overlay2.prototype.render = function() {
    this.updatePixelPosition();
  };
  Overlay2.prototype.handleOffsetChanged = function() {
    this.updatePixelPosition();
  };
  Overlay2.prototype.handlePositionChanged = function() {
    this.updatePixelPosition();
    this.performAutoPan();
  };
  Overlay2.prototype.handlePositioningChanged = function() {
    this.updatePixelPosition();
  };
  Overlay2.prototype.setElement = function(element) {
    this.set(Property$4.ELEMENT, element);
  };
  Overlay2.prototype.setMap = function(map) {
    this.set(Property$4.MAP, map);
  };
  Overlay2.prototype.setOffset = function(offset2) {
    this.set(Property$4.OFFSET, offset2);
  };
  Overlay2.prototype.setPosition = function(position2) {
    this.set(Property$4.POSITION, position2);
  };
  Overlay2.prototype.performAutoPan = function() {
    if (this.autoPan) {
      this.panIntoView(this.autoPan);
    }
  };
  Overlay2.prototype.panIntoView = function(opt_panIntoViewOptions) {
    var map = this.getMap();
    if (!map || !map.getTargetElement() || !this.get(Property$4.POSITION)) {
      return;
    }
    var mapRect = this.getRect(map.getTargetElement(), map.getSize());
    var element = this.getElement();
    var overlayRect = this.getRect(element, [
      outerWidth(element),
      outerHeight(element)
    ]);
    var panIntoViewOptions = opt_panIntoViewOptions || {};
    var myMargin = panIntoViewOptions.margin === void 0 ? 20 : panIntoViewOptions.margin;
    if (!containsExtent(mapRect, overlayRect)) {
      var offsetLeft = overlayRect[0] - mapRect[0];
      var offsetRight = mapRect[2] - overlayRect[2];
      var offsetTop = overlayRect[1] - mapRect[1];
      var offsetBottom = mapRect[3] - overlayRect[3];
      var delta = [0, 0];
      if (offsetLeft < 0) {
        delta[0] = offsetLeft - myMargin;
      } else if (offsetRight < 0) {
        delta[0] = Math.abs(offsetRight) + myMargin;
      }
      if (offsetTop < 0) {
        delta[1] = offsetTop - myMargin;
      } else if (offsetBottom < 0) {
        delta[1] = Math.abs(offsetBottom) + myMargin;
      }
      if (delta[0] !== 0 || delta[1] !== 0) {
        var center = map.getView().getCenterInternal();
        var centerPx = map.getPixelFromCoordinateInternal(center);
        if (!centerPx) {
          return;
        }
        var newCenterPx = [centerPx[0] + delta[0], centerPx[1] + delta[1]];
        var panOptions = panIntoViewOptions.animation || {};
        map.getView().animateInternal({
          center: map.getCoordinateFromPixelInternal(newCenterPx),
          duration: panOptions.duration,
          easing: panOptions.easing
        });
      }
    }
  };
  Overlay2.prototype.getRect = function(element, size) {
    var box = element.getBoundingClientRect();
    var offsetX = box.left + window.pageXOffset;
    var offsetY = box.top + window.pageYOffset;
    return [offsetX, offsetY, offsetX + size[0], offsetY + size[1]];
  };
  Overlay2.prototype.setPositioning = function(positioning) {
    this.set(Property$4.POSITIONING, positioning);
  };
  Overlay2.prototype.setVisible = function(visible) {
    if (this.rendered.visible !== visible) {
      this.element.style.display = visible ? "" : "none";
      this.rendered.visible = visible;
    }
  };
  Overlay2.prototype.updatePixelPosition = function() {
    var map = this.getMap();
    var position2 = this.getPosition();
    if (!map || !map.isRendered() || !position2) {
      this.setVisible(false);
      return;
    }
    var pixel = map.getPixelFromCoordinate(position2);
    var mapSize = map.getSize();
    this.updateRenderedPosition(pixel, mapSize);
  };
  Overlay2.prototype.updateRenderedPosition = function(pixel, mapSize) {
    var style2 = this.element.style;
    var offset2 = this.getOffset();
    var positioning = this.getPositioning();
    this.setVisible(true);
    var x2 = Math.round(pixel[0] + offset2[0]) + "px";
    var y2 = Math.round(pixel[1] + offset2[1]) + "px";
    var posX = "0%";
    var posY = "0%";
    if (positioning == OverlayPositioning.BOTTOM_RIGHT || positioning == OverlayPositioning.CENTER_RIGHT || positioning == OverlayPositioning.TOP_RIGHT) {
      posX = "-100%";
    } else if (positioning == OverlayPositioning.BOTTOM_CENTER || positioning == OverlayPositioning.CENTER_CENTER || positioning == OverlayPositioning.TOP_CENTER) {
      posX = "-50%";
    }
    if (positioning == OverlayPositioning.BOTTOM_LEFT || positioning == OverlayPositioning.BOTTOM_CENTER || positioning == OverlayPositioning.BOTTOM_RIGHT) {
      posY = "-100%";
    } else if (positioning == OverlayPositioning.CENTER_LEFT || positioning == OverlayPositioning.CENTER_CENTER || positioning == OverlayPositioning.CENTER_RIGHT) {
      posY = "-50%";
    }
    var transform2 = "translate(".concat(posX, ", ").concat(posY, ") translate(").concat(x2, ", ").concat(y2, ")");
    if (this.rendered.transform_ != transform2) {
      this.rendered.transform_ = transform2;
      style2.transform = transform2;
      style2.msTransform = transform2;
    }
  };
  Overlay2.prototype.getOptions = function() {
    return this.options;
  };
  return Overlay2;
}(ol_Object);
var Overlay$2 = Overlay$1;
var __extends$1L = globalThis && globalThis.__extends || function() {
  var extendStatics2 = function(d2, b2) {
    extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {
      d3.__proto__ = b3;
    } || function(d3, b3) {
      for (var p5 in b3)
        if (Object.prototype.hasOwnProperty.call(b3, p5))
          d3[p5] = b3[p5];
    };
    return extendStatics2(d2, b2);
  };
  return function(d2, b2) {
    if (typeof b2 !== "function" && b2 !== null)
      throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
    extendStatics2(d2, b2);
    function __() {
      this.constructor = d2;
    }
    d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
  };
}();
var MAX_RATIO = 0.75;
var MIN_RATIO = 0.1;
var ControlledMap = function(_super) {
  __extends$1L(ControlledMap2, _super);
  function ControlledMap2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  ControlledMap2.prototype.createRenderer = function() {
    return new CompositeMapRenderer$1(this);
  };
  return ControlledMap2;
}(PluggableMap$1);
var OverviewMap = function(_super) {
  __extends$1L(OverviewMap2, _super);
  function OverviewMap2(opt_options) {
    var _this = this;
    var options = opt_options ? opt_options : {};
    _this = _super.call(this, {
      element: document.createElement("div"),
      render: options.render,
      target: options.target
    }) || this;
    _this.boundHandleRotationChanged_ = _this.handleRotationChanged_.bind(_this);
    _this.collapsed_ = options.collapsed !== void 0 ? options.collapsed : true;
    _this.collapsible_ = options.collapsible !== void 0 ? options.collapsible : true;
    if (!_this.collapsible_) {
      _this.collapsed_ = false;
    }
    _this.rotateWithView_ = options.rotateWithView !== void 0 ? options.rotateWithView : false;
    _this.viewExtent_ = void 0;
    var className = options.className !== void 0 ? options.className : "ol-overviewmap";
    var tipLabel = options.tipLabel !== void 0 ? options.tipLabel : "Overview map";
    var collapseLabel = options.collapseLabel !== void 0 ? options.collapseLabel : "\u2039";
    if (typeof collapseLabel === "string") {
      _this.collapseLabel_ = document.createElement("span");
      _this.collapseLabel_.textContent = collapseLabel;
    } else {
      _this.collapseLabel_ = collapseLabel;
    }
    var label = options.label !== void 0 ? options.label : "\u203A";
    if (typeof label === "string") {
      _this.label_ = document.createElement("span");
      _this.label_.textContent = label;
    } else {
      _this.label_ = label;
    }
    var activeLabel = _this.collapsible_ && !_this.collapsed_ ? _this.collapseLabel_ : _this.label_;
    var button = document.createElement("button");
    button.setAttribute("type", "button");
    button.title = tipLabel;
    button.appendChild(activeLabel);
    button.addEventListener(EventType.CLICK, _this.handleClick_.bind(_this), false);
    _this.ovmapDiv_ = document.createElement("div");
    _this.ovmapDiv_.className = "ol-overviewmap-map";
    _this.view_ = options.view;
    _this.ovmap_ = new ControlledMap({
      view: options.view
    });
    var ovmap = _this.ovmap_;
    if (options.layers) {
      options.layers.forEach(function(layer) {
        ovmap.addLayer(layer);
      });
    }
    var box = document.createElement("div");
    box.className = "ol-overviewmap-box";
    box.style.boxSizing = "border-box";
    _this.boxOverlay_ = new Overlay$2({
      position: [0, 0],
      positioning: OverlayPositioning.CENTER_CENTER,
      element: box
    });
    _this.ovmap_.addOverlay(_this.boxOverlay_);
    var cssClasses = className + " " + CLASS_UNSELECTABLE + " " + CLASS_CONTROL + (_this.collapsed_ && _this.collapsible_ ? " " + CLASS_COLLAPSED : "") + (_this.collapsible_ ? "" : " ol-uncollapsible");
    var element = _this.element;
    element.className = cssClasses;
    element.appendChild(_this.ovmapDiv_);
    element.appendChild(button);
    var scope = _this;
    var overlay = _this.boxOverlay_;
    var overlayBox = _this.boxOverlay_.getElement();
    var computeDesiredMousePosition = function(mousePosition) {
      return {
        clientX: mousePosition.clientX,
        clientY: mousePosition.clientY
      };
    };
    var move = function(event) {
      var position2 = computeDesiredMousePosition(event);
      var coordinates2 = ovmap.getEventCoordinateInternal(position2);
      overlay.setPosition(coordinates2);
    };
    var endMoving = function(event) {
      var coordinates2 = ovmap.getEventCoordinateInternal(event);
      scope.getMap().getView().setCenterInternal(coordinates2);
      window.removeEventListener("mousemove", move);
      window.removeEventListener("mouseup", endMoving);
    };
    overlayBox.addEventListener("mousedown", function() {
      window.addEventListener("mousemove", move);
      window.addEventListener("mouseup", endMoving);
    });
    return _this;
  }
  OverviewMap2.prototype.setMap = function(map) {
    var oldMap = this.getMap();
    if (map === oldMap) {
      return;
    }
    if (oldMap) {
      var oldView = oldMap.getView();
      if (oldView) {
        this.unbindView_(oldView);
      }
      this.ovmap_.setTarget(null);
    }
    _super.prototype.setMap.call(this, map);
    if (map) {
      this.ovmap_.setTarget(this.ovmapDiv_);
      this.listenerKeys.push(listen(map, ObjectEventType.PROPERTYCHANGE, this.handleMapPropertyChange_, this));
      var view = map.getView();
      if (view) {
        this.bindView_(view);
        if (view.isDef()) {
          this.ovmap_.updateSize();
          this.resetExtent_();
        }
      }
      if (!this.ovmap_.isRendered()) {
        this.updateBoxAfterOvmapIsRendered_();
      }
    }
  };
  OverviewMap2.prototype.handleMapPropertyChange_ = function(event) {
    if (event.key === MapProperty.VIEW) {
      var oldView = event.oldValue;
      if (oldView) {
        this.unbindView_(oldView);
      }
      var newView = this.getMap().getView();
      this.bindView_(newView);
    } else if (!this.ovmap_.isRendered() && (event.key === MapProperty.TARGET || event.key === MapProperty.SIZE)) {
      this.ovmap_.updateSize();
    }
  };
  OverviewMap2.prototype.bindView_ = function(view) {
    if (!this.view_) {
      var newView = new ol_View({
        projection: view.getProjection()
      });
      this.ovmap_.setView(newView);
    }
    view.addChangeListener(ViewProperty.ROTATION, this.boundHandleRotationChanged_);
    this.handleRotationChanged_();
  };
  OverviewMap2.prototype.unbindView_ = function(view) {
    view.removeChangeListener(ViewProperty.ROTATION, this.boundHandleRotationChanged_);
  };
  OverviewMap2.prototype.handleRotationChanged_ = function() {
    if (this.rotateWithView_) {
      this.ovmap_.getView().setRotation(this.getMap().getView().getRotation());
    }
  };
  OverviewMap2.prototype.validateExtent_ = function() {
    var map = this.getMap();
    var ovmap = this.ovmap_;
    if (!map.isRendered() || !ovmap.isRendered()) {
      return;
    }
    var mapSize = map.getSize();
    var view = map.getView();
    var extent2 = view.calculateExtentInternal(mapSize);
    if (this.viewExtent_ && equals$1(extent2, this.viewExtent_)) {
      return;
    }
    this.viewExtent_ = extent2;
    var ovmapSize = ovmap.getSize();
    var ovview = ovmap.getView();
    var ovextent = ovview.calculateExtentInternal(ovmapSize);
    var topLeftPixel = ovmap.getPixelFromCoordinateInternal(getTopLeft(extent2));
    var bottomRightPixel = ovmap.getPixelFromCoordinateInternal(getBottomRight(extent2));
    var boxWidth = Math.abs(topLeftPixel[0] - bottomRightPixel[0]);
    var boxHeight = Math.abs(topLeftPixel[1] - bottomRightPixel[1]);
    var ovmapWidth = ovmapSize[0];
    var ovmapHeight = ovmapSize[1];
    if (boxWidth < ovmapWidth * MIN_RATIO || boxHeight < ovmapHeight * MIN_RATIO || boxWidth > ovmapWidth * MAX_RATIO || boxHeight > ovmapHeight * MAX_RATIO) {
      this.resetExtent_();
    } else if (!containsExtent(ovextent, extent2)) {
      this.recenter_();
    }
  };
  OverviewMap2.prototype.resetExtent_ = function() {
    var map = this.getMap();
    var ovmap = this.ovmap_;
    var mapSize = map.getSize();
    var view = map.getView();
    var extent2 = view.calculateExtentInternal(mapSize);
    var ovview = ovmap.getView();
    var steps = Math.log(MAX_RATIO / MIN_RATIO) / Math.LN2;
    var ratio = 1 / (Math.pow(2, steps / 2) * MIN_RATIO);
    scaleFromCenter(extent2, ratio);
    ovview.fitInternal(fromExtent(extent2));
  };
  OverviewMap2.prototype.recenter_ = function() {
    var map = this.getMap();
    var ovmap = this.ovmap_;
    var view = map.getView();
    var ovview = ovmap.getView();
    ovview.setCenterInternal(view.getCenterInternal());
  };
  OverviewMap2.prototype.updateBox_ = function() {
    var map = this.getMap();
    var ovmap = this.ovmap_;
    if (!map.isRendered() || !ovmap.isRendered()) {
      return;
    }
    var mapSize = map.getSize();
    var view = map.getView();
    var ovview = ovmap.getView();
    var rotation = this.rotateWithView_ ? 0 : -view.getRotation();
    var overlay = this.boxOverlay_;
    var box = this.boxOverlay_.getElement();
    var center = view.getCenterInternal();
    var resolution = view.getResolution();
    var ovresolution = ovview.getResolution();
    var width = mapSize[0] * resolution / ovresolution;
    var height = mapSize[1] * resolution / ovresolution;
    overlay.setPosition(center);
    if (box) {
      box.style.width = width + "px";
      box.style.height = height + "px";
      var transform2 = "rotate(" + rotation + "rad)";
      box.style.transform = transform2;
    }
  };
  OverviewMap2.prototype.updateBoxAfterOvmapIsRendered_ = function() {
    if (this.ovmapPostrenderKey_) {
      return;
    }
    this.ovmapPostrenderKey_ = listenOnce(this.ovmap_, MapEventType.POSTRENDER, function(event) {
      delete this.ovmapPostrenderKey_;
      this.updateBox_();
    }, this);
  };
  OverviewMap2.prototype.handleClick_ = function(event) {
    event.preventDefault();
    this.handleToggle_();
  };
  OverviewMap2.prototype.handleToggle_ = function() {
    this.element.classList.toggle(CLASS_COLLAPSED);
    if (this.collapsed_) {
      replaceNode(this.collapseLabel_, this.label_);
    } else {
      replaceNode(this.label_, this.collapseLabel_);
    }
    this.collapsed_ = !this.collapsed_;
    var ovmap = this.ovmap_;
    if (!this.collapsed_) {
      if (ovmap.isRendered()) {
        this.viewExtent_ = void 0;
        ovmap.render();
        return;
      }
      ovmap.updateSize();
      this.resetExtent_();
      this.updateBoxAfterOvmapIsRendered_();
    }
  };
  OverviewMap2.prototype.getCollapsible = function() {
    return this.collapsible_;
  };
  OverviewMap2.prototype.setCollapsible = function(collapsible) {
    if (this.collapsible_ === collapsible) {
      return;
    }
    this.collapsible_ = collapsible;
    this.element.classList.toggle("ol-uncollapsible");
    if (!collapsible && this.collapsed_) {
      this.handleToggle_();
    }
  };
  OverviewMap2.prototype.setCollapsed = function(collapsed) {
    if (!this.collapsible_ || this.collapsed_ === collapsed) {
      return;
    }
    this.handleToggle_();
  };
  OverviewMap2.prototype.getCollapsed = function() {
    return this.collapsed_;
  };
  OverviewMap2.prototype.getRotateWithView = function() {
    return this.rotateWithView_;
  };
  OverviewMap2.prototype.setRotateWithView = function(rotateWithView) {
    if (this.rotateWithView_ === rotateWithView) {
      return;
    }
    this.rotateWithView_ = rotateWithView;
    if (this.getMap().getView().getRotation() !== 0) {
      if (this.rotateWithView_) {
        this.handleRotationChanged_();
      } else {
        this.ovmap_.getView().setRotation(0);
      }
      this.viewExtent_ = void 0;
      this.validateExtent_();
      this.updateBox_();
    }
  };
  OverviewMap2.prototype.getOverviewMap = function() {
    return this.ovmap_;
  };
  OverviewMap2.prototype.render = function(mapEvent) {
    this.validateExtent_();
    this.updateBox_();
  };
  return OverviewMap2;
}(ol_control_Control);
var OverviewMap$1 = OverviewMap;
var __extends$1K = globalThis && globalThis.__extends || function() {
  var extendStatics2 = function(d2, b2) {
    extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {
      d3.__proto__ = b3;
    } || function(d3, b3) {
      for (var p5 in b3)
        if (Object.prototype.hasOwnProperty.call(b3, p5))
          d3[p5] = b3[p5];
    };
    return extendStatics2(d2, b2);
  };
  return function(d2, b2) {
    if (typeof b2 !== "function" && b2 !== null)
      throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
    extendStatics2(d2, b2);
    function __() {
      this.constructor = d2;
    }
    d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
  };
}();
var UNITS_PROP = "units";
var Units = {
  DEGREES: "degrees",
  IMPERIAL: "imperial",
  NAUTICAL: "nautical",
  METRIC: "metric",
  US: "us"
};
var LEADING_DIGITS = [1, 2, 5];
var DEFAULT_DPI = 25.4 / 0.28;
var ScaleLine = function(_super) {
  __extends$1K(ScaleLine2, _super);
  function ScaleLine2(opt_options) {
    var _this = this;
    var options = opt_options ? opt_options : {};
    var className = options.className !== void 0 ? options.className : options.bar ? "ol-scale-bar" : "ol-scale-line";
    _this = _super.call(this, {
      element: document.createElement("div"),
      render: options.render,
      target: options.target
    }) || this;
    _this.on;
    _this.once;
    _this.un;
    _this.innerElement_ = document.createElement("div");
    _this.innerElement_.className = className + "-inner";
    _this.element.className = className + " " + CLASS_UNSELECTABLE;
    _this.element.appendChild(_this.innerElement_);
    _this.viewState_ = null;
    _this.minWidth_ = options.minWidth !== void 0 ? options.minWidth : 64;
    _this.renderedVisible_ = false;
    _this.renderedWidth_ = void 0;
    _this.renderedHTML_ = "";
    _this.addChangeListener(UNITS_PROP, _this.handleUnitsChanged_);
    _this.setUnits(options.units || Units.METRIC);
    _this.scaleBar_ = options.bar || false;
    _this.scaleBarSteps_ = options.steps || 4;
    _this.scaleBarText_ = options.text || false;
    _this.dpi_ = options.dpi || void 0;
    return _this;
  }
  ScaleLine2.prototype.getUnits = function() {
    return this.get(UNITS_PROP);
  };
  ScaleLine2.prototype.handleUnitsChanged_ = function() {
    this.updateElement_();
  };
  ScaleLine2.prototype.setUnits = function(units2) {
    this.set(UNITS_PROP, units2);
  };
  ScaleLine2.prototype.setDpi = function(dpi) {
    this.dpi_ = dpi;
  };
  ScaleLine2.prototype.updateElement_ = function() {
    var viewState = this.viewState_;
    if (!viewState) {
      if (this.renderedVisible_) {
        this.element.style.display = "none";
        this.renderedVisible_ = false;
      }
      return;
    }
    var center = viewState.center;
    var projection = viewState.projection;
    var units2 = this.getUnits();
    var pointResolutionUnits = units2 == Units.DEGREES ? Units$2.DEGREES : Units$2.METERS;
    var pointResolution = getPointResolution(projection, viewState.resolution, center, pointResolutionUnits);
    var minWidth = this.minWidth_ * (this.dpi_ || DEFAULT_DPI) / DEFAULT_DPI;
    var nominalCount = minWidth * pointResolution;
    var suffix2 = "";
    if (units2 == Units.DEGREES) {
      var metersPerDegree = METERS_PER_UNIT$1[Units$2.DEGREES];
      nominalCount *= metersPerDegree;
      if (nominalCount < metersPerDegree / 60) {
        suffix2 = "\u2033";
        pointResolution *= 3600;
      } else if (nominalCount < metersPerDegree) {
        suffix2 = "\u2032";
        pointResolution *= 60;
      } else {
        suffix2 = "\xB0";
      }
    } else if (units2 == Units.IMPERIAL) {
      if (nominalCount < 0.9144) {
        suffix2 = "in";
        pointResolution /= 0.0254;
      } else if (nominalCount < 1609.344) {
        suffix2 = "ft";
        pointResolution /= 0.3048;
      } else {
        suffix2 = "mi";
        pointResolution /= 1609.344;
      }
    } else if (units2 == Units.NAUTICAL) {
      pointResolution /= 1852;
      suffix2 = "nm";
    } else if (units2 == Units.METRIC) {
      if (nominalCount < 1e-3) {
        suffix2 = "\u03BCm";
        pointResolution *= 1e6;
      } else if (nominalCount < 1) {
        suffix2 = "mm";
        pointResolution *= 1e3;
      } else if (nominalCount < 1e3) {
        suffix2 = "m";
      } else {
        suffix2 = "km";
        pointResolution /= 1e3;
      }
    } else if (units2 == Units.US) {
      if (nominalCount < 0.9144) {
        suffix2 = "in";
        pointResolution *= 39.37;
      } else if (nominalCount < 1609.344) {
        suffix2 = "ft";
        pointResolution /= 0.30480061;
      } else {
        suffix2 = "mi";
        pointResolution /= 1609.3472;
      }
    } else {
      assert(false, 33);
    }
    var i2 = 3 * Math.floor(Math.log(minWidth * pointResolution) / Math.log(10));
    var count, width, decimalCount;
    while (true) {
      decimalCount = Math.floor(i2 / 3);
      var decimal = Math.pow(10, decimalCount);
      count = LEADING_DIGITS[(i2 % 3 + 3) % 3] * decimal;
      width = Math.round(count / pointResolution);
      if (isNaN(width)) {
        this.element.style.display = "none";
        this.renderedVisible_ = false;
        return;
      } else if (width >= minWidth) {
        break;
      }
      ++i2;
    }
    var html2;
    if (this.scaleBar_) {
      html2 = this.createScaleBar(width, count, suffix2);
    } else {
      html2 = count.toFixed(decimalCount < 0 ? -decimalCount : 0) + " " + suffix2;
    }
    if (this.renderedHTML_ != html2) {
      this.innerElement_.innerHTML = html2;
      this.renderedHTML_ = html2;
    }
    if (this.renderedWidth_ != width) {
      this.innerElement_.style.width = width + "px";
      this.renderedWidth_ = width;
    }
    if (!this.renderedVisible_) {
      this.element.style.display = "";
      this.renderedVisible_ = true;
    }
  };
  ScaleLine2.prototype.createScaleBar = function(width, scale2, suffix2) {
    var mapScale = "1 : " + Math.round(this.getScaleForResolution()).toLocaleString();
    var scaleSteps = [];
    var stepWidth = width / this.scaleBarSteps_;
    var backgroundColor2 = "#ffffff";
    for (var i2 = 0; i2 < this.scaleBarSteps_; i2++) {
      if (i2 === 0) {
        scaleSteps.push(this.createMarker("absolute", i2));
      }
      scaleSteps.push('<div><div class="ol-scale-singlebar" style="width: ' + stepWidth + "px;background-color: " + backgroundColor2 + ';"></div>' + this.createMarker("relative", i2) + (i2 % 2 === 0 || this.scaleBarSteps_ === 2 ? this.createStepText(i2, width, false, scale2, suffix2) : "") + "</div>");
      if (i2 === this.scaleBarSteps_ - 1) {
        scaleSteps.push(this.createStepText(i2 + 1, width, true, scale2, suffix2));
      }
      if (backgroundColor2 === "#ffffff") {
        backgroundColor2 = "#000000";
      } else {
        backgroundColor2 = "#ffffff";
      }
    }
    var scaleBarText;
    if (this.scaleBarText_) {
      scaleBarText = '<div class="ol-scale-text" style="width: ' + width + 'px;">' + mapScale + "</div>";
    } else {
      scaleBarText = "";
    }
    var container = '<div style="display: flex;">' + scaleBarText + scaleSteps.join("") + "</div>";
    return container;
  };
  ScaleLine2.prototype.createMarker = function(position2, i2) {
    var top = position2 === "absolute" ? 3 : -10;
    return '<div class="ol-scale-step-marker" style="position: ' + position2 + ";top: " + top + 'px;"></div>';
  };
  ScaleLine2.prototype.createStepText = function(i2, width, isLast, scale2, suffix2) {
    var length = i2 === 0 ? 0 : Math.round(scale2 / this.scaleBarSteps_ * i2 * 100) / 100;
    var lengthString = length + (i2 === 0 ? "" : " " + suffix2);
    var margin = i2 === 0 ? -3 : width / this.scaleBarSteps_ * -1;
    var minWidth = i2 === 0 ? 0 : width / this.scaleBarSteps_ * 2;
    return '<div class="ol-scale-step-text" style="margin-left: ' + margin + "px;text-align: " + (i2 === 0 ? "left" : "center") + "; min-width: " + minWidth + "px;left: " + (isLast ? width + "px" : "unset") + ';">' + lengthString + "</div>";
  };
  ScaleLine2.prototype.getScaleForResolution = function() {
    var resolution = getPointResolution(this.viewState_.projection, this.viewState_.resolution, this.viewState_.center, Units$2.METERS);
    var dpi = this.dpi_ || DEFAULT_DPI;
    var inchesPerMeter = 1e3 / 25.4;
    return parseFloat(resolution.toString()) * inchesPerMeter * dpi;
  };
  ScaleLine2.prototype.render = function(mapEvent) {
    var frameState = mapEvent.frameState;
    if (!frameState) {
      this.viewState_ = null;
    } else {
      this.viewState_ = frameState.viewState;
    }
    this.updateElement_();
  };
  return ScaleLine2;
}(ol_control_Control);
var ScaleLine$1 = ScaleLine;
var __extends$1J = globalThis && globalThis.__extends || function() {
  var extendStatics2 = function(d2, b2) {
    extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {
      d3.__proto__ = b3;
    } || function(d3, b3) {
      for (var p5 in b3)
        if (Object.prototype.hasOwnProperty.call(b3, p5))
          d3[p5] = b3[p5];
    };
    return extendStatics2(d2, b2);
  };
  return function(d2, b2) {
    if (typeof b2 !== "function" && b2 !== null)
      throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
    extendStatics2(d2, b2);
    function __() {
      this.constructor = d2;
    }
    d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
  };
}();
var Direction = {
  VERTICAL: 0,
  HORIZONTAL: 1
};
var ZoomSlider = function(_super) {
  __extends$1J(ZoomSlider2, _super);
  function ZoomSlider2(opt_options) {
    var _this = this;
    var options = opt_options ? opt_options : {};
    _this = _super.call(this, {
      element: document.createElement("div"),
      render: options.render
    }) || this;
    _this.dragListenerKeys_ = [];
    _this.currentResolution_ = void 0;
    _this.direction_ = Direction.VERTICAL;
    _this.dragging_;
    _this.heightLimit_ = 0;
    _this.widthLimit_ = 0;
    _this.startX_;
    _this.startY_;
    _this.thumbSize_ = null;
    _this.sliderInitialized_ = false;
    _this.duration_ = options.duration !== void 0 ? options.duration : 200;
    var className = options.className !== void 0 ? options.className : "ol-zoomslider";
    var thumbElement = document.createElement("button");
    thumbElement.setAttribute("type", "button");
    thumbElement.className = className + "-thumb " + CLASS_UNSELECTABLE;
    var containerElement = _this.element;
    containerElement.className = className + " " + CLASS_UNSELECTABLE + " " + CLASS_CONTROL;
    containerElement.appendChild(thumbElement);
    containerElement.addEventListener(PointerEventType.POINTERDOWN, _this.handleDraggerStart_.bind(_this), false);
    containerElement.addEventListener(PointerEventType.POINTERMOVE, _this.handleDraggerDrag_.bind(_this), false);
    containerElement.addEventListener(PointerEventType.POINTERUP, _this.handleDraggerEnd_.bind(_this), false);
    containerElement.addEventListener(EventType.CLICK, _this.handleContainerClick_.bind(_this), false);
    thumbElement.addEventListener(EventType.CLICK, stopPropagation, false);
    return _this;
  }
  ZoomSlider2.prototype.setMap = function(map) {
    _super.prototype.setMap.call(this, map);
    if (map) {
      map.render();
    }
  };
  ZoomSlider2.prototype.initSlider_ = function() {
    var container = this.element;
    var containerWidth = container.offsetWidth;
    var containerHeight = container.offsetHeight;
    if (containerWidth === 0 && containerHeight === 0) {
      return this.sliderInitialized_ = false;
    }
    var containerStyle = getComputedStyle(container);
    containerWidth -= parseFloat(containerStyle["paddingRight"]) + parseFloat(containerStyle["paddingLeft"]);
    containerHeight -= parseFloat(containerStyle["paddingTop"]) + parseFloat(containerStyle["paddingBottom"]);
    var thumb = container.firstElementChild;
    var thumbStyle = getComputedStyle(thumb);
    var thumbWidth = thumb.offsetWidth + parseFloat(thumbStyle["marginRight"]) + parseFloat(thumbStyle["marginLeft"]);
    var thumbHeight = thumb.offsetHeight + parseFloat(thumbStyle["marginTop"]) + parseFloat(thumbStyle["marginBottom"]);
    this.thumbSize_ = [thumbWidth, thumbHeight];
    if (containerWidth > containerHeight) {
      this.direction_ = Direction.HORIZONTAL;
      this.widthLimit_ = containerWidth - thumbWidth;
    } else {
      this.direction_ = Direction.VERTICAL;
      this.heightLimit_ = containerHeight - thumbHeight;
    }
    return this.sliderInitialized_ = true;
  };
  ZoomSlider2.prototype.handleContainerClick_ = function(event) {
    var view = this.getMap().getView();
    var relativePosition = this.getRelativePosition_(event.offsetX - this.thumbSize_[0] / 2, event.offsetY - this.thumbSize_[1] / 2);
    var resolution = this.getResolutionForPosition_(relativePosition);
    var zoom = view.getConstrainedZoom(view.getZoomForResolution(resolution));
    view.animateInternal({
      zoom,
      duration: this.duration_,
      easing: easeOut
    });
  };
  ZoomSlider2.prototype.handleDraggerStart_ = function(event) {
    if (!this.dragging_ && event.target === this.element.firstElementChild) {
      var element = this.element.firstElementChild;
      this.getMap().getView().beginInteraction();
      this.startX_ = event.clientX - parseFloat(element.style.left);
      this.startY_ = event.clientY - parseFloat(element.style.top);
      this.dragging_ = true;
      if (this.dragListenerKeys_.length === 0) {
        var drag = this.handleDraggerDrag_;
        var end = this.handleDraggerEnd_;
        var doc = this.getMap().getOwnerDocument();
        this.dragListenerKeys_.push(listen(doc, PointerEventType.POINTERMOVE, drag, this), listen(doc, PointerEventType.POINTERUP, end, this));
      }
    }
  };
  ZoomSlider2.prototype.handleDraggerDrag_ = function(event) {
    if (this.dragging_) {
      var deltaX = event.clientX - this.startX_;
      var deltaY = event.clientY - this.startY_;
      var relativePosition = this.getRelativePosition_(deltaX, deltaY);
      this.currentResolution_ = this.getResolutionForPosition_(relativePosition);
      this.getMap().getView().setResolution(this.currentResolution_);
    }
  };
  ZoomSlider2.prototype.handleDraggerEnd_ = function(event) {
    if (this.dragging_) {
      var view = this.getMap().getView();
      view.endInteraction();
      this.dragging_ = false;
      this.startX_ = void 0;
      this.startY_ = void 0;
      this.dragListenerKeys_.forEach(unlistenByKey);
      this.dragListenerKeys_.length = 0;
    }
  };
  ZoomSlider2.prototype.setThumbPosition_ = function(res) {
    var position2 = this.getPositionForResolution_(res);
    var thumb = this.element.firstElementChild;
    if (this.direction_ == Direction.HORIZONTAL) {
      thumb.style.left = this.widthLimit_ * position2 + "px";
    } else {
      thumb.style.top = this.heightLimit_ * position2 + "px";
    }
  };
  ZoomSlider2.prototype.getRelativePosition_ = function(x2, y2) {
    var amount;
    if (this.direction_ === Direction.HORIZONTAL) {
      amount = x2 / this.widthLimit_;
    } else {
      amount = y2 / this.heightLimit_;
    }
    return clamp(amount, 0, 1);
  };
  ZoomSlider2.prototype.getResolutionForPosition_ = function(position2) {
    var fn = this.getMap().getView().getResolutionForValueFunction();
    return fn(1 - position2);
  };
  ZoomSlider2.prototype.getPositionForResolution_ = function(res) {
    var fn = this.getMap().getView().getValueForResolutionFunction();
    return clamp(1 - fn(res), 0, 1);
  };
  ZoomSlider2.prototype.render = function(mapEvent) {
    if (!mapEvent.frameState) {
      return;
    }
    if (!this.sliderInitialized_ && !this.initSlider_()) {
      return;
    }
    var res = mapEvent.frameState.viewState.resolution;
    this.currentResolution_ = res;
    this.setThumbPosition_(res);
  };
  return ZoomSlider2;
}(ol_control_Control);
var ZoomSlider$1 = ZoomSlider;
var __extends$1I = globalThis && globalThis.__extends || function() {
  var extendStatics2 = function(d2, b2) {
    extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {
      d3.__proto__ = b3;
    } || function(d3, b3) {
      for (var p5 in b3)
        if (Object.prototype.hasOwnProperty.call(b3, p5))
          d3[p5] = b3[p5];
    };
    return extendStatics2(d2, b2);
  };
  return function(d2, b2) {
    if (typeof b2 !== "function" && b2 !== null)
      throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
    extendStatics2(d2, b2);
    function __() {
      this.constructor = d2;
    }
    d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
  };
}();
var ZoomToExtent = function(_super) {
  __extends$1I(ZoomToExtent2, _super);
  function ZoomToExtent2(opt_options) {
    var _this = this;
    var options = opt_options ? opt_options : {};
    _this = _super.call(this, {
      element: document.createElement("div"),
      target: options.target
    }) || this;
    _this.extent = options.extent ? options.extent : null;
    var className = options.className !== void 0 ? options.className : "ol-zoom-extent";
    var label = options.label !== void 0 ? options.label : "E";
    var tipLabel = options.tipLabel !== void 0 ? options.tipLabel : "Fit to extent";
    var button = document.createElement("button");
    button.setAttribute("type", "button");
    button.title = tipLabel;
    button.appendChild(typeof label === "string" ? document.createTextNode(label) : label);
    button.addEventListener(EventType.CLICK, _this.handleClick_.bind(_this), false);
    var cssClasses = className + " " + CLASS_UNSELECTABLE + " " + CLASS_CONTROL;
    var element = _this.element;
    element.className = cssClasses;
    element.appendChild(button);
    return _this;
  }
  ZoomToExtent2.prototype.handleClick_ = function(event) {
    event.preventDefault();
    this.handleZoomToExtent();
  };
  ZoomToExtent2.prototype.handleZoomToExtent = function() {
    var map = this.getMap();
    var view = map.getView();
    var extent2 = !this.extent ? view.getProjection().getExtent() : this.extent;
    view.fitInternal(fromExtent(extent2));
  };
  return ZoomToExtent2;
}(ol_control_Control);
var ZoomToExtent$1 = ZoomToExtent;
function defaults$1(opt_options) {
  var options = opt_options ? opt_options : {};
  var controls = new ol_Collection();
  var zoomControl = options.zoom !== void 0 ? options.zoom : true;
  if (zoomControl) {
    controls.push(new Zoom$1(options.zoomOptions));
  }
  var rotateControl = options.rotate !== void 0 ? options.rotate : true;
  if (rotateControl) {
    controls.push(new Rotate$2(options.rotateOptions));
  }
  var attributionControl = options.attribution !== void 0 ? options.attribution : true;
  if (attributionControl) {
    controls.push(new Attribution$1(options.attributionOptions));
  }
  return controls;
}
var InteractionProperty = {
  ACTIVE: "active"
};
var __extends$1H = globalThis && globalThis.__extends || function() {
  var extendStatics2 = function(d2, b2) {
    extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {
      d3.__proto__ = b3;
    } || function(d3, b3) {
      for (var p5 in b3)
        if (Object.prototype.hasOwnProperty.call(b3, p5))
          d3[p5] = b3[p5];
    };
    return extendStatics2(d2, b2);
  };
  return function(d2, b2) {
    if (typeof b2 !== "function" && b2 !== null)
      throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
    extendStatics2(d2, b2);
    function __() {
      this.constructor = d2;
    }
    d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
  };
}();
var Interaction = function(_super) {
  __extends$1H(Interaction2, _super);
  function Interaction2(opt_options) {
    var _this = _super.call(this) || this;
    _this.on;
    _this.once;
    _this.un;
    if (opt_options && opt_options.handleEvent) {
      _this.handleEvent = opt_options.handleEvent;
    }
    _this.map_ = null;
    _this.setActive(true);
    return _this;
  }
  Interaction2.prototype.getActive = function() {
    return this.get(InteractionProperty.ACTIVE);
  };
  Interaction2.prototype.getMap = function() {
    return this.map_;
  };
  Interaction2.prototype.handleEvent = function(mapBrowserEvent) {
    return true;
  };
  Interaction2.prototype.setActive = function(active) {
    this.set(InteractionProperty.ACTIVE, active);
  };
  Interaction2.prototype.setMap = function(map) {
    this.map_ = map;
  };
  return Interaction2;
}(ol_Object);
function pan(view, delta, opt_duration) {
  var currentCenter = view.getCenterInternal();
  if (currentCenter) {
    var center = [currentCenter[0] + delta[0], currentCenter[1] + delta[1]];
    view.animateInternal({
      duration: opt_duration !== void 0 ? opt_duration : 250,
      easing: linear,
      center: view.getConstrainedCenter(center)
    });
  }
}
function zoomByDelta(view, delta, opt_anchor, opt_duration) {
  var currentZoom = view.getZoom();
  if (currentZoom === void 0) {
    return;
  }
  var newZoom = view.getConstrainedZoom(currentZoom + delta);
  var newResolution = view.getResolutionForZoom(newZoom);
  if (view.getAnimating()) {
    view.cancelAnimations();
  }
  view.animate({
    resolution: newResolution,
    anchor: opt_anchor,
    duration: opt_duration !== void 0 ? opt_duration : 250,
    easing: easeOut
  });
}
var Interaction$1 = Interaction;
var __extends$1G = globalThis && globalThis.__extends || function() {
  var extendStatics2 = function(d2, b2) {
    extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {
      d3.__proto__ = b3;
    } || function(d3, b3) {
      for (var p5 in b3)
        if (Object.prototype.hasOwnProperty.call(b3, p5))
          d3[p5] = b3[p5];
    };
    return extendStatics2(d2, b2);
  };
  return function(d2, b2) {
    if (typeof b2 !== "function" && b2 !== null)
      throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
    extendStatics2(d2, b2);
    function __() {
      this.constructor = d2;
    }
    d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
  };
}();
var DoubleClickZoom = function(_super) {
  __extends$1G(DoubleClickZoom2, _super);
  function DoubleClickZoom2(opt_options) {
    var _this = _super.call(this) || this;
    var options = opt_options ? opt_options : {};
    _this.delta_ = options.delta ? options.delta : 1;
    _this.duration_ = options.duration !== void 0 ? options.duration : 250;
    return _this;
  }
  DoubleClickZoom2.prototype.handleEvent = function(mapBrowserEvent) {
    var stopEvent = false;
    if (mapBrowserEvent.type == MapBrowserEventType.DBLCLICK) {
      var browserEvent = mapBrowserEvent.originalEvent;
      var map = mapBrowserEvent.map;
      var anchor = mapBrowserEvent.coordinate;
      var delta = browserEvent.shiftKey ? -this.delta_ : this.delta_;
      var view = map.getView();
      zoomByDelta(view, delta, anchor, this.duration_);
      browserEvent.preventDefault();
      stopEvent = true;
    }
    return !stopEvent;
  };
  return DoubleClickZoom2;
}(Interaction$1);
var DoubleClickZoom$1 = DoubleClickZoom;
var __extends$1F = globalThis && globalThis.__extends || function() {
  var extendStatics2 = function(d2, b2) {
    extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {
      d3.__proto__ = b3;
    } || function(d3, b3) {
      for (var p5 in b3)
        if (Object.prototype.hasOwnProperty.call(b3, p5))
          d3[p5] = b3[p5];
    };
    return extendStatics2(d2, b2);
  };
  return function(d2, b2) {
    if (typeof b2 !== "function" && b2 !== null)
      throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
    extendStatics2(d2, b2);
    function __() {
      this.constructor = d2;
    }
    d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
  };
}();
var PointerInteraction = function(_super) {
  __extends$1F(PointerInteraction2, _super);
  function PointerInteraction2(opt_options) {
    var _this = this;
    var options = opt_options ? opt_options : {};
    _this = _super.call(this, options) || this;
    if (options.handleDownEvent) {
      _this.handleDownEvent = options.handleDownEvent;
    }
    if (options.handleDragEvent) {
      _this.handleDragEvent = options.handleDragEvent;
    }
    if (options.handleMoveEvent) {
      _this.handleMoveEvent = options.handleMoveEvent;
    }
    if (options.handleUpEvent) {
      _this.handleUpEvent = options.handleUpEvent;
    }
    if (options.stopDown) {
      _this.stopDown = options.stopDown;
    }
    _this.handlingDownUpSequence = false;
    _this.trackedPointers_ = {};
    _this.targetPointers = [];
    return _this;
  }
  PointerInteraction2.prototype.getPointerCount = function() {
    return this.targetPointers.length;
  };
  PointerInteraction2.prototype.handleDownEvent = function(mapBrowserEvent) {
    return false;
  };
  PointerInteraction2.prototype.handleDragEvent = function(mapBrowserEvent) {
  };
  PointerInteraction2.prototype.handleEvent = function(mapBrowserEvent) {
    if (!mapBrowserEvent.originalEvent) {
      return true;
    }
    var stopEvent = false;
    this.updateTrackedPointers_(mapBrowserEvent);
    if (this.handlingDownUpSequence) {
      if (mapBrowserEvent.type == MapBrowserEventType.POINTERDRAG) {
        this.handleDragEvent(mapBrowserEvent);
        mapBrowserEvent.originalEvent.preventDefault();
      } else if (mapBrowserEvent.type == MapBrowserEventType.POINTERUP) {
        var handledUp = this.handleUpEvent(mapBrowserEvent);
        this.handlingDownUpSequence = handledUp && this.targetPointers.length > 0;
      }
    } else {
      if (mapBrowserEvent.type == MapBrowserEventType.POINTERDOWN) {
        var handled = this.handleDownEvent(mapBrowserEvent);
        this.handlingDownUpSequence = handled;
        stopEvent = this.stopDown(handled);
      } else if (mapBrowserEvent.type == MapBrowserEventType.POINTERMOVE) {
        this.handleMoveEvent(mapBrowserEvent);
      }
    }
    return !stopEvent;
  };
  PointerInteraction2.prototype.handleMoveEvent = function(mapBrowserEvent) {
  };
  PointerInteraction2.prototype.handleUpEvent = function(mapBrowserEvent) {
    return false;
  };
  PointerInteraction2.prototype.stopDown = function(handled) {
    return handled;
  };
  PointerInteraction2.prototype.updateTrackedPointers_ = function(mapBrowserEvent) {
    if (isPointerDraggingEvent(mapBrowserEvent)) {
      var event_1 = mapBrowserEvent.originalEvent;
      var id = event_1.pointerId.toString();
      if (mapBrowserEvent.type == MapBrowserEventType.POINTERUP) {
        delete this.trackedPointers_[id];
      } else if (mapBrowserEvent.type == MapBrowserEventType.POINTERDOWN) {
        this.trackedPointers_[id] = event_1;
      } else if (id in this.trackedPointers_) {
        this.trackedPointers_[id] = event_1;
      }
      this.targetPointers = getValues(this.trackedPointers_);
    }
  };
  return PointerInteraction2;
}(Interaction$1);
function centroid(pointerEvents) {
  var length = pointerEvents.length;
  var clientX = 0;
  var clientY = 0;
  for (var i2 = 0; i2 < length; i2++) {
    clientX += pointerEvents[i2].clientX;
    clientY += pointerEvents[i2].clientY;
  }
  return [clientX / length, clientY / length];
}
function isPointerDraggingEvent(mapBrowserEvent) {
  var type = mapBrowserEvent.type;
  return type === MapBrowserEventType.POINTERDOWN || type === MapBrowserEventType.POINTERDRAG || type === MapBrowserEventType.POINTERUP;
}
var ol_interaction_Pointer = PointerInteraction;
function all$1(var_args) {
  var conditions = arguments;
  return function(event) {
    var pass = true;
    for (var i2 = 0, ii = conditions.length; i2 < ii; ++i2) {
      pass = pass && conditions[i2](event);
      if (!pass) {
        break;
      }
    }
    return pass;
  };
}
var altKeyOnly = function(mapBrowserEvent) {
  var originalEvent = mapBrowserEvent.originalEvent;
  return originalEvent.altKey && !(originalEvent.metaKey || originalEvent.ctrlKey) && !originalEvent.shiftKey;
};
var altShiftKeysOnly = function(mapBrowserEvent) {
  var originalEvent = mapBrowserEvent.originalEvent;
  return originalEvent.altKey && !(originalEvent.metaKey || originalEvent.ctrlKey) && originalEvent.shiftKey;
};
var focus = function(event) {
  var targetElement = event.map.getTargetElement();
  var activeElement = event.map.getOwnerDocument().activeElement;
  return targetElement.contains(activeElement);
};
var focusWithTabindex = function(event) {
  return event.map.getTargetElement().hasAttribute("tabindex") ? focus(event) : true;
};
var always = TRUE;
var click = function(mapBrowserEvent) {
  return mapBrowserEvent.type == MapBrowserEventType.CLICK;
};
var mouseActionButton = function(mapBrowserEvent) {
  var originalEvent = mapBrowserEvent.originalEvent;
  return originalEvent.button == 0 && !(WEBKIT && MAC && originalEvent.ctrlKey);
};
var never = FALSE;
var pointerMove = function(mapBrowserEvent) {
  return mapBrowserEvent.type == "pointermove";
};
var singleClick = function(mapBrowserEvent) {
  return mapBrowserEvent.type == MapBrowserEventType.SINGLECLICK;
};
var doubleClick = function(mapBrowserEvent) {
  return mapBrowserEvent.type == MapBrowserEventType.DBLCLICK;
};
var noModifierKeys = function(mapBrowserEvent) {
  var originalEvent = mapBrowserEvent.originalEvent;
  return !originalEvent.altKey && !(originalEvent.metaKey || originalEvent.ctrlKey) && !originalEvent.shiftKey;
};
var platformModifierKeyOnly = function(mapBrowserEvent) {
  var originalEvent = mapBrowserEvent.originalEvent;
  return !originalEvent.altKey && (MAC ? originalEvent.metaKey : originalEvent.ctrlKey) && !originalEvent.shiftKey;
};
var shiftKeyOnly = function(mapBrowserEvent) {
  var originalEvent = mapBrowserEvent.originalEvent;
  return !originalEvent.altKey && !(originalEvent.metaKey || originalEvent.ctrlKey) && originalEvent.shiftKey;
};
var targetNotEditable = function(mapBrowserEvent) {
  var originalEvent = mapBrowserEvent.originalEvent;
  var tagName = originalEvent.target.tagName;
  return tagName !== "INPUT" && tagName !== "SELECT" && tagName !== "TEXTAREA";
};
var mouseOnly = function(mapBrowserEvent) {
  var pointerEvent = mapBrowserEvent.originalEvent;
  assert(pointerEvent !== void 0, 56);
  return pointerEvent.pointerType == "mouse";
};
var touchOnly = function(mapBrowserEvent) {
  var pointerEvt = mapBrowserEvent.originalEvent;
  assert(pointerEvt !== void 0, 56);
  return pointerEvt.pointerType === "touch";
};
var penOnly = function(mapBrowserEvent) {
  var pointerEvt = mapBrowserEvent.originalEvent;
  assert(pointerEvt !== void 0, 56);
  return pointerEvt.pointerType === "pen";
};
var primaryAction = function(mapBrowserEvent) {
  var pointerEvent = mapBrowserEvent.originalEvent;
  assert(pointerEvent !== void 0, 56);
  return pointerEvent.isPrimary && pointerEvent.button === 0;
};
var selectconditions = Object.freeze(Object.defineProperty({
  __proto__: null,
  all: all$1,
  altKeyOnly,
  altShiftKeysOnly,
  focus,
  focusWithTabindex,
  always,
  click,
  mouseActionButton,
  never,
  pointerMove,
  singleClick,
  doubleClick,
  noModifierKeys,
  platformModifierKeyOnly,
  shiftKeyOnly,
  targetNotEditable,
  mouseOnly,
  touchOnly,
  penOnly,
  primaryAction
}, Symbol.toStringTag, { value: "Module" }));
var __extends$1E = globalThis && globalThis.__extends || function() {
  var extendStatics2 = function(d2, b2) {
    extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {
      d3.__proto__ = b3;
    } || function(d3, b3) {
      for (var p5 in b3)
        if (Object.prototype.hasOwnProperty.call(b3, p5))
          d3[p5] = b3[p5];
    };
    return extendStatics2(d2, b2);
  };
  return function(d2, b2) {
    if (typeof b2 !== "function" && b2 !== null)
      throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
    extendStatics2(d2, b2);
    function __() {
      this.constructor = d2;
    }
    d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
  };
}();
var DragPan = function(_super) {
  __extends$1E(DragPan2, _super);
  function DragPan2(opt_options) {
    var _this = _super.call(this, {
      stopDown: FALSE
    }) || this;
    var options = opt_options ? opt_options : {};
    _this.kinetic_ = options.kinetic;
    _this.lastCentroid = null;
    _this.lastPointersCount_;
    _this.panning_ = false;
    var condition = options.condition ? options.condition : all$1(noModifierKeys, primaryAction);
    _this.condition_ = options.onFocusOnly ? all$1(focusWithTabindex, condition) : condition;
    _this.noKinetic_ = false;
    return _this;
  }
  DragPan2.prototype.handleDragEvent = function(mapBrowserEvent) {
    if (!this.panning_) {
      this.panning_ = true;
      this.getMap().getView().beginInteraction();
    }
    var targetPointers = this.targetPointers;
    var centroid$1 = centroid(targetPointers);
    if (targetPointers.length == this.lastPointersCount_) {
      if (this.kinetic_) {
        this.kinetic_.update(centroid$1[0], centroid$1[1]);
      }
      if (this.lastCentroid) {
        var delta = [
          this.lastCentroid[0] - centroid$1[0],
          centroid$1[1] - this.lastCentroid[1]
        ];
        var map = mapBrowserEvent.map;
        var view = map.getView();
        scale$2(delta, view.getResolution());
        rotate$1(delta, view.getRotation());
        view.adjustCenterInternal(delta);
      }
    } else if (this.kinetic_) {
      this.kinetic_.begin();
    }
    this.lastCentroid = centroid$1;
    this.lastPointersCount_ = targetPointers.length;
    mapBrowserEvent.originalEvent.preventDefault();
  };
  DragPan2.prototype.handleUpEvent = function(mapBrowserEvent) {
    var map = mapBrowserEvent.map;
    var view = map.getView();
    if (this.targetPointers.length === 0) {
      if (!this.noKinetic_ && this.kinetic_ && this.kinetic_.end()) {
        var distance2 = this.kinetic_.getDistance();
        var angle2 = this.kinetic_.getAngle();
        var center = view.getCenterInternal();
        var centerpx = map.getPixelFromCoordinateInternal(center);
        var dest = map.getCoordinateFromPixelInternal([
          centerpx[0] - distance2 * Math.cos(angle2),
          centerpx[1] - distance2 * Math.sin(angle2)
        ]);
        view.animateInternal({
          center: view.getConstrainedCenter(dest),
          duration: 500,
          easing: easeOut
        });
      }
      if (this.panning_) {
        this.panning_ = false;
        view.endInteraction();
      }
      return false;
    } else {
      if (this.kinetic_) {
        this.kinetic_.begin();
      }
      this.lastCentroid = null;
      return true;
    }
  };
  DragPan2.prototype.handleDownEvent = function(mapBrowserEvent) {
    if (this.targetPointers.length > 0 && this.condition_(mapBrowserEvent)) {
      var map = mapBrowserEvent.map;
      var view = map.getView();
      this.lastCentroid = null;
      if (view.getAnimating()) {
        view.cancelAnimations();
      }
      if (this.kinetic_) {
        this.kinetic_.begin();
      }
      this.noKinetic_ = this.targetPointers.length > 1;
      return true;
    } else {
      return false;
    }
  };
  return DragPan2;
}(ol_interaction_Pointer);
var DragPan$1 = DragPan;
var __extends$1D = globalThis && globalThis.__extends || function() {
  var extendStatics2 = function(d2, b2) {
    extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {
      d3.__proto__ = b3;
    } || function(d3, b3) {
      for (var p5 in b3)
        if (Object.prototype.hasOwnProperty.call(b3, p5))
          d3[p5] = b3[p5];
    };
    return extendStatics2(d2, b2);
  };
  return function(d2, b2) {
    if (typeof b2 !== "function" && b2 !== null)
      throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
    extendStatics2(d2, b2);
    function __() {
      this.constructor = d2;
    }
    d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
  };
}();
var DragRotate = function(_super) {
  __extends$1D(DragRotate2, _super);
  function DragRotate2(opt_options) {
    var _this = this;
    var options = opt_options ? opt_options : {};
    _this = _super.call(this, {
      stopDown: FALSE
    }) || this;
    _this.condition_ = options.condition ? options.condition : altShiftKeysOnly;
    _this.lastAngle_ = void 0;
    _this.duration_ = options.duration !== void 0 ? options.duration : 250;
    return _this;
  }
  DragRotate2.prototype.handleDragEvent = function(mapBrowserEvent) {
    if (!mouseOnly(mapBrowserEvent)) {
      return;
    }
    var map = mapBrowserEvent.map;
    var view = map.getView();
    if (view.getConstraints().rotation === disable) {
      return;
    }
    var size = map.getSize();
    var offset2 = mapBrowserEvent.pixel;
    var theta = Math.atan2(size[1] / 2 - offset2[1], offset2[0] - size[0] / 2);
    if (this.lastAngle_ !== void 0) {
      var delta = theta - this.lastAngle_;
      view.adjustRotationInternal(-delta);
    }
    this.lastAngle_ = theta;
  };
  DragRotate2.prototype.handleUpEvent = function(mapBrowserEvent) {
    if (!mouseOnly(mapBrowserEvent)) {
      return true;
    }
    var map = mapBrowserEvent.map;
    var view = map.getView();
    view.endInteraction(this.duration_);
    return false;
  };
  DragRotate2.prototype.handleDownEvent = function(mapBrowserEvent) {
    if (!mouseOnly(mapBrowserEvent)) {
      return false;
    }
    if (mouseActionButton(mapBrowserEvent) && this.condition_(mapBrowserEvent)) {
      var map = mapBrowserEvent.map;
      map.getView().beginInteraction();
      this.lastAngle_ = void 0;
      return true;
    } else {
      return false;
    }
  };
  return DragRotate2;
}(ol_interaction_Pointer);
var DragRotate$1 = DragRotate;
var __extends$1C = globalThis && globalThis.__extends || function() {
  var extendStatics2 = function(d2, b2) {
    extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {
      d3.__proto__ = b3;
    } || function(d3, b3) {
      for (var p5 in b3)
        if (Object.prototype.hasOwnProperty.call(b3, p5))
          d3[p5] = b3[p5];
    };
    return extendStatics2(d2, b2);
  };
  return function(d2, b2) {
    if (typeof b2 !== "function" && b2 !== null)
      throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
    extendStatics2(d2, b2);
    function __() {
      this.constructor = d2;
    }
    d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
  };
}();
var RenderBox = function(_super) {
  __extends$1C(RenderBox2, _super);
  function RenderBox2(className) {
    var _this = _super.call(this) || this;
    _this.geometry_ = null;
    _this.element_ = document.createElement("div");
    _this.element_.style.position = "absolute";
    _this.element_.style.pointerEvents = "auto";
    _this.element_.className = "ol-box " + className;
    _this.map_ = null;
    _this.startPixel_ = null;
    _this.endPixel_ = null;
    return _this;
  }
  RenderBox2.prototype.disposeInternal = function() {
    this.setMap(null);
  };
  RenderBox2.prototype.render_ = function() {
    var startPixel = this.startPixel_;
    var endPixel = this.endPixel_;
    var px = "px";
    var style2 = this.element_.style;
    style2.left = Math.min(startPixel[0], endPixel[0]) + px;
    style2.top = Math.min(startPixel[1], endPixel[1]) + px;
    style2.width = Math.abs(endPixel[0] - startPixel[0]) + px;
    style2.height = Math.abs(endPixel[1] - startPixel[1]) + px;
  };
  RenderBox2.prototype.setMap = function(map) {
    if (this.map_) {
      this.map_.getOverlayContainer().removeChild(this.element_);
      var style2 = this.element_.style;
      style2.left = "inherit";
      style2.top = "inherit";
      style2.width = "inherit";
      style2.height = "inherit";
    }
    this.map_ = map;
    if (this.map_) {
      this.map_.getOverlayContainer().appendChild(this.element_);
    }
  };
  RenderBox2.prototype.setPixels = function(startPixel, endPixel) {
    this.startPixel_ = startPixel;
    this.endPixel_ = endPixel;
    this.createOrUpdateGeometry();
    this.render_();
  };
  RenderBox2.prototype.createOrUpdateGeometry = function() {
    var startPixel = this.startPixel_;
    var endPixel = this.endPixel_;
    var pixels = [
      startPixel,
      [startPixel[0], endPixel[1]],
      endPixel,
      [endPixel[0], startPixel[1]]
    ];
    var coordinates2 = pixels.map(this.map_.getCoordinateFromPixelInternal, this.map_);
    coordinates2[4] = coordinates2[0].slice();
    if (!this.geometry_) {
      this.geometry_ = new Polygon$2([coordinates2]);
    } else {
      this.geometry_.setCoordinates([coordinates2]);
    }
  };
  RenderBox2.prototype.getGeometry = function() {
    return this.geometry_;
  };
  return RenderBox2;
}(Disposable$1);
var RenderBox$1 = RenderBox;
var __extends$1B = globalThis && globalThis.__extends || function() {
  var extendStatics2 = function(d2, b2) {
    extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {
      d3.__proto__ = b3;
    } || function(d3, b3) {
      for (var p5 in b3)
        if (Object.prototype.hasOwnProperty.call(b3, p5))
          d3[p5] = b3[p5];
    };
    return extendStatics2(d2, b2);
  };
  return function(d2, b2) {
    if (typeof b2 !== "function" && b2 !== null)
      throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
    extendStatics2(d2, b2);
    function __() {
      this.constructor = d2;
    }
    d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
  };
}();
var DragBoxEventType = {
  BOXSTART: "boxstart",
  BOXDRAG: "boxdrag",
  BOXEND: "boxend",
  BOXCANCEL: "boxcancel"
};
var DragBoxEvent = function(_super) {
  __extends$1B(DragBoxEvent2, _super);
  function DragBoxEvent2(type, coordinate, mapBrowserEvent) {
    var _this = _super.call(this, type) || this;
    _this.coordinate = coordinate;
    _this.mapBrowserEvent = mapBrowserEvent;
    return _this;
  }
  return DragBoxEvent2;
}(Event$1);
var DragBox = function(_super) {
  __extends$1B(DragBox2, _super);
  function DragBox2(opt_options) {
    var _this = _super.call(this) || this;
    _this.on;
    _this.once;
    _this.un;
    var options = opt_options ? opt_options : {};
    _this.box_ = new RenderBox$1(options.className || "ol-dragbox");
    _this.minArea_ = options.minArea !== void 0 ? options.minArea : 64;
    if (options.onBoxEnd) {
      _this.onBoxEnd = options.onBoxEnd;
    }
    _this.startPixel_ = null;
    _this.condition_ = options.condition ? options.condition : mouseActionButton;
    _this.boxEndCondition_ = options.boxEndCondition ? options.boxEndCondition : _this.defaultBoxEndCondition;
    return _this;
  }
  DragBox2.prototype.defaultBoxEndCondition = function(mapBrowserEvent, startPixel, endPixel) {
    var width = endPixel[0] - startPixel[0];
    var height = endPixel[1] - startPixel[1];
    return width * width + height * height >= this.minArea_;
  };
  DragBox2.prototype.getGeometry = function() {
    return this.box_.getGeometry();
  };
  DragBox2.prototype.handleDragEvent = function(mapBrowserEvent) {
    this.box_.setPixels(this.startPixel_, mapBrowserEvent.pixel);
    this.dispatchEvent(new DragBoxEvent(DragBoxEventType.BOXDRAG, mapBrowserEvent.coordinate, mapBrowserEvent));
  };
  DragBox2.prototype.handleUpEvent = function(mapBrowserEvent) {
    this.box_.setMap(null);
    var completeBox = this.boxEndCondition_(mapBrowserEvent, this.startPixel_, mapBrowserEvent.pixel);
    if (completeBox) {
      this.onBoxEnd(mapBrowserEvent);
    }
    this.dispatchEvent(new DragBoxEvent(completeBox ? DragBoxEventType.BOXEND : DragBoxEventType.BOXCANCEL, mapBrowserEvent.coordinate, mapBrowserEvent));
    return false;
  };
  DragBox2.prototype.handleDownEvent = function(mapBrowserEvent) {
    if (this.condition_(mapBrowserEvent)) {
      this.startPixel_ = mapBrowserEvent.pixel;
      this.box_.setMap(mapBrowserEvent.map);
      this.box_.setPixels(this.startPixel_, this.startPixel_);
      this.dispatchEvent(new DragBoxEvent(DragBoxEventType.BOXSTART, mapBrowserEvent.coordinate, mapBrowserEvent));
      return true;
    } else {
      return false;
    }
  };
  DragBox2.prototype.onBoxEnd = function(event) {
  };
  return DragBox2;
}(ol_interaction_Pointer);
var DragBox$1 = DragBox;
var __extends$1A = globalThis && globalThis.__extends || function() {
  var extendStatics2 = function(d2, b2) {
    extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {
      d3.__proto__ = b3;
    } || function(d3, b3) {
      for (var p5 in b3)
        if (Object.prototype.hasOwnProperty.call(b3, p5))
          d3[p5] = b3[p5];
    };
    return extendStatics2(d2, b2);
  };
  return function(d2, b2) {
    if (typeof b2 !== "function" && b2 !== null)
      throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
    extendStatics2(d2, b2);
    function __() {
      this.constructor = d2;
    }
    d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
  };
}();
var DragZoom = function(_super) {
  __extends$1A(DragZoom2, _super);
  function DragZoom2(opt_options) {
    var _this = this;
    var options = opt_options ? opt_options : {};
    var condition = options.condition ? options.condition : shiftKeyOnly;
    _this = _super.call(this, {
      condition,
      className: options.className || "ol-dragzoom",
      minArea: options.minArea
    }) || this;
    _this.duration_ = options.duration !== void 0 ? options.duration : 200;
    _this.out_ = options.out !== void 0 ? options.out : false;
    return _this;
  }
  DragZoom2.prototype.onBoxEnd = function(event) {
    var map = this.getMap();
    var view = map.getView();
    var geometry = this.getGeometry();
    if (this.out_) {
      var rotatedExtent = view.rotatedExtentForGeometry(geometry);
      var resolution = view.getResolutionForExtentInternal(rotatedExtent);
      var factor = view.getResolution() / resolution;
      geometry = geometry.clone();
      geometry.scale(factor * factor);
    }
    view.fitInternal(geometry, {
      duration: this.duration_,
      easing: easeOut
    });
  };
  return DragZoom2;
}(DragBox$1);
var DragZoom$1 = DragZoom;
var KeyCode = {
  LEFT: 37,
  UP: 38,
  RIGHT: 39,
  DOWN: 40
};
var __extends$1z = globalThis && globalThis.__extends || function() {
  var extendStatics2 = function(d2, b2) {
    extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {
      d3.__proto__ = b3;
    } || function(d3, b3) {
      for (var p5 in b3)
        if (Object.prototype.hasOwnProperty.call(b3, p5))
          d3[p5] = b3[p5];
    };
    return extendStatics2(d2, b2);
  };
  return function(d2, b2) {
    if (typeof b2 !== "function" && b2 !== null)
      throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
    extendStatics2(d2, b2);
    function __() {
      this.constructor = d2;
    }
    d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
  };
}();
var KeyboardPan = function(_super) {
  __extends$1z(KeyboardPan2, _super);
  function KeyboardPan2(opt_options) {
    var _this = _super.call(this) || this;
    var options = opt_options || {};
    _this.defaultCondition_ = function(mapBrowserEvent) {
      return noModifierKeys(mapBrowserEvent) && targetNotEditable(mapBrowserEvent);
    };
    _this.condition_ = options.condition !== void 0 ? options.condition : _this.defaultCondition_;
    _this.duration_ = options.duration !== void 0 ? options.duration : 100;
    _this.pixelDelta_ = options.pixelDelta !== void 0 ? options.pixelDelta : 128;
    return _this;
  }
  KeyboardPan2.prototype.handleEvent = function(mapBrowserEvent) {
    var stopEvent = false;
    if (mapBrowserEvent.type == EventType.KEYDOWN) {
      var keyEvent = mapBrowserEvent.originalEvent;
      var keyCode = keyEvent.keyCode;
      if (this.condition_(mapBrowserEvent) && (keyCode == KeyCode.DOWN || keyCode == KeyCode.LEFT || keyCode == KeyCode.RIGHT || keyCode == KeyCode.UP)) {
        var map = mapBrowserEvent.map;
        var view = map.getView();
        var mapUnitsDelta = view.getResolution() * this.pixelDelta_;
        var deltaX = 0, deltaY = 0;
        if (keyCode == KeyCode.DOWN) {
          deltaY = -mapUnitsDelta;
        } else if (keyCode == KeyCode.LEFT) {
          deltaX = -mapUnitsDelta;
        } else if (keyCode == KeyCode.RIGHT) {
          deltaX = mapUnitsDelta;
        } else {
          deltaY = mapUnitsDelta;
        }
        var delta = [deltaX, deltaY];
        rotate$1(delta, view.getRotation());
        pan(view, delta, this.duration_);
        keyEvent.preventDefault();
        stopEvent = true;
      }
    }
    return !stopEvent;
  };
  return KeyboardPan2;
}(Interaction$1);
var KeyboardPan$1 = KeyboardPan;
var __extends$1y = globalThis && globalThis.__extends || function() {
  var extendStatics2 = function(d2, b2) {
    extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {
      d3.__proto__ = b3;
    } || function(d3, b3) {
      for (var p5 in b3)
        if (Object.prototype.hasOwnProperty.call(b3, p5))
          d3[p5] = b3[p5];
    };
    return extendStatics2(d2, b2);
  };
  return function(d2, b2) {
    if (typeof b2 !== "function" && b2 !== null)
      throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
    extendStatics2(d2, b2);
    function __() {
      this.constructor = d2;
    }
    d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
  };
}();
var KeyboardZoom = function(_super) {
  __extends$1y(KeyboardZoom2, _super);
  function KeyboardZoom2(opt_options) {
    var _this = _super.call(this) || this;
    var options = opt_options ? opt_options : {};
    _this.condition_ = options.condition ? options.condition : targetNotEditable;
    _this.delta_ = options.delta ? options.delta : 1;
    _this.duration_ = options.duration !== void 0 ? options.duration : 100;
    return _this;
  }
  KeyboardZoom2.prototype.handleEvent = function(mapBrowserEvent) {
    var stopEvent = false;
    if (mapBrowserEvent.type == EventType.KEYDOWN || mapBrowserEvent.type == EventType.KEYPRESS) {
      var keyEvent = mapBrowserEvent.originalEvent;
      var charCode = keyEvent.charCode;
      if (this.condition_(mapBrowserEvent) && (charCode == "+".charCodeAt(0) || charCode == "-".charCodeAt(0))) {
        var map = mapBrowserEvent.map;
        var delta = charCode == "+".charCodeAt(0) ? this.delta_ : -this.delta_;
        var view = map.getView();
        zoomByDelta(view, delta, void 0, this.duration_);
        keyEvent.preventDefault();
        stopEvent = true;
      }
    }
    return !stopEvent;
  };
  return KeyboardZoom2;
}(Interaction$1);
var KeyboardZoom$1 = KeyboardZoom;
var Kinetic = function() {
  function Kinetic2(decay, minVelocity, delay) {
    this.decay_ = decay;
    this.minVelocity_ = minVelocity;
    this.delay_ = delay;
    this.points_ = [];
    this.angle_ = 0;
    this.initialVelocity_ = 0;
  }
  Kinetic2.prototype.begin = function() {
    this.points_.length = 0;
    this.angle_ = 0;
    this.initialVelocity_ = 0;
  };
  Kinetic2.prototype.update = function(x2, y2) {
    this.points_.push(x2, y2, Date.now());
  };
  Kinetic2.prototype.end = function() {
    if (this.points_.length < 6) {
      return false;
    }
    var delay = Date.now() - this.delay_;
    var lastIndex = this.points_.length - 3;
    if (this.points_[lastIndex + 2] < delay) {
      return false;
    }
    var firstIndex = lastIndex - 3;
    while (firstIndex > 0 && this.points_[firstIndex + 2] > delay) {
      firstIndex -= 3;
    }
    var duration2 = this.points_[lastIndex + 2] - this.points_[firstIndex + 2];
    if (duration2 < 1e3 / 60) {
      return false;
    }
    var dx = this.points_[lastIndex] - this.points_[firstIndex];
    var dy = this.points_[lastIndex + 1] - this.points_[firstIndex + 1];
    this.angle_ = Math.atan2(dy, dx);
    this.initialVelocity_ = Math.sqrt(dx * dx + dy * dy) / duration2;
    return this.initialVelocity_ > this.minVelocity_;
  };
  Kinetic2.prototype.getDistance = function() {
    return (this.minVelocity_ - this.initialVelocity_) / this.decay_;
  };
  Kinetic2.prototype.getAngle = function() {
    return this.angle_;
  };
  return Kinetic2;
}();
var Kinetic$1 = Kinetic;
var __extends$1x = globalThis && globalThis.__extends || function() {
  var extendStatics2 = function(d2, b2) {
    extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {
      d3.__proto__ = b3;
    } || function(d3, b3) {
      for (var p5 in b3)
        if (Object.prototype.hasOwnProperty.call(b3, p5))
          d3[p5] = b3[p5];
    };
    return extendStatics2(d2, b2);
  };
  return function(d2, b2) {
    if (typeof b2 !== "function" && b2 !== null)
      throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
    extendStatics2(d2, b2);
    function __() {
      this.constructor = d2;
    }
    d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
  };
}();
var Mode$1 = {
  TRACKPAD: "trackpad",
  WHEEL: "wheel"
};
var MouseWheelZoom = function(_super) {
  __extends$1x(MouseWheelZoom2, _super);
  function MouseWheelZoom2(opt_options) {
    var _this = this;
    var options = opt_options ? opt_options : {};
    _this = _super.call(this, options) || this;
    _this.totalDelta_ = 0;
    _this.lastDelta_ = 0;
    _this.maxDelta_ = options.maxDelta !== void 0 ? options.maxDelta : 1;
    _this.duration_ = options.duration !== void 0 ? options.duration : 250;
    _this.timeout_ = options.timeout !== void 0 ? options.timeout : 80;
    _this.useAnchor_ = options.useAnchor !== void 0 ? options.useAnchor : true;
    _this.constrainResolution_ = options.constrainResolution !== void 0 ? options.constrainResolution : false;
    var condition = options.condition ? options.condition : always;
    _this.condition_ = options.onFocusOnly ? all$1(focusWithTabindex, condition) : condition;
    _this.lastAnchor_ = null;
    _this.startTime_ = void 0;
    _this.timeoutId_;
    _this.mode_ = void 0;
    _this.trackpadEventGap_ = 400;
    _this.trackpadTimeoutId_;
    _this.deltaPerZoom_ = 300;
    return _this;
  }
  MouseWheelZoom2.prototype.endInteraction_ = function() {
    this.trackpadTimeoutId_ = void 0;
    var view = this.getMap().getView();
    view.endInteraction(void 0, this.lastDelta_ ? this.lastDelta_ > 0 ? 1 : -1 : 0, this.lastAnchor_);
  };
  MouseWheelZoom2.prototype.handleEvent = function(mapBrowserEvent) {
    if (!this.condition_(mapBrowserEvent)) {
      return true;
    }
    var type = mapBrowserEvent.type;
    if (type !== EventType.WHEEL) {
      return true;
    }
    var map = mapBrowserEvent.map;
    var wheelEvent = mapBrowserEvent.originalEvent;
    wheelEvent.preventDefault();
    if (this.useAnchor_) {
      this.lastAnchor_ = mapBrowserEvent.coordinate;
    }
    var delta;
    if (mapBrowserEvent.type == EventType.WHEEL) {
      delta = wheelEvent.deltaY;
      if (FIREFOX && wheelEvent.deltaMode === WheelEvent.DOM_DELTA_PIXEL) {
        delta /= DEVICE_PIXEL_RATIO;
      }
      if (wheelEvent.deltaMode === WheelEvent.DOM_DELTA_LINE) {
        delta *= 40;
      }
    }
    if (delta === 0) {
      return false;
    } else {
      this.lastDelta_ = delta;
    }
    var now2 = Date.now();
    if (this.startTime_ === void 0) {
      this.startTime_ = now2;
    }
    if (!this.mode_ || now2 - this.startTime_ > this.trackpadEventGap_) {
      this.mode_ = Math.abs(delta) < 4 ? Mode$1.TRACKPAD : Mode$1.WHEEL;
    }
    var view = map.getView();
    if (this.mode_ === Mode$1.TRACKPAD && !(view.getConstrainResolution() || this.constrainResolution_)) {
      if (this.trackpadTimeoutId_) {
        clearTimeout(this.trackpadTimeoutId_);
      } else {
        if (view.getAnimating()) {
          view.cancelAnimations();
        }
        view.beginInteraction();
      }
      this.trackpadTimeoutId_ = setTimeout(this.endInteraction_.bind(this), this.timeout_);
      view.adjustZoom(-delta / this.deltaPerZoom_, this.lastAnchor_);
      this.startTime_ = now2;
      return false;
    }
    this.totalDelta_ += delta;
    var timeLeft = Math.max(this.timeout_ - (now2 - this.startTime_), 0);
    clearTimeout(this.timeoutId_);
    this.timeoutId_ = setTimeout(this.handleWheelZoom_.bind(this, map), timeLeft);
    return false;
  };
  MouseWheelZoom2.prototype.handleWheelZoom_ = function(map) {
    var view = map.getView();
    if (view.getAnimating()) {
      view.cancelAnimations();
    }
    var delta = -clamp(this.totalDelta_, -this.maxDelta_ * this.deltaPerZoom_, this.maxDelta_ * this.deltaPerZoom_) / this.deltaPerZoom_;
    if (view.getConstrainResolution() || this.constrainResolution_) {
      delta = delta ? delta > 0 ? 1 : -1 : 0;
    }
    zoomByDelta(view, delta, this.lastAnchor_, this.duration_);
    this.mode_ = void 0;
    this.totalDelta_ = 0;
    this.lastAnchor_ = null;
    this.startTime_ = void 0;
    this.timeoutId_ = void 0;
  };
  MouseWheelZoom2.prototype.setMouseAnchor = function(useAnchor) {
    this.useAnchor_ = useAnchor;
    if (!useAnchor) {
      this.lastAnchor_ = null;
    }
  };
  return MouseWheelZoom2;
}(Interaction$1);
var MouseWheelZoom$1 = MouseWheelZoom;
var __extends$1w = globalThis && globalThis.__extends || function() {
  var extendStatics2 = function(d2, b2) {
    extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {
      d3.__proto__ = b3;
    } || function(d3, b3) {
      for (var p5 in b3)
        if (Object.prototype.hasOwnProperty.call(b3, p5))
          d3[p5] = b3[p5];
    };
    return extendStatics2(d2, b2);
  };
  return function(d2, b2) {
    if (typeof b2 !== "function" && b2 !== null)
      throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
    extendStatics2(d2, b2);
    function __() {
      this.constructor = d2;
    }
    d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
  };
}();
var PinchRotate = function(_super) {
  __extends$1w(PinchRotate2, _super);
  function PinchRotate2(opt_options) {
    var _this = this;
    var options = opt_options ? opt_options : {};
    var pointerOptions = options;
    if (!pointerOptions.stopDown) {
      pointerOptions.stopDown = FALSE;
    }
    _this = _super.call(this, pointerOptions) || this;
    _this.anchor_ = null;
    _this.lastAngle_ = void 0;
    _this.rotating_ = false;
    _this.rotationDelta_ = 0;
    _this.threshold_ = options.threshold !== void 0 ? options.threshold : 0.3;
    _this.duration_ = options.duration !== void 0 ? options.duration : 250;
    return _this;
  }
  PinchRotate2.prototype.handleDragEvent = function(mapBrowserEvent) {
    var rotationDelta = 0;
    var touch0 = this.targetPointers[0];
    var touch1 = this.targetPointers[1];
    var angle2 = Math.atan2(touch1.clientY - touch0.clientY, touch1.clientX - touch0.clientX);
    if (this.lastAngle_ !== void 0) {
      var delta = angle2 - this.lastAngle_;
      this.rotationDelta_ += delta;
      if (!this.rotating_ && Math.abs(this.rotationDelta_) > this.threshold_) {
        this.rotating_ = true;
      }
      rotationDelta = delta;
    }
    this.lastAngle_ = angle2;
    var map = mapBrowserEvent.map;
    var view = map.getView();
    if (view.getConstraints().rotation === disable) {
      return;
    }
    var viewportPosition = map.getViewport().getBoundingClientRect();
    var centroid$1 = centroid(this.targetPointers);
    centroid$1[0] -= viewportPosition.left;
    centroid$1[1] -= viewportPosition.top;
    this.anchor_ = map.getCoordinateFromPixelInternal(centroid$1);
    if (this.rotating_) {
      map.render();
      view.adjustRotationInternal(rotationDelta, this.anchor_);
    }
  };
  PinchRotate2.prototype.handleUpEvent = function(mapBrowserEvent) {
    if (this.targetPointers.length < 2) {
      var map = mapBrowserEvent.map;
      var view = map.getView();
      view.endInteraction(this.duration_);
      return false;
    } else {
      return true;
    }
  };
  PinchRotate2.prototype.handleDownEvent = function(mapBrowserEvent) {
    if (this.targetPointers.length >= 2) {
      var map = mapBrowserEvent.map;
      this.anchor_ = null;
      this.lastAngle_ = void 0;
      this.rotating_ = false;
      this.rotationDelta_ = 0;
      if (!this.handlingDownUpSequence) {
        map.getView().beginInteraction();
      }
      return true;
    } else {
      return false;
    }
  };
  return PinchRotate2;
}(ol_interaction_Pointer);
var PinchRotate$1 = PinchRotate;
var __extends$1v = globalThis && globalThis.__extends || function() {
  var extendStatics2 = function(d2, b2) {
    extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {
      d3.__proto__ = b3;
    } || function(d3, b3) {
      for (var p5 in b3)
        if (Object.prototype.hasOwnProperty.call(b3, p5))
          d3[p5] = b3[p5];
    };
    return extendStatics2(d2, b2);
  };
  return function(d2, b2) {
    if (typeof b2 !== "function" && b2 !== null)
      throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
    extendStatics2(d2, b2);
    function __() {
      this.constructor = d2;
    }
    d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
  };
}();
var PinchZoom = function(_super) {
  __extends$1v(PinchZoom2, _super);
  function PinchZoom2(opt_options) {
    var _this = this;
    var options = opt_options ? opt_options : {};
    var pointerOptions = options;
    if (!pointerOptions.stopDown) {
      pointerOptions.stopDown = FALSE;
    }
    _this = _super.call(this, pointerOptions) || this;
    _this.anchor_ = null;
    _this.duration_ = options.duration !== void 0 ? options.duration : 400;
    _this.lastDistance_ = void 0;
    _this.lastScaleDelta_ = 1;
    return _this;
  }
  PinchZoom2.prototype.handleDragEvent = function(mapBrowserEvent) {
    var scaleDelta = 1;
    var touch0 = this.targetPointers[0];
    var touch1 = this.targetPointers[1];
    var dx = touch0.clientX - touch1.clientX;
    var dy = touch0.clientY - touch1.clientY;
    var distance2 = Math.sqrt(dx * dx + dy * dy);
    if (this.lastDistance_ !== void 0) {
      scaleDelta = this.lastDistance_ / distance2;
    }
    this.lastDistance_ = distance2;
    var map = mapBrowserEvent.map;
    var view = map.getView();
    if (scaleDelta != 1) {
      this.lastScaleDelta_ = scaleDelta;
    }
    var viewportPosition = map.getViewport().getBoundingClientRect();
    var centroid$1 = centroid(this.targetPointers);
    centroid$1[0] -= viewportPosition.left;
    centroid$1[1] -= viewportPosition.top;
    this.anchor_ = map.getCoordinateFromPixelInternal(centroid$1);
    map.render();
    view.adjustResolutionInternal(scaleDelta, this.anchor_);
  };
  PinchZoom2.prototype.handleUpEvent = function(mapBrowserEvent) {
    if (this.targetPointers.length < 2) {
      var map = mapBrowserEvent.map;
      var view = map.getView();
      var direction2 = this.lastScaleDelta_ > 1 ? 1 : -1;
      view.endInteraction(this.duration_, direction2);
      return false;
    } else {
      return true;
    }
  };
  PinchZoom2.prototype.handleDownEvent = function(mapBrowserEvent) {
    if (this.targetPointers.length >= 2) {
      var map = mapBrowserEvent.map;
      this.anchor_ = null;
      this.lastDistance_ = void 0;
      this.lastScaleDelta_ = 1;
      if (!this.handlingDownUpSequence) {
        map.getView().beginInteraction();
      }
      return true;
    } else {
      return false;
    }
  };
  return PinchZoom2;
}(ol_interaction_Pointer);
var PinchZoom$1 = PinchZoom;
var FormatType = {
  ARRAY_BUFFER: "arraybuffer",
  JSON: "json",
  TEXT: "text",
  XML: "xml"
};
var __extends$1u = globalThis && globalThis.__extends || function() {
  var extendStatics2 = function(d2, b2) {
    extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {
      d3.__proto__ = b3;
    } || function(d3, b3) {
      for (var p5 in b3)
        if (Object.prototype.hasOwnProperty.call(b3, p5))
          d3[p5] = b3[p5];
    };
    return extendStatics2(d2, b2);
  };
  return function(d2, b2) {
    if (typeof b2 !== "function" && b2 !== null)
      throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
    extendStatics2(d2, b2);
    function __() {
      this.constructor = d2;
    }
    d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
  };
}();
var DragRotateAndZoom = function(_super) {
  __extends$1u(DragRotateAndZoom2, _super);
  function DragRotateAndZoom2(opt_options) {
    var _this = this;
    var options = opt_options ? opt_options : {};
    _this = _super.call(this, options) || this;
    _this.condition_ = options.condition ? options.condition : shiftKeyOnly;
    _this.lastAngle_ = void 0;
    _this.lastMagnitude_ = void 0;
    _this.lastScaleDelta_ = 0;
    _this.duration_ = options.duration !== void 0 ? options.duration : 400;
    return _this;
  }
  DragRotateAndZoom2.prototype.handleDragEvent = function(mapBrowserEvent) {
    if (!mouseOnly(mapBrowserEvent)) {
      return;
    }
    var map = mapBrowserEvent.map;
    var size = map.getSize();
    var offset2 = mapBrowserEvent.pixel;
    var deltaX = offset2[0] - size[0] / 2;
    var deltaY = size[1] / 2 - offset2[1];
    var theta = Math.atan2(deltaY, deltaX);
    var magnitude = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
    var view = map.getView();
    if (this.lastAngle_ !== void 0) {
      var angleDelta = this.lastAngle_ - theta;
      view.adjustRotationInternal(angleDelta);
    }
    this.lastAngle_ = theta;
    if (this.lastMagnitude_ !== void 0) {
      view.adjustResolutionInternal(this.lastMagnitude_ / magnitude);
    }
    if (this.lastMagnitude_ !== void 0) {
      this.lastScaleDelta_ = this.lastMagnitude_ / magnitude;
    }
    this.lastMagnitude_ = magnitude;
  };
  DragRotateAndZoom2.prototype.handleUpEvent = function(mapBrowserEvent) {
    if (!mouseOnly(mapBrowserEvent)) {
      return true;
    }
    var map = mapBrowserEvent.map;
    var view = map.getView();
    var direction2 = this.lastScaleDelta_ > 1 ? 1 : -1;
    view.endInteraction(this.duration_, direction2);
    this.lastScaleDelta_ = 0;
    return false;
  };
  DragRotateAndZoom2.prototype.handleDownEvent = function(mapBrowserEvent) {
    if (!mouseOnly(mapBrowserEvent)) {
      return false;
    }
    if (this.condition_(mapBrowserEvent)) {
      mapBrowserEvent.map.getView().beginInteraction();
      this.lastAngle_ = void 0;
      this.lastMagnitude_ = void 0;
      return true;
    } else {
      return false;
    }
  };
  return DragRotateAndZoom2;
}(ol_interaction_Pointer);
var DragRotateAndZoom$1 = DragRotateAndZoom;
var __extends$1t = globalThis && globalThis.__extends || function() {
  var extendStatics2 = function(d2, b2) {
    extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {
      d3.__proto__ = b3;
    } || function(d3, b3) {
      for (var p5 in b3)
        if (Object.prototype.hasOwnProperty.call(b3, p5))
          d3[p5] = b3[p5];
    };
    return extendStatics2(d2, b2);
  };
  return function(d2, b2) {
    if (typeof b2 !== "function" && b2 !== null)
      throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
    extendStatics2(d2, b2);
    function __() {
      this.constructor = d2;
    }
    d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
  };
}();
var Circle$1 = function(_super) {
  __extends$1t(Circle2, _super);
  function Circle2(center, opt_radius, opt_layout) {
    var _this = _super.call(this) || this;
    if (opt_layout !== void 0 && opt_radius === void 0) {
      _this.setFlatCoordinates(opt_layout, center);
    } else {
      var radius = opt_radius ? opt_radius : 0;
      _this.setCenterAndRadius(center, radius, opt_layout);
    }
    return _this;
  }
  Circle2.prototype.clone = function() {
    var circle = new Circle2(this.flatCoordinates.slice(), void 0, this.layout);
    circle.applyProperties(this);
    return circle;
  };
  Circle2.prototype.closestPointXY = function(x2, y2, closestPoint, minSquaredDistance) {
    var flatCoordinates = this.flatCoordinates;
    var dx = x2 - flatCoordinates[0];
    var dy = y2 - flatCoordinates[1];
    var squaredDistance2 = dx * dx + dy * dy;
    if (squaredDistance2 < minSquaredDistance) {
      if (squaredDistance2 === 0) {
        for (var i2 = 0; i2 < this.stride; ++i2) {
          closestPoint[i2] = flatCoordinates[i2];
        }
      } else {
        var delta = this.getRadius() / Math.sqrt(squaredDistance2);
        closestPoint[0] = flatCoordinates[0] + delta * dx;
        closestPoint[1] = flatCoordinates[1] + delta * dy;
        for (var i2 = 2; i2 < this.stride; ++i2) {
          closestPoint[i2] = flatCoordinates[i2];
        }
      }
      closestPoint.length = this.stride;
      return squaredDistance2;
    } else {
      return minSquaredDistance;
    }
  };
  Circle2.prototype.containsXY = function(x2, y2) {
    var flatCoordinates = this.flatCoordinates;
    var dx = x2 - flatCoordinates[0];
    var dy = y2 - flatCoordinates[1];
    return dx * dx + dy * dy <= this.getRadiusSquared_();
  };
  Circle2.prototype.getCenter = function() {
    return this.flatCoordinates.slice(0, this.stride);
  };
  Circle2.prototype.computeExtent = function(extent2) {
    var flatCoordinates = this.flatCoordinates;
    var radius = flatCoordinates[this.stride] - flatCoordinates[0];
    return createOrUpdate$2(flatCoordinates[0] - radius, flatCoordinates[1] - radius, flatCoordinates[0] + radius, flatCoordinates[1] + radius, extent2);
  };
  Circle2.prototype.getRadius = function() {
    return Math.sqrt(this.getRadiusSquared_());
  };
  Circle2.prototype.getRadiusSquared_ = function() {
    var dx = this.flatCoordinates[this.stride] - this.flatCoordinates[0];
    var dy = this.flatCoordinates[this.stride + 1] - this.flatCoordinates[1];
    return dx * dx + dy * dy;
  };
  Circle2.prototype.getType = function() {
    return GeometryType.CIRCLE;
  };
  Circle2.prototype.intersectsExtent = function(extent2) {
    var circleExtent = this.getExtent();
    if (intersects$1(extent2, circleExtent)) {
      var center = this.getCenter();
      if (extent2[0] <= center[0] && extent2[2] >= center[0]) {
        return true;
      }
      if (extent2[1] <= center[1] && extent2[3] >= center[1]) {
        return true;
      }
      return forEachCorner(extent2, this.intersectsCoordinate.bind(this));
    }
    return false;
  };
  Circle2.prototype.setCenter = function(center) {
    var stride = this.stride;
    var radius = this.flatCoordinates[stride] - this.flatCoordinates[0];
    var flatCoordinates = center.slice();
    flatCoordinates[stride] = flatCoordinates[0] + radius;
    for (var i2 = 1; i2 < stride; ++i2) {
      flatCoordinates[stride + i2] = center[i2];
    }
    this.setFlatCoordinates(this.layout, flatCoordinates);
    this.changed();
  };
  Circle2.prototype.setCenterAndRadius = function(center, radius, opt_layout) {
    this.setLayout(opt_layout, center, 0);
    if (!this.flatCoordinates) {
      this.flatCoordinates = [];
    }
    var flatCoordinates = this.flatCoordinates;
    var offset2 = deflateCoordinate(flatCoordinates, 0, center, this.stride);
    flatCoordinates[offset2++] = flatCoordinates[0] + radius;
    for (var i2 = 1, ii = this.stride; i2 < ii; ++i2) {
      flatCoordinates[offset2++] = flatCoordinates[i2];
    }
    flatCoordinates.length = offset2;
    this.changed();
  };
  Circle2.prototype.getCoordinates = function() {
    return null;
  };
  Circle2.prototype.setCoordinates = function(coordinates2, opt_layout) {
  };
  Circle2.prototype.setRadius = function(radius) {
    this.flatCoordinates[this.stride] = this.flatCoordinates[0] + radius;
    this.changed();
  };
  Circle2.prototype.rotate = function(angle2, anchor) {
    var center = this.getCenter();
    var stride = this.getStride();
    this.setCenter(rotate(center, 0, center.length, stride, angle2, anchor, center));
    this.changed();
  };
  Circle2.prototype.translate = function(deltaX, deltaY) {
    var center = this.getCenter();
    var stride = this.getStride();
    this.setCenter(translate(center, 0, center.length, stride, deltaX, deltaY, center));
    this.changed();
  };
  return Circle2;
}(SimpleGeometry$1);
Circle$1.prototype.transform;
var ol_geom_Circle = Circle$1;
var __extends$1s = globalThis && globalThis.__extends || function() {
  var extendStatics2 = function(d2, b2) {
    extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {
      d3.__proto__ = b3;
    } || function(d3, b3) {
      for (var p5 in b3)
        if (Object.prototype.hasOwnProperty.call(b3, p5))
          d3[p5] = b3[p5];
    };
    return extendStatics2(d2, b2);
  };
  return function(d2, b2) {
    if (typeof b2 !== "function" && b2 !== null)
      throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
    extendStatics2(d2, b2);
    function __() {
      this.constructor = d2;
    }
    d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
  };
}();
var Feature$1 = function(_super) {
  __extends$1s(Feature2, _super);
  function Feature2(opt_geometryOrProperties) {
    var _this = _super.call(this) || this;
    _this.on;
    _this.once;
    _this.un;
    _this.id_ = void 0;
    _this.geometryName_ = "geometry";
    _this.style_ = null;
    _this.styleFunction_ = void 0;
    _this.geometryChangeKey_ = null;
    _this.addChangeListener(_this.geometryName_, _this.handleGeometryChanged_);
    if (opt_geometryOrProperties) {
      if (typeof opt_geometryOrProperties.getSimplifiedGeometry === "function") {
        var geometry = opt_geometryOrProperties;
        _this.setGeometry(geometry);
      } else {
        var properties = opt_geometryOrProperties;
        _this.setProperties(properties);
      }
    }
    return _this;
  }
  Feature2.prototype.clone = function() {
    var clone2 = new Feature2(this.hasProperties() ? this.getProperties() : null);
    clone2.setGeometryName(this.getGeometryName());
    var geometry = this.getGeometry();
    if (geometry) {
      clone2.setGeometry(geometry.clone());
    }
    var style2 = this.getStyle();
    if (style2) {
      clone2.setStyle(style2);
    }
    return clone2;
  };
  Feature2.prototype.getGeometry = function() {
    return this.get(this.geometryName_);
  };
  Feature2.prototype.getId = function() {
    return this.id_;
  };
  Feature2.prototype.getGeometryName = function() {
    return this.geometryName_;
  };
  Feature2.prototype.getStyle = function() {
    return this.style_;
  };
  Feature2.prototype.getStyleFunction = function() {
    return this.styleFunction_;
  };
  Feature2.prototype.handleGeometryChange_ = function() {
    this.changed();
  };
  Feature2.prototype.handleGeometryChanged_ = function() {
    if (this.geometryChangeKey_) {
      unlistenByKey(this.geometryChangeKey_);
      this.geometryChangeKey_ = null;
    }
    var geometry = this.getGeometry();
    if (geometry) {
      this.geometryChangeKey_ = listen(geometry, EventType.CHANGE, this.handleGeometryChange_, this);
    }
    this.changed();
  };
  Feature2.prototype.setGeometry = function(geometry) {
    this.set(this.geometryName_, geometry);
  };
  Feature2.prototype.setStyle = function(opt_style) {
    this.style_ = opt_style;
    this.styleFunction_ = !opt_style ? void 0 : createStyleFunction(opt_style);
    this.changed();
  };
  Feature2.prototype.setId = function(id) {
    this.id_ = id;
    this.changed();
  };
  Feature2.prototype.setGeometryName = function(name) {
    this.removeChangeListener(this.geometryName_, this.handleGeometryChanged_);
    this.geometryName_ = name;
    this.addChangeListener(this.geometryName_, this.handleGeometryChanged_);
    this.handleGeometryChanged_();
  };
  return Feature2;
}(ol_Object);
function createStyleFunction(obj) {
  if (typeof obj === "function") {
    return obj;
  } else {
    var styles_1;
    if (Array.isArray(obj)) {
      styles_1 = obj;
    } else {
      assert(typeof obj.getZIndex === "function", 41);
      var style2 = obj;
      styles_1 = [style2];
    }
    return function() {
      return styles_1;
    };
  }
}
var feature = Feature$1;
function interpolatePoint(flatCoordinates, offset2, end, stride, fraction, opt_dest, opt_dimension) {
  var o2, t3;
  var n2 = (end - offset2) / stride;
  if (n2 === 1) {
    o2 = offset2;
  } else if (n2 === 2) {
    o2 = offset2;
    t3 = fraction;
  } else if (n2 !== 0) {
    var x1 = flatCoordinates[offset2];
    var y1 = flatCoordinates[offset2 + 1];
    var length_1 = 0;
    var cumulativeLengths = [0];
    for (var i2 = offset2 + stride; i2 < end; i2 += stride) {
      var x2 = flatCoordinates[i2];
      var y2 = flatCoordinates[i2 + 1];
      length_1 += Math.sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1));
      cumulativeLengths.push(length_1);
      x1 = x2;
      y1 = y2;
    }
    var target = fraction * length_1;
    var index2 = binarySearch(cumulativeLengths, target);
    if (index2 < 0) {
      t3 = (target - cumulativeLengths[-index2 - 2]) / (cumulativeLengths[-index2 - 1] - cumulativeLengths[-index2 - 2]);
      o2 = offset2 + (-index2 - 2) * stride;
    } else {
      o2 = offset2 + index2 * stride;
    }
  }
  var dimension = opt_dimension > 1 ? opt_dimension : 2;
  var dest = opt_dest ? opt_dest : new Array(dimension);
  for (var i2 = 0; i2 < dimension; ++i2) {
    dest[i2] = o2 === void 0 ? NaN : t3 === void 0 ? flatCoordinates[o2 + i2] : lerp$1(flatCoordinates[o2 + i2], flatCoordinates[o2 + stride + i2], t3);
  }
  return dest;
}
function lineStringCoordinateAtM(flatCoordinates, offset2, end, stride, m2, extrapolate) {
  if (end == offset2) {
    return null;
  }
  var coordinate;
  if (m2 < flatCoordinates[offset2 + stride - 1]) {
    if (extrapolate) {
      coordinate = flatCoordinates.slice(offset2, offset2 + stride);
      coordinate[stride - 1] = m2;
      return coordinate;
    } else {
      return null;
    }
  } else if (flatCoordinates[end - 1] < m2) {
    if (extrapolate) {
      coordinate = flatCoordinates.slice(end - stride, end);
      coordinate[stride - 1] = m2;
      return coordinate;
    } else {
      return null;
    }
  }
  if (m2 == flatCoordinates[offset2 + stride - 1]) {
    return flatCoordinates.slice(offset2, offset2 + stride);
  }
  var lo = offset2 / stride;
  var hi = end / stride;
  while (lo < hi) {
    var mid = lo + hi >> 1;
    if (m2 < flatCoordinates[(mid + 1) * stride - 1]) {
      hi = mid;
    } else {
      lo = mid + 1;
    }
  }
  var m0 = flatCoordinates[lo * stride - 1];
  if (m2 == m0) {
    return flatCoordinates.slice((lo - 1) * stride, (lo - 1) * stride + stride);
  }
  var m1 = flatCoordinates[(lo + 1) * stride - 1];
  var t3 = (m2 - m0) / (m1 - m0);
  coordinate = [];
  for (var i2 = 0; i2 < stride - 1; ++i2) {
    coordinate.push(lerp$1(flatCoordinates[(lo - 1) * stride + i2], flatCoordinates[lo * stride + i2], t3));
  }
  coordinate.push(m2);
  return coordinate;
}
function lineStringsCoordinateAtM(flatCoordinates, offset2, ends, stride, m2, extrapolate, interpolate) {
  if (interpolate) {
    return lineStringCoordinateAtM(flatCoordinates, offset2, ends[ends.length - 1], stride, m2, extrapolate);
  }
  var coordinate;
  if (m2 < flatCoordinates[stride - 1]) {
    if (extrapolate) {
      coordinate = flatCoordinates.slice(0, stride);
      coordinate[stride - 1] = m2;
      return coordinate;
    } else {
      return null;
    }
  }
  if (flatCoordinates[flatCoordinates.length - 1] < m2) {
    if (extrapolate) {
      coordinate = flatCoordinates.slice(flatCoordinates.length - stride);
      coordinate[stride - 1] = m2;
      return coordinate;
    } else {
      return null;
    }
  }
  for (var i2 = 0, ii = ends.length; i2 < ii; ++i2) {
    var end = ends[i2];
    if (offset2 == end) {
      continue;
    }
    if (m2 < flatCoordinates[offset2 + stride - 1]) {
      return null;
    } else if (m2 <= flatCoordinates[end - 1]) {
      return lineStringCoordinateAtM(flatCoordinates, offset2, end, stride, m2, false);
    }
    offset2 = end;
  }
  return null;
}
function lineStringLength(flatCoordinates, offset2, end, stride) {
  var x1 = flatCoordinates[offset2];
  var y1 = flatCoordinates[offset2 + 1];
  var length = 0;
  for (var i2 = offset2 + stride; i2 < end; i2 += stride) {
    var x2 = flatCoordinates[i2];
    var y2 = flatCoordinates[i2 + 1];
    length += Math.sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1));
    x1 = x2;
    y1 = y2;
  }
  return length;
}
var __extends$1r = globalThis && globalThis.__extends || function() {
  var extendStatics2 = function(d2, b2) {
    extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {
      d3.__proto__ = b3;
    } || function(d3, b3) {
      for (var p5 in b3)
        if (Object.prototype.hasOwnProperty.call(b3, p5))
          d3[p5] = b3[p5];
    };
    return extendStatics2(d2, b2);
  };
  return function(d2, b2) {
    if (typeof b2 !== "function" && b2 !== null)
      throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
    extendStatics2(d2, b2);
    function __() {
      this.constructor = d2;
    }
    d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
  };
}();
var LineString$1 = function(_super) {
  __extends$1r(LineString2, _super);
  function LineString2(coordinates2, opt_layout) {
    var _this = _super.call(this) || this;
    _this.flatMidpoint_ = null;
    _this.flatMidpointRevision_ = -1;
    _this.maxDelta_ = -1;
    _this.maxDeltaRevision_ = -1;
    if (opt_layout !== void 0 && !Array.isArray(coordinates2[0])) {
      _this.setFlatCoordinates(opt_layout, coordinates2);
    } else {
      _this.setCoordinates(coordinates2, opt_layout);
    }
    return _this;
  }
  LineString2.prototype.appendCoordinate = function(coordinate) {
    if (!this.flatCoordinates) {
      this.flatCoordinates = coordinate.slice();
    } else {
      extend$3(this.flatCoordinates, coordinate);
    }
    this.changed();
  };
  LineString2.prototype.clone = function() {
    var lineString = new LineString2(this.flatCoordinates.slice(), this.layout);
    lineString.applyProperties(this);
    return lineString;
  };
  LineString2.prototype.closestPointXY = function(x2, y2, closestPoint, minSquaredDistance) {
    if (minSquaredDistance < closestSquaredDistanceXY(this.getExtent(), x2, y2)) {
      return minSquaredDistance;
    }
    if (this.maxDeltaRevision_ != this.getRevision()) {
      this.maxDelta_ = Math.sqrt(maxSquaredDelta(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, 0));
      this.maxDeltaRevision_ = this.getRevision();
    }
    return assignClosestPoint(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, this.maxDelta_, false, x2, y2, closestPoint, minSquaredDistance);
  };
  LineString2.prototype.forEachSegment = function(callback) {
    return forEach(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, callback);
  };
  LineString2.prototype.getCoordinateAtM = function(m2, opt_extrapolate) {
    if (this.layout != GeometryLayout.XYM && this.layout != GeometryLayout.XYZM) {
      return null;
    }
    var extrapolate = opt_extrapolate !== void 0 ? opt_extrapolate : false;
    return lineStringCoordinateAtM(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, m2, extrapolate);
  };
  LineString2.prototype.getCoordinates = function() {
    return inflateCoordinates(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride);
  };
  LineString2.prototype.getCoordinateAt = function(fraction, opt_dest) {
    return interpolatePoint(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, fraction, opt_dest, this.stride);
  };
  LineString2.prototype.getLength = function() {
    return lineStringLength(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride);
  };
  LineString2.prototype.getFlatMidpoint = function() {
    if (this.flatMidpointRevision_ != this.getRevision()) {
      this.flatMidpoint_ = this.getCoordinateAt(0.5, this.flatMidpoint_);
      this.flatMidpointRevision_ = this.getRevision();
    }
    return this.flatMidpoint_;
  };
  LineString2.prototype.getSimplifiedGeometryInternal = function(squaredTolerance) {
    var simplifiedFlatCoordinates = [];
    simplifiedFlatCoordinates.length = douglasPeucker(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, squaredTolerance, simplifiedFlatCoordinates, 0);
    return new LineString2(simplifiedFlatCoordinates, GeometryLayout.XY);
  };
  LineString2.prototype.getType = function() {
    return GeometryType.LINE_STRING;
  };
  LineString2.prototype.intersectsExtent = function(extent2) {
    return intersectsLineString(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, extent2);
  };
  LineString2.prototype.setCoordinates = function(coordinates2, opt_layout) {
    this.setLayout(opt_layout, coordinates2, 1);
    if (!this.flatCoordinates) {
      this.flatCoordinates = [];
    }
    this.flatCoordinates.length = deflateCoordinates(this.flatCoordinates, 0, coordinates2, this.stride);
    this.changed();
  };
  return LineString2;
}(SimpleGeometry$1);
var LineString$2 = LineString$1;
var __extends$1q = globalThis && globalThis.__extends || function() {
  var extendStatics2 = function(d2, b2) {
    extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {
      d3.__proto__ = b3;
    } || function(d3, b3) {
      for (var p5 in b3)
        if (Object.prototype.hasOwnProperty.call(b3, p5))
          d3[p5] = b3[p5];
    };
    return extendStatics2(d2, b2);
  };
  return function(d2, b2) {
    if (typeof b2 !== "function" && b2 !== null)
      throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
    extendStatics2(d2, b2);
    function __() {
      this.constructor = d2;
    }
    d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
  };
}();
var MultiLineString$1 = function(_super) {
  __extends$1q(MultiLineString2, _super);
  function MultiLineString2(coordinates2, opt_layout, opt_ends) {
    var _this = _super.call(this) || this;
    _this.ends_ = [];
    _this.maxDelta_ = -1;
    _this.maxDeltaRevision_ = -1;
    if (Array.isArray(coordinates2[0])) {
      _this.setCoordinates(coordinates2, opt_layout);
    } else if (opt_layout !== void 0 && opt_ends) {
      _this.setFlatCoordinates(opt_layout, coordinates2);
      _this.ends_ = opt_ends;
    } else {
      var layout = _this.getLayout();
      var lineStrings = coordinates2;
      var flatCoordinates = [];
      var ends = [];
      for (var i2 = 0, ii = lineStrings.length; i2 < ii; ++i2) {
        var lineString = lineStrings[i2];
        if (i2 === 0) {
          layout = lineString.getLayout();
        }
        extend$3(flatCoordinates, lineString.getFlatCoordinates());
        ends.push(flatCoordinates.length);
      }
      _this.setFlatCoordinates(layout, flatCoordinates);
      _this.ends_ = ends;
    }
    return _this;
  }
  MultiLineString2.prototype.appendLineString = function(lineString) {
    if (!this.flatCoordinates) {
      this.flatCoordinates = lineString.getFlatCoordinates().slice();
    } else {
      extend$3(this.flatCoordinates, lineString.getFlatCoordinates().slice());
    }
    this.ends_.push(this.flatCoordinates.length);
    this.changed();
  };
  MultiLineString2.prototype.clone = function() {
    var multiLineString = new MultiLineString2(this.flatCoordinates.slice(), this.layout, this.ends_.slice());
    multiLineString.applyProperties(this);
    return multiLineString;
  };
  MultiLineString2.prototype.closestPointXY = function(x2, y2, closestPoint, minSquaredDistance) {
    if (minSquaredDistance < closestSquaredDistanceXY(this.getExtent(), x2, y2)) {
      return minSquaredDistance;
    }
    if (this.maxDeltaRevision_ != this.getRevision()) {
      this.maxDelta_ = Math.sqrt(arrayMaxSquaredDelta(this.flatCoordinates, 0, this.ends_, this.stride, 0));
      this.maxDeltaRevision_ = this.getRevision();
    }
    return assignClosestArrayPoint(this.flatCoordinates, 0, this.ends_, this.stride, this.maxDelta_, false, x2, y2, closestPoint, minSquaredDistance);
  };
  MultiLineString2.prototype.getCoordinateAtM = function(m2, opt_extrapolate, opt_interpolate) {
    if (this.layout != GeometryLayout.XYM && this.layout != GeometryLayout.XYZM || this.flatCoordinates.length === 0) {
      return null;
    }
    var extrapolate = opt_extrapolate !== void 0 ? opt_extrapolate : false;
    var interpolate = opt_interpolate !== void 0 ? opt_interpolate : false;
    return lineStringsCoordinateAtM(this.flatCoordinates, 0, this.ends_, this.stride, m2, extrapolate, interpolate);
  };
  MultiLineString2.prototype.getCoordinates = function() {
    return inflateCoordinatesArray(this.flatCoordinates, 0, this.ends_, this.stride);
  };
  MultiLineString2.prototype.getEnds = function() {
    return this.ends_;
  };
  MultiLineString2.prototype.getLineString = function(index2) {
    if (index2 < 0 || this.ends_.length <= index2) {
      return null;
    }
    return new LineString$2(this.flatCoordinates.slice(index2 === 0 ? 0 : this.ends_[index2 - 1], this.ends_[index2]), this.layout);
  };
  MultiLineString2.prototype.getLineStrings = function() {
    var flatCoordinates = this.flatCoordinates;
    var ends = this.ends_;
    var layout = this.layout;
    var lineStrings = [];
    var offset2 = 0;
    for (var i2 = 0, ii = ends.length; i2 < ii; ++i2) {
      var end = ends[i2];
      var lineString = new LineString$2(flatCoordinates.slice(offset2, end), layout);
      lineStrings.push(lineString);
      offset2 = end;
    }
    return lineStrings;
  };
  MultiLineString2.prototype.getFlatMidpoints = function() {
    var midpoints = [];
    var flatCoordinates = this.flatCoordinates;
    var offset2 = 0;
    var ends = this.ends_;
    var stride = this.stride;
    for (var i2 = 0, ii = ends.length; i2 < ii; ++i2) {
      var end = ends[i2];
      var midpoint = interpolatePoint(flatCoordinates, offset2, end, stride, 0.5);
      extend$3(midpoints, midpoint);
      offset2 = end;
    }
    return midpoints;
  };
  MultiLineString2.prototype.getSimplifiedGeometryInternal = function(squaredTolerance) {
    var simplifiedFlatCoordinates = [];
    var simplifiedEnds = [];
    simplifiedFlatCoordinates.length = douglasPeuckerArray(this.flatCoordinates, 0, this.ends_, this.stride, squaredTolerance, simplifiedFlatCoordinates, 0, simplifiedEnds);
    return new MultiLineString2(simplifiedFlatCoordinates, GeometryLayout.XY, simplifiedEnds);
  };
  MultiLineString2.prototype.getType = function() {
    return GeometryType.MULTI_LINE_STRING;
  };
  MultiLineString2.prototype.intersectsExtent = function(extent2) {
    return intersectsLineStringArray(this.flatCoordinates, 0, this.ends_, this.stride, extent2);
  };
  MultiLineString2.prototype.setCoordinates = function(coordinates2, opt_layout) {
    this.setLayout(opt_layout, coordinates2, 2);
    if (!this.flatCoordinates) {
      this.flatCoordinates = [];
    }
    var ends = deflateCoordinatesArray(this.flatCoordinates, 0, coordinates2, this.stride, this.ends_);
    this.flatCoordinates.length = ends.length === 0 ? 0 : ends[ends.length - 1];
    this.changed();
  };
  return MultiLineString2;
}(SimpleGeometry$1);
var MultiLineString$2 = MultiLineString$1;
var __extends$1p = globalThis && globalThis.__extends || function() {
  var extendStatics2 = function(d2, b2) {
    extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {
      d3.__proto__ = b3;
    } || function(d3, b3) {
      for (var p5 in b3)
        if (Object.prototype.hasOwnProperty.call(b3, p5))
          d3[p5] = b3[p5];
    };
    return extendStatics2(d2, b2);
  };
  return function(d2, b2) {
    if (typeof b2 !== "function" && b2 !== null)
      throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
    extendStatics2(d2, b2);
    function __() {
      this.constructor = d2;
    }
    d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
  };
}();
var MultiPoint$1 = function(_super) {
  __extends$1p(MultiPoint2, _super);
  function MultiPoint2(coordinates2, opt_layout) {
    var _this = _super.call(this) || this;
    if (opt_layout && !Array.isArray(coordinates2[0])) {
      _this.setFlatCoordinates(opt_layout, coordinates2);
    } else {
      _this.setCoordinates(coordinates2, opt_layout);
    }
    return _this;
  }
  MultiPoint2.prototype.appendPoint = function(point) {
    if (!this.flatCoordinates) {
      this.flatCoordinates = point.getFlatCoordinates().slice();
    } else {
      extend$3(this.flatCoordinates, point.getFlatCoordinates());
    }
    this.changed();
  };
  MultiPoint2.prototype.clone = function() {
    var multiPoint = new MultiPoint2(this.flatCoordinates.slice(), this.layout);
    multiPoint.applyProperties(this);
    return multiPoint;
  };
  MultiPoint2.prototype.closestPointXY = function(x2, y2, closestPoint, minSquaredDistance) {
    if (minSquaredDistance < closestSquaredDistanceXY(this.getExtent(), x2, y2)) {
      return minSquaredDistance;
    }
    var flatCoordinates = this.flatCoordinates;
    var stride = this.stride;
    for (var i2 = 0, ii = flatCoordinates.length; i2 < ii; i2 += stride) {
      var squaredDistance2 = squaredDistance$1(x2, y2, flatCoordinates[i2], flatCoordinates[i2 + 1]);
      if (squaredDistance2 < minSquaredDistance) {
        minSquaredDistance = squaredDistance2;
        for (var j2 = 0; j2 < stride; ++j2) {
          closestPoint[j2] = flatCoordinates[i2 + j2];
        }
        closestPoint.length = stride;
      }
    }
    return minSquaredDistance;
  };
  MultiPoint2.prototype.getCoordinates = function() {
    return inflateCoordinates(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride);
  };
  MultiPoint2.prototype.getPoint = function(index2) {
    var n2 = !this.flatCoordinates ? 0 : this.flatCoordinates.length / this.stride;
    if (index2 < 0 || n2 <= index2) {
      return null;
    }
    return new Point$4(this.flatCoordinates.slice(index2 * this.stride, (index2 + 1) * this.stride), this.layout);
  };
  MultiPoint2.prototype.getPoints = function() {
    var flatCoordinates = this.flatCoordinates;
    var layout = this.layout;
    var stride = this.stride;
    var points = [];
    for (var i2 = 0, ii = flatCoordinates.length; i2 < ii; i2 += stride) {
      var point = new Point$4(flatCoordinates.slice(i2, i2 + stride), layout);
      points.push(point);
    }
    return points;
  };
  MultiPoint2.prototype.getType = function() {
    return GeometryType.MULTI_POINT;
  };
  MultiPoint2.prototype.intersectsExtent = function(extent2) {
    var flatCoordinates = this.flatCoordinates;
    var stride = this.stride;
    for (var i2 = 0, ii = flatCoordinates.length; i2 < ii; i2 += stride) {
      var x2 = flatCoordinates[i2];
      var y2 = flatCoordinates[i2 + 1];
      if (containsXY(extent2, x2, y2)) {
        return true;
      }
    }
    return false;
  };
  MultiPoint2.prototype.setCoordinates = function(coordinates2, opt_layout) {
    this.setLayout(opt_layout, coordinates2, 1);
    if (!this.flatCoordinates) {
      this.flatCoordinates = [];
    }
    this.flatCoordinates.length = deflateCoordinates(this.flatCoordinates, 0, coordinates2, this.stride);
    this.changed();
  };
  return MultiPoint2;
}(SimpleGeometry$1);
var MultiPoint$2 = MultiPoint$1;
function linearRingss(flatCoordinates, offset2, endss, stride) {
  var flatCenters = [];
  var extent2 = createEmpty();
  for (var i2 = 0, ii = endss.length; i2 < ii; ++i2) {
    var ends = endss[i2];
    extent2 = createOrUpdateFromFlatCoordinates(flatCoordinates, offset2, ends[0], stride);
    flatCenters.push((extent2[0] + extent2[2]) / 2, (extent2[1] + extent2[3]) / 2);
    offset2 = ends[ends.length - 1];
  }
  return flatCenters;
}
var __extends$1o = globalThis && globalThis.__extends || function() {
  var extendStatics2 = function(d2, b2) {
    extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {
      d3.__proto__ = b3;
    } || function(d3, b3) {
      for (var p5 in b3)
        if (Object.prototype.hasOwnProperty.call(b3, p5))
          d3[p5] = b3[p5];
    };
    return extendStatics2(d2, b2);
  };
  return function(d2, b2) {
    if (typeof b2 !== "function" && b2 !== null)
      throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
    extendStatics2(d2, b2);
    function __() {
      this.constructor = d2;
    }
    d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
  };
}();
var MultiPolygon$1 = function(_super) {
  __extends$1o(MultiPolygon2, _super);
  function MultiPolygon2(coordinates2, opt_layout, opt_endss) {
    var _this = _super.call(this) || this;
    _this.endss_ = [];
    _this.flatInteriorPointsRevision_ = -1;
    _this.flatInteriorPoints_ = null;
    _this.maxDelta_ = -1;
    _this.maxDeltaRevision_ = -1;
    _this.orientedRevision_ = -1;
    _this.orientedFlatCoordinates_ = null;
    if (!opt_endss && !Array.isArray(coordinates2[0])) {
      var layout = _this.getLayout();
      var polygons = coordinates2;
      var flatCoordinates = [];
      var endss = [];
      for (var i2 = 0, ii = polygons.length; i2 < ii; ++i2) {
        var polygon = polygons[i2];
        if (i2 === 0) {
          layout = polygon.getLayout();
        }
        var offset2 = flatCoordinates.length;
        var ends = polygon.getEnds();
        for (var j2 = 0, jj = ends.length; j2 < jj; ++j2) {
          ends[j2] += offset2;
        }
        extend$3(flatCoordinates, polygon.getFlatCoordinates());
        endss.push(ends);
      }
      opt_layout = layout;
      coordinates2 = flatCoordinates;
      opt_endss = endss;
    }
    if (opt_layout !== void 0 && opt_endss) {
      _this.setFlatCoordinates(opt_layout, coordinates2);
      _this.endss_ = opt_endss;
    } else {
      _this.setCoordinates(coordinates2, opt_layout);
    }
    return _this;
  }
  MultiPolygon2.prototype.appendPolygon = function(polygon) {
    var ends;
    if (!this.flatCoordinates) {
      this.flatCoordinates = polygon.getFlatCoordinates().slice();
      ends = polygon.getEnds().slice();
      this.endss_.push();
    } else {
      var offset2 = this.flatCoordinates.length;
      extend$3(this.flatCoordinates, polygon.getFlatCoordinates());
      ends = polygon.getEnds().slice();
      for (var i2 = 0, ii = ends.length; i2 < ii; ++i2) {
        ends[i2] += offset2;
      }
    }
    this.endss_.push(ends);
    this.changed();
  };
  MultiPolygon2.prototype.clone = function() {
    var len = this.endss_.length;
    var newEndss = new Array(len);
    for (var i2 = 0; i2 < len; ++i2) {
      newEndss[i2] = this.endss_[i2].slice();
    }
    var multiPolygon = new MultiPolygon2(this.flatCoordinates.slice(), this.layout, newEndss);
    multiPolygon.applyProperties(this);
    return multiPolygon;
  };
  MultiPolygon2.prototype.closestPointXY = function(x2, y2, closestPoint, minSquaredDistance) {
    if (minSquaredDistance < closestSquaredDistanceXY(this.getExtent(), x2, y2)) {
      return minSquaredDistance;
    }
    if (this.maxDeltaRevision_ != this.getRevision()) {
      this.maxDelta_ = Math.sqrt(multiArrayMaxSquaredDelta(this.flatCoordinates, 0, this.endss_, this.stride, 0));
      this.maxDeltaRevision_ = this.getRevision();
    }
    return assignClosestMultiArrayPoint(this.getOrientedFlatCoordinates(), 0, this.endss_, this.stride, this.maxDelta_, true, x2, y2, closestPoint, minSquaredDistance);
  };
  MultiPolygon2.prototype.containsXY = function(x2, y2) {
    return linearRingssContainsXY(this.getOrientedFlatCoordinates(), 0, this.endss_, this.stride, x2, y2);
  };
  MultiPolygon2.prototype.getArea = function() {
    return linearRingss$1(this.getOrientedFlatCoordinates(), 0, this.endss_, this.stride);
  };
  MultiPolygon2.prototype.getCoordinates = function(opt_right) {
    var flatCoordinates;
    if (opt_right !== void 0) {
      flatCoordinates = this.getOrientedFlatCoordinates().slice();
      orientLinearRingsArray(flatCoordinates, 0, this.endss_, this.stride, opt_right);
    } else {
      flatCoordinates = this.flatCoordinates;
    }
    return inflateMultiCoordinatesArray(flatCoordinates, 0, this.endss_, this.stride);
  };
  MultiPolygon2.prototype.getEndss = function() {
    return this.endss_;
  };
  MultiPolygon2.prototype.getFlatInteriorPoints = function() {
    if (this.flatInteriorPointsRevision_ != this.getRevision()) {
      var flatCenters = linearRingss(this.flatCoordinates, 0, this.endss_, this.stride);
      this.flatInteriorPoints_ = getInteriorPointsOfMultiArray(this.getOrientedFlatCoordinates(), 0, this.endss_, this.stride, flatCenters);
      this.flatInteriorPointsRevision_ = this.getRevision();
    }
    return this.flatInteriorPoints_;
  };
  MultiPolygon2.prototype.getInteriorPoints = function() {
    return new MultiPoint$2(this.getFlatInteriorPoints().slice(), GeometryLayout.XYM);
  };
  MultiPolygon2.prototype.getOrientedFlatCoordinates = function() {
    if (this.orientedRevision_ != this.getRevision()) {
      var flatCoordinates = this.flatCoordinates;
      if (linearRingssAreOriented(flatCoordinates, 0, this.endss_, this.stride)) {
        this.orientedFlatCoordinates_ = flatCoordinates;
      } else {
        this.orientedFlatCoordinates_ = flatCoordinates.slice();
        this.orientedFlatCoordinates_.length = orientLinearRingsArray(this.orientedFlatCoordinates_, 0, this.endss_, this.stride);
      }
      this.orientedRevision_ = this.getRevision();
    }
    return this.orientedFlatCoordinates_;
  };
  MultiPolygon2.prototype.getSimplifiedGeometryInternal = function(squaredTolerance) {
    var simplifiedFlatCoordinates = [];
    var simplifiedEndss = [];
    simplifiedFlatCoordinates.length = quantizeMultiArray(this.flatCoordinates, 0, this.endss_, this.stride, Math.sqrt(squaredTolerance), simplifiedFlatCoordinates, 0, simplifiedEndss);
    return new MultiPolygon2(simplifiedFlatCoordinates, GeometryLayout.XY, simplifiedEndss);
  };
  MultiPolygon2.prototype.getPolygon = function(index2) {
    if (index2 < 0 || this.endss_.length <= index2) {
      return null;
    }
    var offset2;
    if (index2 === 0) {
      offset2 = 0;
    } else {
      var prevEnds = this.endss_[index2 - 1];
      offset2 = prevEnds[prevEnds.length - 1];
    }
    var ends = this.endss_[index2].slice();
    var end = ends[ends.length - 1];
    if (offset2 !== 0) {
      for (var i2 = 0, ii = ends.length; i2 < ii; ++i2) {
        ends[i2] -= offset2;
      }
    }
    return new Polygon$2(this.flatCoordinates.slice(offset2, end), this.layout, ends);
  };
  MultiPolygon2.prototype.getPolygons = function() {
    var layout = this.layout;
    var flatCoordinates = this.flatCoordinates;
    var endss = this.endss_;
    var polygons = [];
    var offset2 = 0;
    for (var i2 = 0, ii = endss.length; i2 < ii; ++i2) {
      var ends = endss[i2].slice();
      var end = ends[ends.length - 1];
      if (offset2 !== 0) {
        for (var j2 = 0, jj = ends.length; j2 < jj; ++j2) {
          ends[j2] -= offset2;
        }
      }
      var polygon = new Polygon$2(flatCoordinates.slice(offset2, end), layout, ends);
      polygons.push(polygon);
      offset2 = end;
    }
    return polygons;
  };
  MultiPolygon2.prototype.getType = function() {
    return GeometryType.MULTI_POLYGON;
  };
  MultiPolygon2.prototype.intersectsExtent = function(extent2) {
    return intersectsLinearRingMultiArray(this.getOrientedFlatCoordinates(), 0, this.endss_, this.stride, extent2);
  };
  MultiPolygon2.prototype.setCoordinates = function(coordinates2, opt_layout) {
    this.setLayout(opt_layout, coordinates2, 3);
    if (!this.flatCoordinates) {
      this.flatCoordinates = [];
    }
    var endss = deflateMultiCoordinatesArray(this.flatCoordinates, 0, coordinates2, this.stride, this.endss_);
    if (endss.length === 0) {
      this.flatCoordinates.length = 0;
    } else {
      var lastEnds = endss[endss.length - 1];
      this.flatCoordinates.length = lastEnds.length === 0 ? 0 : lastEnds[lastEnds.length - 1];
    }
    this.changed();
  };
  return MultiPolygon2;
}(SimpleGeometry$1);
var MultiPolygon$2 = MultiPolygon$1;
function quickselect(arr, k2, left, right, compare) {
  quickselectStep(arr, k2, left || 0, right || arr.length - 1, compare || defaultCompare);
}
function quickselectStep(arr, k2, left, right, compare) {
  while (right > left) {
    if (right - left > 600) {
      var n2 = right - left + 1;
      var m2 = k2 - left + 1;
      var z2 = Math.log(n2);
      var s2 = 0.5 * Math.exp(2 * z2 / 3);
      var sd = 0.5 * Math.sqrt(z2 * s2 * (n2 - s2) / n2) * (m2 - n2 / 2 < 0 ? -1 : 1);
      var newLeft = Math.max(left, Math.floor(k2 - m2 * s2 / n2 + sd));
      var newRight = Math.min(right, Math.floor(k2 + (n2 - m2) * s2 / n2 + sd));
      quickselectStep(arr, k2, newLeft, newRight, compare);
    }
    var t3 = arr[k2];
    var i2 = left;
    var j2 = right;
    swap(arr, left, k2);
    if (compare(arr[right], t3) > 0)
      swap(arr, left, right);
    while (i2 < j2) {
      swap(arr, i2, j2);
      i2++;
      j2--;
      while (compare(arr[i2], t3) < 0)
        i2++;
      while (compare(arr[j2], t3) > 0)
        j2--;
    }
    if (compare(arr[left], t3) === 0)
      swap(arr, left, j2);
    else {
      j2++;
      swap(arr, j2, right);
    }
    if (j2 <= k2)
      left = j2 + 1;
    if (k2 <= j2)
      right = j2 - 1;
  }
}
function swap(arr, i2, j2) {
  var tmp = arr[i2];
  arr[i2] = arr[j2];
  arr[j2] = tmp;
}
function defaultCompare(a2, b2) {
  return a2 < b2 ? -1 : a2 > b2 ? 1 : 0;
}
var RBush$2 = class {
  constructor(maxEntries = 9) {
    this._maxEntries = Math.max(4, maxEntries);
    this._minEntries = Math.max(2, Math.ceil(this._maxEntries * 0.4));
    this.clear();
  }
  all() {
    return this._all(this.data, []);
  }
  search(bbox2) {
    let node2 = this.data;
    const result = [];
    if (!intersects(bbox2, node2))
      return result;
    const toBBox = this.toBBox;
    const nodesToSearch = [];
    while (node2) {
      for (let i2 = 0; i2 < node2.children.length; i2++) {
        const child = node2.children[i2];
        const childBBox = node2.leaf ? toBBox(child) : child;
        if (intersects(bbox2, childBBox)) {
          if (node2.leaf)
            result.push(child);
          else if (contains$1(bbox2, childBBox))
            this._all(child, result);
          else
            nodesToSearch.push(child);
        }
      }
      node2 = nodesToSearch.pop();
    }
    return result;
  }
  collides(bbox2) {
    let node2 = this.data;
    if (!intersects(bbox2, node2))
      return false;
    const nodesToSearch = [];
    while (node2) {
      for (let i2 = 0; i2 < node2.children.length; i2++) {
        const child = node2.children[i2];
        const childBBox = node2.leaf ? this.toBBox(child) : child;
        if (intersects(bbox2, childBBox)) {
          if (node2.leaf || contains$1(bbox2, childBBox))
            return true;
          nodesToSearch.push(child);
        }
      }
      node2 = nodesToSearch.pop();
    }
    return false;
  }
  load(data2) {
    if (!(data2 && data2.length))
      return this;
    if (data2.length < this._minEntries) {
      for (let i2 = 0; i2 < data2.length; i2++) {
        this.insert(data2[i2]);
      }
      return this;
    }
    let node2 = this._build(data2.slice(), 0, data2.length - 1, 0);
    if (!this.data.children.length) {
      this.data = node2;
    } else if (this.data.height === node2.height) {
      this._splitRoot(this.data, node2);
    } else {
      if (this.data.height < node2.height) {
        const tmpNode = this.data;
        this.data = node2;
        node2 = tmpNode;
      }
      this._insert(node2, this.data.height - node2.height - 1, true);
    }
    return this;
  }
  insert(item) {
    if (item)
      this._insert(item, this.data.height - 1);
    return this;
  }
  clear() {
    this.data = createNode([]);
    return this;
  }
  remove(item, equalsFn) {
    if (!item)
      return this;
    let node2 = this.data;
    const bbox2 = this.toBBox(item);
    const path = [];
    const indexes = [];
    let i2, parent, goingUp;
    while (node2 || path.length) {
      if (!node2) {
        node2 = path.pop();
        parent = path[path.length - 1];
        i2 = indexes.pop();
        goingUp = true;
      }
      if (node2.leaf) {
        const index2 = findItem(item, node2.children, equalsFn);
        if (index2 !== -1) {
          node2.children.splice(index2, 1);
          path.push(node2);
          this._condense(path);
          return this;
        }
      }
      if (!goingUp && !node2.leaf && contains$1(node2, bbox2)) {
        path.push(node2);
        indexes.push(i2);
        i2 = 0;
        parent = node2;
        node2 = node2.children[0];
      } else if (parent) {
        i2++;
        node2 = parent.children[i2];
        goingUp = false;
      } else
        node2 = null;
    }
    return this;
  }
  toBBox(item) {
    return item;
  }
  compareMinX(a2, b2) {
    return a2.minX - b2.minX;
  }
  compareMinY(a2, b2) {
    return a2.minY - b2.minY;
  }
  toJSON() {
    return this.data;
  }
  fromJSON(data2) {
    this.data = data2;
    return this;
  }
  _all(node2, result) {
    const nodesToSearch = [];
    while (node2) {
      if (node2.leaf)
        result.push(...node2.children);
      else
        nodesToSearch.push(...node2.children);
      node2 = nodesToSearch.pop();
    }
    return result;
  }
  _build(items, left, right, height) {
    const N2 = right - left + 1;
    let M2 = this._maxEntries;
    let node2;
    if (N2 <= M2) {
      node2 = createNode(items.slice(left, right + 1));
      calcBBox(node2, this.toBBox);
      return node2;
    }
    if (!height) {
      height = Math.ceil(Math.log(N2) / Math.log(M2));
      M2 = Math.ceil(N2 / Math.pow(M2, height - 1));
    }
    node2 = createNode([]);
    node2.leaf = false;
    node2.height = height;
    const N22 = Math.ceil(N2 / M2);
    const N1 = N22 * Math.ceil(Math.sqrt(M2));
    multiSelect(items, left, right, N1, this.compareMinX);
    for (let i2 = left; i2 <= right; i2 += N1) {
      const right2 = Math.min(i2 + N1 - 1, right);
      multiSelect(items, i2, right2, N22, this.compareMinY);
      for (let j2 = i2; j2 <= right2; j2 += N22) {
        const right3 = Math.min(j2 + N22 - 1, right2);
        node2.children.push(this._build(items, j2, right3, height - 1));
      }
    }
    calcBBox(node2, this.toBBox);
    return node2;
  }
  _chooseSubtree(bbox2, node2, level, path) {
    while (true) {
      path.push(node2);
      if (node2.leaf || path.length - 1 === level)
        break;
      let minArea = Infinity;
      let minEnlargement = Infinity;
      let targetNode;
      for (let i2 = 0; i2 < node2.children.length; i2++) {
        const child = node2.children[i2];
        const area = bboxArea(child);
        const enlargement = enlargedArea(bbox2, child) - area;
        if (enlargement < minEnlargement) {
          minEnlargement = enlargement;
          minArea = area < minArea ? area : minArea;
          targetNode = child;
        } else if (enlargement === minEnlargement) {
          if (area < minArea) {
            minArea = area;
            targetNode = child;
          }
        }
      }
      node2 = targetNode || node2.children[0];
    }
    return node2;
  }
  _insert(item, level, isNode) {
    const bbox2 = isNode ? item : this.toBBox(item);
    const insertPath = [];
    const node2 = this._chooseSubtree(bbox2, this.data, level, insertPath);
    node2.children.push(item);
    extend$1(node2, bbox2);
    while (level >= 0) {
      if (insertPath[level].children.length > this._maxEntries) {
        this._split(insertPath, level);
        level--;
      } else
        break;
    }
    this._adjustParentBBoxes(bbox2, insertPath, level);
  }
  _split(insertPath, level) {
    const node2 = insertPath[level];
    const M2 = node2.children.length;
    const m2 = this._minEntries;
    this._chooseSplitAxis(node2, m2, M2);
    const splitIndex = this._chooseSplitIndex(node2, m2, M2);
    const newNode = createNode(node2.children.splice(splitIndex, node2.children.length - splitIndex));
    newNode.height = node2.height;
    newNode.leaf = node2.leaf;
    calcBBox(node2, this.toBBox);
    calcBBox(newNode, this.toBBox);
    if (level)
      insertPath[level - 1].children.push(newNode);
    else
      this._splitRoot(node2, newNode);
  }
  _splitRoot(node2, newNode) {
    this.data = createNode([node2, newNode]);
    this.data.height = node2.height + 1;
    this.data.leaf = false;
    calcBBox(this.data, this.toBBox);
  }
  _chooseSplitIndex(node2, m2, M2) {
    let index2;
    let minOverlap = Infinity;
    let minArea = Infinity;
    for (let i2 = m2; i2 <= M2 - m2; i2++) {
      const bbox1 = distBBox(node2, 0, i2, this.toBBox);
      const bbox2 = distBBox(node2, i2, M2, this.toBBox);
      const overlap = intersectionArea(bbox1, bbox2);
      const area = bboxArea(bbox1) + bboxArea(bbox2);
      if (overlap < minOverlap) {
        minOverlap = overlap;
        index2 = i2;
        minArea = area < minArea ? area : minArea;
      } else if (overlap === minOverlap) {
        if (area < minArea) {
          minArea = area;
          index2 = i2;
        }
      }
    }
    return index2 || M2 - m2;
  }
  _chooseSplitAxis(node2, m2, M2) {
    const compareMinX = node2.leaf ? this.compareMinX : compareNodeMinX;
    const compareMinY = node2.leaf ? this.compareMinY : compareNodeMinY;
    const xMargin = this._allDistMargin(node2, m2, M2, compareMinX);
    const yMargin = this._allDistMargin(node2, m2, M2, compareMinY);
    if (xMargin < yMargin)
      node2.children.sort(compareMinX);
  }
  _allDistMargin(node2, m2, M2, compare) {
    node2.children.sort(compare);
    const toBBox = this.toBBox;
    const leftBBox = distBBox(node2, 0, m2, toBBox);
    const rightBBox = distBBox(node2, M2 - m2, M2, toBBox);
    let margin = bboxMargin(leftBBox) + bboxMargin(rightBBox);
    for (let i2 = m2; i2 < M2 - m2; i2++) {
      const child = node2.children[i2];
      extend$1(leftBBox, node2.leaf ? toBBox(child) : child);
      margin += bboxMargin(leftBBox);
    }
    for (let i2 = M2 - m2 - 1; i2 >= m2; i2--) {
      const child = node2.children[i2];
      extend$1(rightBBox, node2.leaf ? toBBox(child) : child);
      margin += bboxMargin(rightBBox);
    }
    return margin;
  }
  _adjustParentBBoxes(bbox2, path, level) {
    for (let i2 = level; i2 >= 0; i2--) {
      extend$1(path[i2], bbox2);
    }
  }
  _condense(path) {
    for (let i2 = path.length - 1, siblings; i2 >= 0; i2--) {
      if (path[i2].children.length === 0) {
        if (i2 > 0) {
          siblings = path[i2 - 1].children;
          siblings.splice(siblings.indexOf(path[i2]), 1);
        } else
          this.clear();
      } else
        calcBBox(path[i2], this.toBBox);
    }
  }
};
function findItem(item, items, equalsFn) {
  if (!equalsFn)
    return items.indexOf(item);
  for (let i2 = 0; i2 < items.length; i2++) {
    if (equalsFn(item, items[i2]))
      return i2;
  }
  return -1;
}
function calcBBox(node2, toBBox) {
  distBBox(node2, 0, node2.children.length, toBBox, node2);
}
function distBBox(node2, k2, p5, toBBox, destNode) {
  if (!destNode)
    destNode = createNode(null);
  destNode.minX = Infinity;
  destNode.minY = Infinity;
  destNode.maxX = -Infinity;
  destNode.maxY = -Infinity;
  for (let i2 = k2; i2 < p5; i2++) {
    const child = node2.children[i2];
    extend$1(destNode, node2.leaf ? toBBox(child) : child);
  }
  return destNode;
}
function extend$1(a2, b2) {
  a2.minX = Math.min(a2.minX, b2.minX);
  a2.minY = Math.min(a2.minY, b2.minY);
  a2.maxX = Math.max(a2.maxX, b2.maxX);
  a2.maxY = Math.max(a2.maxY, b2.maxY);
  return a2;
}
function compareNodeMinX(a2, b2) {
  return a2.minX - b2.minX;
}
function compareNodeMinY(a2, b2) {
  return a2.minY - b2.minY;
}
function bboxArea(a2) {
  return (a2.maxX - a2.minX) * (a2.maxY - a2.minY);
}
function bboxMargin(a2) {
  return a2.maxX - a2.minX + (a2.maxY - a2.minY);
}
function enlargedArea(a2, b2) {
  return (Math.max(b2.maxX, a2.maxX) - Math.min(b2.minX, a2.minX)) * (Math.max(b2.maxY, a2.maxY) - Math.min(b2.minY, a2.minY));
}
function intersectionArea(a2, b2) {
  const minX = Math.max(a2.minX, b2.minX);
  const minY = Math.max(a2.minY, b2.minY);
  const maxX = Math.min(a2.maxX, b2.maxX);
  const maxY = Math.min(a2.maxY, b2.maxY);
  return Math.max(0, maxX - minX) * Math.max(0, maxY - minY);
}
function contains$1(a2, b2) {
  return a2.minX <= b2.minX && a2.minY <= b2.minY && b2.maxX <= a2.maxX && b2.maxY <= a2.maxY;
}
function intersects(a2, b2) {
  return b2.minX <= a2.maxX && b2.minY <= a2.maxY && b2.maxX >= a2.minX && b2.maxY >= a2.minY;
}
function createNode(children) {
  return {
    children,
    height: 1,
    leaf: true,
    minX: Infinity,
    minY: Infinity,
    maxX: -Infinity,
    maxY: -Infinity
  };
}
function multiSelect(arr, left, right, n2, compare) {
  const stack = [left, right];
  while (stack.length) {
    right = stack.pop();
    left = stack.pop();
    if (right - left <= n2)
      continue;
    const mid = left + Math.ceil((right - left) / n2 / 2) * n2;
    quickselect(arr, mid, left, right, compare);
    stack.push(left, mid, mid, right);
  }
}
var ImageState = {
  IDLE: 0,
  LOADING: 1,
  LOADED: 2,
  ERROR: 3,
  EMPTY: 4
};
var ImageStyle = function() {
  function ImageStyle2(options) {
    this.opacity_ = options.opacity;
    this.rotateWithView_ = options.rotateWithView;
    this.rotation_ = options.rotation;
    this.scale_ = options.scale;
    this.scaleArray_ = toSize(options.scale);
    this.displacement_ = options.displacement;
  }
  ImageStyle2.prototype.clone = function() {
    var scale2 = this.getScale();
    return new ImageStyle2({
      opacity: this.getOpacity(),
      scale: Array.isArray(scale2) ? scale2.slice() : scale2,
      rotation: this.getRotation(),
      rotateWithView: this.getRotateWithView(),
      displacement: this.getDisplacement().slice()
    });
  };
  ImageStyle2.prototype.getOpacity = function() {
    return this.opacity_;
  };
  ImageStyle2.prototype.getRotateWithView = function() {
    return this.rotateWithView_;
  };
  ImageStyle2.prototype.getRotation = function() {
    return this.rotation_;
  };
  ImageStyle2.prototype.getScale = function() {
    return this.scale_;
  };
  ImageStyle2.prototype.getScaleArray = function() {
    return this.scaleArray_;
  };
  ImageStyle2.prototype.getDisplacement = function() {
    return this.displacement_;
  };
  ImageStyle2.prototype.getAnchor = function() {
    return abstract();
  };
  ImageStyle2.prototype.getImage = function(pixelRatio) {
    return abstract();
  };
  ImageStyle2.prototype.getHitDetectionImage = function() {
    return abstract();
  };
  ImageStyle2.prototype.getPixelRatio = function(pixelRatio) {
    return 1;
  };
  ImageStyle2.prototype.getImageState = function() {
    return abstract();
  };
  ImageStyle2.prototype.getImageSize = function() {
    return abstract();
  };
  ImageStyle2.prototype.getOrigin = function() {
    return abstract();
  };
  ImageStyle2.prototype.getSize = function() {
    return abstract();
  };
  ImageStyle2.prototype.setDisplacement = function(displacement) {
    this.displacement_ = displacement;
  };
  ImageStyle2.prototype.setOpacity = function(opacity2) {
    this.opacity_ = opacity2;
  };
  ImageStyle2.prototype.setRotateWithView = function(rotateWithView) {
    this.rotateWithView_ = rotateWithView;
  };
  ImageStyle2.prototype.setRotation = function(rotation) {
    this.rotation_ = rotation;
  };
  ImageStyle2.prototype.setScale = function(scale2) {
    this.scale_ = scale2;
    this.scaleArray_ = toSize(scale2);
  };
  ImageStyle2.prototype.listenImageChange = function(listener2) {
    abstract();
  };
  ImageStyle2.prototype.load = function() {
    abstract();
  };
  ImageStyle2.prototype.unlistenImageChange = function(listener2) {
    abstract();
  };
  return ImageStyle2;
}();
var ImageStyle$1 = ImageStyle;
function asColorLike(color2) {
  if (Array.isArray(color2)) {
    return toString$c(color2);
  } else {
    return color2;
  }
}
var __extends$1n = globalThis && globalThis.__extends || function() {
  var extendStatics2 = function(d2, b2) {
    extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {
      d3.__proto__ = b3;
    } || function(d3, b3) {
      for (var p5 in b3)
        if (Object.prototype.hasOwnProperty.call(b3, p5))
          d3[p5] = b3[p5];
    };
    return extendStatics2(d2, b2);
  };
  return function(d2, b2) {
    if (typeof b2 !== "function" && b2 !== null)
      throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
    extendStatics2(d2, b2);
    function __() {
      this.constructor = d2;
    }
    d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
  };
}();
var RegularShape = function(_super) {
  __extends$1n(RegularShape2, _super);
  function RegularShape2(options) {
    var _this = this;
    var rotateWithView = options.rotateWithView !== void 0 ? options.rotateWithView : false;
    _this = _super.call(this, {
      opacity: 1,
      rotateWithView,
      rotation: options.rotation !== void 0 ? options.rotation : 0,
      scale: options.scale !== void 0 ? options.scale : 1,
      displacement: options.displacement !== void 0 ? options.displacement : [0, 0]
    }) || this;
    _this.canvas_ = void 0;
    _this.hitDetectionCanvas_ = null;
    _this.fill_ = options.fill !== void 0 ? options.fill : null;
    _this.origin_ = [0, 0];
    _this.points_ = options.points;
    _this.radius_ = options.radius !== void 0 ? options.radius : options.radius1;
    _this.radius2_ = options.radius2;
    _this.angle_ = options.angle !== void 0 ? options.angle : 0;
    _this.stroke_ = options.stroke !== void 0 ? options.stroke : null;
    _this.size_ = null;
    _this.renderOptions_ = null;
    _this.render();
    return _this;
  }
  RegularShape2.prototype.clone = function() {
    var scale2 = this.getScale();
    var style2 = new RegularShape2({
      fill: this.getFill() ? this.getFill().clone() : void 0,
      points: this.getPoints(),
      radius: this.getRadius(),
      radius2: this.getRadius2(),
      angle: this.getAngle(),
      stroke: this.getStroke() ? this.getStroke().clone() : void 0,
      rotation: this.getRotation(),
      rotateWithView: this.getRotateWithView(),
      scale: Array.isArray(scale2) ? scale2.slice() : scale2,
      displacement: this.getDisplacement().slice()
    });
    style2.setOpacity(this.getOpacity());
    return style2;
  };
  RegularShape2.prototype.getAnchor = function() {
    var size = this.size_;
    if (!size) {
      return null;
    }
    var displacement = this.getDisplacement();
    return [size[0] / 2 - displacement[0], size[1] / 2 + displacement[1]];
  };
  RegularShape2.prototype.getAngle = function() {
    return this.angle_;
  };
  RegularShape2.prototype.getFill = function() {
    return this.fill_;
  };
  RegularShape2.prototype.getHitDetectionImage = function() {
    if (!this.hitDetectionCanvas_) {
      this.createHitDetectionCanvas_(this.renderOptions_);
    }
    return this.hitDetectionCanvas_;
  };
  RegularShape2.prototype.getImage = function(pixelRatio) {
    var image2 = this.canvas_[pixelRatio];
    if (!image2) {
      var renderOptions = this.renderOptions_;
      var context = createCanvasContext2D(renderOptions.size * pixelRatio, renderOptions.size * pixelRatio);
      this.draw_(renderOptions, context, pixelRatio);
      image2 = context.canvas;
      this.canvas_[pixelRatio] = image2;
    }
    return image2;
  };
  RegularShape2.prototype.getPixelRatio = function(pixelRatio) {
    return pixelRatio;
  };
  RegularShape2.prototype.getImageSize = function() {
    return this.size_;
  };
  RegularShape2.prototype.getImageState = function() {
    return ImageState.LOADED;
  };
  RegularShape2.prototype.getOrigin = function() {
    return this.origin_;
  };
  RegularShape2.prototype.getPoints = function() {
    return this.points_;
  };
  RegularShape2.prototype.getRadius = function() {
    return this.radius_;
  };
  RegularShape2.prototype.getRadius2 = function() {
    return this.radius2_;
  };
  RegularShape2.prototype.getSize = function() {
    return this.size_;
  };
  RegularShape2.prototype.getStroke = function() {
    return this.stroke_;
  };
  RegularShape2.prototype.listenImageChange = function(listener2) {
  };
  RegularShape2.prototype.load = function() {
  };
  RegularShape2.prototype.unlistenImageChange = function(listener2) {
  };
  RegularShape2.prototype.calculateLineJoinSize_ = function(lineJoin, strokeWidth, miterLimit) {
    if (strokeWidth === 0 || this.points_ === Infinity || lineJoin !== "bevel" && lineJoin !== "miter") {
      return strokeWidth;
    }
    var r1 = this.radius_;
    var r2 = this.radius2_ === void 0 ? r1 : this.radius2_;
    if (r1 < r2) {
      var tmp = r1;
      r1 = r2;
      r2 = tmp;
    }
    var points = this.radius2_ === void 0 ? this.points_ : this.points_ * 2;
    var alpha = 2 * Math.PI / points;
    var a2 = r2 * Math.sin(alpha);
    var b2 = Math.sqrt(r2 * r2 - a2 * a2);
    var d2 = r1 - b2;
    var e2 = Math.sqrt(a2 * a2 + d2 * d2);
    var miterRatio = e2 / a2;
    if (lineJoin === "miter" && miterRatio <= miterLimit) {
      return miterRatio * strokeWidth;
    }
    var k2 = strokeWidth / 2 / miterRatio;
    var l2 = strokeWidth / 2 * (d2 / e2);
    var maxr = Math.sqrt((r1 + k2) * (r1 + k2) + l2 * l2);
    var bevelAdd = maxr - r1;
    if (this.radius2_ === void 0 || lineJoin === "bevel") {
      return bevelAdd * 2;
    }
    var aa = r1 * Math.sin(alpha);
    var bb = Math.sqrt(r1 * r1 - aa * aa);
    var dd = r2 - bb;
    var ee2 = Math.sqrt(aa * aa + dd * dd);
    var innerMiterRatio = ee2 / aa;
    if (innerMiterRatio <= miterLimit) {
      var innerLength = innerMiterRatio * strokeWidth / 2 - r2 - r1;
      return 2 * Math.max(bevelAdd, innerLength);
    }
    return bevelAdd * 2;
  };
  RegularShape2.prototype.createRenderOptions = function() {
    var lineJoin = defaultLineJoin;
    var miterLimit = 0;
    var lineDash = null;
    var lineDashOffset = 0;
    var strokeStyle;
    var strokeWidth = 0;
    if (this.stroke_) {
      strokeStyle = this.stroke_.getColor();
      if (strokeStyle === null) {
        strokeStyle = defaultStrokeStyle;
      }
      strokeStyle = asColorLike(strokeStyle);
      strokeWidth = this.stroke_.getWidth();
      if (strokeWidth === void 0) {
        strokeWidth = defaultLineWidth;
      }
      lineDash = this.stroke_.getLineDash();
      lineDashOffset = this.stroke_.getLineDashOffset();
      lineJoin = this.stroke_.getLineJoin();
      if (lineJoin === void 0) {
        lineJoin = defaultLineJoin;
      }
      miterLimit = this.stroke_.getMiterLimit();
      if (miterLimit === void 0) {
        miterLimit = defaultMiterLimit;
      }
    }
    var add2 = this.calculateLineJoinSize_(lineJoin, strokeWidth, miterLimit);
    var maxRadius = Math.max(this.radius_, this.radius2_ || 0);
    var size = Math.ceil(2 * maxRadius + add2);
    return {
      strokeStyle,
      strokeWidth,
      size,
      lineDash,
      lineDashOffset,
      lineJoin,
      miterLimit
    };
  };
  RegularShape2.prototype.render = function() {
    this.renderOptions_ = this.createRenderOptions();
    var size = this.renderOptions_.size;
    this.canvas_ = {};
    this.size_ = [size, size];
  };
  RegularShape2.prototype.draw_ = function(renderOptions, context, pixelRatio) {
    context.scale(pixelRatio, pixelRatio);
    context.translate(renderOptions.size / 2, renderOptions.size / 2);
    this.createPath_(context);
    if (this.fill_) {
      var color2 = this.fill_.getColor();
      if (color2 === null) {
        color2 = defaultFillStyle;
      }
      context.fillStyle = asColorLike(color2);
      context.fill();
    }
    if (this.stroke_) {
      context.strokeStyle = renderOptions.strokeStyle;
      context.lineWidth = renderOptions.strokeWidth;
      if (context.setLineDash && renderOptions.lineDash) {
        context.setLineDash(renderOptions.lineDash);
        context.lineDashOffset = renderOptions.lineDashOffset;
      }
      context.lineJoin = renderOptions.lineJoin;
      context.miterLimit = renderOptions.miterLimit;
      context.stroke();
    }
  };
  RegularShape2.prototype.createHitDetectionCanvas_ = function(renderOptions) {
    if (this.fill_) {
      var color2 = this.fill_.getColor();
      var opacity2 = 0;
      if (typeof color2 === "string") {
        color2 = asArray(color2);
      }
      if (color2 === null) {
        opacity2 = 1;
      } else if (Array.isArray(color2)) {
        opacity2 = color2.length === 4 ? color2[3] : 1;
      }
      if (opacity2 === 0) {
        var context = createCanvasContext2D(renderOptions.size, renderOptions.size);
        this.hitDetectionCanvas_ = context.canvas;
        this.drawHitDetectionCanvas_(renderOptions, context);
      }
    }
    if (!this.hitDetectionCanvas_) {
      this.hitDetectionCanvas_ = this.getImage(1);
    }
  };
  RegularShape2.prototype.createPath_ = function(context) {
    var points = this.points_;
    var radius = this.radius_;
    if (points === Infinity) {
      context.arc(0, 0, radius, 0, 2 * Math.PI);
    } else {
      var radius2 = this.radius2_ === void 0 ? radius : this.radius2_;
      if (this.radius2_ !== void 0) {
        points *= 2;
      }
      var startAngle = this.angle_ - Math.PI / 2;
      var step = 2 * Math.PI / points;
      for (var i2 = 0; i2 < points; i2++) {
        var angle0 = startAngle + i2 * step;
        var radiusC = i2 % 2 === 0 ? radius : radius2;
        context.lineTo(radiusC * Math.cos(angle0), radiusC * Math.sin(angle0));
      }
      context.closePath();
    }
  };
  RegularShape2.prototype.drawHitDetectionCanvas_ = function(renderOptions, context) {
    context.translate(renderOptions.size / 2, renderOptions.size / 2);
    this.createPath_(context);
    context.fillStyle = defaultFillStyle;
    context.fill();
    if (this.stroke_) {
      context.strokeStyle = renderOptions.strokeStyle;
      context.lineWidth = renderOptions.strokeWidth;
      if (renderOptions.lineDash) {
        context.setLineDash(renderOptions.lineDash);
        context.lineDashOffset = renderOptions.lineDashOffset;
      }
      context.lineJoin = renderOptions.lineJoin;
      context.miterLimit = renderOptions.miterLimit;
      context.stroke();
    }
  };
  return RegularShape2;
}(ImageStyle$1);
var ol_style_RegularShape = RegularShape;
var __extends$1m = globalThis && globalThis.__extends || function() {
  var extendStatics2 = function(d2, b2) {
    extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {
      d3.__proto__ = b3;
    } || function(d3, b3) {
      for (var p5 in b3)
        if (Object.prototype.hasOwnProperty.call(b3, p5))
          d3[p5] = b3[p5];
    };
    return extendStatics2(d2, b2);
  };
  return function(d2, b2) {
    if (typeof b2 !== "function" && b2 !== null)
      throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
    extendStatics2(d2, b2);
    function __() {
      this.constructor = d2;
    }
    d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
  };
}();
var CircleStyle = function(_super) {
  __extends$1m(CircleStyle2, _super);
  function CircleStyle2(opt_options) {
    var options = opt_options ? opt_options : {};
    return _super.call(this, {
      points: Infinity,
      fill: options.fill,
      radius: options.radius,
      stroke: options.stroke,
      scale: options.scale !== void 0 ? options.scale : 1,
      rotation: options.rotation !== void 0 ? options.rotation : 0,
      rotateWithView: options.rotateWithView !== void 0 ? options.rotateWithView : false,
      displacement: options.displacement !== void 0 ? options.displacement : [0, 0]
    }) || this;
  }
  CircleStyle2.prototype.clone = function() {
    var scale2 = this.getScale();
    var style2 = new CircleStyle2({
      fill: this.getFill() ? this.getFill().clone() : void 0,
      stroke: this.getStroke() ? this.getStroke().clone() : void 0,
      radius: this.getRadius(),
      scale: Array.isArray(scale2) ? scale2.slice() : scale2,
      rotation: this.getRotation(),
      rotateWithView: this.getRotateWithView(),
      displacement: this.getDisplacement().slice()
    });
    style2.setOpacity(this.getOpacity());
    return style2;
  };
  CircleStyle2.prototype.setRadius = function(radius) {
    this.radius_ = radius;
    this.render();
  };
  return CircleStyle2;
}(ol_style_RegularShape);
var ol_style_Circle = CircleStyle;
var Fill$1 = function() {
  function Fill2(opt_options) {
    var options = opt_options || {};
    this.color_ = options.color !== void 0 ? options.color : null;
  }
  Fill2.prototype.clone = function() {
    var color2 = this.getColor();
    return new Fill2({
      color: Array.isArray(color2) ? color2.slice() : color2 || void 0
    });
  };
  Fill2.prototype.getColor = function() {
    return this.color_;
  };
  Fill2.prototype.setColor = function(color2) {
    this.color_ = color2;
  };
  return Fill2;
}();
var Fill$2 = Fill$1;
var Stroke$1 = function() {
  function Stroke2(opt_options) {
    var options = opt_options || {};
    this.color_ = options.color !== void 0 ? options.color : null;
    this.lineCap_ = options.lineCap;
    this.lineDash_ = options.lineDash !== void 0 ? options.lineDash : null;
    this.lineDashOffset_ = options.lineDashOffset;
    this.lineJoin_ = options.lineJoin;
    this.miterLimit_ = options.miterLimit;
    this.width_ = options.width;
  }
  Stroke2.prototype.clone = function() {
    var color2 = this.getColor();
    return new Stroke2({
      color: Array.isArray(color2) ? color2.slice() : color2 || void 0,
      lineCap: this.getLineCap(),
      lineDash: this.getLineDash() ? this.getLineDash().slice() : void 0,
      lineDashOffset: this.getLineDashOffset(),
      lineJoin: this.getLineJoin(),
      miterLimit: this.getMiterLimit(),
      width: this.getWidth()
    });
  };
  Stroke2.prototype.getColor = function() {
    return this.color_;
  };
  Stroke2.prototype.getLineCap = function() {
    return this.lineCap_;
  };
  Stroke2.prototype.getLineDash = function() {
    return this.lineDash_;
  };
  Stroke2.prototype.getLineDashOffset = function() {
    return this.lineDashOffset_;
  };
  Stroke2.prototype.getLineJoin = function() {
    return this.lineJoin_;
  };
  Stroke2.prototype.getMiterLimit = function() {
    return this.miterLimit_;
  };
  Stroke2.prototype.getWidth = function() {
    return this.width_;
  };
  Stroke2.prototype.setColor = function(color2) {
    this.color_ = color2;
  };
  Stroke2.prototype.setLineCap = function(lineCap) {
    this.lineCap_ = lineCap;
  };
  Stroke2.prototype.setLineDash = function(lineDash) {
    this.lineDash_ = lineDash;
  };
  Stroke2.prototype.setLineDashOffset = function(lineDashOffset) {
    this.lineDashOffset_ = lineDashOffset;
  };
  Stroke2.prototype.setLineJoin = function(lineJoin) {
    this.lineJoin_ = lineJoin;
  };
  Stroke2.prototype.setMiterLimit = function(miterLimit) {
    this.miterLimit_ = miterLimit;
  };
  Stroke2.prototype.setWidth = function(width) {
    this.width_ = width;
  };
  return Stroke2;
}();
var Stroke$2 = Stroke$1;
var Style$1 = function() {
  function Style2(opt_options) {
    var options = opt_options || {};
    this.geometry_ = null;
    this.geometryFunction_ = defaultGeometryFunction;
    if (options.geometry !== void 0) {
      this.setGeometry(options.geometry);
    }
    this.fill_ = options.fill !== void 0 ? options.fill : null;
    this.image_ = options.image !== void 0 ? options.image : null;
    this.renderer_ = options.renderer !== void 0 ? options.renderer : null;
    this.hitDetectionRenderer_ = options.hitDetectionRenderer !== void 0 ? options.hitDetectionRenderer : null;
    this.stroke_ = options.stroke !== void 0 ? options.stroke : null;
    this.text_ = options.text !== void 0 ? options.text : null;
    this.zIndex_ = options.zIndex;
  }
  Style2.prototype.clone = function() {
    var geometry = this.getGeometry();
    if (geometry && typeof geometry === "object") {
      geometry = geometry.clone();
    }
    return new Style2({
      geometry,
      fill: this.getFill() ? this.getFill().clone() : void 0,
      image: this.getImage() ? this.getImage().clone() : void 0,
      renderer: this.getRenderer(),
      stroke: this.getStroke() ? this.getStroke().clone() : void 0,
      text: this.getText() ? this.getText().clone() : void 0,
      zIndex: this.getZIndex()
    });
  };
  Style2.prototype.getRenderer = function() {
    return this.renderer_;
  };
  Style2.prototype.setRenderer = function(renderer) {
    this.renderer_ = renderer;
  };
  Style2.prototype.setHitDetectionRenderer = function(renderer) {
    this.hitDetectionRenderer_ = renderer;
  };
  Style2.prototype.getHitDetectionRenderer = function() {
    return this.hitDetectionRenderer_;
  };
  Style2.prototype.getGeometry = function() {
    return this.geometry_;
  };
  Style2.prototype.getGeometryFunction = function() {
    return this.geometryFunction_;
  };
  Style2.prototype.getFill = function() {
    return this.fill_;
  };
  Style2.prototype.setFill = function(fill) {
    this.fill_ = fill;
  };
  Style2.prototype.getImage = function() {
    return this.image_;
  };
  Style2.prototype.setImage = function(image2) {
    this.image_ = image2;
  };
  Style2.prototype.getStroke = function() {
    return this.stroke_;
  };
  Style2.prototype.setStroke = function(stroke) {
    this.stroke_ = stroke;
  };
  Style2.prototype.getText = function() {
    return this.text_;
  };
  Style2.prototype.setText = function(text2) {
    this.text_ = text2;
  };
  Style2.prototype.getZIndex = function() {
    return this.zIndex_;
  };
  Style2.prototype.setGeometry = function(geometry) {
    if (typeof geometry === "function") {
      this.geometryFunction_ = geometry;
    } else if (typeof geometry === "string") {
      this.geometryFunction_ = function(feature2) {
        return feature2.get(geometry);
      };
    } else if (!geometry) {
      this.geometryFunction_ = defaultGeometryFunction;
    } else if (geometry !== void 0) {
      this.geometryFunction_ = function() {
        return geometry;
      };
    }
    this.geometry_ = geometry;
  };
  Style2.prototype.setZIndex = function(zIndex2) {
    this.zIndex_ = zIndex2;
  };
  return Style2;
}();
function toFunction(obj) {
  var styleFunction;
  if (typeof obj === "function") {
    styleFunction = obj;
  } else {
    var styles_1;
    if (Array.isArray(obj)) {
      styles_1 = obj;
    } else {
      assert(typeof obj.getZIndex === "function", 41);
      var style2 = obj;
      styles_1 = [style2];
    }
    styleFunction = function() {
      return styles_1;
    };
  }
  return styleFunction;
}
var defaultStyles = null;
function createDefaultStyle(feature2, resolution) {
  if (!defaultStyles) {
    var fill = new Fill$2({
      color: "rgba(255,255,255,0.4)"
    });
    var stroke = new Stroke$2({
      color: "#3399CC",
      width: 1.25
    });
    defaultStyles = [
      new Style$1({
        image: new ol_style_Circle({
          fill,
          stroke,
          radius: 5
        }),
        fill,
        stroke
      })
    ];
  }
  return defaultStyles;
}
function createEditingStyle() {
  var styles = {};
  var white = [255, 255, 255, 1];
  var blue = [0, 153, 255, 1];
  var width = 3;
  styles[GeometryType.POLYGON] = [
    new Style$1({
      fill: new Fill$2({
        color: [255, 255, 255, 0.5]
      })
    })
  ];
  styles[GeometryType.MULTI_POLYGON] = styles[GeometryType.POLYGON];
  styles[GeometryType.LINE_STRING] = [
    new Style$1({
      stroke: new Stroke$2({
        color: white,
        width: width + 2
      })
    }),
    new Style$1({
      stroke: new Stroke$2({
        color: blue,
        width
      })
    })
  ];
  styles[GeometryType.MULTI_LINE_STRING] = styles[GeometryType.LINE_STRING];
  styles[GeometryType.CIRCLE] = styles[GeometryType.POLYGON].concat(styles[GeometryType.LINE_STRING]);
  styles[GeometryType.POINT] = [
    new Style$1({
      image: new ol_style_Circle({
        radius: width * 2,
        fill: new Fill$2({
          color: blue
        }),
        stroke: new Stroke$2({
          color: white,
          width: width / 2
        })
      }),
      zIndex: Infinity
    })
  ];
  styles[GeometryType.MULTI_POINT] = styles[GeometryType.POINT];
  styles[GeometryType.GEOMETRY_COLLECTION] = styles[GeometryType.POLYGON].concat(styles[GeometryType.LINE_STRING], styles[GeometryType.POINT]);
  return styles;
}
function defaultGeometryFunction(feature2) {
  return feature2.getGeometry();
}
var Style$2 = Style$1;
var __extends$1l = globalThis && globalThis.__extends || function() {
  var extendStatics2 = function(d2, b2) {
    extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {
      d3.__proto__ = b3;
    } || function(d3, b3) {
      for (var p5 in b3)
        if (Object.prototype.hasOwnProperty.call(b3, p5))
          d3[p5] = b3[p5];
    };
    return extendStatics2(d2, b2);
  };
  return function(d2, b2) {
    if (typeof b2 !== "function" && b2 !== null)
      throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
    extendStatics2(d2, b2);
    function __() {
      this.constructor = d2;
    }
    d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
  };
}();
var Property$3 = {
  RENDER_ORDER: "renderOrder"
};
var BaseVectorLayer = function(_super) {
  __extends$1l(BaseVectorLayer2, _super);
  function BaseVectorLayer2(opt_options) {
    var _this = this;
    var options = opt_options ? opt_options : {};
    var baseOptions = assign({}, options);
    delete baseOptions.style;
    delete baseOptions.renderBuffer;
    delete baseOptions.updateWhileAnimating;
    delete baseOptions.updateWhileInteracting;
    _this = _super.call(this, baseOptions) || this;
    _this.declutter_ = options.declutter !== void 0 ? options.declutter : false;
    _this.renderBuffer_ = options.renderBuffer !== void 0 ? options.renderBuffer : 100;
    _this.style_ = null;
    _this.styleFunction_ = void 0;
    _this.setStyle(options.style);
    _this.updateWhileAnimating_ = options.updateWhileAnimating !== void 0 ? options.updateWhileAnimating : false;
    _this.updateWhileInteracting_ = options.updateWhileInteracting !== void 0 ? options.updateWhileInteracting : false;
    return _this;
  }
  BaseVectorLayer2.prototype.getDeclutter = function() {
    return this.declutter_;
  };
  BaseVectorLayer2.prototype.getFeatures = function(pixel) {
    return _super.prototype.getFeatures.call(this, pixel);
  };
  BaseVectorLayer2.prototype.getRenderBuffer = function() {
    return this.renderBuffer_;
  };
  BaseVectorLayer2.prototype.getRenderOrder = function() {
    return this.get(Property$3.RENDER_ORDER);
  };
  BaseVectorLayer2.prototype.getStyle = function() {
    return this.style_;
  };
  BaseVectorLayer2.prototype.getStyleFunction = function() {
    return this.styleFunction_;
  };
  BaseVectorLayer2.prototype.getUpdateWhileAnimating = function() {
    return this.updateWhileAnimating_;
  };
  BaseVectorLayer2.prototype.getUpdateWhileInteracting = function() {
    return this.updateWhileInteracting_;
  };
  BaseVectorLayer2.prototype.renderDeclutter = function(frameState) {
    if (!frameState.declutterTree) {
      frameState.declutterTree = new RBush$2(9);
    }
    this.getRenderer().renderDeclutter(frameState);
  };
  BaseVectorLayer2.prototype.setRenderOrder = function(renderOrder) {
    this.set(Property$3.RENDER_ORDER, renderOrder);
  };
  BaseVectorLayer2.prototype.setStyle = function(opt_style) {
    this.style_ = opt_style !== void 0 ? opt_style : createDefaultStyle;
    this.styleFunction_ = opt_style === null ? void 0 : toFunction(this.style_);
    this.changed();
  };
  return BaseVectorLayer2;
}(ol_layer_Base);
var BaseVectorLayer$1 = BaseVectorLayer;
var Instruction = {
  BEGIN_GEOMETRY: 0,
  BEGIN_PATH: 1,
  CIRCLE: 2,
  CLOSE_PATH: 3,
  CUSTOM: 4,
  DRAW_CHARS: 5,
  DRAW_IMAGE: 6,
  END_GEOMETRY: 7,
  FILL: 8,
  MOVE_TO_LINE_TO: 9,
  SET_FILL_STYLE: 10,
  SET_STROKE_STYLE: 11,
  STROKE: 12
};
var fillInstruction = [Instruction.FILL];
var strokeInstruction = [Instruction.STROKE];
var beginPathInstruction = [Instruction.BEGIN_PATH];
var closePathInstruction = [Instruction.CLOSE_PATH];
var CanvasInstruction = Instruction;
var VectorContext = function() {
  function VectorContext2() {
  }
  VectorContext2.prototype.drawCustom = function(geometry, feature2, renderer, hitDetectionRenderer) {
  };
  VectorContext2.prototype.drawGeometry = function(geometry) {
  };
  VectorContext2.prototype.setStyle = function(style2) {
  };
  VectorContext2.prototype.drawCircle = function(circleGeometry, feature2) {
  };
  VectorContext2.prototype.drawFeature = function(feature2, style2) {
  };
  VectorContext2.prototype.drawGeometryCollection = function(geometryCollectionGeometry, feature2) {
  };
  VectorContext2.prototype.drawLineString = function(lineStringGeometry, feature2) {
  };
  VectorContext2.prototype.drawMultiLineString = function(multiLineStringGeometry, feature2) {
  };
  VectorContext2.prototype.drawMultiPoint = function(multiPointGeometry, feature2) {
  };
  VectorContext2.prototype.drawMultiPolygon = function(multiPolygonGeometry, feature2) {
  };
  VectorContext2.prototype.drawPoint = function(pointGeometry, feature2) {
  };
  VectorContext2.prototype.drawPolygon = function(polygonGeometry, feature2) {
  };
  VectorContext2.prototype.drawText = function(geometry, feature2) {
  };
  VectorContext2.prototype.setFillStrokeStyle = function(fillStyle, strokeStyle) {
  };
  VectorContext2.prototype.setImageStyle = function(imageStyle, opt_declutterImageWithText) {
  };
  VectorContext2.prototype.setTextStyle = function(textStyle, opt_declutterImageWithText) {
  };
  return VectorContext2;
}();
var VectorContext$1 = VectorContext;
var __extends$1k = globalThis && globalThis.__extends || function() {
  var extendStatics2 = function(d2, b2) {
    extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {
      d3.__proto__ = b3;
    } || function(d3, b3) {
      for (var p5 in b3)
        if (Object.prototype.hasOwnProperty.call(b3, p5))
          d3[p5] = b3[p5];
    };
    return extendStatics2(d2, b2);
  };
  return function(d2, b2) {
    if (typeof b2 !== "function" && b2 !== null)
      throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
    extendStatics2(d2, b2);
    function __() {
      this.constructor = d2;
    }
    d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
  };
}();
var CanvasBuilder = function(_super) {
  __extends$1k(CanvasBuilder2, _super);
  function CanvasBuilder2(tolerance, maxExtent, resolution, pixelRatio) {
    var _this = _super.call(this) || this;
    _this.tolerance = tolerance;
    _this.maxExtent = maxExtent;
    _this.pixelRatio = pixelRatio;
    _this.maxLineWidth = 0;
    _this.resolution = resolution;
    _this.beginGeometryInstruction1_ = null;
    _this.beginGeometryInstruction2_ = null;
    _this.bufferedMaxExtent_ = null;
    _this.instructions = [];
    _this.coordinates = [];
    _this.tmpCoordinate_ = [];
    _this.hitDetectionInstructions = [];
    _this.state = {};
    return _this;
  }
  CanvasBuilder2.prototype.applyPixelRatio = function(dashArray) {
    var pixelRatio = this.pixelRatio;
    return pixelRatio == 1 ? dashArray : dashArray.map(function(dash) {
      return dash * pixelRatio;
    });
  };
  CanvasBuilder2.prototype.appendFlatPointCoordinates = function(flatCoordinates, stride) {
    var extent2 = this.getBufferedMaxExtent();
    var tmpCoord = this.tmpCoordinate_;
    var coordinates2 = this.coordinates;
    var myEnd = coordinates2.length;
    for (var i2 = 0, ii = flatCoordinates.length; i2 < ii; i2 += stride) {
      tmpCoord[0] = flatCoordinates[i2];
      tmpCoord[1] = flatCoordinates[i2 + 1];
      if (containsCoordinate(extent2, tmpCoord)) {
        coordinates2[myEnd++] = tmpCoord[0];
        coordinates2[myEnd++] = tmpCoord[1];
      }
    }
    return myEnd;
  };
  CanvasBuilder2.prototype.appendFlatLineCoordinates = function(flatCoordinates, offset2, end, stride, closed, skipFirst) {
    var coordinates2 = this.coordinates;
    var myEnd = coordinates2.length;
    var extent2 = this.getBufferedMaxExtent();
    if (skipFirst) {
      offset2 += stride;
    }
    var lastXCoord = flatCoordinates[offset2];
    var lastYCoord = flatCoordinates[offset2 + 1];
    var nextCoord = this.tmpCoordinate_;
    var skipped = true;
    var i2, lastRel, nextRel;
    for (i2 = offset2 + stride; i2 < end; i2 += stride) {
      nextCoord[0] = flatCoordinates[i2];
      nextCoord[1] = flatCoordinates[i2 + 1];
      nextRel = coordinateRelationship(extent2, nextCoord);
      if (nextRel !== lastRel) {
        if (skipped) {
          coordinates2[myEnd++] = lastXCoord;
          coordinates2[myEnd++] = lastYCoord;
          skipped = false;
        }
        coordinates2[myEnd++] = nextCoord[0];
        coordinates2[myEnd++] = nextCoord[1];
      } else if (nextRel === Relationship.INTERSECTING) {
        coordinates2[myEnd++] = nextCoord[0];
        coordinates2[myEnd++] = nextCoord[1];
        skipped = false;
      } else {
        skipped = true;
      }
      lastXCoord = nextCoord[0];
      lastYCoord = nextCoord[1];
      lastRel = nextRel;
    }
    if (closed && skipped || i2 === offset2 + stride) {
      coordinates2[myEnd++] = lastXCoord;
      coordinates2[myEnd++] = lastYCoord;
    }
    return myEnd;
  };
  CanvasBuilder2.prototype.drawCustomCoordinates_ = function(flatCoordinates, offset2, ends, stride, builderEnds) {
    for (var i2 = 0, ii = ends.length; i2 < ii; ++i2) {
      var end = ends[i2];
      var builderEnd = this.appendFlatLineCoordinates(flatCoordinates, offset2, end, stride, false, false);
      builderEnds.push(builderEnd);
      offset2 = end;
    }
    return offset2;
  };
  CanvasBuilder2.prototype.drawCustom = function(geometry, feature2, renderer, hitDetectionRenderer) {
    this.beginGeometry(geometry, feature2);
    var type = geometry.getType();
    var stride = geometry.getStride();
    var builderBegin = this.coordinates.length;
    var flatCoordinates, builderEnd, builderEnds, builderEndss;
    var offset2;
    switch (type) {
      case GeometryType.MULTI_POLYGON:
        flatCoordinates = geometry.getOrientedFlatCoordinates();
        builderEndss = [];
        var endss = geometry.getEndss();
        offset2 = 0;
        for (var i2 = 0, ii = endss.length; i2 < ii; ++i2) {
          var myEnds = [];
          offset2 = this.drawCustomCoordinates_(flatCoordinates, offset2, endss[i2], stride, myEnds);
          builderEndss.push(myEnds);
        }
        this.instructions.push([
          CanvasInstruction.CUSTOM,
          builderBegin,
          builderEndss,
          geometry,
          renderer,
          inflateMultiCoordinatesArray
        ]);
        this.hitDetectionInstructions.push([
          CanvasInstruction.CUSTOM,
          builderBegin,
          builderEndss,
          geometry,
          hitDetectionRenderer || renderer,
          inflateMultiCoordinatesArray
        ]);
        break;
      case GeometryType.POLYGON:
      case GeometryType.MULTI_LINE_STRING:
        builderEnds = [];
        flatCoordinates = type == GeometryType.POLYGON ? geometry.getOrientedFlatCoordinates() : geometry.getFlatCoordinates();
        offset2 = this.drawCustomCoordinates_(flatCoordinates, 0, geometry.getEnds(), stride, builderEnds);
        this.instructions.push([
          CanvasInstruction.CUSTOM,
          builderBegin,
          builderEnds,
          geometry,
          renderer,
          inflateCoordinatesArray
        ]);
        this.hitDetectionInstructions.push([
          CanvasInstruction.CUSTOM,
          builderBegin,
          builderEnds,
          geometry,
          hitDetectionRenderer || renderer,
          inflateCoordinatesArray
        ]);
        break;
      case GeometryType.LINE_STRING:
      case GeometryType.CIRCLE:
        flatCoordinates = geometry.getFlatCoordinates();
        builderEnd = this.appendFlatLineCoordinates(flatCoordinates, 0, flatCoordinates.length, stride, false, false);
        this.instructions.push([
          CanvasInstruction.CUSTOM,
          builderBegin,
          builderEnd,
          geometry,
          renderer,
          inflateCoordinates
        ]);
        this.hitDetectionInstructions.push([
          CanvasInstruction.CUSTOM,
          builderBegin,
          builderEnd,
          geometry,
          hitDetectionRenderer || renderer,
          inflateCoordinates
        ]);
        break;
      case GeometryType.MULTI_POINT:
        flatCoordinates = geometry.getFlatCoordinates();
        builderEnd = this.appendFlatPointCoordinates(flatCoordinates, stride);
        if (builderEnd > builderBegin) {
          this.instructions.push([
            CanvasInstruction.CUSTOM,
            builderBegin,
            builderEnd,
            geometry,
            renderer,
            inflateCoordinates
          ]);
          this.hitDetectionInstructions.push([
            CanvasInstruction.CUSTOM,
            builderBegin,
            builderEnd,
            geometry,
            hitDetectionRenderer || renderer,
            inflateCoordinates
          ]);
        }
        break;
      case GeometryType.POINT:
        flatCoordinates = geometry.getFlatCoordinates();
        this.coordinates.push(flatCoordinates[0], flatCoordinates[1]);
        builderEnd = this.coordinates.length;
        this.instructions.push([
          CanvasInstruction.CUSTOM,
          builderBegin,
          builderEnd,
          geometry,
          renderer
        ]);
        this.hitDetectionInstructions.push([
          CanvasInstruction.CUSTOM,
          builderBegin,
          builderEnd,
          geometry,
          hitDetectionRenderer || renderer
        ]);
        break;
    }
    this.endGeometry(feature2);
  };
  CanvasBuilder2.prototype.beginGeometry = function(geometry, feature2) {
    this.beginGeometryInstruction1_ = [
      CanvasInstruction.BEGIN_GEOMETRY,
      feature2,
      0,
      geometry
    ];
    this.instructions.push(this.beginGeometryInstruction1_);
    this.beginGeometryInstruction2_ = [
      CanvasInstruction.BEGIN_GEOMETRY,
      feature2,
      0,
      geometry
    ];
    this.hitDetectionInstructions.push(this.beginGeometryInstruction2_);
  };
  CanvasBuilder2.prototype.finish = function() {
    return {
      instructions: this.instructions,
      hitDetectionInstructions: this.hitDetectionInstructions,
      coordinates: this.coordinates
    };
  };
  CanvasBuilder2.prototype.reverseHitDetectionInstructions = function() {
    var hitDetectionInstructions = this.hitDetectionInstructions;
    hitDetectionInstructions.reverse();
    var i2;
    var n2 = hitDetectionInstructions.length;
    var instruction;
    var type;
    var begin = -1;
    for (i2 = 0; i2 < n2; ++i2) {
      instruction = hitDetectionInstructions[i2];
      type = instruction[0];
      if (type == CanvasInstruction.END_GEOMETRY) {
        begin = i2;
      } else if (type == CanvasInstruction.BEGIN_GEOMETRY) {
        instruction[2] = i2;
        reverseSubArray(this.hitDetectionInstructions, begin, i2);
        begin = -1;
      }
    }
  };
  CanvasBuilder2.prototype.setFillStrokeStyle = function(fillStyle, strokeStyle) {
    var state = this.state;
    if (fillStyle) {
      var fillStyleColor = fillStyle.getColor();
      state.fillStyle = asColorLike(fillStyleColor ? fillStyleColor : defaultFillStyle);
    } else {
      state.fillStyle = void 0;
    }
    if (strokeStyle) {
      var strokeStyleColor = strokeStyle.getColor();
      state.strokeStyle = asColorLike(strokeStyleColor ? strokeStyleColor : defaultStrokeStyle);
      var strokeStyleLineCap = strokeStyle.getLineCap();
      state.lineCap = strokeStyleLineCap !== void 0 ? strokeStyleLineCap : defaultLineCap;
      var strokeStyleLineDash = strokeStyle.getLineDash();
      state.lineDash = strokeStyleLineDash ? strokeStyleLineDash.slice() : defaultLineDash;
      var strokeStyleLineDashOffset = strokeStyle.getLineDashOffset();
      state.lineDashOffset = strokeStyleLineDashOffset ? strokeStyleLineDashOffset : defaultLineDashOffset;
      var strokeStyleLineJoin = strokeStyle.getLineJoin();
      state.lineJoin = strokeStyleLineJoin !== void 0 ? strokeStyleLineJoin : defaultLineJoin;
      var strokeStyleWidth = strokeStyle.getWidth();
      state.lineWidth = strokeStyleWidth !== void 0 ? strokeStyleWidth : defaultLineWidth;
      var strokeStyleMiterLimit = strokeStyle.getMiterLimit();
      state.miterLimit = strokeStyleMiterLimit !== void 0 ? strokeStyleMiterLimit : defaultMiterLimit;
      if (state.lineWidth > this.maxLineWidth) {
        this.maxLineWidth = state.lineWidth;
        this.bufferedMaxExtent_ = null;
      }
    } else {
      state.strokeStyle = void 0;
      state.lineCap = void 0;
      state.lineDash = null;
      state.lineDashOffset = void 0;
      state.lineJoin = void 0;
      state.lineWidth = void 0;
      state.miterLimit = void 0;
    }
  };
  CanvasBuilder2.prototype.createFill = function(state) {
    var fillStyle = state.fillStyle;
    var fillInstruction2 = [CanvasInstruction.SET_FILL_STYLE, fillStyle];
    if (typeof fillStyle !== "string") {
      fillInstruction2.push(true);
    }
    return fillInstruction2;
  };
  CanvasBuilder2.prototype.applyStroke = function(state) {
    this.instructions.push(this.createStroke(state));
  };
  CanvasBuilder2.prototype.createStroke = function(state) {
    return [
      CanvasInstruction.SET_STROKE_STYLE,
      state.strokeStyle,
      state.lineWidth * this.pixelRatio,
      state.lineCap,
      state.lineJoin,
      state.miterLimit,
      this.applyPixelRatio(state.lineDash),
      state.lineDashOffset * this.pixelRatio
    ];
  };
  CanvasBuilder2.prototype.updateFillStyle = function(state, createFill) {
    var fillStyle = state.fillStyle;
    if (typeof fillStyle !== "string" || state.currentFillStyle != fillStyle) {
      if (fillStyle !== void 0) {
        this.instructions.push(createFill.call(this, state));
      }
      state.currentFillStyle = fillStyle;
    }
  };
  CanvasBuilder2.prototype.updateStrokeStyle = function(state, applyStroke) {
    var strokeStyle = state.strokeStyle;
    var lineCap = state.lineCap;
    var lineDash = state.lineDash;
    var lineDashOffset = state.lineDashOffset;
    var lineJoin = state.lineJoin;
    var lineWidth = state.lineWidth;
    var miterLimit = state.miterLimit;
    if (state.currentStrokeStyle != strokeStyle || state.currentLineCap != lineCap || lineDash != state.currentLineDash && !equals$2(state.currentLineDash, lineDash) || state.currentLineDashOffset != lineDashOffset || state.currentLineJoin != lineJoin || state.currentLineWidth != lineWidth || state.currentMiterLimit != miterLimit) {
      if (strokeStyle !== void 0) {
        applyStroke.call(this, state);
      }
      state.currentStrokeStyle = strokeStyle;
      state.currentLineCap = lineCap;
      state.currentLineDash = lineDash;
      state.currentLineDashOffset = lineDashOffset;
      state.currentLineJoin = lineJoin;
      state.currentLineWidth = lineWidth;
      state.currentMiterLimit = miterLimit;
    }
  };
  CanvasBuilder2.prototype.endGeometry = function(feature2) {
    this.beginGeometryInstruction1_[2] = this.instructions.length;
    this.beginGeometryInstruction1_ = null;
    this.beginGeometryInstruction2_[2] = this.hitDetectionInstructions.length;
    this.beginGeometryInstruction2_ = null;
    var endGeometryInstruction = [CanvasInstruction.END_GEOMETRY, feature2];
    this.instructions.push(endGeometryInstruction);
    this.hitDetectionInstructions.push(endGeometryInstruction);
  };
  CanvasBuilder2.prototype.getBufferedMaxExtent = function() {
    if (!this.bufferedMaxExtent_) {
      this.bufferedMaxExtent_ = clone$1(this.maxExtent);
      if (this.maxLineWidth > 0) {
        var width = this.resolution * (this.maxLineWidth + 1) / 2;
        buffer$1(this.bufferedMaxExtent_, width, this.bufferedMaxExtent_);
      }
    }
    return this.bufferedMaxExtent_;
  };
  return CanvasBuilder2;
}(VectorContext$1);
var Builder = CanvasBuilder;
var __extends$1j = globalThis && globalThis.__extends || function() {
  var extendStatics2 = function(d2, b2) {
    extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {
      d3.__proto__ = b3;
    } || function(d3, b3) {
      for (var p5 in b3)
        if (Object.prototype.hasOwnProperty.call(b3, p5))
          d3[p5] = b3[p5];
    };
    return extendStatics2(d2, b2);
  };
  return function(d2, b2) {
    if (typeof b2 !== "function" && b2 !== null)
      throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
    extendStatics2(d2, b2);
    function __() {
      this.constructor = d2;
    }
    d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
  };
}();
var CanvasImageBuilder = function(_super) {
  __extends$1j(CanvasImageBuilder2, _super);
  function CanvasImageBuilder2(tolerance, maxExtent, resolution, pixelRatio) {
    var _this = _super.call(this, tolerance, maxExtent, resolution, pixelRatio) || this;
    _this.hitDetectionImage_ = null;
    _this.image_ = null;
    _this.imagePixelRatio_ = void 0;
    _this.anchorX_ = void 0;
    _this.anchorY_ = void 0;
    _this.height_ = void 0;
    _this.opacity_ = void 0;
    _this.originX_ = void 0;
    _this.originY_ = void 0;
    _this.rotateWithView_ = void 0;
    _this.rotation_ = void 0;
    _this.scale_ = void 0;
    _this.width_ = void 0;
    _this.declutterImageWithText_ = void 0;
    return _this;
  }
  CanvasImageBuilder2.prototype.drawPoint = function(pointGeometry, feature2) {
    if (!this.image_) {
      return;
    }
    this.beginGeometry(pointGeometry, feature2);
    var flatCoordinates = pointGeometry.getFlatCoordinates();
    var stride = pointGeometry.getStride();
    var myBegin = this.coordinates.length;
    var myEnd = this.appendFlatPointCoordinates(flatCoordinates, stride);
    this.instructions.push([
      CanvasInstruction.DRAW_IMAGE,
      myBegin,
      myEnd,
      this.image_,
      this.anchorX_ * this.imagePixelRatio_,
      this.anchorY_ * this.imagePixelRatio_,
      Math.ceil(this.height_ * this.imagePixelRatio_),
      this.opacity_,
      this.originX_,
      this.originY_,
      this.rotateWithView_,
      this.rotation_,
      [
        this.scale_[0] * this.pixelRatio / this.imagePixelRatio_,
        this.scale_[1] * this.pixelRatio / this.imagePixelRatio_
      ],
      Math.ceil(this.width_ * this.imagePixelRatio_),
      this.declutterImageWithText_
    ]);
    this.hitDetectionInstructions.push([
      CanvasInstruction.DRAW_IMAGE,
      myBegin,
      myEnd,
      this.hitDetectionImage_,
      this.anchorX_,
      this.anchorY_,
      this.height_,
      this.opacity_,
      this.originX_,
      this.originY_,
      this.rotateWithView_,
      this.rotation_,
      this.scale_,
      this.width_,
      this.declutterImageWithText_
    ]);
    this.endGeometry(feature2);
  };
  CanvasImageBuilder2.prototype.drawMultiPoint = function(multiPointGeometry, feature2) {
    if (!this.image_) {
      return;
    }
    this.beginGeometry(multiPointGeometry, feature2);
    var flatCoordinates = multiPointGeometry.getFlatCoordinates();
    var stride = multiPointGeometry.getStride();
    var myBegin = this.coordinates.length;
    var myEnd = this.appendFlatPointCoordinates(flatCoordinates, stride);
    this.instructions.push([
      CanvasInstruction.DRAW_IMAGE,
      myBegin,
      myEnd,
      this.image_,
      this.anchorX_ * this.imagePixelRatio_,
      this.anchorY_ * this.imagePixelRatio_,
      Math.ceil(this.height_ * this.imagePixelRatio_),
      this.opacity_,
      this.originX_,
      this.originY_,
      this.rotateWithView_,
      this.rotation_,
      [
        this.scale_[0] * this.pixelRatio / this.imagePixelRatio_,
        this.scale_[1] * this.pixelRatio / this.imagePixelRatio_
      ],
      Math.ceil(this.width_ * this.imagePixelRatio_),
      this.declutterImageWithText_
    ]);
    this.hitDetectionInstructions.push([
      CanvasInstruction.DRAW_IMAGE,
      myBegin,
      myEnd,
      this.hitDetectionImage_,
      this.anchorX_,
      this.anchorY_,
      this.height_,
      this.opacity_,
      this.originX_,
      this.originY_,
      this.rotateWithView_,
      this.rotation_,
      this.scale_,
      this.width_,
      this.declutterImageWithText_
    ]);
    this.endGeometry(feature2);
  };
  CanvasImageBuilder2.prototype.finish = function() {
    this.reverseHitDetectionInstructions();
    this.anchorX_ = void 0;
    this.anchorY_ = void 0;
    this.hitDetectionImage_ = null;
    this.image_ = null;
    this.imagePixelRatio_ = void 0;
    this.height_ = void 0;
    this.scale_ = void 0;
    this.opacity_ = void 0;
    this.originX_ = void 0;
    this.originY_ = void 0;
    this.rotateWithView_ = void 0;
    this.rotation_ = void 0;
    this.width_ = void 0;
    return _super.prototype.finish.call(this);
  };
  CanvasImageBuilder2.prototype.setImageStyle = function(imageStyle, opt_sharedData) {
    var anchor = imageStyle.getAnchor();
    var size = imageStyle.getSize();
    var hitDetectionImage = imageStyle.getHitDetectionImage();
    var image2 = imageStyle.getImage(this.pixelRatio);
    var origin = imageStyle.getOrigin();
    this.imagePixelRatio_ = imageStyle.getPixelRatio(this.pixelRatio);
    this.anchorX_ = anchor[0];
    this.anchorY_ = anchor[1];
    this.hitDetectionImage_ = hitDetectionImage;
    this.image_ = image2;
    this.height_ = size[1];
    this.opacity_ = imageStyle.getOpacity();
    this.originX_ = origin[0] * this.imagePixelRatio_;
    this.originY_ = origin[1] * this.imagePixelRatio_;
    this.rotateWithView_ = imageStyle.getRotateWithView();
    this.rotation_ = imageStyle.getRotation();
    this.scale_ = imageStyle.getScaleArray();
    this.width_ = size[0];
    this.declutterImageWithText_ = opt_sharedData;
  };
  return CanvasImageBuilder2;
}(Builder);
var ImageBuilder = CanvasImageBuilder;
var __extends$1i = globalThis && globalThis.__extends || function() {
  var extendStatics2 = function(d2, b2) {
    extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {
      d3.__proto__ = b3;
    } || function(d3, b3) {
      for (var p5 in b3)
        if (Object.prototype.hasOwnProperty.call(b3, p5))
          d3[p5] = b3[p5];
    };
    return extendStatics2(d2, b2);
  };
  return function(d2, b2) {
    if (typeof b2 !== "function" && b2 !== null)
      throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
    extendStatics2(d2, b2);
    function __() {
      this.constructor = d2;
    }
    d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
  };
}();
var CanvasLineStringBuilder = function(_super) {
  __extends$1i(CanvasLineStringBuilder2, _super);
  function CanvasLineStringBuilder2(tolerance, maxExtent, resolution, pixelRatio) {
    return _super.call(this, tolerance, maxExtent, resolution, pixelRatio) || this;
  }
  CanvasLineStringBuilder2.prototype.drawFlatCoordinates_ = function(flatCoordinates, offset2, end, stride) {
    var myBegin = this.coordinates.length;
    var myEnd = this.appendFlatLineCoordinates(flatCoordinates, offset2, end, stride, false, false);
    var moveToLineToInstruction = [
      CanvasInstruction.MOVE_TO_LINE_TO,
      myBegin,
      myEnd
    ];
    this.instructions.push(moveToLineToInstruction);
    this.hitDetectionInstructions.push(moveToLineToInstruction);
    return end;
  };
  CanvasLineStringBuilder2.prototype.drawLineString = function(lineStringGeometry, feature2) {
    var state = this.state;
    var strokeStyle = state.strokeStyle;
    var lineWidth = state.lineWidth;
    if (strokeStyle === void 0 || lineWidth === void 0) {
      return;
    }
    this.updateStrokeStyle(state, this.applyStroke);
    this.beginGeometry(lineStringGeometry, feature2);
    this.hitDetectionInstructions.push([
      CanvasInstruction.SET_STROKE_STYLE,
      state.strokeStyle,
      state.lineWidth,
      state.lineCap,
      state.lineJoin,
      state.miterLimit,
      defaultLineDash,
      defaultLineDashOffset
    ], beginPathInstruction);
    var flatCoordinates = lineStringGeometry.getFlatCoordinates();
    var stride = lineStringGeometry.getStride();
    this.drawFlatCoordinates_(flatCoordinates, 0, flatCoordinates.length, stride);
    this.hitDetectionInstructions.push(strokeInstruction);
    this.endGeometry(feature2);
  };
  CanvasLineStringBuilder2.prototype.drawMultiLineString = function(multiLineStringGeometry, feature2) {
    var state = this.state;
    var strokeStyle = state.strokeStyle;
    var lineWidth = state.lineWidth;
    if (strokeStyle === void 0 || lineWidth === void 0) {
      return;
    }
    this.updateStrokeStyle(state, this.applyStroke);
    this.beginGeometry(multiLineStringGeometry, feature2);
    this.hitDetectionInstructions.push([
      CanvasInstruction.SET_STROKE_STYLE,
      state.strokeStyle,
      state.lineWidth,
      state.lineCap,
      state.lineJoin,
      state.miterLimit,
      state.lineDash,
      state.lineDashOffset
    ], beginPathInstruction);
    var ends = multiLineStringGeometry.getEnds();
    var flatCoordinates = multiLineStringGeometry.getFlatCoordinates();
    var stride = multiLineStringGeometry.getStride();
    var offset2 = 0;
    for (var i2 = 0, ii = ends.length; i2 < ii; ++i2) {
      offset2 = this.drawFlatCoordinates_(flatCoordinates, offset2, ends[i2], stride);
    }
    this.hitDetectionInstructions.push(strokeInstruction);
    this.endGeometry(feature2);
  };
  CanvasLineStringBuilder2.prototype.finish = function() {
    var state = this.state;
    if (state.lastStroke != void 0 && state.lastStroke != this.coordinates.length) {
      this.instructions.push(strokeInstruction);
    }
    this.reverseHitDetectionInstructions();
    this.state = null;
    return _super.prototype.finish.call(this);
  };
  CanvasLineStringBuilder2.prototype.applyStroke = function(state) {
    if (state.lastStroke != void 0 && state.lastStroke != this.coordinates.length) {
      this.instructions.push(strokeInstruction);
      state.lastStroke = this.coordinates.length;
    }
    state.lastStroke = 0;
    _super.prototype.applyStroke.call(this, state);
    this.instructions.push(beginPathInstruction);
  };
  return CanvasLineStringBuilder2;
}(Builder);
var LineStringBuilder = CanvasLineStringBuilder;
var __extends$1h = globalThis && globalThis.__extends || function() {
  var extendStatics2 = function(d2, b2) {
    extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {
      d3.__proto__ = b3;
    } || function(d3, b3) {
      for (var p5 in b3)
        if (Object.prototype.hasOwnProperty.call(b3, p5))
          d3[p5] = b3[p5];
    };
    return extendStatics2(d2, b2);
  };
  return function(d2, b2) {
    if (typeof b2 !== "function" && b2 !== null)
      throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
    extendStatics2(d2, b2);
    function __() {
      this.constructor = d2;
    }
    d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
  };
}();
var CanvasPolygonBuilder = function(_super) {
  __extends$1h(CanvasPolygonBuilder2, _super);
  function CanvasPolygonBuilder2(tolerance, maxExtent, resolution, pixelRatio) {
    return _super.call(this, tolerance, maxExtent, resolution, pixelRatio) || this;
  }
  CanvasPolygonBuilder2.prototype.drawFlatCoordinatess_ = function(flatCoordinates, offset2, ends, stride) {
    var state = this.state;
    var fill = state.fillStyle !== void 0;
    var stroke = state.strokeStyle !== void 0;
    var numEnds = ends.length;
    this.instructions.push(beginPathInstruction);
    this.hitDetectionInstructions.push(beginPathInstruction);
    for (var i2 = 0; i2 < numEnds; ++i2) {
      var end = ends[i2];
      var myBegin = this.coordinates.length;
      var myEnd = this.appendFlatLineCoordinates(flatCoordinates, offset2, end, stride, true, !stroke);
      var moveToLineToInstruction = [
        CanvasInstruction.MOVE_TO_LINE_TO,
        myBegin,
        myEnd
      ];
      this.instructions.push(moveToLineToInstruction);
      this.hitDetectionInstructions.push(moveToLineToInstruction);
      if (stroke) {
        this.instructions.push(closePathInstruction);
        this.hitDetectionInstructions.push(closePathInstruction);
      }
      offset2 = end;
    }
    if (fill) {
      this.instructions.push(fillInstruction);
      this.hitDetectionInstructions.push(fillInstruction);
    }
    if (stroke) {
      this.instructions.push(strokeInstruction);
      this.hitDetectionInstructions.push(strokeInstruction);
    }
    return offset2;
  };
  CanvasPolygonBuilder2.prototype.drawCircle = function(circleGeometry, feature2) {
    var state = this.state;
    var fillStyle = state.fillStyle;
    var strokeStyle = state.strokeStyle;
    if (fillStyle === void 0 && strokeStyle === void 0) {
      return;
    }
    this.setFillStrokeStyles_();
    this.beginGeometry(circleGeometry, feature2);
    if (state.fillStyle !== void 0) {
      this.hitDetectionInstructions.push([
        CanvasInstruction.SET_FILL_STYLE,
        defaultFillStyle
      ]);
    }
    if (state.strokeStyle !== void 0) {
      this.hitDetectionInstructions.push([
        CanvasInstruction.SET_STROKE_STYLE,
        state.strokeStyle,
        state.lineWidth,
        state.lineCap,
        state.lineJoin,
        state.miterLimit,
        state.lineDash,
        state.lineDashOffset
      ]);
    }
    var flatCoordinates = circleGeometry.getFlatCoordinates();
    var stride = circleGeometry.getStride();
    var myBegin = this.coordinates.length;
    this.appendFlatLineCoordinates(flatCoordinates, 0, flatCoordinates.length, stride, false, false);
    var circleInstruction = [CanvasInstruction.CIRCLE, myBegin];
    this.instructions.push(beginPathInstruction, circleInstruction);
    this.hitDetectionInstructions.push(beginPathInstruction, circleInstruction);
    if (state.fillStyle !== void 0) {
      this.instructions.push(fillInstruction);
      this.hitDetectionInstructions.push(fillInstruction);
    }
    if (state.strokeStyle !== void 0) {
      this.instructions.push(strokeInstruction);
      this.hitDetectionInstructions.push(strokeInstruction);
    }
    this.endGeometry(feature2);
  };
  CanvasPolygonBuilder2.prototype.drawPolygon = function(polygonGeometry, feature2) {
    var state = this.state;
    var fillStyle = state.fillStyle;
    var strokeStyle = state.strokeStyle;
    if (fillStyle === void 0 && strokeStyle === void 0) {
      return;
    }
    this.setFillStrokeStyles_();
    this.beginGeometry(polygonGeometry, feature2);
    if (state.fillStyle !== void 0) {
      this.hitDetectionInstructions.push([
        CanvasInstruction.SET_FILL_STYLE,
        defaultFillStyle
      ]);
    }
    if (state.strokeStyle !== void 0) {
      this.hitDetectionInstructions.push([
        CanvasInstruction.SET_STROKE_STYLE,
        state.strokeStyle,
        state.lineWidth,
        state.lineCap,
        state.lineJoin,
        state.miterLimit,
        state.lineDash,
        state.lineDashOffset
      ]);
    }
    var ends = polygonGeometry.getEnds();
    var flatCoordinates = polygonGeometry.getOrientedFlatCoordinates();
    var stride = polygonGeometry.getStride();
    this.drawFlatCoordinatess_(flatCoordinates, 0, ends, stride);
    this.endGeometry(feature2);
  };
  CanvasPolygonBuilder2.prototype.drawMultiPolygon = function(multiPolygonGeometry, feature2) {
    var state = this.state;
    var fillStyle = state.fillStyle;
    var strokeStyle = state.strokeStyle;
    if (fillStyle === void 0 && strokeStyle === void 0) {
      return;
    }
    this.setFillStrokeStyles_();
    this.beginGeometry(multiPolygonGeometry, feature2);
    if (state.fillStyle !== void 0) {
      this.hitDetectionInstructions.push([
        CanvasInstruction.SET_FILL_STYLE,
        defaultFillStyle
      ]);
    }
    if (state.strokeStyle !== void 0) {
      this.hitDetectionInstructions.push([
        CanvasInstruction.SET_STROKE_STYLE,
        state.strokeStyle,
        state.lineWidth,
        state.lineCap,
        state.lineJoin,
        state.miterLimit,
        state.lineDash,
        state.lineDashOffset
      ]);
    }
    var endss = multiPolygonGeometry.getEndss();
    var flatCoordinates = multiPolygonGeometry.getOrientedFlatCoordinates();
    var stride = multiPolygonGeometry.getStride();
    var offset2 = 0;
    for (var i2 = 0, ii = endss.length; i2 < ii; ++i2) {
      offset2 = this.drawFlatCoordinatess_(flatCoordinates, offset2, endss[i2], stride);
    }
    this.endGeometry(feature2);
  };
  CanvasPolygonBuilder2.prototype.finish = function() {
    this.reverseHitDetectionInstructions();
    this.state = null;
    var tolerance = this.tolerance;
    if (tolerance !== 0) {
      var coordinates2 = this.coordinates;
      for (var i2 = 0, ii = coordinates2.length; i2 < ii; ++i2) {
        coordinates2[i2] = snap(coordinates2[i2], tolerance);
      }
    }
    return _super.prototype.finish.call(this);
  };
  CanvasPolygonBuilder2.prototype.setFillStrokeStyles_ = function() {
    var state = this.state;
    var fillStyle = state.fillStyle;
    if (fillStyle !== void 0) {
      this.updateFillStyle(state, this.createFill);
    }
    if (state.strokeStyle !== void 0) {
      this.updateStrokeStyle(state, this.applyStroke);
    }
  };
  return CanvasPolygonBuilder2;
}(Builder);
var PolygonBuilder = CanvasPolygonBuilder;
var TextPlacement = {
  POINT: "point",
  LINE: "line"
};
function matchingChunk(maxAngle, flatCoordinates, offset2, end, stride) {
  var chunkStart = offset2;
  var chunkEnd = offset2;
  var chunkM = 0;
  var m2 = 0;
  var start2 = offset2;
  var acos, i2, m12, m23, x1, y1, x12, y12, x23, y23;
  for (i2 = offset2; i2 < end; i2 += stride) {
    var x2 = flatCoordinates[i2];
    var y2 = flatCoordinates[i2 + 1];
    if (x1 !== void 0) {
      x23 = x2 - x1;
      y23 = y2 - y1;
      m23 = Math.sqrt(x23 * x23 + y23 * y23);
      if (x12 !== void 0) {
        m2 += m12;
        acos = Math.acos((x12 * x23 + y12 * y23) / (m12 * m23));
        if (acos > maxAngle) {
          if (m2 > chunkM) {
            chunkM = m2;
            chunkStart = start2;
            chunkEnd = i2;
          }
          m2 = 0;
          start2 = i2 - stride;
        }
      }
      m12 = m23;
      x12 = x23;
      y12 = y23;
    }
    x1 = x2;
    y1 = y2;
  }
  m2 += m23;
  return m2 > chunkM ? [start2, i2] : [chunkStart, chunkEnd];
}
var __extends$1g = globalThis && globalThis.__extends || function() {
  var extendStatics2 = function(d2, b2) {
    extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {
      d3.__proto__ = b3;
    } || function(d3, b3) {
      for (var p5 in b3)
        if (Object.prototype.hasOwnProperty.call(b3, p5))
          d3[p5] = b3[p5];
    };
    return extendStatics2(d2, b2);
  };
  return function(d2, b2) {
    if (typeof b2 !== "function" && b2 !== null)
      throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
    extendStatics2(d2, b2);
    function __() {
      this.constructor = d2;
    }
    d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
  };
}();
var TEXT_ALIGN = {
  "left": 0,
  "end": 0,
  "center": 0.5,
  "right": 1,
  "start": 1,
  "top": 0,
  "middle": 0.5,
  "hanging": 0.2,
  "alphabetic": 0.8,
  "ideographic": 0.8,
  "bottom": 1
};
var CanvasTextBuilder = function(_super) {
  __extends$1g(CanvasTextBuilder2, _super);
  function CanvasTextBuilder2(tolerance, maxExtent, resolution, pixelRatio) {
    var _this = _super.call(this, tolerance, maxExtent, resolution, pixelRatio) || this;
    _this.labels_ = null;
    _this.text_ = "";
    _this.textOffsetX_ = 0;
    _this.textOffsetY_ = 0;
    _this.textRotateWithView_ = void 0;
    _this.textRotation_ = 0;
    _this.textFillState_ = null;
    _this.fillStates = {};
    _this.textStrokeState_ = null;
    _this.strokeStates = {};
    _this.textState_ = {};
    _this.textStates = {};
    _this.textKey_ = "";
    _this.fillKey_ = "";
    _this.strokeKey_ = "";
    _this.declutterImageWithText_ = void 0;
    return _this;
  }
  CanvasTextBuilder2.prototype.finish = function() {
    var instructions = _super.prototype.finish.call(this);
    instructions.textStates = this.textStates;
    instructions.fillStates = this.fillStates;
    instructions.strokeStates = this.strokeStates;
    return instructions;
  };
  CanvasTextBuilder2.prototype.drawText = function(geometry, feature2) {
    var fillState = this.textFillState_;
    var strokeState = this.textStrokeState_;
    var textState = this.textState_;
    if (this.text_ === "" || !textState || !fillState && !strokeState) {
      return;
    }
    var coordinates2 = this.coordinates;
    var begin = coordinates2.length;
    var geometryType = geometry.getType();
    var flatCoordinates = null;
    var stride = geometry.getStride();
    if (textState.placement === TextPlacement.LINE && (geometryType == GeometryType.LINE_STRING || geometryType == GeometryType.MULTI_LINE_STRING || geometryType == GeometryType.POLYGON || geometryType == GeometryType.MULTI_POLYGON)) {
      if (!intersects$1(this.getBufferedMaxExtent(), geometry.getExtent())) {
        return;
      }
      var ends = void 0;
      flatCoordinates = geometry.getFlatCoordinates();
      if (geometryType == GeometryType.LINE_STRING) {
        ends = [flatCoordinates.length];
      } else if (geometryType == GeometryType.MULTI_LINE_STRING) {
        ends = geometry.getEnds();
      } else if (geometryType == GeometryType.POLYGON) {
        ends = geometry.getEnds().slice(0, 1);
      } else if (geometryType == GeometryType.MULTI_POLYGON) {
        var endss = geometry.getEndss();
        ends = [];
        for (var i2 = 0, ii = endss.length; i2 < ii; ++i2) {
          ends.push(endss[i2][0]);
        }
      }
      this.beginGeometry(geometry, feature2);
      var textAlign2 = textState.textAlign;
      var flatOffset = 0;
      var flatEnd = void 0;
      for (var o2 = 0, oo = ends.length; o2 < oo; ++o2) {
        if (textAlign2 == void 0) {
          var range = matchingChunk(textState.maxAngle, flatCoordinates, flatOffset, ends[o2], stride);
          flatOffset = range[0];
          flatEnd = range[1];
        } else {
          flatEnd = ends[o2];
        }
        for (var i2 = flatOffset; i2 < flatEnd; i2 += stride) {
          coordinates2.push(flatCoordinates[i2], flatCoordinates[i2 + 1]);
        }
        var end = coordinates2.length;
        flatOffset = ends[o2];
        this.drawChars_(begin, end);
        begin = end;
      }
      this.endGeometry(feature2);
    } else {
      var geometryWidths = textState.overflow ? null : [];
      switch (geometryType) {
        case GeometryType.POINT:
        case GeometryType.MULTI_POINT:
          flatCoordinates = geometry.getFlatCoordinates();
          break;
        case GeometryType.LINE_STRING:
          flatCoordinates = geometry.getFlatMidpoint();
          break;
        case GeometryType.CIRCLE:
          flatCoordinates = geometry.getCenter();
          break;
        case GeometryType.MULTI_LINE_STRING:
          flatCoordinates = geometry.getFlatMidpoints();
          stride = 2;
          break;
        case GeometryType.POLYGON:
          flatCoordinates = geometry.getFlatInteriorPoint();
          if (!textState.overflow) {
            geometryWidths.push(flatCoordinates[2] / this.resolution);
          }
          stride = 3;
          break;
        case GeometryType.MULTI_POLYGON:
          var interiorPoints = geometry.getFlatInteriorPoints();
          flatCoordinates = [];
          for (var i2 = 0, ii = interiorPoints.length; i2 < ii; i2 += 3) {
            if (!textState.overflow) {
              geometryWidths.push(interiorPoints[i2 + 2] / this.resolution);
            }
            flatCoordinates.push(interiorPoints[i2], interiorPoints[i2 + 1]);
          }
          if (flatCoordinates.length === 0) {
            return;
          }
          stride = 2;
          break;
      }
      var end = this.appendFlatPointCoordinates(flatCoordinates, stride);
      if (end === begin) {
        return;
      }
      if (geometryWidths && (end - begin) / 2 !== flatCoordinates.length / stride) {
        var beg_1 = begin / 2;
        geometryWidths = geometryWidths.filter(function(w2, i3) {
          var keep = coordinates2[(beg_1 + i3) * 2] === flatCoordinates[i3 * stride] && coordinates2[(beg_1 + i3) * 2 + 1] === flatCoordinates[i3 * stride + 1];
          if (!keep) {
            --beg_1;
          }
          return keep;
        });
      }
      this.saveTextStates_();
      if (textState.backgroundFill || textState.backgroundStroke) {
        this.setFillStrokeStyle(textState.backgroundFill, textState.backgroundStroke);
        if (textState.backgroundFill) {
          this.updateFillStyle(this.state, this.createFill);
          this.hitDetectionInstructions.push(this.createFill(this.state));
        }
        if (textState.backgroundStroke) {
          this.updateStrokeStyle(this.state, this.applyStroke);
          this.hitDetectionInstructions.push(this.createStroke(this.state));
        }
      }
      this.beginGeometry(geometry, feature2);
      var padding = textState.padding;
      if (padding != defaultPadding && (textState.scale[0] < 0 || textState.scale[1] < 0)) {
        var p0 = textState.padding[0];
        var p12 = textState.padding[1];
        var p22 = textState.padding[2];
        var p32 = textState.padding[3];
        if (textState.scale[0] < 0) {
          p12 = -p12;
          p32 = -p32;
        }
        if (textState.scale[1] < 0) {
          p0 = -p0;
          p22 = -p22;
        }
        padding = [p0, p12, p22, p32];
      }
      var pixelRatio_1 = this.pixelRatio;
      this.instructions.push([
        CanvasInstruction.DRAW_IMAGE,
        begin,
        end,
        null,
        NaN,
        NaN,
        NaN,
        1,
        0,
        0,
        this.textRotateWithView_,
        this.textRotation_,
        [1, 1],
        NaN,
        this.declutterImageWithText_,
        padding == defaultPadding ? defaultPadding : padding.map(function(p5) {
          return p5 * pixelRatio_1;
        }),
        !!textState.backgroundFill,
        !!textState.backgroundStroke,
        this.text_,
        this.textKey_,
        this.strokeKey_,
        this.fillKey_,
        this.textOffsetX_,
        this.textOffsetY_,
        geometryWidths
      ]);
      var scale2 = 1 / pixelRatio_1;
      this.hitDetectionInstructions.push([
        CanvasInstruction.DRAW_IMAGE,
        begin,
        end,
        null,
        NaN,
        NaN,
        NaN,
        1,
        0,
        0,
        this.textRotateWithView_,
        this.textRotation_,
        [scale2, scale2],
        NaN,
        this.declutterImageWithText_,
        padding,
        !!textState.backgroundFill,
        !!textState.backgroundStroke,
        this.text_,
        this.textKey_,
        this.strokeKey_,
        this.fillKey_,
        this.textOffsetX_,
        this.textOffsetY_,
        geometryWidths
      ]);
      this.endGeometry(feature2);
    }
  };
  CanvasTextBuilder2.prototype.saveTextStates_ = function() {
    var strokeState = this.textStrokeState_;
    var textState = this.textState_;
    var fillState = this.textFillState_;
    var strokeKey = this.strokeKey_;
    if (strokeState) {
      if (!(strokeKey in this.strokeStates)) {
        this.strokeStates[strokeKey] = {
          strokeStyle: strokeState.strokeStyle,
          lineCap: strokeState.lineCap,
          lineDashOffset: strokeState.lineDashOffset,
          lineWidth: strokeState.lineWidth,
          lineJoin: strokeState.lineJoin,
          miterLimit: strokeState.miterLimit,
          lineDash: strokeState.lineDash
        };
      }
    }
    var textKey = this.textKey_;
    if (!(textKey in this.textStates)) {
      this.textStates[textKey] = {
        font: textState.font,
        textAlign: textState.textAlign || defaultTextAlign,
        textBaseline: textState.textBaseline || defaultTextBaseline,
        scale: textState.scale
      };
    }
    var fillKey = this.fillKey_;
    if (fillState) {
      if (!(fillKey in this.fillStates)) {
        this.fillStates[fillKey] = {
          fillStyle: fillState.fillStyle
        };
      }
    }
  };
  CanvasTextBuilder2.prototype.drawChars_ = function(begin, end) {
    var strokeState = this.textStrokeState_;
    var textState = this.textState_;
    var strokeKey = this.strokeKey_;
    var textKey = this.textKey_;
    var fillKey = this.fillKey_;
    this.saveTextStates_();
    var pixelRatio = this.pixelRatio;
    var baseline = TEXT_ALIGN[textState.textBaseline];
    var offsetY = this.textOffsetY_ * pixelRatio;
    var text2 = this.text_;
    var strokeWidth = strokeState ? strokeState.lineWidth * Math.abs(textState.scale[0]) / 2 : 0;
    this.instructions.push([
      CanvasInstruction.DRAW_CHARS,
      begin,
      end,
      baseline,
      textState.overflow,
      fillKey,
      textState.maxAngle,
      pixelRatio,
      offsetY,
      strokeKey,
      strokeWidth * pixelRatio,
      text2,
      textKey,
      1
    ]);
    this.hitDetectionInstructions.push([
      CanvasInstruction.DRAW_CHARS,
      begin,
      end,
      baseline,
      textState.overflow,
      fillKey,
      textState.maxAngle,
      1,
      offsetY,
      strokeKey,
      strokeWidth,
      text2,
      textKey,
      1 / pixelRatio
    ]);
  };
  CanvasTextBuilder2.prototype.setTextStyle = function(textStyle, opt_sharedData) {
    var textState, fillState, strokeState;
    if (!textStyle) {
      this.text_ = "";
    } else {
      var textFillStyle = textStyle.getFill();
      if (!textFillStyle) {
        fillState = null;
        this.textFillState_ = fillState;
      } else {
        fillState = this.textFillState_;
        if (!fillState) {
          fillState = {};
          this.textFillState_ = fillState;
        }
        fillState.fillStyle = asColorLike(textFillStyle.getColor() || defaultFillStyle);
      }
      var textStrokeStyle = textStyle.getStroke();
      if (!textStrokeStyle) {
        strokeState = null;
        this.textStrokeState_ = strokeState;
      } else {
        strokeState = this.textStrokeState_;
        if (!strokeState) {
          strokeState = {};
          this.textStrokeState_ = strokeState;
        }
        var lineDash = textStrokeStyle.getLineDash();
        var lineDashOffset = textStrokeStyle.getLineDashOffset();
        var lineWidth = textStrokeStyle.getWidth();
        var miterLimit = textStrokeStyle.getMiterLimit();
        strokeState.lineCap = textStrokeStyle.getLineCap() || defaultLineCap;
        strokeState.lineDash = lineDash ? lineDash.slice() : defaultLineDash;
        strokeState.lineDashOffset = lineDashOffset === void 0 ? defaultLineDashOffset : lineDashOffset;
        strokeState.lineJoin = textStrokeStyle.getLineJoin() || defaultLineJoin;
        strokeState.lineWidth = lineWidth === void 0 ? defaultLineWidth : lineWidth;
        strokeState.miterLimit = miterLimit === void 0 ? defaultMiterLimit : miterLimit;
        strokeState.strokeStyle = asColorLike(textStrokeStyle.getColor() || defaultStrokeStyle);
      }
      textState = this.textState_;
      var font = textStyle.getFont() || defaultFont;
      registerFont(font);
      var textScale = textStyle.getScaleArray();
      textState.overflow = textStyle.getOverflow();
      textState.font = font;
      textState.maxAngle = textStyle.getMaxAngle();
      textState.placement = textStyle.getPlacement();
      textState.textAlign = textStyle.getTextAlign();
      textState.textBaseline = textStyle.getTextBaseline() || defaultTextBaseline;
      textState.backgroundFill = textStyle.getBackgroundFill();
      textState.backgroundStroke = textStyle.getBackgroundStroke();
      textState.padding = textStyle.getPadding() || defaultPadding;
      textState.scale = textScale === void 0 ? [1, 1] : textScale;
      var textOffsetX = textStyle.getOffsetX();
      var textOffsetY = textStyle.getOffsetY();
      var textRotateWithView = textStyle.getRotateWithView();
      var textRotation = textStyle.getRotation();
      this.text_ = textStyle.getText() || "";
      this.textOffsetX_ = textOffsetX === void 0 ? 0 : textOffsetX;
      this.textOffsetY_ = textOffsetY === void 0 ? 0 : textOffsetY;
      this.textRotateWithView_ = textRotateWithView === void 0 ? false : textRotateWithView;
      this.textRotation_ = textRotation === void 0 ? 0 : textRotation;
      this.strokeKey_ = strokeState ? (typeof strokeState.strokeStyle == "string" ? strokeState.strokeStyle : getUid(strokeState.strokeStyle)) + strokeState.lineCap + strokeState.lineDashOffset + "|" + strokeState.lineWidth + strokeState.lineJoin + strokeState.miterLimit + "[" + strokeState.lineDash.join() + "]" : "";
      this.textKey_ = textState.font + textState.scale + (textState.textAlign || "?") + (textState.textBaseline || "?");
      this.fillKey_ = fillState ? typeof fillState.fillStyle == "string" ? fillState.fillStyle : "|" + getUid(fillState.fillStyle) : "";
    }
    this.declutterImageWithText_ = opt_sharedData;
  };
  return CanvasTextBuilder2;
}(Builder);
var TextBuilder = CanvasTextBuilder;
var BATCH_CONSTRUCTORS = {
  "Circle": PolygonBuilder,
  "Default": Builder,
  "Image": ImageBuilder,
  "LineString": LineStringBuilder,
  "Polygon": PolygonBuilder,
  "Text": TextBuilder
};
var BuilderGroup = function() {
  function BuilderGroup2(tolerance, maxExtent, resolution, pixelRatio) {
    this.tolerance_ = tolerance;
    this.maxExtent_ = maxExtent;
    this.pixelRatio_ = pixelRatio;
    this.resolution_ = resolution;
    this.buildersByZIndex_ = {};
  }
  BuilderGroup2.prototype.finish = function() {
    var builderInstructions = {};
    for (var zKey in this.buildersByZIndex_) {
      builderInstructions[zKey] = builderInstructions[zKey] || {};
      var builders = this.buildersByZIndex_[zKey];
      for (var builderKey in builders) {
        var builderInstruction = builders[builderKey].finish();
        builderInstructions[zKey][builderKey] = builderInstruction;
      }
    }
    return builderInstructions;
  };
  BuilderGroup2.prototype.getBuilder = function(zIndex2, builderType) {
    var zIndexKey = zIndex2 !== void 0 ? zIndex2.toString() : "0";
    var replays = this.buildersByZIndex_[zIndexKey];
    if (replays === void 0) {
      replays = {};
      this.buildersByZIndex_[zIndexKey] = replays;
    }
    var replay = replays[builderType];
    if (replay === void 0) {
      var Constructor = BATCH_CONSTRUCTORS[builderType];
      replay = new Constructor(this.tolerance_, this.maxExtent_, this.resolution_, this.pixelRatio_);
      replays[builderType] = replay;
    }
    return replay;
  };
  return BuilderGroup2;
}();
var CanvasBuilderGroup = BuilderGroup;
var __extends$1f = globalThis && globalThis.__extends || function() {
  var extendStatics2 = function(d2, b2) {
    extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {
      d3.__proto__ = b3;
    } || function(d3, b3) {
      for (var p5 in b3)
        if (Object.prototype.hasOwnProperty.call(b3, p5))
          d3[p5] = b3[p5];
    };
    return extendStatics2(d2, b2);
  };
  return function(d2, b2) {
    if (typeof b2 !== "function" && b2 !== null)
      throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
    extendStatics2(d2, b2);
    function __() {
      this.constructor = d2;
    }
    d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
  };
}();
var LayerRenderer = function(_super) {
  __extends$1f(LayerRenderer2, _super);
  function LayerRenderer2(layer) {
    var _this = _super.call(this) || this;
    _this.ready = true;
    _this.boundHandleImageChange_ = _this.handleImageChange_.bind(_this);
    _this.layer_ = layer;
    _this.declutterExecutorGroup = null;
    return _this;
  }
  LayerRenderer2.prototype.getFeatures = function(pixel) {
    return abstract();
  };
  LayerRenderer2.prototype.getData = function(pixel) {
    return null;
  };
  LayerRenderer2.prototype.prepareFrame = function(frameState) {
    return abstract();
  };
  LayerRenderer2.prototype.renderFrame = function(frameState, target) {
    return abstract();
  };
  LayerRenderer2.prototype.loadedTileCallback = function(tiles, zoom, tile2) {
    if (!tiles[zoom]) {
      tiles[zoom] = {};
    }
    tiles[zoom][tile2.tileCoord.toString()] = tile2;
    return void 0;
  };
  LayerRenderer2.prototype.createLoadedTileFinder = function(source, projection, tiles) {
    return function(zoom, tileRange) {
      var callback = this.loadedTileCallback.bind(this, tiles, zoom);
      return source.forEachLoadedTile(projection, zoom, tileRange, callback);
    }.bind(this);
  };
  LayerRenderer2.prototype.forEachFeatureAtCoordinate = function(coordinate, frameState, hitTolerance, callback, matches) {
    return void 0;
  };
  LayerRenderer2.prototype.getDataAtPixel = function(pixel, frameState, hitTolerance) {
    return null;
  };
  LayerRenderer2.prototype.getLayer = function() {
    return this.layer_;
  };
  LayerRenderer2.prototype.handleFontsChanged = function() {
  };
  LayerRenderer2.prototype.handleImageChange_ = function(event) {
    var image2 = event.target;
    if (image2.getState() === ImageState.LOADED) {
      this.renderIfReadyAndVisible();
    }
  };
  LayerRenderer2.prototype.loadImage = function(image2) {
    var imageState = image2.getState();
    if (imageState != ImageState.LOADED && imageState != ImageState.ERROR) {
      image2.addEventListener(EventType.CHANGE, this.boundHandleImageChange_);
    }
    if (imageState == ImageState.IDLE) {
      image2.load();
      imageState = image2.getState();
    }
    return imageState == ImageState.LOADED;
  };
  LayerRenderer2.prototype.renderIfReadyAndVisible = function() {
    var layer = this.getLayer();
    if (layer.getVisible() && layer.getSourceState() == SourceState.READY) {
      layer.changed();
    }
  };
  LayerRenderer2.prototype.disposeInternal = function() {
    delete this.layer_;
    _super.prototype.disposeInternal.call(this);
  };
  return LayerRenderer2;
}(Observable);
var LayerRenderer$1 = LayerRenderer;
var __extends$1e = globalThis && globalThis.__extends || function() {
  var extendStatics2 = function(d2, b2) {
    extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {
      d3.__proto__ = b3;
    } || function(d3, b3) {
      for (var p5 in b3)
        if (Object.prototype.hasOwnProperty.call(b3, p5))
          d3[p5] = b3[p5];
    };
    return extendStatics2(d2, b2);
  };
  return function(d2, b2) {
    if (typeof b2 !== "function" && b2 !== null)
      throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
    extendStatics2(d2, b2);
    function __() {
      this.constructor = d2;
    }
    d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
  };
}();
var pixelContext$1 = null;
function createPixelContext$1() {
  var canvas = document.createElement("canvas");
  canvas.width = 1;
  canvas.height = 1;
  pixelContext$1 = canvas.getContext("2d");
}
var CanvasLayerRenderer = function(_super) {
  __extends$1e(CanvasLayerRenderer2, _super);
  function CanvasLayerRenderer2(layer) {
    var _this = _super.call(this, layer) || this;
    _this.container = null;
    _this.renderedResolution;
    _this.tempTransform = create$6();
    _this.pixelTransform = create$6();
    _this.inversePixelTransform = create$6();
    _this.context = null;
    _this.containerReused = false;
    _this.pixelContext_ = null;
    _this.frameState = null;
    return _this;
  }
  CanvasLayerRenderer2.prototype.getImageData = function(image2, col, row) {
    if (!pixelContext$1) {
      createPixelContext$1();
    }
    pixelContext$1.clearRect(0, 0, 1, 1);
    var data2;
    try {
      pixelContext$1.drawImage(image2, col, row, 1, 1, 0, 0, 1, 1);
      data2 = pixelContext$1.getImageData(0, 0, 1, 1).data;
    } catch (err) {
      return null;
    }
    return data2;
  };
  CanvasLayerRenderer2.prototype.getBackground = function(frameState) {
    var layer = this.getLayer();
    var background = layer.getBackground();
    if (typeof background === "function") {
      background = background(frameState.viewState.resolution);
    }
    return background || void 0;
  };
  CanvasLayerRenderer2.prototype.useContainer = function(target, transform2, opacity2, opt_backgroundColor) {
    var layerClassName = this.getLayer().getClassName();
    var container, context;
    if (target && target.className === layerClassName && target.style.opacity === "" && opacity2 === 1 && (!opt_backgroundColor || target.style.backgroundColor && equals$2(asArray(target.style.backgroundColor), asArray(opt_backgroundColor)))) {
      var canvas = target.firstElementChild;
      if (canvas instanceof HTMLCanvasElement) {
        context = canvas.getContext("2d");
      }
    }
    if (context && context.canvas.style.transform === transform2) {
      this.container = target;
      this.context = context;
      this.containerReused = true;
    } else if (this.containerReused) {
      this.container = null;
      this.context = null;
      this.containerReused = false;
    }
    if (!this.container) {
      container = document.createElement("div");
      container.className = layerClassName;
      var style2 = container.style;
      style2.position = "absolute";
      style2.width = "100%";
      style2.height = "100%";
      if (opt_backgroundColor) {
        style2.backgroundColor = opt_backgroundColor;
      }
      context = createCanvasContext2D();
      var canvas = context.canvas;
      container.appendChild(canvas);
      style2 = canvas.style;
      style2.position = "absolute";
      style2.left = "0";
      style2.transformOrigin = "top left";
      this.container = container;
      this.context = context;
    }
  };
  CanvasLayerRenderer2.prototype.clipUnrotated = function(context, frameState, extent2) {
    var topLeft = getTopLeft(extent2);
    var topRight = getTopRight(extent2);
    var bottomRight = getBottomRight(extent2);
    var bottomLeft = getBottomLeft(extent2);
    apply$5(frameState.coordinateToPixelTransform, topLeft);
    apply$5(frameState.coordinateToPixelTransform, topRight);
    apply$5(frameState.coordinateToPixelTransform, bottomRight);
    apply$5(frameState.coordinateToPixelTransform, bottomLeft);
    var inverted = this.inversePixelTransform;
    apply$5(inverted, topLeft);
    apply$5(inverted, topRight);
    apply$5(inverted, bottomRight);
    apply$5(inverted, bottomLeft);
    context.save();
    context.beginPath();
    context.moveTo(Math.round(topLeft[0]), Math.round(topLeft[1]));
    context.lineTo(Math.round(topRight[0]), Math.round(topRight[1]));
    context.lineTo(Math.round(bottomRight[0]), Math.round(bottomRight[1]));
    context.lineTo(Math.round(bottomLeft[0]), Math.round(bottomLeft[1]));
    context.clip();
  };
  CanvasLayerRenderer2.prototype.dispatchRenderEvent_ = function(type, context, frameState) {
    var layer = this.getLayer();
    if (layer.hasListener(type)) {
      var event_1 = new RenderEvent$1(type, this.inversePixelTransform, frameState, context);
      layer.dispatchEvent(event_1);
    }
  };
  CanvasLayerRenderer2.prototype.preRender = function(context, frameState) {
    this.frameState = frameState;
    this.dispatchRenderEvent_(RenderEventType.PRERENDER, context, frameState);
  };
  CanvasLayerRenderer2.prototype.postRender = function(context, frameState) {
    this.dispatchRenderEvent_(RenderEventType.POSTRENDER, context, frameState);
  };
  CanvasLayerRenderer2.prototype.getRenderTransform = function(center, resolution, rotation, pixelRatio, width, height, offsetX) {
    var dx1 = width / 2;
    var dy1 = height / 2;
    var sx = pixelRatio / resolution;
    var sy = -sx;
    var dx2 = -center[0] + offsetX;
    var dy2 = -center[1];
    return compose(this.tempTransform, dx1, dy1, sx, sy, -rotation, dx2, dy2);
  };
  CanvasLayerRenderer2.prototype.getDataAtPixel = function(pixel, frameState, hitTolerance) {
    var renderPixel = apply$5(this.inversePixelTransform, pixel.slice());
    var context = this.context;
    var layer = this.getLayer();
    var layerExtent = layer.getExtent();
    if (layerExtent) {
      var renderCoordinate = apply$5(frameState.pixelToCoordinateTransform, pixel.slice());
      if (!containsCoordinate(layerExtent, renderCoordinate)) {
        return null;
      }
    }
    var x2 = Math.round(renderPixel[0]);
    var y2 = Math.round(renderPixel[1]);
    var pixelContext2 = this.pixelContext_;
    if (!pixelContext2) {
      var pixelCanvas = document.createElement("canvas");
      pixelCanvas.width = 1;
      pixelCanvas.height = 1;
      pixelContext2 = pixelCanvas.getContext("2d");
      this.pixelContext_ = pixelContext2;
    }
    pixelContext2.clearRect(0, 0, 1, 1);
    var data2;
    try {
      pixelContext2.drawImage(context.canvas, x2, y2, 1, 1, 0, 0, 1, 1);
      data2 = pixelContext2.getImageData(0, 0, 1, 1).data;
    } catch (err) {
      if (err.name === "SecurityError") {
        this.pixelContext_ = null;
        return new Uint8Array();
      }
      return data2;
    }
    if (data2[3] === 0) {
      return null;
    }
    return data2;
  };
  CanvasLayerRenderer2.prototype.disposeInternal = function() {
    delete this.frameState;
    _super.prototype.disposeInternal.call(this);
  };
  return CanvasLayerRenderer2;
}(LayerRenderer$1);
var CanvasLayerRenderer$1 = CanvasLayerRenderer;
var ReplayType = {
  CIRCLE: "Circle",
  DEFAULT: "Default",
  IMAGE: "Image",
  LINE_STRING: "LineString",
  POLYGON: "Polygon",
  TEXT: "Text"
};
function drawTextOnPath(flatCoordinates, offset2, end, stride, text2, startM, maxAngle, scale2, measureAndCacheTextWidth2, font, cache2, rotation) {
  var x2 = flatCoordinates[offset2];
  var y2 = flatCoordinates[offset2 + 1];
  var x1 = 0;
  var y1 = 0;
  var segmentLength = 0;
  var segmentM = 0;
  function advance() {
    x1 = x2;
    y1 = y2;
    offset2 += stride;
    x2 = flatCoordinates[offset2];
    y2 = flatCoordinates[offset2 + 1];
    segmentM += segmentLength;
    segmentLength = Math.sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1));
  }
  do {
    advance();
  } while (offset2 < end - stride && segmentM + segmentLength < startM);
  var interpolate = segmentLength === 0 ? 0 : (startM - segmentM) / segmentLength;
  var beginX = lerp$1(x1, x2, interpolate);
  var beginY = lerp$1(y1, y2, interpolate);
  var startOffset = offset2 - stride;
  var startLength = segmentM;
  var endM = startM + scale2 * measureAndCacheTextWidth2(font, text2, cache2);
  while (offset2 < end - stride && segmentM + segmentLength < endM) {
    advance();
  }
  interpolate = segmentLength === 0 ? 0 : (endM - segmentM) / segmentLength;
  var endX = lerp$1(x1, x2, interpolate);
  var endY = lerp$1(y1, y2, interpolate);
  var reverse2;
  if (rotation) {
    var flat = [beginX, beginY, endX, endY];
    rotate(flat, 0, 4, 2, rotation, flat, flat);
    reverse2 = flat[0] > flat[2];
  } else {
    reverse2 = beginX > endX;
  }
  var PI = Math.PI;
  var result = [];
  var singleSegment = startOffset + stride === offset2;
  offset2 = startOffset;
  segmentLength = 0;
  segmentM = startLength;
  x2 = flatCoordinates[offset2];
  y2 = flatCoordinates[offset2 + 1];
  var previousAngle;
  if (singleSegment) {
    advance();
    previousAngle = Math.atan2(y2 - y1, x2 - x1);
    if (reverse2) {
      previousAngle += previousAngle > 0 ? -PI : PI;
    }
    var x3 = (endX + beginX) / 2;
    var y3 = (endY + beginY) / 2;
    result[0] = [x3, y3, (endM - startM) / 2, previousAngle, text2];
    return result;
  }
  for (var i2 = 0, ii = text2.length; i2 < ii; ) {
    advance();
    var angle2 = Math.atan2(y2 - y1, x2 - x1);
    if (reverse2) {
      angle2 += angle2 > 0 ? -PI : PI;
    }
    if (previousAngle !== void 0) {
      var delta = angle2 - previousAngle;
      delta += delta > PI ? -2 * PI : delta < -PI ? 2 * PI : 0;
      if (Math.abs(delta) > maxAngle) {
        return null;
      }
    }
    previousAngle = angle2;
    var iStart = i2;
    var charLength = 0;
    for (; i2 < ii; ++i2) {
      var index2 = reverse2 ? ii - i2 - 1 : i2;
      var len = scale2 * measureAndCacheTextWidth2(font, text2[index2], cache2);
      if (offset2 + stride < end && segmentM + segmentLength < startM + charLength + len / 2) {
        break;
      }
      charLength += len;
    }
    if (i2 === iStart) {
      continue;
    }
    var chars2 = reverse2 ? text2.substring(ii - iStart, ii - i2) : text2.substring(iStart, i2);
    interpolate = segmentLength === 0 ? 0 : (startM + charLength / 2 - segmentM) / segmentLength;
    var x3 = lerp$1(x1, x2, interpolate);
    var y3 = lerp$1(y1, y2, interpolate);
    result.push([x3, y3, charLength / 2, angle2, chars2]);
    startM += charLength;
  }
  return result;
}
var tmpExtent = createEmpty();
var p1 = [];
var p2 = [];
var p3 = [];
var p4 = [];
function getDeclutterBox(replayImageOrLabelArgs) {
  return replayImageOrLabelArgs[3].declutterBox;
}
var rtlRegEx = new RegExp("[" + String.fromCharCode(1425) + "-" + String.fromCharCode(2303) + String.fromCharCode(64285) + "-" + String.fromCharCode(65023) + String.fromCharCode(65136) + "-" + String.fromCharCode(65276) + String.fromCharCode(67584) + "-" + String.fromCharCode(69631) + String.fromCharCode(124928) + "-" + String.fromCharCode(126975) + "]");
function horizontalTextAlign(text2, align) {
  if ((align === "start" || align === "end") && !rtlRegEx.test(text2)) {
    align = align === "start" ? "left" : "right";
  }
  return TEXT_ALIGN[align];
}
function createTextChunks(acc, line, i2) {
  if (i2 > 0) {
    acc.push("\n", "");
  }
  acc.push(line, "");
  return acc;
}
var Executor = function() {
  function Executor2(resolution, pixelRatio, overlaps, instructions) {
    this.overlaps = overlaps;
    this.pixelRatio = pixelRatio;
    this.resolution = resolution;
    this.alignFill_;
    this.instructions = instructions.instructions;
    this.coordinates = instructions.coordinates;
    this.coordinateCache_ = {};
    this.renderedTransform_ = create$6();
    this.hitDetectionInstructions = instructions.hitDetectionInstructions;
    this.pixelCoordinates_ = null;
    this.viewRotation_ = 0;
    this.fillStates = instructions.fillStates || {};
    this.strokeStates = instructions.strokeStates || {};
    this.textStates = instructions.textStates || {};
    this.widths_ = {};
    this.labels_ = {};
  }
  Executor2.prototype.createLabel = function(text2, textKey, fillKey, strokeKey) {
    var key = text2 + textKey + fillKey + strokeKey;
    if (this.labels_[key]) {
      return this.labels_[key];
    }
    var strokeState = strokeKey ? this.strokeStates[strokeKey] : null;
    var fillState = fillKey ? this.fillStates[fillKey] : null;
    var textState = this.textStates[textKey];
    var pixelRatio = this.pixelRatio;
    var scale2 = [
      textState.scale[0] * pixelRatio,
      textState.scale[1] * pixelRatio
    ];
    var textIsArray = Array.isArray(text2);
    var align = horizontalTextAlign(textIsArray ? text2[0] : text2, textState.textAlign || defaultTextAlign);
    var strokeWidth = strokeKey && strokeState.lineWidth ? strokeState.lineWidth : 0;
    var chunks = textIsArray ? text2 : text2.split("\n").reduce(createTextChunks, []);
    var _a2 = getTextDimensions(textState, chunks), width = _a2.width, height = _a2.height, widths = _a2.widths, heights = _a2.heights, lineWidths = _a2.lineWidths;
    var renderWidth = width + strokeWidth;
    var contextInstructions = [];
    var w2 = (renderWidth + 2) * scale2[0];
    var h2 = (height + strokeWidth) * scale2[1];
    var label = {
      width: w2 < 0 ? Math.floor(w2) : Math.ceil(w2),
      height: h2 < 0 ? Math.floor(h2) : Math.ceil(h2),
      contextInstructions
    };
    if (scale2[0] != 1 || scale2[1] != 1) {
      contextInstructions.push("scale", scale2);
    }
    if (strokeKey) {
      contextInstructions.push("strokeStyle", strokeState.strokeStyle);
      contextInstructions.push("lineWidth", strokeWidth);
      contextInstructions.push("lineCap", strokeState.lineCap);
      contextInstructions.push("lineJoin", strokeState.lineJoin);
      contextInstructions.push("miterLimit", strokeState.miterLimit);
      var Context2 = WORKER_OFFSCREEN_CANVAS ? OffscreenCanvasRenderingContext2D : CanvasRenderingContext2D;
      if (Context2.prototype.setLineDash) {
        contextInstructions.push("setLineDash", [strokeState.lineDash]);
        contextInstructions.push("lineDashOffset", strokeState.lineDashOffset);
      }
    }
    if (fillKey) {
      contextInstructions.push("fillStyle", fillState.fillStyle);
    }
    contextInstructions.push("textBaseline", "middle");
    contextInstructions.push("textAlign", "center");
    var leftRight = 0.5 - align;
    var x2 = align * renderWidth + leftRight * strokeWidth;
    var strokeInstructions = [];
    var fillInstructions = [];
    var lineHeight2 = 0;
    var lineOffset = 0;
    var widthHeightIndex = 0;
    var lineWidthIndex = 0;
    var previousFont;
    for (var i2 = 0, ii = chunks.length; i2 < ii; i2 += 2) {
      var text_1 = chunks[i2];
      if (text_1 === "\n") {
        lineOffset += lineHeight2;
        lineHeight2 = 0;
        x2 = align * renderWidth + leftRight * strokeWidth;
        ++lineWidthIndex;
        continue;
      }
      var font = chunks[i2 + 1] || textState.font;
      if (font !== previousFont) {
        if (strokeKey) {
          strokeInstructions.push("font", font);
        }
        if (fillKey) {
          fillInstructions.push("font", font);
        }
        previousFont = font;
      }
      lineHeight2 = Math.max(lineHeight2, heights[widthHeightIndex]);
      var fillStrokeArgs = [
        text_1,
        x2 + leftRight * widths[widthHeightIndex] + align * (widths[widthHeightIndex] - lineWidths[lineWidthIndex]),
        0.5 * (strokeWidth + lineHeight2) + lineOffset
      ];
      x2 += widths[widthHeightIndex];
      if (strokeKey) {
        strokeInstructions.push("strokeText", fillStrokeArgs);
      }
      if (fillKey) {
        fillInstructions.push("fillText", fillStrokeArgs);
      }
      ++widthHeightIndex;
    }
    Array.prototype.push.apply(contextInstructions, strokeInstructions);
    Array.prototype.push.apply(contextInstructions, fillInstructions);
    this.labels_[key] = label;
    return label;
  };
  Executor2.prototype.replayTextBackground_ = function(context, p12, p22, p32, p42, fillInstruction2, strokeInstruction2) {
    context.beginPath();
    context.moveTo.apply(context, p12);
    context.lineTo.apply(context, p22);
    context.lineTo.apply(context, p32);
    context.lineTo.apply(context, p42);
    context.lineTo.apply(context, p12);
    if (fillInstruction2) {
      this.alignFill_ = fillInstruction2[2];
      this.fill_(context);
    }
    if (strokeInstruction2) {
      this.setStrokeStyle_(context, strokeInstruction2);
      context.stroke();
    }
  };
  Executor2.prototype.calculateImageOrLabelDimensions_ = function(sheetWidth, sheetHeight, centerX, centerY, width, height, anchorX, anchorY, originX, originY, rotation, scale2, snapToPixel, padding, fillStroke, feature2) {
    anchorX *= scale2[0];
    anchorY *= scale2[1];
    var x2 = centerX - anchorX;
    var y2 = centerY - anchorY;
    var w2 = width + originX > sheetWidth ? sheetWidth - originX : width;
    var h2 = height + originY > sheetHeight ? sheetHeight - originY : height;
    var boxW = padding[3] + w2 * scale2[0] + padding[1];
    var boxH = padding[0] + h2 * scale2[1] + padding[2];
    var boxX = x2 - padding[3];
    var boxY = y2 - padding[0];
    if (fillStroke || rotation !== 0) {
      p1[0] = boxX;
      p4[0] = boxX;
      p1[1] = boxY;
      p2[1] = boxY;
      p2[0] = boxX + boxW;
      p3[0] = p2[0];
      p3[1] = boxY + boxH;
      p4[1] = p3[1];
    }
    var transform2;
    if (rotation !== 0) {
      transform2 = compose(create$6(), centerX, centerY, 1, 1, rotation, -centerX, -centerY);
      apply$5(transform2, p1);
      apply$5(transform2, p2);
      apply$5(transform2, p3);
      apply$5(transform2, p4);
      createOrUpdate$2(Math.min(p1[0], p2[0], p3[0], p4[0]), Math.min(p1[1], p2[1], p3[1], p4[1]), Math.max(p1[0], p2[0], p3[0], p4[0]), Math.max(p1[1], p2[1], p3[1], p4[1]), tmpExtent);
    } else {
      createOrUpdate$2(Math.min(boxX, boxX + boxW), Math.min(boxY, boxY + boxH), Math.max(boxX, boxX + boxW), Math.max(boxY, boxY + boxH), tmpExtent);
    }
    if (snapToPixel) {
      x2 = Math.round(x2);
      y2 = Math.round(y2);
    }
    return {
      drawImageX: x2,
      drawImageY: y2,
      drawImageW: w2,
      drawImageH: h2,
      originX,
      originY,
      declutterBox: {
        minX: tmpExtent[0],
        minY: tmpExtent[1],
        maxX: tmpExtent[2],
        maxY: tmpExtent[3],
        value: feature2
      },
      canvasTransform: transform2,
      scale: scale2
    };
  };
  Executor2.prototype.replayImageOrLabel_ = function(context, contextScale, imageOrLabel, dimensions, opacity2, fillInstruction2, strokeInstruction2) {
    var fillStroke = !!(fillInstruction2 || strokeInstruction2);
    var box = dimensions.declutterBox;
    var canvas = context.canvas;
    var strokePadding = strokeInstruction2 ? strokeInstruction2[2] * dimensions.scale[0] / 2 : 0;
    var intersects2 = box.minX - strokePadding <= canvas.width / contextScale && box.maxX + strokePadding >= 0 && box.minY - strokePadding <= canvas.height / contextScale && box.maxY + strokePadding >= 0;
    if (intersects2) {
      if (fillStroke) {
        this.replayTextBackground_(context, p1, p2, p3, p4, fillInstruction2, strokeInstruction2);
      }
      drawImageOrLabel(context, dimensions.canvasTransform, opacity2, imageOrLabel, dimensions.originX, dimensions.originY, dimensions.drawImageW, dimensions.drawImageH, dimensions.drawImageX, dimensions.drawImageY, dimensions.scale);
    }
    return true;
  };
  Executor2.prototype.fill_ = function(context) {
    if (this.alignFill_) {
      var origin_1 = apply$5(this.renderedTransform_, [0, 0]);
      var repeatSize = 512 * this.pixelRatio;
      context.save();
      context.translate(origin_1[0] % repeatSize, origin_1[1] % repeatSize);
      context.rotate(this.viewRotation_);
    }
    context.fill();
    if (this.alignFill_) {
      context.restore();
    }
  };
  Executor2.prototype.setStrokeStyle_ = function(context, instruction) {
    context["strokeStyle"] = instruction[1];
    context.lineWidth = instruction[2];
    context.lineCap = instruction[3];
    context.lineJoin = instruction[4];
    context.miterLimit = instruction[5];
    if (context.setLineDash) {
      context.lineDashOffset = instruction[7];
      context.setLineDash(instruction[6]);
    }
  };
  Executor2.prototype.drawLabelWithPointPlacement_ = function(text2, textKey, strokeKey, fillKey) {
    var textState = this.textStates[textKey];
    var label = this.createLabel(text2, textKey, fillKey, strokeKey);
    var strokeState = this.strokeStates[strokeKey];
    var pixelRatio = this.pixelRatio;
    var align = horizontalTextAlign(Array.isArray(text2) ? text2[0] : text2, textState.textAlign || defaultTextAlign);
    var baseline = TEXT_ALIGN[textState.textBaseline || defaultTextBaseline];
    var strokeWidth = strokeState && strokeState.lineWidth ? strokeState.lineWidth : 0;
    var width = label.width / pixelRatio - 2 * textState.scale[0];
    var anchorX = align * width + 2 * (0.5 - align) * strokeWidth;
    var anchorY = baseline * label.height / pixelRatio + 2 * (0.5 - baseline) * strokeWidth;
    return {
      label,
      anchorX,
      anchorY
    };
  };
  Executor2.prototype.execute_ = function(context, contextScale, transform2, instructions, snapToPixel, opt_featureCallback, opt_hitExtent, opt_declutterTree) {
    var pixelCoordinates;
    if (this.pixelCoordinates_ && equals$2(transform2, this.renderedTransform_)) {
      pixelCoordinates = this.pixelCoordinates_;
    } else {
      if (!this.pixelCoordinates_) {
        this.pixelCoordinates_ = [];
      }
      pixelCoordinates = transform2D(this.coordinates, 0, this.coordinates.length, 2, transform2, this.pixelCoordinates_);
      setFromArray(this.renderedTransform_, transform2);
    }
    var i2 = 0;
    var ii = instructions.length;
    var d2 = 0;
    var dd;
    var anchorX, anchorY, prevX, prevY, roundX, roundY, image2, text2, textKey, strokeKey, fillKey;
    var pendingFill = 0;
    var pendingStroke = 0;
    var lastFillInstruction = null;
    var lastStrokeInstruction = null;
    var coordinateCache = this.coordinateCache_;
    var viewRotation = this.viewRotation_;
    var viewRotationFromTransform = Math.round(Math.atan2(-transform2[1], transform2[0]) * 1e12) / 1e12;
    var state = {
      context,
      pixelRatio: this.pixelRatio,
      resolution: this.resolution,
      rotation: viewRotation
    };
    var batchSize = this.instructions != instructions || this.overlaps ? 0 : 200;
    var feature2;
    var x2, y2, currentGeometry;
    while (i2 < ii) {
      var instruction = instructions[i2];
      var type = instruction[0];
      switch (type) {
        case CanvasInstruction.BEGIN_GEOMETRY:
          feature2 = instruction[1];
          currentGeometry = instruction[3];
          if (!feature2.getGeometry()) {
            i2 = instruction[2];
          } else if (opt_hitExtent !== void 0 && !intersects$1(opt_hitExtent, currentGeometry.getExtent())) {
            i2 = instruction[2] + 1;
          } else {
            ++i2;
          }
          break;
        case CanvasInstruction.BEGIN_PATH:
          if (pendingFill > batchSize) {
            this.fill_(context);
            pendingFill = 0;
          }
          if (pendingStroke > batchSize) {
            context.stroke();
            pendingStroke = 0;
          }
          if (!pendingFill && !pendingStroke) {
            context.beginPath();
            prevX = NaN;
            prevY = NaN;
          }
          ++i2;
          break;
        case CanvasInstruction.CIRCLE:
          d2 = instruction[1];
          var x1 = pixelCoordinates[d2];
          var y1 = pixelCoordinates[d2 + 1];
          var x22 = pixelCoordinates[d2 + 2];
          var y22 = pixelCoordinates[d2 + 3];
          var dx = x22 - x1;
          var dy = y22 - y1;
          var r2 = Math.sqrt(dx * dx + dy * dy);
          context.moveTo(x1 + r2, y1);
          context.arc(x1, y1, r2, 0, 2 * Math.PI, true);
          ++i2;
          break;
        case CanvasInstruction.CLOSE_PATH:
          context.closePath();
          ++i2;
          break;
        case CanvasInstruction.CUSTOM:
          d2 = instruction[1];
          dd = instruction[2];
          var geometry = instruction[3];
          var renderer = instruction[4];
          var fn = instruction.length == 6 ? instruction[5] : void 0;
          state.geometry = geometry;
          state.feature = feature2;
          if (!(i2 in coordinateCache)) {
            coordinateCache[i2] = [];
          }
          var coords = coordinateCache[i2];
          if (fn) {
            fn(pixelCoordinates, d2, dd, 2, coords);
          } else {
            coords[0] = pixelCoordinates[d2];
            coords[1] = pixelCoordinates[d2 + 1];
            coords.length = 2;
          }
          renderer(coords, state);
          ++i2;
          break;
        case CanvasInstruction.DRAW_IMAGE:
          d2 = instruction[1];
          dd = instruction[2];
          image2 = instruction[3];
          anchorX = instruction[4];
          anchorY = instruction[5];
          var height = instruction[6];
          var opacity2 = instruction[7];
          var originX = instruction[8];
          var originY = instruction[9];
          var rotateWithView = instruction[10];
          var rotation = instruction[11];
          var scale2 = instruction[12];
          var width = instruction[13];
          var declutterImageWithText = instruction[14];
          if (!image2 && instruction.length >= 19) {
            text2 = instruction[18];
            textKey = instruction[19];
            strokeKey = instruction[20];
            fillKey = instruction[21];
            var labelWithAnchor = this.drawLabelWithPointPlacement_(text2, textKey, strokeKey, fillKey);
            image2 = labelWithAnchor.label;
            instruction[3] = image2;
            var textOffsetX = instruction[22];
            anchorX = (labelWithAnchor.anchorX - textOffsetX) * this.pixelRatio;
            instruction[4] = anchorX;
            var textOffsetY = instruction[23];
            anchorY = (labelWithAnchor.anchorY - textOffsetY) * this.pixelRatio;
            instruction[5] = anchorY;
            height = image2.height;
            instruction[6] = height;
            width = image2.width;
            instruction[13] = width;
          }
          var geometryWidths = void 0;
          if (instruction.length > 24) {
            geometryWidths = instruction[24];
          }
          var padding = void 0, backgroundFill = void 0, backgroundStroke = void 0;
          if (instruction.length > 16) {
            padding = instruction[15];
            backgroundFill = instruction[16];
            backgroundStroke = instruction[17];
          } else {
            padding = defaultPadding;
            backgroundFill = false;
            backgroundStroke = false;
          }
          if (rotateWithView && viewRotationFromTransform) {
            rotation += viewRotation;
          } else if (!rotateWithView && !viewRotationFromTransform) {
            rotation -= viewRotation;
          }
          var widthIndex = 0;
          for (; d2 < dd; d2 += 2) {
            if (geometryWidths && geometryWidths[widthIndex++] < width / this.pixelRatio) {
              continue;
            }
            var dimensions = this.calculateImageOrLabelDimensions_(image2.width, image2.height, pixelCoordinates[d2], pixelCoordinates[d2 + 1], width, height, anchorX, anchorY, originX, originY, rotation, scale2, snapToPixel, padding, backgroundFill || backgroundStroke, feature2);
            var args = [
              context,
              contextScale,
              image2,
              dimensions,
              opacity2,
              backgroundFill ? lastFillInstruction : null,
              backgroundStroke ? lastStrokeInstruction : null
            ];
            var imageArgs = void 0;
            var imageDeclutterBox = void 0;
            if (opt_declutterTree && declutterImageWithText) {
              var index2 = dd - d2;
              if (!declutterImageWithText[index2]) {
                declutterImageWithText[index2] = args;
                continue;
              }
              imageArgs = declutterImageWithText[index2];
              delete declutterImageWithText[index2];
              imageDeclutterBox = getDeclutterBox(imageArgs);
              if (opt_declutterTree.collides(imageDeclutterBox)) {
                continue;
              }
            }
            if (opt_declutterTree && opt_declutterTree.collides(dimensions.declutterBox)) {
              continue;
            }
            if (imageArgs) {
              if (opt_declutterTree) {
                opt_declutterTree.insert(imageDeclutterBox);
              }
              this.replayImageOrLabel_.apply(this, imageArgs);
            }
            if (opt_declutterTree) {
              opt_declutterTree.insert(dimensions.declutterBox);
            }
            this.replayImageOrLabel_.apply(this, args);
          }
          ++i2;
          break;
        case CanvasInstruction.DRAW_CHARS:
          var begin = instruction[1];
          var end = instruction[2];
          var baseline = instruction[3];
          var overflow2 = instruction[4];
          fillKey = instruction[5];
          var maxAngle = instruction[6];
          var measurePixelRatio = instruction[7];
          var offsetY = instruction[8];
          strokeKey = instruction[9];
          var strokeWidth = instruction[10];
          text2 = instruction[11];
          textKey = instruction[12];
          var pixelRatioScale = [
            instruction[13],
            instruction[13]
          ];
          var textState = this.textStates[textKey];
          var font = textState.font;
          var textScale = [
            textState.scale[0] * measurePixelRatio,
            textState.scale[1] * measurePixelRatio
          ];
          var cachedWidths = void 0;
          if (font in this.widths_) {
            cachedWidths = this.widths_[font];
          } else {
            cachedWidths = {};
            this.widths_[font] = cachedWidths;
          }
          var pathLength = lineStringLength(pixelCoordinates, begin, end, 2);
          var textLength = Math.abs(textScale[0]) * measureAndCacheTextWidth(font, text2, cachedWidths);
          if (overflow2 || textLength <= pathLength) {
            var textAlign2 = this.textStates[textKey].textAlign;
            var startM = (pathLength - textLength) * TEXT_ALIGN[textAlign2];
            var parts = drawTextOnPath(pixelCoordinates, begin, end, 2, text2, startM, maxAngle, Math.abs(textScale[0]), measureAndCacheTextWidth, font, cachedWidths, viewRotationFromTransform ? 0 : this.viewRotation_);
            drawChars:
              if (parts) {
                var replayImageOrLabelArgs = [];
                var c2 = void 0, cc = void 0, chars2 = void 0, label = void 0, part = void 0;
                if (strokeKey) {
                  for (c2 = 0, cc = parts.length; c2 < cc; ++c2) {
                    part = parts[c2];
                    chars2 = part[4];
                    label = this.createLabel(chars2, textKey, "", strokeKey);
                    anchorX = part[2] + (textScale[0] < 0 ? -strokeWidth : strokeWidth);
                    anchorY = baseline * label.height + (0.5 - baseline) * 2 * strokeWidth * textScale[1] / textScale[0] - offsetY;
                    var dimensions = this.calculateImageOrLabelDimensions_(label.width, label.height, part[0], part[1], label.width, label.height, anchorX, anchorY, 0, 0, part[3], pixelRatioScale, false, defaultPadding, false, feature2);
                    if (opt_declutterTree && opt_declutterTree.collides(dimensions.declutterBox)) {
                      break drawChars;
                    }
                    replayImageOrLabelArgs.push([
                      context,
                      contextScale,
                      label,
                      dimensions,
                      1,
                      null,
                      null
                    ]);
                  }
                }
                if (fillKey) {
                  for (c2 = 0, cc = parts.length; c2 < cc; ++c2) {
                    part = parts[c2];
                    chars2 = part[4];
                    label = this.createLabel(chars2, textKey, fillKey, "");
                    anchorX = part[2];
                    anchorY = baseline * label.height - offsetY;
                    var dimensions = this.calculateImageOrLabelDimensions_(label.width, label.height, part[0], part[1], label.width, label.height, anchorX, anchorY, 0, 0, part[3], pixelRatioScale, false, defaultPadding, false, feature2);
                    if (opt_declutterTree && opt_declutterTree.collides(dimensions.declutterBox)) {
                      break drawChars;
                    }
                    replayImageOrLabelArgs.push([
                      context,
                      contextScale,
                      label,
                      dimensions,
                      1,
                      null,
                      null
                    ]);
                  }
                }
                if (opt_declutterTree) {
                  opt_declutterTree.load(replayImageOrLabelArgs.map(getDeclutterBox));
                }
                for (var i_1 = 0, ii_1 = replayImageOrLabelArgs.length; i_1 < ii_1; ++i_1) {
                  this.replayImageOrLabel_.apply(this, replayImageOrLabelArgs[i_1]);
                }
              }
          }
          ++i2;
          break;
        case CanvasInstruction.END_GEOMETRY:
          if (opt_featureCallback !== void 0) {
            feature2 = instruction[1];
            var result = opt_featureCallback(feature2, currentGeometry);
            if (result) {
              return result;
            }
          }
          ++i2;
          break;
        case CanvasInstruction.FILL:
          if (batchSize) {
            pendingFill++;
          } else {
            this.fill_(context);
          }
          ++i2;
          break;
        case CanvasInstruction.MOVE_TO_LINE_TO:
          d2 = instruction[1];
          dd = instruction[2];
          x2 = pixelCoordinates[d2];
          y2 = pixelCoordinates[d2 + 1];
          roundX = x2 + 0.5 | 0;
          roundY = y2 + 0.5 | 0;
          if (roundX !== prevX || roundY !== prevY) {
            context.moveTo(x2, y2);
            prevX = roundX;
            prevY = roundY;
          }
          for (d2 += 2; d2 < dd; d2 += 2) {
            x2 = pixelCoordinates[d2];
            y2 = pixelCoordinates[d2 + 1];
            roundX = x2 + 0.5 | 0;
            roundY = y2 + 0.5 | 0;
            if (d2 == dd - 2 || roundX !== prevX || roundY !== prevY) {
              context.lineTo(x2, y2);
              prevX = roundX;
              prevY = roundY;
            }
          }
          ++i2;
          break;
        case CanvasInstruction.SET_FILL_STYLE:
          lastFillInstruction = instruction;
          this.alignFill_ = instruction[2];
          if (pendingFill) {
            this.fill_(context);
            pendingFill = 0;
            if (pendingStroke) {
              context.stroke();
              pendingStroke = 0;
            }
          }
          context.fillStyle = instruction[1];
          ++i2;
          break;
        case CanvasInstruction.SET_STROKE_STYLE:
          lastStrokeInstruction = instruction;
          if (pendingStroke) {
            context.stroke();
            pendingStroke = 0;
          }
          this.setStrokeStyle_(context, instruction);
          ++i2;
          break;
        case CanvasInstruction.STROKE:
          if (batchSize) {
            pendingStroke++;
          } else {
            context.stroke();
          }
          ++i2;
          break;
        default:
          ++i2;
          break;
      }
    }
    if (pendingFill) {
      this.fill_(context);
    }
    if (pendingStroke) {
      context.stroke();
    }
    return void 0;
  };
  Executor2.prototype.execute = function(context, contextScale, transform2, viewRotation, snapToPixel, opt_declutterTree) {
    this.viewRotation_ = viewRotation;
    this.execute_(context, contextScale, transform2, this.instructions, snapToPixel, void 0, void 0, opt_declutterTree);
  };
  Executor2.prototype.executeHitDetection = function(context, transform2, viewRotation, opt_featureCallback, opt_hitExtent) {
    this.viewRotation_ = viewRotation;
    return this.execute_(context, 1, transform2, this.hitDetectionInstructions, true, opt_featureCallback, opt_hitExtent);
  };
  return Executor2;
}();
var Executor$1 = Executor;
var ORDER = [
  ReplayType.POLYGON,
  ReplayType.CIRCLE,
  ReplayType.LINE_STRING,
  ReplayType.IMAGE,
  ReplayType.TEXT,
  ReplayType.DEFAULT
];
var ExecutorGroup = function() {
  function ExecutorGroup2(maxExtent, resolution, pixelRatio, overlaps, allInstructions, opt_renderBuffer) {
    this.maxExtent_ = maxExtent;
    this.overlaps_ = overlaps;
    this.pixelRatio_ = pixelRatio;
    this.resolution_ = resolution;
    this.renderBuffer_ = opt_renderBuffer;
    this.executorsByZIndex_ = {};
    this.hitDetectionContext_ = null;
    this.hitDetectionTransform_ = create$6();
    this.createExecutors_(allInstructions);
  }
  ExecutorGroup2.prototype.clip = function(context, transform2) {
    var flatClipCoords = this.getClipCoords(transform2);
    context.beginPath();
    context.moveTo(flatClipCoords[0], flatClipCoords[1]);
    context.lineTo(flatClipCoords[2], flatClipCoords[3]);
    context.lineTo(flatClipCoords[4], flatClipCoords[5]);
    context.lineTo(flatClipCoords[6], flatClipCoords[7]);
    context.clip();
  };
  ExecutorGroup2.prototype.createExecutors_ = function(allInstructions) {
    for (var zIndex2 in allInstructions) {
      var executors = this.executorsByZIndex_[zIndex2];
      if (executors === void 0) {
        executors = {};
        this.executorsByZIndex_[zIndex2] = executors;
      }
      var instructionByZindex = allInstructions[zIndex2];
      for (var builderType in instructionByZindex) {
        var instructions = instructionByZindex[builderType];
        executors[builderType] = new Executor$1(this.resolution_, this.pixelRatio_, this.overlaps_, instructions);
      }
    }
  };
  ExecutorGroup2.prototype.hasExecutors = function(executors) {
    for (var zIndex2 in this.executorsByZIndex_) {
      var candidates = this.executorsByZIndex_[zIndex2];
      for (var i2 = 0, ii = executors.length; i2 < ii; ++i2) {
        if (executors[i2] in candidates) {
          return true;
        }
      }
    }
    return false;
  };
  ExecutorGroup2.prototype.forEachFeatureAtCoordinate = function(coordinate, resolution, rotation, hitTolerance, callback, declutteredFeatures) {
    hitTolerance = Math.round(hitTolerance);
    var contextSize = hitTolerance * 2 + 1;
    var transform2 = compose(this.hitDetectionTransform_, hitTolerance + 0.5, hitTolerance + 0.5, 1 / resolution, -1 / resolution, -rotation, -coordinate[0], -coordinate[1]);
    var newContext = !this.hitDetectionContext_;
    if (newContext) {
      this.hitDetectionContext_ = createCanvasContext2D(contextSize, contextSize);
    }
    var context = this.hitDetectionContext_;
    if (context.canvas.width !== contextSize || context.canvas.height !== contextSize) {
      context.canvas.width = contextSize;
      context.canvas.height = contextSize;
    } else if (!newContext) {
      context.clearRect(0, 0, contextSize, contextSize);
    }
    var hitExtent;
    if (this.renderBuffer_ !== void 0) {
      hitExtent = createEmpty();
      extendCoordinate(hitExtent, coordinate);
      buffer$1(hitExtent, resolution * (this.renderBuffer_ + hitTolerance), hitExtent);
    }
    var indexes = getPixelIndexArray(hitTolerance);
    var builderType;
    function featureCallback(feature2, geometry) {
      var imageData = context.getImageData(0, 0, contextSize, contextSize).data;
      for (var i_1 = 0, ii = indexes.length; i_1 < ii; i_1++) {
        if (imageData[indexes[i_1]] > 0) {
          if (!declutteredFeatures || builderType !== ReplayType.IMAGE && builderType !== ReplayType.TEXT || declutteredFeatures.indexOf(feature2) !== -1) {
            var idx = (indexes[i_1] - 3) / 4;
            var x2 = hitTolerance - idx % contextSize;
            var y2 = hitTolerance - (idx / contextSize | 0);
            var result_1 = callback(feature2, geometry, x2 * x2 + y2 * y2);
            if (result_1) {
              return result_1;
            }
          }
          context.clearRect(0, 0, contextSize, contextSize);
          break;
        }
      }
      return void 0;
    }
    var zs = Object.keys(this.executorsByZIndex_).map(Number);
    zs.sort(numberSafeCompareFunction);
    var i2, j2, executors, executor, result;
    for (i2 = zs.length - 1; i2 >= 0; --i2) {
      var zIndexKey = zs[i2].toString();
      executors = this.executorsByZIndex_[zIndexKey];
      for (j2 = ORDER.length - 1; j2 >= 0; --j2) {
        builderType = ORDER[j2];
        executor = executors[builderType];
        if (executor !== void 0) {
          result = executor.executeHitDetection(context, transform2, rotation, featureCallback, hitExtent);
          if (result) {
            return result;
          }
        }
      }
    }
    return void 0;
  };
  ExecutorGroup2.prototype.getClipCoords = function(transform2) {
    var maxExtent = this.maxExtent_;
    if (!maxExtent) {
      return null;
    }
    var minX = maxExtent[0];
    var minY = maxExtent[1];
    var maxX = maxExtent[2];
    var maxY = maxExtent[3];
    var flatClipCoords = [minX, minY, minX, maxY, maxX, maxY, maxX, minY];
    transform2D(flatClipCoords, 0, 8, 2, transform2, flatClipCoords);
    return flatClipCoords;
  };
  ExecutorGroup2.prototype.isEmpty = function() {
    return isEmpty(this.executorsByZIndex_);
  };
  ExecutorGroup2.prototype.execute = function(context, contextScale, transform2, viewRotation, snapToPixel, opt_builderTypes, opt_declutterTree) {
    var zs = Object.keys(this.executorsByZIndex_).map(Number);
    zs.sort(numberSafeCompareFunction);
    if (this.maxExtent_) {
      context.save();
      this.clip(context, transform2);
    }
    var builderTypes = opt_builderTypes ? opt_builderTypes : ORDER;
    var i2, ii, j2, jj, replays, replay;
    if (opt_declutterTree) {
      zs.reverse();
    }
    for (i2 = 0, ii = zs.length; i2 < ii; ++i2) {
      var zIndexKey = zs[i2].toString();
      replays = this.executorsByZIndex_[zIndexKey];
      for (j2 = 0, jj = builderTypes.length; j2 < jj; ++j2) {
        var builderType = builderTypes[j2];
        replay = replays[builderType];
        if (replay !== void 0) {
          replay.execute(context, contextScale, transform2, viewRotation, snapToPixel, opt_declutterTree);
        }
      }
    }
    if (this.maxExtent_) {
      context.restore();
    }
  };
  return ExecutorGroup2;
}();
var circlePixelIndexArrayCache = {};
function getPixelIndexArray(radius) {
  if (circlePixelIndexArrayCache[radius] !== void 0) {
    return circlePixelIndexArrayCache[radius];
  }
  var size = radius * 2 + 1;
  var maxDistanceSq = radius * radius;
  var distances = new Array(maxDistanceSq + 1);
  for (var i2 = 0; i2 <= radius; ++i2) {
    for (var j2 = 0; j2 <= radius; ++j2) {
      var distanceSq = i2 * i2 + j2 * j2;
      if (distanceSq > maxDistanceSq) {
        break;
      }
      var distance2 = distances[distanceSq];
      if (!distance2) {
        distance2 = [];
        distances[distanceSq] = distance2;
      }
      distance2.push(((radius + i2) * size + (radius + j2)) * 4 + 3);
      if (i2 > 0) {
        distance2.push(((radius - i2) * size + (radius + j2)) * 4 + 3);
      }
      if (j2 > 0) {
        distance2.push(((radius + i2) * size + (radius - j2)) * 4 + 3);
        if (i2 > 0) {
          distance2.push(((radius - i2) * size + (radius - j2)) * 4 + 3);
        }
      }
    }
  }
  var pixelIndex = [];
  for (var i2 = 0, ii = distances.length; i2 < ii; ++i2) {
    if (distances[i2]) {
      pixelIndex.push.apply(pixelIndex, distances[i2]);
    }
  }
  circlePixelIndexArrayCache[radius] = pixelIndex;
  return pixelIndex;
}
var CanvasExecutorGroup = ExecutorGroup;
var __extends$1d = globalThis && globalThis.__extends || function() {
  var extendStatics2 = function(d2, b2) {
    extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {
      d3.__proto__ = b3;
    } || function(d3, b3) {
      for (var p5 in b3)
        if (Object.prototype.hasOwnProperty.call(b3, p5))
          d3[p5] = b3[p5];
    };
    return extendStatics2(d2, b2);
  };
  return function(d2, b2) {
    if (typeof b2 !== "function" && b2 !== null)
      throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
    extendStatics2(d2, b2);
    function __() {
      this.constructor = d2;
    }
    d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
  };
}();
var CanvasImmediateRenderer = function(_super) {
  __extends$1d(CanvasImmediateRenderer2, _super);
  function CanvasImmediateRenderer2(context, pixelRatio, extent2, transform2, viewRotation, opt_squaredTolerance, opt_userTransform) {
    var _this = _super.call(this) || this;
    _this.context_ = context;
    _this.pixelRatio_ = pixelRatio;
    _this.extent_ = extent2;
    _this.transform_ = transform2;
    _this.viewRotation_ = viewRotation;
    _this.squaredTolerance_ = opt_squaredTolerance;
    _this.userTransform_ = opt_userTransform;
    _this.contextFillState_ = null;
    _this.contextStrokeState_ = null;
    _this.contextTextState_ = null;
    _this.fillState_ = null;
    _this.strokeState_ = null;
    _this.image_ = null;
    _this.imageAnchorX_ = 0;
    _this.imageAnchorY_ = 0;
    _this.imageHeight_ = 0;
    _this.imageOpacity_ = 0;
    _this.imageOriginX_ = 0;
    _this.imageOriginY_ = 0;
    _this.imageRotateWithView_ = false;
    _this.imageRotation_ = 0;
    _this.imageScale_ = [0, 0];
    _this.imageWidth_ = 0;
    _this.text_ = "";
    _this.textOffsetX_ = 0;
    _this.textOffsetY_ = 0;
    _this.textRotateWithView_ = false;
    _this.textRotation_ = 0;
    _this.textScale_ = [0, 0];
    _this.textFillState_ = null;
    _this.textStrokeState_ = null;
    _this.textState_ = null;
    _this.pixelCoordinates_ = [];
    _this.tmpLocalTransform_ = create$6();
    return _this;
  }
  CanvasImmediateRenderer2.prototype.drawImages_ = function(flatCoordinates, offset2, end, stride) {
    if (!this.image_) {
      return;
    }
    var pixelCoordinates = transform2D(flatCoordinates, offset2, end, stride, this.transform_, this.pixelCoordinates_);
    var context = this.context_;
    var localTransform = this.tmpLocalTransform_;
    var alpha = context.globalAlpha;
    if (this.imageOpacity_ != 1) {
      context.globalAlpha = alpha * this.imageOpacity_;
    }
    var rotation = this.imageRotation_;
    if (this.imageRotateWithView_) {
      rotation += this.viewRotation_;
    }
    for (var i2 = 0, ii = pixelCoordinates.length; i2 < ii; i2 += 2) {
      var x2 = pixelCoordinates[i2] - this.imageAnchorX_;
      var y2 = pixelCoordinates[i2 + 1] - this.imageAnchorY_;
      if (rotation !== 0 || this.imageScale_[0] != 1 || this.imageScale_[1] != 1) {
        var centerX = x2 + this.imageAnchorX_;
        var centerY = y2 + this.imageAnchorY_;
        compose(localTransform, centerX, centerY, 1, 1, rotation, -centerX, -centerY);
        context.setTransform.apply(context, localTransform);
        context.translate(centerX, centerY);
        context.scale(this.imageScale_[0], this.imageScale_[1]);
        context.drawImage(this.image_, this.imageOriginX_, this.imageOriginY_, this.imageWidth_, this.imageHeight_, -this.imageAnchorX_, -this.imageAnchorY_, this.imageWidth_, this.imageHeight_);
        context.setTransform(1, 0, 0, 1, 0, 0);
      } else {
        context.drawImage(this.image_, this.imageOriginX_, this.imageOriginY_, this.imageWidth_, this.imageHeight_, x2, y2, this.imageWidth_, this.imageHeight_);
      }
    }
    if (this.imageOpacity_ != 1) {
      context.globalAlpha = alpha;
    }
  };
  CanvasImmediateRenderer2.prototype.drawText_ = function(flatCoordinates, offset2, end, stride) {
    if (!this.textState_ || this.text_ === "") {
      return;
    }
    if (this.textFillState_) {
      this.setContextFillState_(this.textFillState_);
    }
    if (this.textStrokeState_) {
      this.setContextStrokeState_(this.textStrokeState_);
    }
    this.setContextTextState_(this.textState_);
    var pixelCoordinates = transform2D(flatCoordinates, offset2, end, stride, this.transform_, this.pixelCoordinates_);
    var context = this.context_;
    var rotation = this.textRotation_;
    if (this.textRotateWithView_) {
      rotation += this.viewRotation_;
    }
    for (; offset2 < end; offset2 += stride) {
      var x2 = pixelCoordinates[offset2] + this.textOffsetX_;
      var y2 = pixelCoordinates[offset2 + 1] + this.textOffsetY_;
      if (rotation !== 0 || this.textScale_[0] != 1 || this.textScale_[1] != 1) {
        var localTransform = compose(this.tmpLocalTransform_, x2, y2, 1, 1, rotation, -x2, -y2);
        context.setTransform.apply(context, localTransform);
        context.translate(x2, y2);
        context.scale(this.textScale_[0], this.textScale_[1]);
        if (this.textStrokeState_) {
          context.strokeText(this.text_, 0, 0);
        }
        if (this.textFillState_) {
          context.fillText(this.text_, 0, 0);
        }
        context.setTransform(1, 0, 0, 1, 0, 0);
      } else {
        if (this.textStrokeState_) {
          context.strokeText(this.text_, x2, y2);
        }
        if (this.textFillState_) {
          context.fillText(this.text_, x2, y2);
        }
      }
    }
  };
  CanvasImmediateRenderer2.prototype.moveToLineTo_ = function(flatCoordinates, offset2, end, stride, close) {
    var context = this.context_;
    var pixelCoordinates = transform2D(flatCoordinates, offset2, end, stride, this.transform_, this.pixelCoordinates_);
    context.moveTo(pixelCoordinates[0], pixelCoordinates[1]);
    var length = pixelCoordinates.length;
    if (close) {
      length -= 2;
    }
    for (var i2 = 2; i2 < length; i2 += 2) {
      context.lineTo(pixelCoordinates[i2], pixelCoordinates[i2 + 1]);
    }
    if (close) {
      context.closePath();
    }
    return end;
  };
  CanvasImmediateRenderer2.prototype.drawRings_ = function(flatCoordinates, offset2, ends, stride) {
    for (var i2 = 0, ii = ends.length; i2 < ii; ++i2) {
      offset2 = this.moveToLineTo_(flatCoordinates, offset2, ends[i2], stride, true);
    }
    return offset2;
  };
  CanvasImmediateRenderer2.prototype.drawCircle = function(geometry) {
    if (!intersects$1(this.extent_, geometry.getExtent())) {
      return;
    }
    if (this.fillState_ || this.strokeState_) {
      if (this.fillState_) {
        this.setContextFillState_(this.fillState_);
      }
      if (this.strokeState_) {
        this.setContextStrokeState_(this.strokeState_);
      }
      var pixelCoordinates = transformGeom2D(geometry, this.transform_, this.pixelCoordinates_);
      var dx = pixelCoordinates[2] - pixelCoordinates[0];
      var dy = pixelCoordinates[3] - pixelCoordinates[1];
      var radius = Math.sqrt(dx * dx + dy * dy);
      var context = this.context_;
      context.beginPath();
      context.arc(pixelCoordinates[0], pixelCoordinates[1], radius, 0, 2 * Math.PI);
      if (this.fillState_) {
        context.fill();
      }
      if (this.strokeState_) {
        context.stroke();
      }
    }
    if (this.text_ !== "") {
      this.drawText_(geometry.getCenter(), 0, 2, 2);
    }
  };
  CanvasImmediateRenderer2.prototype.setStyle = function(style2) {
    this.setFillStrokeStyle(style2.getFill(), style2.getStroke());
    this.setImageStyle(style2.getImage());
    this.setTextStyle(style2.getText());
  };
  CanvasImmediateRenderer2.prototype.setTransform = function(transform2) {
    this.transform_ = transform2;
  };
  CanvasImmediateRenderer2.prototype.drawGeometry = function(geometry) {
    var type = geometry.getType();
    switch (type) {
      case GeometryType.POINT:
        this.drawPoint(geometry);
        break;
      case GeometryType.LINE_STRING:
        this.drawLineString(geometry);
        break;
      case GeometryType.POLYGON:
        this.drawPolygon(geometry);
        break;
      case GeometryType.MULTI_POINT:
        this.drawMultiPoint(geometry);
        break;
      case GeometryType.MULTI_LINE_STRING:
        this.drawMultiLineString(geometry);
        break;
      case GeometryType.MULTI_POLYGON:
        this.drawMultiPolygon(geometry);
        break;
      case GeometryType.GEOMETRY_COLLECTION:
        this.drawGeometryCollection(geometry);
        break;
      case GeometryType.CIRCLE:
        this.drawCircle(geometry);
        break;
    }
  };
  CanvasImmediateRenderer2.prototype.drawFeature = function(feature2, style2) {
    var geometry = style2.getGeometryFunction()(feature2);
    if (!geometry || !intersects$1(this.extent_, geometry.getExtent())) {
      return;
    }
    this.setStyle(style2);
    this.drawGeometry(geometry);
  };
  CanvasImmediateRenderer2.prototype.drawGeometryCollection = function(geometry) {
    var geometries = geometry.getGeometriesArray();
    for (var i2 = 0, ii = geometries.length; i2 < ii; ++i2) {
      this.drawGeometry(geometries[i2]);
    }
  };
  CanvasImmediateRenderer2.prototype.drawPoint = function(geometry) {
    if (this.squaredTolerance_) {
      geometry = geometry.simplifyTransformed(this.squaredTolerance_, this.userTransform_);
    }
    var flatCoordinates = geometry.getFlatCoordinates();
    var stride = geometry.getStride();
    if (this.image_) {
      this.drawImages_(flatCoordinates, 0, flatCoordinates.length, stride);
    }
    if (this.text_ !== "") {
      this.drawText_(flatCoordinates, 0, flatCoordinates.length, stride);
    }
  };
  CanvasImmediateRenderer2.prototype.drawMultiPoint = function(geometry) {
    if (this.squaredTolerance_) {
      geometry = geometry.simplifyTransformed(this.squaredTolerance_, this.userTransform_);
    }
    var flatCoordinates = geometry.getFlatCoordinates();
    var stride = geometry.getStride();
    if (this.image_) {
      this.drawImages_(flatCoordinates, 0, flatCoordinates.length, stride);
    }
    if (this.text_ !== "") {
      this.drawText_(flatCoordinates, 0, flatCoordinates.length, stride);
    }
  };
  CanvasImmediateRenderer2.prototype.drawLineString = function(geometry) {
    if (this.squaredTolerance_) {
      geometry = geometry.simplifyTransformed(this.squaredTolerance_, this.userTransform_);
    }
    if (!intersects$1(this.extent_, geometry.getExtent())) {
      return;
    }
    if (this.strokeState_) {
      this.setContextStrokeState_(this.strokeState_);
      var context = this.context_;
      var flatCoordinates = geometry.getFlatCoordinates();
      context.beginPath();
      this.moveToLineTo_(flatCoordinates, 0, flatCoordinates.length, geometry.getStride(), false);
      context.stroke();
    }
    if (this.text_ !== "") {
      var flatMidpoint = geometry.getFlatMidpoint();
      this.drawText_(flatMidpoint, 0, 2, 2);
    }
  };
  CanvasImmediateRenderer2.prototype.drawMultiLineString = function(geometry) {
    if (this.squaredTolerance_) {
      geometry = geometry.simplifyTransformed(this.squaredTolerance_, this.userTransform_);
    }
    var geometryExtent = geometry.getExtent();
    if (!intersects$1(this.extent_, geometryExtent)) {
      return;
    }
    if (this.strokeState_) {
      this.setContextStrokeState_(this.strokeState_);
      var context = this.context_;
      var flatCoordinates = geometry.getFlatCoordinates();
      var offset2 = 0;
      var ends = geometry.getEnds();
      var stride = geometry.getStride();
      context.beginPath();
      for (var i2 = 0, ii = ends.length; i2 < ii; ++i2) {
        offset2 = this.moveToLineTo_(flatCoordinates, offset2, ends[i2], stride, false);
      }
      context.stroke();
    }
    if (this.text_ !== "") {
      var flatMidpoints = geometry.getFlatMidpoints();
      this.drawText_(flatMidpoints, 0, flatMidpoints.length, 2);
    }
  };
  CanvasImmediateRenderer2.prototype.drawPolygon = function(geometry) {
    if (this.squaredTolerance_) {
      geometry = geometry.simplifyTransformed(this.squaredTolerance_, this.userTransform_);
    }
    if (!intersects$1(this.extent_, geometry.getExtent())) {
      return;
    }
    if (this.strokeState_ || this.fillState_) {
      if (this.fillState_) {
        this.setContextFillState_(this.fillState_);
      }
      if (this.strokeState_) {
        this.setContextStrokeState_(this.strokeState_);
      }
      var context = this.context_;
      context.beginPath();
      this.drawRings_(geometry.getOrientedFlatCoordinates(), 0, geometry.getEnds(), geometry.getStride());
      if (this.fillState_) {
        context.fill();
      }
      if (this.strokeState_) {
        context.stroke();
      }
    }
    if (this.text_ !== "") {
      var flatInteriorPoint = geometry.getFlatInteriorPoint();
      this.drawText_(flatInteriorPoint, 0, 2, 2);
    }
  };
  CanvasImmediateRenderer2.prototype.drawMultiPolygon = function(geometry) {
    if (this.squaredTolerance_) {
      geometry = geometry.simplifyTransformed(this.squaredTolerance_, this.userTransform_);
    }
    if (!intersects$1(this.extent_, geometry.getExtent())) {
      return;
    }
    if (this.strokeState_ || this.fillState_) {
      if (this.fillState_) {
        this.setContextFillState_(this.fillState_);
      }
      if (this.strokeState_) {
        this.setContextStrokeState_(this.strokeState_);
      }
      var context = this.context_;
      var flatCoordinates = geometry.getOrientedFlatCoordinates();
      var offset2 = 0;
      var endss = geometry.getEndss();
      var stride = geometry.getStride();
      context.beginPath();
      for (var i2 = 0, ii = endss.length; i2 < ii; ++i2) {
        var ends = endss[i2];
        offset2 = this.drawRings_(flatCoordinates, offset2, ends, stride);
      }
      if (this.fillState_) {
        context.fill();
      }
      if (this.strokeState_) {
        context.stroke();
      }
    }
    if (this.text_ !== "") {
      var flatInteriorPoints = geometry.getFlatInteriorPoints();
      this.drawText_(flatInteriorPoints, 0, flatInteriorPoints.length, 2);
    }
  };
  CanvasImmediateRenderer2.prototype.setContextFillState_ = function(fillState) {
    var context = this.context_;
    var contextFillState = this.contextFillState_;
    if (!contextFillState) {
      context.fillStyle = fillState.fillStyle;
      this.contextFillState_ = {
        fillStyle: fillState.fillStyle
      };
    } else {
      if (contextFillState.fillStyle != fillState.fillStyle) {
        contextFillState.fillStyle = fillState.fillStyle;
        context.fillStyle = fillState.fillStyle;
      }
    }
  };
  CanvasImmediateRenderer2.prototype.setContextStrokeState_ = function(strokeState) {
    var context = this.context_;
    var contextStrokeState = this.contextStrokeState_;
    if (!contextStrokeState) {
      context.lineCap = strokeState.lineCap;
      if (context.setLineDash) {
        context.setLineDash(strokeState.lineDash);
        context.lineDashOffset = strokeState.lineDashOffset;
      }
      context.lineJoin = strokeState.lineJoin;
      context.lineWidth = strokeState.lineWidth;
      context.miterLimit = strokeState.miterLimit;
      context.strokeStyle = strokeState.strokeStyle;
      this.contextStrokeState_ = {
        lineCap: strokeState.lineCap,
        lineDash: strokeState.lineDash,
        lineDashOffset: strokeState.lineDashOffset,
        lineJoin: strokeState.lineJoin,
        lineWidth: strokeState.lineWidth,
        miterLimit: strokeState.miterLimit,
        strokeStyle: strokeState.strokeStyle
      };
    } else {
      if (contextStrokeState.lineCap != strokeState.lineCap) {
        contextStrokeState.lineCap = strokeState.lineCap;
        context.lineCap = strokeState.lineCap;
      }
      if (context.setLineDash) {
        if (!equals$2(contextStrokeState.lineDash, strokeState.lineDash)) {
          context.setLineDash(contextStrokeState.lineDash = strokeState.lineDash);
        }
        if (contextStrokeState.lineDashOffset != strokeState.lineDashOffset) {
          contextStrokeState.lineDashOffset = strokeState.lineDashOffset;
          context.lineDashOffset = strokeState.lineDashOffset;
        }
      }
      if (contextStrokeState.lineJoin != strokeState.lineJoin) {
        contextStrokeState.lineJoin = strokeState.lineJoin;
        context.lineJoin = strokeState.lineJoin;
      }
      if (contextStrokeState.lineWidth != strokeState.lineWidth) {
        contextStrokeState.lineWidth = strokeState.lineWidth;
        context.lineWidth = strokeState.lineWidth;
      }
      if (contextStrokeState.miterLimit != strokeState.miterLimit) {
        contextStrokeState.miterLimit = strokeState.miterLimit;
        context.miterLimit = strokeState.miterLimit;
      }
      if (contextStrokeState.strokeStyle != strokeState.strokeStyle) {
        contextStrokeState.strokeStyle = strokeState.strokeStyle;
        context.strokeStyle = strokeState.strokeStyle;
      }
    }
  };
  CanvasImmediateRenderer2.prototype.setContextTextState_ = function(textState) {
    var context = this.context_;
    var contextTextState = this.contextTextState_;
    var textAlign2 = textState.textAlign ? textState.textAlign : defaultTextAlign;
    if (!contextTextState) {
      context.font = textState.font;
      context.textAlign = textAlign2;
      context.textBaseline = textState.textBaseline;
      this.contextTextState_ = {
        font: textState.font,
        textAlign: textAlign2,
        textBaseline: textState.textBaseline
      };
    } else {
      if (contextTextState.font != textState.font) {
        contextTextState.font = textState.font;
        context.font = textState.font;
      }
      if (contextTextState.textAlign != textAlign2) {
        contextTextState.textAlign = textAlign2;
        context.textAlign = textAlign2;
      }
      if (contextTextState.textBaseline != textState.textBaseline) {
        contextTextState.textBaseline = textState.textBaseline;
        context.textBaseline = textState.textBaseline;
      }
    }
  };
  CanvasImmediateRenderer2.prototype.setFillStrokeStyle = function(fillStyle, strokeStyle) {
    var _this = this;
    if (!fillStyle) {
      this.fillState_ = null;
    } else {
      var fillStyleColor = fillStyle.getColor();
      this.fillState_ = {
        fillStyle: asColorLike(fillStyleColor ? fillStyleColor : defaultFillStyle)
      };
    }
    if (!strokeStyle) {
      this.strokeState_ = null;
    } else {
      var strokeStyleColor = strokeStyle.getColor();
      var strokeStyleLineCap = strokeStyle.getLineCap();
      var strokeStyleLineDash = strokeStyle.getLineDash();
      var strokeStyleLineDashOffset = strokeStyle.getLineDashOffset();
      var strokeStyleLineJoin = strokeStyle.getLineJoin();
      var strokeStyleWidth = strokeStyle.getWidth();
      var strokeStyleMiterLimit = strokeStyle.getMiterLimit();
      var lineDash = strokeStyleLineDash ? strokeStyleLineDash : defaultLineDash;
      this.strokeState_ = {
        lineCap: strokeStyleLineCap !== void 0 ? strokeStyleLineCap : defaultLineCap,
        lineDash: this.pixelRatio_ === 1 ? lineDash : lineDash.map(function(n2) {
          return n2 * _this.pixelRatio_;
        }),
        lineDashOffset: (strokeStyleLineDashOffset ? strokeStyleLineDashOffset : defaultLineDashOffset) * this.pixelRatio_,
        lineJoin: strokeStyleLineJoin !== void 0 ? strokeStyleLineJoin : defaultLineJoin,
        lineWidth: (strokeStyleWidth !== void 0 ? strokeStyleWidth : defaultLineWidth) * this.pixelRatio_,
        miterLimit: strokeStyleMiterLimit !== void 0 ? strokeStyleMiterLimit : defaultMiterLimit,
        strokeStyle: asColorLike(strokeStyleColor ? strokeStyleColor : defaultStrokeStyle)
      };
    }
  };
  CanvasImmediateRenderer2.prototype.setImageStyle = function(imageStyle) {
    var imageSize;
    if (!imageStyle || !(imageSize = imageStyle.getSize())) {
      this.image_ = null;
      return;
    }
    var imageAnchor = imageStyle.getAnchor();
    var imageOrigin = imageStyle.getOrigin();
    this.image_ = imageStyle.getImage(this.pixelRatio_);
    this.imageAnchorX_ = imageAnchor[0] * this.pixelRatio_;
    this.imageAnchorY_ = imageAnchor[1] * this.pixelRatio_;
    this.imageHeight_ = imageSize[1] * this.pixelRatio_;
    this.imageOpacity_ = imageStyle.getOpacity();
    this.imageOriginX_ = imageOrigin[0];
    this.imageOriginY_ = imageOrigin[1];
    this.imageRotateWithView_ = imageStyle.getRotateWithView();
    this.imageRotation_ = imageStyle.getRotation();
    this.imageScale_ = imageStyle.getScaleArray();
    this.imageWidth_ = imageSize[0] * this.pixelRatio_;
  };
  CanvasImmediateRenderer2.prototype.setTextStyle = function(textStyle) {
    if (!textStyle) {
      this.text_ = "";
    } else {
      var textFillStyle = textStyle.getFill();
      if (!textFillStyle) {
        this.textFillState_ = null;
      } else {
        var textFillStyleColor = textFillStyle.getColor();
        this.textFillState_ = {
          fillStyle: asColorLike(textFillStyleColor ? textFillStyleColor : defaultFillStyle)
        };
      }
      var textStrokeStyle = textStyle.getStroke();
      if (!textStrokeStyle) {
        this.textStrokeState_ = null;
      } else {
        var textStrokeStyleColor = textStrokeStyle.getColor();
        var textStrokeStyleLineCap = textStrokeStyle.getLineCap();
        var textStrokeStyleLineDash = textStrokeStyle.getLineDash();
        var textStrokeStyleLineDashOffset = textStrokeStyle.getLineDashOffset();
        var textStrokeStyleLineJoin = textStrokeStyle.getLineJoin();
        var textStrokeStyleWidth = textStrokeStyle.getWidth();
        var textStrokeStyleMiterLimit = textStrokeStyle.getMiterLimit();
        this.textStrokeState_ = {
          lineCap: textStrokeStyleLineCap !== void 0 ? textStrokeStyleLineCap : defaultLineCap,
          lineDash: textStrokeStyleLineDash ? textStrokeStyleLineDash : defaultLineDash,
          lineDashOffset: textStrokeStyleLineDashOffset ? textStrokeStyleLineDashOffset : defaultLineDashOffset,
          lineJoin: textStrokeStyleLineJoin !== void 0 ? textStrokeStyleLineJoin : defaultLineJoin,
          lineWidth: textStrokeStyleWidth !== void 0 ? textStrokeStyleWidth : defaultLineWidth,
          miterLimit: textStrokeStyleMiterLimit !== void 0 ? textStrokeStyleMiterLimit : defaultMiterLimit,
          strokeStyle: asColorLike(textStrokeStyleColor ? textStrokeStyleColor : defaultStrokeStyle)
        };
      }
      var textFont = textStyle.getFont();
      var textOffsetX = textStyle.getOffsetX();
      var textOffsetY = textStyle.getOffsetY();
      var textRotateWithView = textStyle.getRotateWithView();
      var textRotation = textStyle.getRotation();
      var textScale = textStyle.getScaleArray();
      var textText = textStyle.getText();
      var textTextAlign = textStyle.getTextAlign();
      var textTextBaseline = textStyle.getTextBaseline();
      this.textState_ = {
        font: textFont !== void 0 ? textFont : defaultFont,
        textAlign: textTextAlign !== void 0 ? textTextAlign : defaultTextAlign,
        textBaseline: textTextBaseline !== void 0 ? textTextBaseline : defaultTextBaseline
      };
      this.text_ = textText !== void 0 ? Array.isArray(textText) ? textText.reduce(function(acc, t3, i2) {
        return acc += i2 % 2 ? " " : t3;
      }, "") : textText : "";
      this.textOffsetX_ = textOffsetX !== void 0 ? this.pixelRatio_ * textOffsetX : 0;
      this.textOffsetY_ = textOffsetY !== void 0 ? this.pixelRatio_ * textOffsetY : 0;
      this.textRotateWithView_ = textRotateWithView !== void 0 ? textRotateWithView : false;
      this.textRotation_ = textRotation !== void 0 ? textRotation : 0;
      this.textScale_ = [
        this.pixelRatio_ * textScale[0],
        this.pixelRatio_ * textScale[1]
      ];
    }
  };
  return CanvasImmediateRenderer2;
}(VectorContext$1);
var CanvasImmediateRenderer$1 = CanvasImmediateRenderer;
var IconAnchorUnits = {
  FRACTION: "fraction",
  PIXELS: "pixels"
};
var IconOrigin = {
  BOTTOM_LEFT: "bottom-left",
  BOTTOM_RIGHT: "bottom-right",
  TOP_LEFT: "top-left",
  TOP_RIGHT: "top-right"
};
var __extends$1c = globalThis && globalThis.__extends || function() {
  var extendStatics2 = function(d2, b2) {
    extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {
      d3.__proto__ = b3;
    } || function(d3, b3) {
      for (var p5 in b3)
        if (Object.prototype.hasOwnProperty.call(b3, p5))
          d3[p5] = b3[p5];
    };
    return extendStatics2(d2, b2);
  };
  return function(d2, b2) {
    if (typeof b2 !== "function" && b2 !== null)
      throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
    extendStatics2(d2, b2);
    function __() {
      this.constructor = d2;
    }
    d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
  };
}();
var ImageBase = function(_super) {
  __extends$1c(ImageBase2, _super);
  function ImageBase2(extent2, resolution, pixelRatio, state) {
    var _this = _super.call(this) || this;
    _this.extent = extent2;
    _this.pixelRatio_ = pixelRatio;
    _this.resolution = resolution;
    _this.state = state;
    return _this;
  }
  ImageBase2.prototype.changed = function() {
    this.dispatchEvent(EventType.CHANGE);
  };
  ImageBase2.prototype.getExtent = function() {
    return this.extent;
  };
  ImageBase2.prototype.getImage = function() {
    return abstract();
  };
  ImageBase2.prototype.getPixelRatio = function() {
    return this.pixelRatio_;
  };
  ImageBase2.prototype.getResolution = function() {
    return this.resolution;
  };
  ImageBase2.prototype.getState = function() {
    return this.state;
  };
  ImageBase2.prototype.load = function() {
    abstract();
  };
  return ImageBase2;
}(EventTarget);
var ImageBase$1 = ImageBase;
var __extends$1b = globalThis && globalThis.__extends || function() {
  var extendStatics2 = function(d2, b2) {
    extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {
      d3.__proto__ = b3;
    } || function(d3, b3) {
      for (var p5 in b3)
        if (Object.prototype.hasOwnProperty.call(b3, p5))
          d3[p5] = b3[p5];
    };
    return extendStatics2(d2, b2);
  };
  return function(d2, b2) {
    if (typeof b2 !== "function" && b2 !== null)
      throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
    extendStatics2(d2, b2);
    function __() {
      this.constructor = d2;
    }
    d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
  };
}();
var ImageWrapper = function(_super) {
  __extends$1b(ImageWrapper2, _super);
  function ImageWrapper2(extent2, resolution, pixelRatio, src, crossOrigin, imageLoadFunction) {
    var _this = _super.call(this, extent2, resolution, pixelRatio, ImageState.IDLE) || this;
    _this.src_ = src;
    _this.image_ = new Image();
    if (crossOrigin !== null) {
      _this.image_.crossOrigin = crossOrigin;
    }
    _this.unlisten_ = null;
    _this.state = ImageState.IDLE;
    _this.imageLoadFunction_ = imageLoadFunction;
    return _this;
  }
  ImageWrapper2.prototype.getImage = function() {
    return this.image_;
  };
  ImageWrapper2.prototype.handleImageError_ = function() {
    this.state = ImageState.ERROR;
    this.unlistenImage_();
    this.changed();
  };
  ImageWrapper2.prototype.handleImageLoad_ = function() {
    if (this.resolution === void 0) {
      this.resolution = getHeight(this.extent) / this.image_.height;
    }
    this.state = ImageState.LOADED;
    this.unlistenImage_();
    this.changed();
  };
  ImageWrapper2.prototype.load = function() {
    if (this.state == ImageState.IDLE || this.state == ImageState.ERROR) {
      this.state = ImageState.LOADING;
      this.changed();
      this.imageLoadFunction_(this, this.src_);
      this.unlisten_ = listenImage(this.image_, this.handleImageLoad_.bind(this), this.handleImageError_.bind(this));
    }
  };
  ImageWrapper2.prototype.setImage = function(image2) {
    this.image_ = image2;
    this.resolution = getHeight(this.extent) / this.image_.height;
  };
  ImageWrapper2.prototype.unlistenImage_ = function() {
    if (this.unlisten_) {
      this.unlisten_();
      this.unlisten_ = null;
    }
  };
  return ImageWrapper2;
}(ImageBase$1);
function listenImage(image2, loadHandler, errorHandler) {
  var img = image2;
  var listening = true;
  var decoding = false;
  var loaded = false;
  var listenerKeys = [
    listenOnce(img, EventType.LOAD, function() {
      loaded = true;
      if (!decoding) {
        loadHandler();
      }
    })
  ];
  if (img.src && IMAGE_DECODE) {
    decoding = true;
    img.decode().then(function() {
      if (listening) {
        loadHandler();
      }
    }).catch(function(error) {
      if (listening) {
        if (loaded) {
          loadHandler();
        } else {
          errorHandler();
        }
      }
    });
  } else {
    listenerKeys.push(listenOnce(img, EventType.ERROR, errorHandler));
  }
  return function unlisten() {
    listening = false;
    listenerKeys.forEach(unlistenByKey);
  };
}
var ImageWrapper$1 = ImageWrapper;
var __extends$1a = globalThis && globalThis.__extends || function() {
  var extendStatics2 = function(d2, b2) {
    extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {
      d3.__proto__ = b3;
    } || function(d3, b3) {
      for (var p5 in b3)
        if (Object.prototype.hasOwnProperty.call(b3, p5))
          d3[p5] = b3[p5];
    };
    return extendStatics2(d2, b2);
  };
  return function(d2, b2) {
    if (typeof b2 !== "function" && b2 !== null)
      throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
    extendStatics2(d2, b2);
    function __() {
      this.constructor = d2;
    }
    d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
  };
}();
var taintedTestContext = null;
var IconImage = function(_super) {
  __extends$1a(IconImage2, _super);
  function IconImage2(image2, src, size, crossOrigin, imageState, color2) {
    var _this = _super.call(this) || this;
    _this.hitDetectionImage_ = null;
    _this.image_ = !image2 ? new Image() : image2;
    if (crossOrigin !== null) {
      _this.image_.crossOrigin = crossOrigin;
    }
    _this.canvas_ = {};
    _this.color_ = color2;
    _this.unlisten_ = null;
    _this.imageState_ = imageState;
    _this.size_ = size;
    _this.src_ = src;
    _this.tainted_;
    return _this;
  }
  IconImage2.prototype.isTainted_ = function() {
    if (this.tainted_ === void 0 && this.imageState_ === ImageState.LOADED) {
      if (!taintedTestContext) {
        taintedTestContext = createCanvasContext2D(1, 1);
      }
      taintedTestContext.drawImage(this.image_, 0, 0);
      try {
        taintedTestContext.getImageData(0, 0, 1, 1);
        this.tainted_ = false;
      } catch (e2) {
        taintedTestContext = null;
        this.tainted_ = true;
      }
    }
    return this.tainted_ === true;
  };
  IconImage2.prototype.dispatchChangeEvent_ = function() {
    this.dispatchEvent(EventType.CHANGE);
  };
  IconImage2.prototype.handleImageError_ = function() {
    this.imageState_ = ImageState.ERROR;
    this.unlistenImage_();
    this.dispatchChangeEvent_();
  };
  IconImage2.prototype.handleImageLoad_ = function() {
    this.imageState_ = ImageState.LOADED;
    if (this.size_) {
      this.image_.width = this.size_[0];
      this.image_.height = this.size_[1];
    } else {
      this.size_ = [this.image_.width, this.image_.height];
    }
    this.unlistenImage_();
    this.dispatchChangeEvent_();
  };
  IconImage2.prototype.getImage = function(pixelRatio) {
    this.replaceColor_(pixelRatio);
    return this.canvas_[pixelRatio] ? this.canvas_[pixelRatio] : this.image_;
  };
  IconImage2.prototype.getPixelRatio = function(pixelRatio) {
    this.replaceColor_(pixelRatio);
    return this.canvas_[pixelRatio] ? pixelRatio : 1;
  };
  IconImage2.prototype.getImageState = function() {
    return this.imageState_;
  };
  IconImage2.prototype.getHitDetectionImage = function() {
    if (!this.hitDetectionImage_) {
      if (this.isTainted_()) {
        var width = this.size_[0];
        var height = this.size_[1];
        var context = createCanvasContext2D(width, height);
        context.fillRect(0, 0, width, height);
        this.hitDetectionImage_ = context.canvas;
      } else {
        this.hitDetectionImage_ = this.image_;
      }
    }
    return this.hitDetectionImage_;
  };
  IconImage2.prototype.getSize = function() {
    return this.size_;
  };
  IconImage2.prototype.getSrc = function() {
    return this.src_;
  };
  IconImage2.prototype.load = function() {
    if (this.imageState_ == ImageState.IDLE) {
      this.imageState_ = ImageState.LOADING;
      try {
        this.image_.src = this.src_;
      } catch (e2) {
        this.handleImageError_();
      }
      this.unlisten_ = listenImage(this.image_, this.handleImageLoad_.bind(this), this.handleImageError_.bind(this));
    }
  };
  IconImage2.prototype.replaceColor_ = function(pixelRatio) {
    if (!this.color_ || this.canvas_[pixelRatio] || this.imageState_ !== ImageState.LOADED) {
      return;
    }
    var canvas = document.createElement("canvas");
    this.canvas_[pixelRatio] = canvas;
    canvas.width = Math.ceil(this.image_.width * pixelRatio);
    canvas.height = Math.ceil(this.image_.height * pixelRatio);
    var ctx = canvas.getContext("2d");
    ctx.scale(pixelRatio, pixelRatio);
    ctx.drawImage(this.image_, 0, 0);
    ctx.globalCompositeOperation = "multiply";
    if (ctx.globalCompositeOperation === "multiply" || this.isTainted_()) {
      ctx.fillStyle = asString$1(this.color_);
      ctx.fillRect(0, 0, canvas.width / pixelRatio, canvas.height / pixelRatio);
      ctx.globalCompositeOperation = "destination-in";
      ctx.drawImage(this.image_, 0, 0);
    } else {
      var imgData = ctx.getImageData(0, 0, canvas.width, canvas.height);
      var data2 = imgData.data;
      var r2 = this.color_[0] / 255;
      var g2 = this.color_[1] / 255;
      var b2 = this.color_[2] / 255;
      var a2 = this.color_[3];
      for (var i2 = 0, ii = data2.length; i2 < ii; i2 += 4) {
        data2[i2] *= r2;
        data2[i2 + 1] *= g2;
        data2[i2 + 2] *= b2;
        data2[i2 + 3] *= a2;
      }
      ctx.putImageData(imgData, 0, 0);
    }
  };
  IconImage2.prototype.unlistenImage_ = function() {
    if (this.unlisten_) {
      this.unlisten_();
      this.unlisten_ = null;
    }
  };
  return IconImage2;
}(EventTarget);
function get$2(image2, src, size, crossOrigin, imageState, color2) {
  var iconImage = shared$5.get(src, crossOrigin, color2);
  if (!iconImage) {
    iconImage = new IconImage(image2, src, size, crossOrigin, imageState, color2);
    shared$5.set(src, crossOrigin, color2, iconImage);
  }
  return iconImage;
}
var __extends$19 = globalThis && globalThis.__extends || function() {
  var extendStatics2 = function(d2, b2) {
    extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {
      d3.__proto__ = b3;
    } || function(d3, b3) {
      for (var p5 in b3)
        if (Object.prototype.hasOwnProperty.call(b3, p5))
          d3[p5] = b3[p5];
    };
    return extendStatics2(d2, b2);
  };
  return function(d2, b2) {
    if (typeof b2 !== "function" && b2 !== null)
      throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
    extendStatics2(d2, b2);
    function __() {
      this.constructor = d2;
    }
    d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
  };
}();
var Icon$1 = function(_super) {
  __extends$19(Icon2, _super);
  function Icon2(opt_options) {
    var _this = this;
    var options = opt_options || {};
    var opacity2 = options.opacity !== void 0 ? options.opacity : 1;
    var rotation = options.rotation !== void 0 ? options.rotation : 0;
    var scale2 = options.scale !== void 0 ? options.scale : 1;
    var rotateWithView = options.rotateWithView !== void 0 ? options.rotateWithView : false;
    _this = _super.call(this, {
      opacity: opacity2,
      rotation,
      scale: scale2,
      displacement: options.displacement !== void 0 ? options.displacement : [0, 0],
      rotateWithView
    }) || this;
    _this.anchor_ = options.anchor !== void 0 ? options.anchor : [0.5, 0.5];
    _this.normalizedAnchor_ = null;
    _this.anchorOrigin_ = options.anchorOrigin !== void 0 ? options.anchorOrigin : IconOrigin.TOP_LEFT;
    _this.anchorXUnits_ = options.anchorXUnits !== void 0 ? options.anchorXUnits : IconAnchorUnits.FRACTION;
    _this.anchorYUnits_ = options.anchorYUnits !== void 0 ? options.anchorYUnits : IconAnchorUnits.FRACTION;
    _this.crossOrigin_ = options.crossOrigin !== void 0 ? options.crossOrigin : null;
    var image2 = options.img !== void 0 ? options.img : null;
    _this.imgSize_ = options.imgSize;
    var src = options.src;
    assert(!(src !== void 0 && image2), 4);
    assert(!image2 || image2 && _this.imgSize_, 5);
    if ((src === void 0 || src.length === 0) && image2) {
      src = image2.src || getUid(image2);
    }
    assert(src !== void 0 && src.length > 0, 6);
    var imageState = options.src !== void 0 ? ImageState.IDLE : ImageState.LOADED;
    _this.color_ = options.color !== void 0 ? asArray(options.color) : null;
    _this.iconImage_ = get$2(image2, src, _this.imgSize_ !== void 0 ? _this.imgSize_ : null, _this.crossOrigin_, imageState, _this.color_);
    _this.offset_ = options.offset !== void 0 ? options.offset : [0, 0];
    _this.offsetOrigin_ = options.offsetOrigin !== void 0 ? options.offsetOrigin : IconOrigin.TOP_LEFT;
    _this.origin_ = null;
    _this.size_ = options.size !== void 0 ? options.size : null;
    return _this;
  }
  Icon2.prototype.clone = function() {
    var scale2 = this.getScale();
    return new Icon2({
      anchor: this.anchor_.slice(),
      anchorOrigin: this.anchorOrigin_,
      anchorXUnits: this.anchorXUnits_,
      anchorYUnits: this.anchorYUnits_,
      color: this.color_ && this.color_.slice ? this.color_.slice() : this.color_ || void 0,
      crossOrigin: this.crossOrigin_,
      imgSize: this.imgSize_,
      offset: this.offset_.slice(),
      offsetOrigin: this.offsetOrigin_,
      opacity: this.getOpacity(),
      rotateWithView: this.getRotateWithView(),
      rotation: this.getRotation(),
      scale: Array.isArray(scale2) ? scale2.slice() : scale2,
      size: this.size_ !== null ? this.size_.slice() : void 0,
      src: this.getSrc()
    });
  };
  Icon2.prototype.getAnchor = function() {
    var anchor = this.normalizedAnchor_;
    if (!anchor) {
      anchor = this.anchor_;
      var size = this.getSize();
      if (this.anchorXUnits_ == IconAnchorUnits.FRACTION || this.anchorYUnits_ == IconAnchorUnits.FRACTION) {
        if (!size) {
          return null;
        }
        anchor = this.anchor_.slice();
        if (this.anchorXUnits_ == IconAnchorUnits.FRACTION) {
          anchor[0] *= size[0];
        }
        if (this.anchorYUnits_ == IconAnchorUnits.FRACTION) {
          anchor[1] *= size[1];
        }
      }
      if (this.anchorOrigin_ != IconOrigin.TOP_LEFT) {
        if (!size) {
          return null;
        }
        if (anchor === this.anchor_) {
          anchor = this.anchor_.slice();
        }
        if (this.anchorOrigin_ == IconOrigin.TOP_RIGHT || this.anchorOrigin_ == IconOrigin.BOTTOM_RIGHT) {
          anchor[0] = -anchor[0] + size[0];
        }
        if (this.anchorOrigin_ == IconOrigin.BOTTOM_LEFT || this.anchorOrigin_ == IconOrigin.BOTTOM_RIGHT) {
          anchor[1] = -anchor[1] + size[1];
        }
      }
      this.normalizedAnchor_ = anchor;
    }
    var displacement = this.getDisplacement();
    return [anchor[0] - displacement[0], anchor[1] + displacement[1]];
  };
  Icon2.prototype.setAnchor = function(anchor) {
    this.anchor_ = anchor;
    this.normalizedAnchor_ = null;
  };
  Icon2.prototype.getColor = function() {
    return this.color_;
  };
  Icon2.prototype.getImage = function(pixelRatio) {
    return this.iconImage_.getImage(pixelRatio);
  };
  Icon2.prototype.getPixelRatio = function(pixelRatio) {
    return this.iconImage_.getPixelRatio(pixelRatio);
  };
  Icon2.prototype.getImageSize = function() {
    return this.iconImage_.getSize();
  };
  Icon2.prototype.getImageState = function() {
    return this.iconImage_.getImageState();
  };
  Icon2.prototype.getHitDetectionImage = function() {
    return this.iconImage_.getHitDetectionImage();
  };
  Icon2.prototype.getOrigin = function() {
    if (this.origin_) {
      return this.origin_;
    }
    var offset2 = this.offset_;
    if (this.offsetOrigin_ != IconOrigin.TOP_LEFT) {
      var size = this.getSize();
      var iconImageSize = this.iconImage_.getSize();
      if (!size || !iconImageSize) {
        return null;
      }
      offset2 = offset2.slice();
      if (this.offsetOrigin_ == IconOrigin.TOP_RIGHT || this.offsetOrigin_ == IconOrigin.BOTTOM_RIGHT) {
        offset2[0] = iconImageSize[0] - size[0] - offset2[0];
      }
      if (this.offsetOrigin_ == IconOrigin.BOTTOM_LEFT || this.offsetOrigin_ == IconOrigin.BOTTOM_RIGHT) {
        offset2[1] = iconImageSize[1] - size[1] - offset2[1];
      }
    }
    this.origin_ = offset2;
    return this.origin_;
  };
  Icon2.prototype.getSrc = function() {
    return this.iconImage_.getSrc();
  };
  Icon2.prototype.getSize = function() {
    return !this.size_ ? this.iconImage_.getSize() : this.size_;
  };
  Icon2.prototype.listenImageChange = function(listener2) {
    this.iconImage_.addEventListener(EventType.CHANGE, listener2);
  };
  Icon2.prototype.load = function() {
    this.iconImage_.load();
  };
  Icon2.prototype.unlistenImageChange = function(listener2) {
    this.iconImage_.removeEventListener(EventType.CHANGE, listener2);
  };
  return Icon2;
}(ImageStyle$1);
var Icon$2 = Icon$1;
var DEFAULT_FILL_COLOR = "#333";
var Text$1 = function() {
  function Text2(opt_options) {
    var options = opt_options || {};
    this.font_ = options.font;
    this.rotation_ = options.rotation;
    this.rotateWithView_ = options.rotateWithView;
    this.scale_ = options.scale;
    this.scaleArray_ = toSize(options.scale !== void 0 ? options.scale : 1);
    this.text_ = options.text;
    this.textAlign_ = options.textAlign;
    this.textBaseline_ = options.textBaseline;
    this.fill_ = options.fill !== void 0 ? options.fill : new Fill$2({ color: DEFAULT_FILL_COLOR });
    this.maxAngle_ = options.maxAngle !== void 0 ? options.maxAngle : Math.PI / 4;
    this.placement_ = options.placement !== void 0 ? options.placement : TextPlacement.POINT;
    this.overflow_ = !!options.overflow;
    this.stroke_ = options.stroke !== void 0 ? options.stroke : null;
    this.offsetX_ = options.offsetX !== void 0 ? options.offsetX : 0;
    this.offsetY_ = options.offsetY !== void 0 ? options.offsetY : 0;
    this.backgroundFill_ = options.backgroundFill ? options.backgroundFill : null;
    this.backgroundStroke_ = options.backgroundStroke ? options.backgroundStroke : null;
    this.padding_ = options.padding === void 0 ? null : options.padding;
  }
  Text2.prototype.clone = function() {
    var scale2 = this.getScale();
    return new Text2({
      font: this.getFont(),
      placement: this.getPlacement(),
      maxAngle: this.getMaxAngle(),
      overflow: this.getOverflow(),
      rotation: this.getRotation(),
      rotateWithView: this.getRotateWithView(),
      scale: Array.isArray(scale2) ? scale2.slice() : scale2,
      text: this.getText(),
      textAlign: this.getTextAlign(),
      textBaseline: this.getTextBaseline(),
      fill: this.getFill() ? this.getFill().clone() : void 0,
      stroke: this.getStroke() ? this.getStroke().clone() : void 0,
      offsetX: this.getOffsetX(),
      offsetY: this.getOffsetY(),
      backgroundFill: this.getBackgroundFill() ? this.getBackgroundFill().clone() : void 0,
      backgroundStroke: this.getBackgroundStroke() ? this.getBackgroundStroke().clone() : void 0,
      padding: this.getPadding() || void 0
    });
  };
  Text2.prototype.getOverflow = function() {
    return this.overflow_;
  };
  Text2.prototype.getFont = function() {
    return this.font_;
  };
  Text2.prototype.getMaxAngle = function() {
    return this.maxAngle_;
  };
  Text2.prototype.getPlacement = function() {
    return this.placement_;
  };
  Text2.prototype.getOffsetX = function() {
    return this.offsetX_;
  };
  Text2.prototype.getOffsetY = function() {
    return this.offsetY_;
  };
  Text2.prototype.getFill = function() {
    return this.fill_;
  };
  Text2.prototype.getRotateWithView = function() {
    return this.rotateWithView_;
  };
  Text2.prototype.getRotation = function() {
    return this.rotation_;
  };
  Text2.prototype.getScale = function() {
    return this.scale_;
  };
  Text2.prototype.getScaleArray = function() {
    return this.scaleArray_;
  };
  Text2.prototype.getStroke = function() {
    return this.stroke_;
  };
  Text2.prototype.getText = function() {
    return this.text_;
  };
  Text2.prototype.getTextAlign = function() {
    return this.textAlign_;
  };
  Text2.prototype.getTextBaseline = function() {
    return this.textBaseline_;
  };
  Text2.prototype.getBackgroundFill = function() {
    return this.backgroundFill_;
  };
  Text2.prototype.getBackgroundStroke = function() {
    return this.backgroundStroke_;
  };
  Text2.prototype.getPadding = function() {
    return this.padding_;
  };
  Text2.prototype.setOverflow = function(overflow2) {
    this.overflow_ = overflow2;
  };
  Text2.prototype.setFont = function(font) {
    this.font_ = font;
  };
  Text2.prototype.setMaxAngle = function(maxAngle) {
    this.maxAngle_ = maxAngle;
  };
  Text2.prototype.setOffsetX = function(offsetX) {
    this.offsetX_ = offsetX;
  };
  Text2.prototype.setOffsetY = function(offsetY) {
    this.offsetY_ = offsetY;
  };
  Text2.prototype.setPlacement = function(placement) {
    this.placement_ = placement;
  };
  Text2.prototype.setRotateWithView = function(rotateWithView) {
    this.rotateWithView_ = rotateWithView;
  };
  Text2.prototype.setFill = function(fill) {
    this.fill_ = fill;
  };
  Text2.prototype.setRotation = function(rotation) {
    this.rotation_ = rotation;
  };
  Text2.prototype.setScale = function(scale2) {
    this.scale_ = scale2;
    this.scaleArray_ = toSize(scale2 !== void 0 ? scale2 : 1);
  };
  Text2.prototype.setStroke = function(stroke) {
    this.stroke_ = stroke;
  };
  Text2.prototype.setText = function(text2) {
    this.text_ = text2;
  };
  Text2.prototype.setTextAlign = function(textAlign2) {
    this.textAlign_ = textAlign2;
  };
  Text2.prototype.setTextBaseline = function(textBaseline) {
    this.textBaseline_ = textBaseline;
  };
  Text2.prototype.setBackgroundFill = function(fill) {
    this.backgroundFill_ = fill;
  };
  Text2.prototype.setBackgroundStroke = function(stroke) {
    this.backgroundStroke_ = stroke;
  };
  Text2.prototype.setPadding = function(padding) {
    this.padding_ = padding;
  };
  return Text2;
}();
var Text$2 = Text$1;
var HIT_DETECT_RESOLUTION = 0.5;
function createHitDetectionImageData(size, transforms2, features, styleFunction, extent2, resolution, rotation) {
  var width = size[0] * HIT_DETECT_RESOLUTION;
  var height = size[1] * HIT_DETECT_RESOLUTION;
  var context = createCanvasContext2D(width, height);
  context.imageSmoothingEnabled = false;
  var canvas = context.canvas;
  var renderer = new CanvasImmediateRenderer$1(context, HIT_DETECT_RESOLUTION, extent2, null, rotation);
  var featureCount = features.length;
  var indexFactor = Math.floor((256 * 256 * 256 - 1) / featureCount);
  var featuresByZIndex = {};
  for (var i2 = 1; i2 <= featureCount; ++i2) {
    var feature2 = features[i2 - 1];
    var featureStyleFunction = feature2.getStyleFunction() || styleFunction;
    if (!styleFunction) {
      continue;
    }
    var styles = featureStyleFunction(feature2, resolution);
    if (!styles) {
      continue;
    }
    if (!Array.isArray(styles)) {
      styles = [styles];
    }
    var index2 = i2 * indexFactor;
    var color2 = "#" + ("000000" + index2.toString(16)).slice(-6);
    for (var j2 = 0, jj = styles.length; j2 < jj; ++j2) {
      var originalStyle = styles[j2];
      var geometry = originalStyle.getGeometryFunction()(feature2);
      if (!geometry || !intersects$1(extent2, geometry.getExtent())) {
        continue;
      }
      var style2 = originalStyle.clone();
      var fill = style2.getFill();
      if (fill) {
        fill.setColor(color2);
      }
      var stroke = style2.getStroke();
      if (stroke) {
        stroke.setColor(color2);
        stroke.setLineDash(null);
      }
      style2.setText(void 0);
      var image2 = originalStyle.getImage();
      if (image2 && image2.getOpacity() !== 0) {
        var imgSize = image2.getImageSize();
        if (!imgSize) {
          continue;
        }
        var imgContext = createCanvasContext2D(imgSize[0], imgSize[1], void 0, { alpha: false });
        var img = imgContext.canvas;
        imgContext.fillStyle = color2;
        imgContext.fillRect(0, 0, img.width, img.height);
        style2.setImage(new Icon$2({
          img,
          imgSize,
          anchor: image2.getAnchor(),
          anchorXUnits: IconAnchorUnits.PIXELS,
          anchorYUnits: IconAnchorUnits.PIXELS,
          offset: image2.getOrigin(),
          opacity: 1,
          size: image2.getSize(),
          scale: image2.getScale(),
          rotation: image2.getRotation(),
          rotateWithView: image2.getRotateWithView()
        }));
      }
      var zIndex2 = style2.getZIndex() || 0;
      var byGeometryType = featuresByZIndex[zIndex2];
      if (!byGeometryType) {
        byGeometryType = {};
        featuresByZIndex[zIndex2] = byGeometryType;
        byGeometryType[GeometryType.POLYGON] = [];
        byGeometryType[GeometryType.CIRCLE] = [];
        byGeometryType[GeometryType.LINE_STRING] = [];
        byGeometryType[GeometryType.POINT] = [];
      }
      byGeometryType[geometry.getType().replace("Multi", "")].push(geometry, style2);
    }
  }
  var zIndexKeys = Object.keys(featuresByZIndex).map(Number).sort(numberSafeCompareFunction);
  for (var i2 = 0, ii = zIndexKeys.length; i2 < ii; ++i2) {
    var byGeometryType = featuresByZIndex[zIndexKeys[i2]];
    for (var type in byGeometryType) {
      var geomAndStyle = byGeometryType[type];
      for (var j2 = 0, jj = geomAndStyle.length; j2 < jj; j2 += 2) {
        renderer.setStyle(geomAndStyle[j2 + 1]);
        for (var k2 = 0, kk = transforms2.length; k2 < kk; ++k2) {
          renderer.setTransform(transforms2[k2]);
          renderer.drawGeometry(geomAndStyle[j2]);
        }
      }
    }
  }
  return context.getImageData(0, 0, canvas.width, canvas.height);
}
function hitDetect(pixel, features, imageData) {
  var resultFeatures = [];
  if (imageData) {
    var x2 = Math.floor(Math.round(pixel[0]) * HIT_DETECT_RESOLUTION);
    var y2 = Math.floor(Math.round(pixel[1]) * HIT_DETECT_RESOLUTION);
    var index2 = (clamp(x2, 0, imageData.width - 1) + clamp(y2, 0, imageData.height - 1) * imageData.width) * 4;
    var r2 = imageData.data[index2];
    var g2 = imageData.data[index2 + 1];
    var b2 = imageData.data[index2 + 2];
    var i2 = b2 + 256 * (g2 + 256 * r2);
    var indexFactor = Math.floor((256 * 256 * 256 - 1) / features.length);
    if (i2 && i2 % indexFactor === 0) {
      resultFeatures.push(features[i2 / indexFactor - 1]);
    }
  }
  return resultFeatures;
}
var SIMPLIFY_TOLERANCE = 0.5;
var GEOMETRY_RENDERERS = {
  "Point": renderPointGeometry,
  "LineString": renderLineStringGeometry,
  "Polygon": renderPolygonGeometry,
  "MultiPoint": renderMultiPointGeometry,
  "MultiLineString": renderMultiLineStringGeometry,
  "MultiPolygon": renderMultiPolygonGeometry,
  "GeometryCollection": renderGeometryCollectionGeometry,
  "Circle": renderCircleGeometry
};
function defaultOrder(feature1, feature2) {
  return parseInt(getUid(feature1), 10) - parseInt(getUid(feature2), 10);
}
function getSquaredTolerance(resolution, pixelRatio) {
  var tolerance = getTolerance(resolution, pixelRatio);
  return tolerance * tolerance;
}
function getTolerance(resolution, pixelRatio) {
  return SIMPLIFY_TOLERANCE * resolution / pixelRatio;
}
function renderCircleGeometry(builderGroup, geometry, style2, feature2, opt_declutterBuilderGroup) {
  var fillStyle = style2.getFill();
  var strokeStyle = style2.getStroke();
  if (fillStyle || strokeStyle) {
    var circleReplay = builderGroup.getBuilder(style2.getZIndex(), ReplayType.CIRCLE);
    circleReplay.setFillStrokeStyle(fillStyle, strokeStyle);
    circleReplay.drawCircle(geometry, feature2);
  }
  var textStyle = style2.getText();
  if (textStyle && textStyle.getText()) {
    var textReplay = (opt_declutterBuilderGroup || builderGroup).getBuilder(style2.getZIndex(), ReplayType.TEXT);
    textReplay.setTextStyle(textStyle);
    textReplay.drawText(geometry, feature2);
  }
}
function renderFeature(replayGroup, feature2, style2, squaredTolerance, listener2, opt_transform, opt_declutterBuilderGroup) {
  var loading = false;
  var imageStyle = style2.getImage();
  if (imageStyle) {
    var imageState = imageStyle.getImageState();
    if (imageState == ImageState.LOADED || imageState == ImageState.ERROR) {
      imageStyle.unlistenImageChange(listener2);
    } else {
      if (imageState == ImageState.IDLE) {
        imageStyle.load();
      }
      imageState = imageStyle.getImageState();
      imageStyle.listenImageChange(listener2);
      loading = true;
    }
  }
  renderFeatureInternal(replayGroup, feature2, style2, squaredTolerance, opt_transform, opt_declutterBuilderGroup);
  return loading;
}
function renderFeatureInternal(replayGroup, feature2, style2, squaredTolerance, opt_transform, opt_declutterBuilderGroup) {
  var geometry = style2.getGeometryFunction()(feature2);
  if (!geometry) {
    return;
  }
  var simplifiedGeometry = geometry.simplifyTransformed(squaredTolerance, opt_transform);
  var renderer = style2.getRenderer();
  if (renderer) {
    renderGeometry(replayGroup, simplifiedGeometry, style2, feature2);
  } else {
    var geometryRenderer = GEOMETRY_RENDERERS[simplifiedGeometry.getType()];
    geometryRenderer(replayGroup, simplifiedGeometry, style2, feature2, opt_declutterBuilderGroup);
  }
}
function renderGeometry(replayGroup, geometry, style2, feature2) {
  if (geometry.getType() == GeometryType.GEOMETRY_COLLECTION) {
    var geometries = geometry.getGeometries();
    for (var i2 = 0, ii = geometries.length; i2 < ii; ++i2) {
      renderGeometry(replayGroup, geometries[i2], style2, feature2);
    }
    return;
  }
  var replay = replayGroup.getBuilder(style2.getZIndex(), ReplayType.DEFAULT);
  replay.drawCustom(geometry, feature2, style2.getRenderer(), style2.getHitDetectionRenderer());
}
function renderGeometryCollectionGeometry(replayGroup, geometry, style2, feature2, opt_declutterBuilderGroup) {
  var geometries = geometry.getGeometriesArray();
  var i2, ii;
  for (i2 = 0, ii = geometries.length; i2 < ii; ++i2) {
    var geometryRenderer = GEOMETRY_RENDERERS[geometries[i2].getType()];
    geometryRenderer(replayGroup, geometries[i2], style2, feature2, opt_declutterBuilderGroup);
  }
}
function renderLineStringGeometry(builderGroup, geometry, style2, feature2, opt_declutterBuilderGroup) {
  var strokeStyle = style2.getStroke();
  if (strokeStyle) {
    var lineStringReplay = builderGroup.getBuilder(style2.getZIndex(), ReplayType.LINE_STRING);
    lineStringReplay.setFillStrokeStyle(null, strokeStyle);
    lineStringReplay.drawLineString(geometry, feature2);
  }
  var textStyle = style2.getText();
  if (textStyle && textStyle.getText()) {
    var textReplay = (opt_declutterBuilderGroup || builderGroup).getBuilder(style2.getZIndex(), ReplayType.TEXT);
    textReplay.setTextStyle(textStyle);
    textReplay.drawText(geometry, feature2);
  }
}
function renderMultiLineStringGeometry(builderGroup, geometry, style2, feature2, opt_declutterBuilderGroup) {
  var strokeStyle = style2.getStroke();
  if (strokeStyle) {
    var lineStringReplay = builderGroup.getBuilder(style2.getZIndex(), ReplayType.LINE_STRING);
    lineStringReplay.setFillStrokeStyle(null, strokeStyle);
    lineStringReplay.drawMultiLineString(geometry, feature2);
  }
  var textStyle = style2.getText();
  if (textStyle && textStyle.getText()) {
    var textReplay = (opt_declutterBuilderGroup || builderGroup).getBuilder(style2.getZIndex(), ReplayType.TEXT);
    textReplay.setTextStyle(textStyle);
    textReplay.drawText(geometry, feature2);
  }
}
function renderMultiPolygonGeometry(builderGroup, geometry, style2, feature2, opt_declutterBuilderGroup) {
  var fillStyle = style2.getFill();
  var strokeStyle = style2.getStroke();
  if (strokeStyle || fillStyle) {
    var polygonReplay = builderGroup.getBuilder(style2.getZIndex(), ReplayType.POLYGON);
    polygonReplay.setFillStrokeStyle(fillStyle, strokeStyle);
    polygonReplay.drawMultiPolygon(geometry, feature2);
  }
  var textStyle = style2.getText();
  if (textStyle && textStyle.getText()) {
    var textReplay = (opt_declutterBuilderGroup || builderGroup).getBuilder(style2.getZIndex(), ReplayType.TEXT);
    textReplay.setTextStyle(textStyle);
    textReplay.drawText(geometry, feature2);
  }
}
function renderPointGeometry(builderGroup, geometry, style2, feature2, opt_declutterBuilderGroup) {
  var imageStyle = style2.getImage();
  var textStyle = style2.getText();
  var declutterImageWithText;
  if (opt_declutterBuilderGroup) {
    builderGroup = opt_declutterBuilderGroup;
    declutterImageWithText = imageStyle && textStyle && textStyle.getText() ? {} : void 0;
  }
  if (imageStyle) {
    if (imageStyle.getImageState() != ImageState.LOADED) {
      return;
    }
    var imageReplay = builderGroup.getBuilder(style2.getZIndex(), ReplayType.IMAGE);
    imageReplay.setImageStyle(imageStyle, declutterImageWithText);
    imageReplay.drawPoint(geometry, feature2);
  }
  if (textStyle && textStyle.getText()) {
    var textReplay = builderGroup.getBuilder(style2.getZIndex(), ReplayType.TEXT);
    textReplay.setTextStyle(textStyle, declutterImageWithText);
    textReplay.drawText(geometry, feature2);
  }
}
function renderMultiPointGeometry(builderGroup, geometry, style2, feature2, opt_declutterBuilderGroup) {
  var imageStyle = style2.getImage();
  var textStyle = style2.getText();
  var declutterImageWithText;
  if (opt_declutterBuilderGroup) {
    builderGroup = opt_declutterBuilderGroup;
    declutterImageWithText = imageStyle && textStyle && textStyle.getText() ? {} : void 0;
  }
  if (imageStyle) {
    if (imageStyle.getImageState() != ImageState.LOADED) {
      return;
    }
    var imageReplay = builderGroup.getBuilder(style2.getZIndex(), ReplayType.IMAGE);
    imageReplay.setImageStyle(imageStyle, declutterImageWithText);
    imageReplay.drawMultiPoint(geometry, feature2);
  }
  if (textStyle && textStyle.getText()) {
    var textReplay = (opt_declutterBuilderGroup || builderGroup).getBuilder(style2.getZIndex(), ReplayType.TEXT);
    textReplay.setTextStyle(textStyle, declutterImageWithText);
    textReplay.drawText(geometry, feature2);
  }
}
function renderPolygonGeometry(builderGroup, geometry, style2, feature2, opt_declutterBuilderGroup) {
  var fillStyle = style2.getFill();
  var strokeStyle = style2.getStroke();
  if (fillStyle || strokeStyle) {
    var polygonReplay = builderGroup.getBuilder(style2.getZIndex(), ReplayType.POLYGON);
    polygonReplay.setFillStrokeStyle(fillStyle, strokeStyle);
    polygonReplay.drawPolygon(geometry, feature2);
  }
  var textStyle = style2.getText();
  if (textStyle && textStyle.getText()) {
    var textReplay = (opt_declutterBuilderGroup || builderGroup).getBuilder(style2.getZIndex(), ReplayType.TEXT);
    textReplay.setTextStyle(textStyle);
    textReplay.drawText(geometry, feature2);
  }
}
var __extends$18 = globalThis && globalThis.__extends || function() {
  var extendStatics2 = function(d2, b2) {
    extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {
      d3.__proto__ = b3;
    } || function(d3, b3) {
      for (var p5 in b3)
        if (Object.prototype.hasOwnProperty.call(b3, p5))
          d3[p5] = b3[p5];
    };
    return extendStatics2(d2, b2);
  };
  return function(d2, b2) {
    if (typeof b2 !== "function" && b2 !== null)
      throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
    extendStatics2(d2, b2);
    function __() {
      this.constructor = d2;
    }
    d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
  };
}();
var CanvasVectorLayerRenderer = function(_super) {
  __extends$18(CanvasVectorLayerRenderer2, _super);
  function CanvasVectorLayerRenderer2(vectorLayer) {
    var _this = _super.call(this, vectorLayer) || this;
    _this.boundHandleStyleImageChange_ = _this.handleStyleImageChange_.bind(_this);
    _this.animatingOrInteracting_;
    _this.dirty_ = false;
    _this.hitDetectionImageData_ = null;
    _this.renderedFeatures_ = null;
    _this.renderedRevision_ = -1;
    _this.renderedResolution_ = NaN;
    _this.renderedExtent_ = createEmpty();
    _this.wrappedRenderedExtent_ = createEmpty();
    _this.renderedRotation_;
    _this.renderedCenter_ = null;
    _this.renderedProjection_ = null;
    _this.renderedRenderOrder_ = null;
    _this.replayGroup_ = null;
    _this.replayGroupChanged = true;
    _this.declutterExecutorGroup = null;
    _this.clipping = true;
    return _this;
  }
  CanvasVectorLayerRenderer2.prototype.renderWorlds = function(executorGroup, frameState, opt_declutterTree) {
    var extent2 = frameState.extent;
    var viewState = frameState.viewState;
    var center = viewState.center;
    var resolution = viewState.resolution;
    var projection = viewState.projection;
    var rotation = viewState.rotation;
    var projectionExtent = projection.getExtent();
    var vectorSource = this.getLayer().getSource();
    var pixelRatio = frameState.pixelRatio;
    var viewHints = frameState.viewHints;
    var snapToPixel = !(viewHints[ViewHint.ANIMATING] || viewHints[ViewHint.INTERACTING]);
    var context = this.context;
    var width = Math.round(frameState.size[0] * pixelRatio);
    var height = Math.round(frameState.size[1] * pixelRatio);
    var multiWorld = vectorSource.getWrapX() && projection.canWrapX();
    var worldWidth = multiWorld ? getWidth(projectionExtent) : null;
    var endWorld = multiWorld ? Math.ceil((extent2[2] - projectionExtent[2]) / worldWidth) + 1 : 1;
    var world = multiWorld ? Math.floor((extent2[0] - projectionExtent[0]) / worldWidth) : 0;
    do {
      var transform2 = this.getRenderTransform(center, resolution, rotation, pixelRatio, width, height, world * worldWidth);
      executorGroup.execute(context, 1, transform2, rotation, snapToPixel, void 0, opt_declutterTree);
    } while (++world < endWorld);
  };
  CanvasVectorLayerRenderer2.prototype.renderDeclutter = function(frameState) {
    if (this.declutterExecutorGroup) {
      this.renderWorlds(this.declutterExecutorGroup, frameState, frameState.declutterTree);
    }
  };
  CanvasVectorLayerRenderer2.prototype.renderFrame = function(frameState, target) {
    var pixelRatio = frameState.pixelRatio;
    var layerState = frameState.layerStatesArray[frameState.layerIndex];
    makeScale(this.pixelTransform, 1 / pixelRatio, 1 / pixelRatio);
    makeInverse(this.inversePixelTransform, this.pixelTransform);
    var canvasTransform = toString$d(this.pixelTransform);
    this.useContainer(target, canvasTransform, layerState.opacity, this.getBackground(frameState));
    var context = this.context;
    var canvas = context.canvas;
    var replayGroup = this.replayGroup_;
    var declutterExecutorGroup = this.declutterExecutorGroup;
    if ((!replayGroup || replayGroup.isEmpty()) && (!declutterExecutorGroup || declutterExecutorGroup.isEmpty())) {
      return null;
    }
    var width = Math.round(frameState.size[0] * pixelRatio);
    var height = Math.round(frameState.size[1] * pixelRatio);
    if (canvas.width != width || canvas.height != height) {
      canvas.width = width;
      canvas.height = height;
      if (canvas.style.transform !== canvasTransform) {
        canvas.style.transform = canvasTransform;
      }
    } else if (!this.containerReused) {
      context.clearRect(0, 0, width, height);
    }
    this.preRender(context, frameState);
    var viewState = frameState.viewState;
    viewState.projection;
    var clipped = false;
    var render2 = true;
    if (layerState.extent && this.clipping) {
      var layerExtent = fromUserExtent(layerState.extent);
      render2 = intersects$1(layerExtent, frameState.extent);
      clipped = render2 && !containsExtent(layerExtent, frameState.extent);
      if (clipped) {
        this.clipUnrotated(context, frameState, layerExtent);
      }
    }
    if (render2) {
      this.renderWorlds(replayGroup, frameState);
    }
    if (clipped) {
      context.restore();
    }
    this.postRender(context, frameState);
    var opacity2 = cssOpacity(layerState.opacity);
    var container = this.container;
    if (opacity2 !== container.style.opacity) {
      container.style.opacity = opacity2;
    }
    if (this.renderedRotation_ !== viewState.rotation) {
      this.renderedRotation_ = viewState.rotation;
      this.hitDetectionImageData_ = null;
    }
    return this.container;
  };
  CanvasVectorLayerRenderer2.prototype.getFeatures = function(pixel) {
    return new Promise(function(resolve2) {
      if (!this.hitDetectionImageData_ && !this.animatingOrInteracting_) {
        var size = [this.context.canvas.width, this.context.canvas.height];
        apply$5(this.pixelTransform, size);
        var center = this.renderedCenter_;
        var resolution = this.renderedResolution_;
        var rotation = this.renderedRotation_;
        var projection = this.renderedProjection_;
        var extent2 = this.wrappedRenderedExtent_;
        var layer = this.getLayer();
        var transforms2 = [];
        var width = size[0] * HIT_DETECT_RESOLUTION;
        var height = size[1] * HIT_DETECT_RESOLUTION;
        transforms2.push(this.getRenderTransform(center, resolution, rotation, HIT_DETECT_RESOLUTION, width, height, 0).slice());
        var source = layer.getSource();
        var projectionExtent = projection.getExtent();
        if (source.getWrapX() && projection.canWrapX() && !containsExtent(projectionExtent, extent2)) {
          var startX = extent2[0];
          var worldWidth = getWidth(projectionExtent);
          var world = 0;
          var offsetX = void 0;
          while (startX < projectionExtent[0]) {
            --world;
            offsetX = worldWidth * world;
            transforms2.push(this.getRenderTransform(center, resolution, rotation, HIT_DETECT_RESOLUTION, width, height, offsetX).slice());
            startX += worldWidth;
          }
          world = 0;
          startX = extent2[2];
          while (startX > projectionExtent[2]) {
            ++world;
            offsetX = worldWidth * world;
            transforms2.push(this.getRenderTransform(center, resolution, rotation, HIT_DETECT_RESOLUTION, width, height, offsetX).slice());
            startX -= worldWidth;
          }
        }
        this.hitDetectionImageData_ = createHitDetectionImageData(size, transforms2, this.renderedFeatures_, layer.getStyleFunction(), extent2, resolution, rotation);
      }
      resolve2(hitDetect(pixel, this.renderedFeatures_, this.hitDetectionImageData_));
    }.bind(this));
  };
  CanvasVectorLayerRenderer2.prototype.forEachFeatureAtCoordinate = function(coordinate, frameState, hitTolerance, callback, matches) {
    var _this = this;
    if (!this.replayGroup_) {
      return void 0;
    }
    var resolution = frameState.viewState.resolution;
    var rotation = frameState.viewState.rotation;
    var layer = this.getLayer();
    var features = {};
    var featureCallback = function(feature2, geometry, distanceSq) {
      var key = getUid(feature2);
      var match2 = features[key];
      if (!match2) {
        if (distanceSq === 0) {
          features[key] = true;
          return callback(feature2, layer, geometry);
        }
        matches.push(features[key] = {
          feature: feature2,
          layer,
          geometry,
          distanceSq,
          callback
        });
      } else if (match2 !== true && distanceSq < match2.distanceSq) {
        if (distanceSq === 0) {
          features[key] = true;
          matches.splice(matches.lastIndexOf(match2), 1);
          return callback(feature2, layer, geometry);
        }
        match2.geometry = geometry;
        match2.distanceSq = distanceSq;
      }
      return void 0;
    };
    var result;
    var executorGroups = [this.replayGroup_];
    if (this.declutterExecutorGroup) {
      executorGroups.push(this.declutterExecutorGroup);
    }
    executorGroups.some(function(executorGroup) {
      return result = executorGroup.forEachFeatureAtCoordinate(coordinate, resolution, rotation, hitTolerance, featureCallback, executorGroup === _this.declutterExecutorGroup && frameState.declutterTree ? frameState.declutterTree.all().map(function(item) {
        return item.value;
      }) : null);
    });
    return result;
  };
  CanvasVectorLayerRenderer2.prototype.handleFontsChanged = function() {
    var layer = this.getLayer();
    if (layer.getVisible() && this.replayGroup_) {
      layer.changed();
    }
  };
  CanvasVectorLayerRenderer2.prototype.handleStyleImageChange_ = function(event) {
    this.renderIfReadyAndVisible();
  };
  CanvasVectorLayerRenderer2.prototype.prepareFrame = function(frameState) {
    var vectorLayer = this.getLayer();
    var vectorSource = vectorLayer.getSource();
    if (!vectorSource) {
      return false;
    }
    var animating = frameState.viewHints[ViewHint.ANIMATING];
    var interacting = frameState.viewHints[ViewHint.INTERACTING];
    var updateWhileAnimating = vectorLayer.getUpdateWhileAnimating();
    var updateWhileInteracting = vectorLayer.getUpdateWhileInteracting();
    if (!this.dirty_ && !updateWhileAnimating && animating || !updateWhileInteracting && interacting) {
      this.animatingOrInteracting_ = true;
      return true;
    }
    this.animatingOrInteracting_ = false;
    var frameStateExtent = frameState.extent;
    var viewState = frameState.viewState;
    var projection = viewState.projection;
    var resolution = viewState.resolution;
    var pixelRatio = frameState.pixelRatio;
    var vectorLayerRevision = vectorLayer.getRevision();
    var vectorLayerRenderBuffer = vectorLayer.getRenderBuffer();
    var vectorLayerRenderOrder = vectorLayer.getRenderOrder();
    if (vectorLayerRenderOrder === void 0) {
      vectorLayerRenderOrder = defaultOrder;
    }
    var center = viewState.center.slice();
    var extent2 = buffer$1(frameStateExtent, vectorLayerRenderBuffer * resolution);
    var renderedExtent = extent2.slice();
    var loadExtents = [extent2.slice()];
    var projectionExtent = projection.getExtent();
    if (vectorSource.getWrapX() && projection.canWrapX() && !containsExtent(projectionExtent, frameState.extent)) {
      var worldWidth = getWidth(projectionExtent);
      var gutter = Math.max(getWidth(extent2) / 2, worldWidth);
      extent2[0] = projectionExtent[0] - gutter;
      extent2[2] = projectionExtent[2] + gutter;
      wrapX$1(center, projection);
      var loadExtent = wrapX$2(loadExtents[0], projection);
      if (loadExtent[0] < projectionExtent[0] && loadExtent[2] < projectionExtent[2]) {
        loadExtents.push([
          loadExtent[0] + worldWidth,
          loadExtent[1],
          loadExtent[2] + worldWidth,
          loadExtent[3]
        ]);
      } else if (loadExtent[0] > projectionExtent[0] && loadExtent[2] > projectionExtent[2]) {
        loadExtents.push([
          loadExtent[0] - worldWidth,
          loadExtent[1],
          loadExtent[2] - worldWidth,
          loadExtent[3]
        ]);
      }
    }
    if (!this.dirty_ && this.renderedResolution_ == resolution && this.renderedRevision_ == vectorLayerRevision && this.renderedRenderOrder_ == vectorLayerRenderOrder && containsExtent(this.wrappedRenderedExtent_, extent2)) {
      if (!equals$2(this.renderedExtent_, renderedExtent)) {
        this.hitDetectionImageData_ = null;
        this.renderedExtent_ = renderedExtent;
      }
      this.renderedCenter_ = center;
      this.replayGroupChanged = false;
      return true;
    }
    this.replayGroup_ = null;
    this.dirty_ = false;
    var replayGroup = new CanvasBuilderGroup(getTolerance(resolution, pixelRatio), extent2, resolution, pixelRatio);
    var declutterBuilderGroup;
    if (this.getLayer().getDeclutter()) {
      declutterBuilderGroup = new CanvasBuilderGroup(getTolerance(resolution, pixelRatio), extent2, resolution, pixelRatio);
    }
    var userTransform;
    var i2, ii;
    {
      for (var i2 = 0, ii = loadExtents.length; i2 < ii; ++i2) {
        vectorSource.loadFeatures(loadExtents[i2], resolution, projection);
      }
    }
    var squaredTolerance = getSquaredTolerance(resolution, pixelRatio);
    var render2 = function(feature2) {
      var styles;
      var styleFunction = feature2.getStyleFunction() || vectorLayer.getStyleFunction();
      if (styleFunction) {
        styles = styleFunction(feature2, resolution);
      }
      if (styles) {
        var dirty = this.renderFeature(feature2, squaredTolerance, styles, replayGroup, userTransform, declutterBuilderGroup);
        this.dirty_ = this.dirty_ || dirty;
      }
    }.bind(this);
    var userExtent = toUserExtent(extent2);
    var features = vectorSource.getFeaturesInExtent(userExtent);
    if (vectorLayerRenderOrder) {
      features.sort(vectorLayerRenderOrder);
    }
    for (var i2 = 0, ii = features.length; i2 < ii; ++i2) {
      render2(features[i2]);
    }
    this.renderedFeatures_ = features;
    var replayGroupInstructions = replayGroup.finish();
    var executorGroup = new CanvasExecutorGroup(extent2, resolution, pixelRatio, vectorSource.getOverlaps(), replayGroupInstructions, vectorLayer.getRenderBuffer());
    if (declutterBuilderGroup) {
      this.declutterExecutorGroup = new CanvasExecutorGroup(extent2, resolution, pixelRatio, vectorSource.getOverlaps(), declutterBuilderGroup.finish(), vectorLayer.getRenderBuffer());
    }
    this.renderedResolution_ = resolution;
    this.renderedRevision_ = vectorLayerRevision;
    this.renderedRenderOrder_ = vectorLayerRenderOrder;
    this.renderedExtent_ = renderedExtent;
    this.wrappedRenderedExtent_ = extent2;
    this.renderedCenter_ = center;
    this.renderedProjection_ = projection;
    this.replayGroup_ = executorGroup;
    this.hitDetectionImageData_ = null;
    this.replayGroupChanged = true;
    return true;
  };
  CanvasVectorLayerRenderer2.prototype.renderFeature = function(feature2, squaredTolerance, styles, builderGroup, opt_transform, opt_declutterBuilderGroup) {
    if (!styles) {
      return false;
    }
    var loading = false;
    if (Array.isArray(styles)) {
      for (var i2 = 0, ii = styles.length; i2 < ii; ++i2) {
        loading = renderFeature(builderGroup, feature2, styles[i2], squaredTolerance, this.boundHandleStyleImageChange_, opt_transform, opt_declutterBuilderGroup) || loading;
      }
    } else {
      loading = renderFeature(builderGroup, feature2, styles, squaredTolerance, this.boundHandleStyleImageChange_, opt_transform, opt_declutterBuilderGroup);
    }
    return loading;
  };
  return CanvasVectorLayerRenderer2;
}(CanvasLayerRenderer$1);
var CanvasVectorLayerRenderer$1 = CanvasVectorLayerRenderer;
var __extends$17 = globalThis && globalThis.__extends || function() {
  var extendStatics2 = function(d2, b2) {
    extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {
      d3.__proto__ = b3;
    } || function(d3, b3) {
      for (var p5 in b3)
        if (Object.prototype.hasOwnProperty.call(b3, p5))
          d3[p5] = b3[p5];
    };
    return extendStatics2(d2, b2);
  };
  return function(d2, b2) {
    if (typeof b2 !== "function" && b2 !== null)
      throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
    extendStatics2(d2, b2);
    function __() {
      this.constructor = d2;
    }
    d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
  };
}();
var VectorLayer$1 = function(_super) {
  __extends$17(VectorLayer2, _super);
  function VectorLayer2(opt_options) {
    return _super.call(this, opt_options) || this;
  }
  VectorLayer2.prototype.createRenderer = function() {
    return new CanvasVectorLayerRenderer$1(this);
  };
  return VectorLayer2;
}(BaseVectorLayer$1);
var ol_layer_Vector = VectorLayer$1;
var RBush = function() {
  function RBush2(opt_maxEntries) {
    this.rbush_ = new RBush$2(opt_maxEntries);
    this.items_ = {};
  }
  RBush2.prototype.insert = function(extent2, value) {
    var item = {
      minX: extent2[0],
      minY: extent2[1],
      maxX: extent2[2],
      maxY: extent2[3],
      value
    };
    this.rbush_.insert(item);
    this.items_[getUid(value)] = item;
  };
  RBush2.prototype.load = function(extents, values2) {
    var items = new Array(values2.length);
    for (var i2 = 0, l2 = values2.length; i2 < l2; i2++) {
      var extent2 = extents[i2];
      var value = values2[i2];
      var item = {
        minX: extent2[0],
        minY: extent2[1],
        maxX: extent2[2],
        maxY: extent2[3],
        value
      };
      items[i2] = item;
      this.items_[getUid(value)] = item;
    }
    this.rbush_.load(items);
  };
  RBush2.prototype.remove = function(value) {
    var uid2 = getUid(value);
    var item = this.items_[uid2];
    delete this.items_[uid2];
    return this.rbush_.remove(item) !== null;
  };
  RBush2.prototype.update = function(extent2, value) {
    var item = this.items_[getUid(value)];
    var bbox2 = [item.minX, item.minY, item.maxX, item.maxY];
    if (!equals$1(bbox2, extent2)) {
      this.remove(value);
      this.insert(extent2, value);
    }
  };
  RBush2.prototype.getAll = function() {
    var items = this.rbush_.all();
    return items.map(function(item) {
      return item.value;
    });
  };
  RBush2.prototype.getInExtent = function(extent2) {
    var bbox2 = {
      minX: extent2[0],
      minY: extent2[1],
      maxX: extent2[2],
      maxY: extent2[3]
    };
    var items = this.rbush_.search(bbox2);
    return items.map(function(item) {
      return item.value;
    });
  };
  RBush2.prototype.forEach = function(callback) {
    return this.forEach_(this.getAll(), callback);
  };
  RBush2.prototype.forEachInExtent = function(extent2, callback) {
    return this.forEach_(this.getInExtent(extent2), callback);
  };
  RBush2.prototype.forEach_ = function(values2, callback) {
    var result;
    for (var i2 = 0, l2 = values2.length; i2 < l2; i2++) {
      result = callback(values2[i2]);
      if (result) {
        return result;
      }
    }
    return result;
  };
  RBush2.prototype.isEmpty = function() {
    return isEmpty(this.items_);
  };
  RBush2.prototype.clear = function() {
    this.rbush_.clear();
    this.items_ = {};
  };
  RBush2.prototype.getExtent = function(opt_extent) {
    var data2 = this.rbush_.toJSON();
    return createOrUpdate$2(data2.minX, data2.minY, data2.maxX, data2.maxY, opt_extent);
  };
  RBush2.prototype.concat = function(rbush) {
    this.rbush_.load(rbush.rbush_.all());
    for (var i2 in rbush.items_) {
      this.items_[i2] = rbush.items_[i2];
    }
  };
  return RBush2;
}();
var RBush$1 = RBush;
var __extends$16 = globalThis && globalThis.__extends || function() {
  var extendStatics2 = function(d2, b2) {
    extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {
      d3.__proto__ = b3;
    } || function(d3, b3) {
      for (var p5 in b3)
        if (Object.prototype.hasOwnProperty.call(b3, p5))
          d3[p5] = b3[p5];
    };
    return extendStatics2(d2, b2);
  };
  return function(d2, b2) {
    if (typeof b2 !== "function" && b2 !== null)
      throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
    extendStatics2(d2, b2);
    function __() {
      this.constructor = d2;
    }
    d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
  };
}();
var Source = function(_super) {
  __extends$16(Source2, _super);
  function Source2(options) {
    var _this = _super.call(this) || this;
    _this.projection = get$3(options.projection);
    _this.attributions_ = adaptAttributions(options.attributions);
    _this.attributionsCollapsible_ = options.attributionsCollapsible !== void 0 ? options.attributionsCollapsible : true;
    _this.loading = false;
    _this.state_ = options.state !== void 0 ? options.state : SourceState.READY;
    _this.wrapX_ = options.wrapX !== void 0 ? options.wrapX : false;
    _this.interpolate_ = !!options.interpolate;
    _this.viewResolver = null;
    _this.viewRejector = null;
    var self2 = _this;
    _this.viewPromise_ = new Promise(function(resolve2, reject2) {
      self2.viewResolver = resolve2;
      self2.viewRejector = reject2;
    });
    return _this;
  }
  Source2.prototype.getAttributions = function() {
    return this.attributions_;
  };
  Source2.prototype.getAttributionsCollapsible = function() {
    return this.attributionsCollapsible_;
  };
  Source2.prototype.getProjection = function() {
    return this.projection;
  };
  Source2.prototype.getResolutions = function() {
    return abstract();
  };
  Source2.prototype.getView = function() {
    return this.viewPromise_;
  };
  Source2.prototype.getState = function() {
    return this.state_;
  };
  Source2.prototype.getWrapX = function() {
    return this.wrapX_;
  };
  Source2.prototype.getInterpolate = function() {
    return this.interpolate_;
  };
  Source2.prototype.refresh = function() {
    this.changed();
  };
  Source2.prototype.setAttributions = function(attributions) {
    this.attributions_ = adaptAttributions(attributions);
    this.changed();
  };
  Source2.prototype.setState = function(state) {
    this.state_ = state;
    this.changed();
  };
  return Source2;
}(ol_Object);
function adaptAttributions(attributionLike) {
  if (!attributionLike) {
    return null;
  }
  if (Array.isArray(attributionLike)) {
    return function(frameState) {
      return attributionLike;
    };
  }
  if (typeof attributionLike === "function") {
    return attributionLike;
  }
  return function(frameState) {
    return [attributionLike];
  };
}
var ol_source_Source = Source;
var VectorEventType = {
  ADDFEATURE: "addfeature",
  CHANGEFEATURE: "changefeature",
  CLEAR: "clear",
  REMOVEFEATURE: "removefeature",
  FEATURESLOADSTART: "featuresloadstart",
  FEATURESLOADEND: "featuresloadend",
  FEATURESLOADERROR: "featuresloaderror"
};
function all(extent2, resolution) {
  return [[-Infinity, -Infinity, Infinity, Infinity]];
}
function bbox$1(extent2, resolution) {
  return [extent2];
}
function tile(tileGrid) {
  return function(extent2, resolution, projection) {
    var z2 = tileGrid.getZForResolution(fromUserResolution(resolution));
    var tileRange = tileGrid.getTileRangeForExtentAndZ(fromUserExtent(extent2), z2);
    var extents = [];
    var tileCoord = [z2, 0, 0];
    for (tileCoord[1] = tileRange.minX; tileCoord[1] <= tileRange.maxX; ++tileCoord[1]) {
      for (tileCoord[2] = tileRange.minY; tileCoord[2] <= tileRange.maxY; ++tileCoord[2]) {
        extents.push(toUserExtent(tileGrid.getTileCoordExtent(tileCoord)));
      }
    }
    return extents;
  };
}
var loadingstrategy = Object.freeze(Object.defineProperty({
  __proto__: null,
  all,
  bbox: bbox$1,
  tile
}, Symbol.toStringTag, { value: "Module" }));
var withCredentials = false;
function loadFeaturesXhr(url, format2, extent2, resolution, projection, success, failure) {
  var xhr2 = new XMLHttpRequest();
  xhr2.open("GET", typeof url === "function" ? url(extent2, resolution, projection) : url, true);
  if (format2.getType() == FormatType.ARRAY_BUFFER) {
    xhr2.responseType = "arraybuffer";
  }
  xhr2.withCredentials = withCredentials;
  xhr2.onload = function(event) {
    if (!xhr2.status || xhr2.status >= 200 && xhr2.status < 300) {
      var type = format2.getType();
      var source = void 0;
      if (type == FormatType.JSON || type == FormatType.TEXT) {
        source = xhr2.responseText;
      } else if (type == FormatType.XML) {
        source = xhr2.responseXML;
        if (!source) {
          source = new DOMParser().parseFromString(xhr2.responseText, "application/xml");
        }
      } else if (type == FormatType.ARRAY_BUFFER) {
        source = xhr2.response;
      }
      if (source) {
        success(format2.readFeatures(source, {
          extent: extent2,
          featureProjection: projection
        }), format2.readProjection(source));
      } else {
        failure();
      }
    } else {
      failure();
    }
  };
  xhr2.onerror = failure;
  xhr2.send();
}
function xhr(url, format2) {
  return function(extent2, resolution, projection, success, failure) {
    var source = this;
    loadFeaturesXhr(url, format2, extent2, resolution, projection, function(features, dataProjection) {
      source.addFeatures(features);
      if (success !== void 0) {
        success(features);
      }
    }, failure ? failure : VOID);
  };
}
var __extends$15 = globalThis && globalThis.__extends || function() {
  var extendStatics2 = function(d2, b2) {
    extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {
      d3.__proto__ = b3;
    } || function(d3, b3) {
      for (var p5 in b3)
        if (Object.prototype.hasOwnProperty.call(b3, p5))
          d3[p5] = b3[p5];
    };
    return extendStatics2(d2, b2);
  };
  return function(d2, b2) {
    if (typeof b2 !== "function" && b2 !== null)
      throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
    extendStatics2(d2, b2);
    function __() {
      this.constructor = d2;
    }
    d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
  };
}();
var VectorSourceEvent = function(_super) {
  __extends$15(VectorSourceEvent2, _super);
  function VectorSourceEvent2(type, opt_feature, opt_features) {
    var _this = _super.call(this, type) || this;
    _this.feature = opt_feature;
    _this.features = opt_features;
    return _this;
  }
  return VectorSourceEvent2;
}(Event$1);
var VectorSource = function(_super) {
  __extends$15(VectorSource2, _super);
  function VectorSource2(opt_options) {
    var _this = this;
    var options = opt_options || {};
    _this = _super.call(this, {
      attributions: options.attributions,
      interpolate: true,
      projection: void 0,
      state: SourceState.READY,
      wrapX: options.wrapX !== void 0 ? options.wrapX : true
    }) || this;
    _this.on;
    _this.once;
    _this.un;
    _this.loader_ = VOID;
    _this.format_ = options.format;
    _this.overlaps_ = options.overlaps === void 0 ? true : options.overlaps;
    _this.url_ = options.url;
    if (options.loader !== void 0) {
      _this.loader_ = options.loader;
    } else if (_this.url_ !== void 0) {
      assert(_this.format_, 7);
      _this.loader_ = xhr(_this.url_, _this.format_);
    }
    _this.strategy_ = options.strategy !== void 0 ? options.strategy : all;
    var useSpatialIndex = options.useSpatialIndex !== void 0 ? options.useSpatialIndex : true;
    _this.featuresRtree_ = useSpatialIndex ? new RBush$1() : null;
    _this.loadedExtentsRtree_ = new RBush$1();
    _this.loadingExtentsCount_ = 0;
    _this.nullGeometryFeatures_ = {};
    _this.idIndex_ = {};
    _this.uidIndex_ = {};
    _this.featureChangeKeys_ = {};
    _this.featuresCollection_ = null;
    var collection, features;
    if (Array.isArray(options.features)) {
      features = options.features;
    } else if (options.features) {
      collection = options.features;
      features = collection.getArray();
    }
    if (!useSpatialIndex && collection === void 0) {
      collection = new ol_Collection(features);
    }
    if (features !== void 0) {
      _this.addFeaturesInternal(features);
    }
    if (collection !== void 0) {
      _this.bindFeaturesCollection_(collection);
    }
    return _this;
  }
  VectorSource2.prototype.addFeature = function(feature2) {
    this.addFeatureInternal(feature2);
    this.changed();
  };
  VectorSource2.prototype.addFeatureInternal = function(feature2) {
    var featureKey = getUid(feature2);
    if (!this.addToIndex_(featureKey, feature2)) {
      if (this.featuresCollection_) {
        this.featuresCollection_.remove(feature2);
      }
      return;
    }
    this.setupChangeEvents_(featureKey, feature2);
    var geometry = feature2.getGeometry();
    if (geometry) {
      var extent2 = geometry.getExtent();
      if (this.featuresRtree_) {
        this.featuresRtree_.insert(extent2, feature2);
      }
    } else {
      this.nullGeometryFeatures_[featureKey] = feature2;
    }
    this.dispatchEvent(new VectorSourceEvent(VectorEventType.ADDFEATURE, feature2));
  };
  VectorSource2.prototype.setupChangeEvents_ = function(featureKey, feature2) {
    this.featureChangeKeys_[featureKey] = [
      listen(feature2, EventType.CHANGE, this.handleFeatureChange_, this),
      listen(feature2, ObjectEventType.PROPERTYCHANGE, this.handleFeatureChange_, this)
    ];
  };
  VectorSource2.prototype.addToIndex_ = function(featureKey, feature2) {
    var valid = true;
    var id = feature2.getId();
    if (id !== void 0) {
      if (!(id.toString() in this.idIndex_)) {
        this.idIndex_[id.toString()] = feature2;
      } else {
        valid = false;
      }
    }
    if (valid) {
      assert(!(featureKey in this.uidIndex_), 30);
      this.uidIndex_[featureKey] = feature2;
    }
    return valid;
  };
  VectorSource2.prototype.addFeatures = function(features) {
    this.addFeaturesInternal(features);
    this.changed();
  };
  VectorSource2.prototype.addFeaturesInternal = function(features) {
    var extents = [];
    var newFeatures = [];
    var geometryFeatures = [];
    for (var i2 = 0, length_1 = features.length; i2 < length_1; i2++) {
      var feature2 = features[i2];
      var featureKey = getUid(feature2);
      if (this.addToIndex_(featureKey, feature2)) {
        newFeatures.push(feature2);
      }
    }
    for (var i2 = 0, length_2 = newFeatures.length; i2 < length_2; i2++) {
      var feature2 = newFeatures[i2];
      var featureKey = getUid(feature2);
      this.setupChangeEvents_(featureKey, feature2);
      var geometry = feature2.getGeometry();
      if (geometry) {
        var extent2 = geometry.getExtent();
        extents.push(extent2);
        geometryFeatures.push(feature2);
      } else {
        this.nullGeometryFeatures_[featureKey] = feature2;
      }
    }
    if (this.featuresRtree_) {
      this.featuresRtree_.load(extents, geometryFeatures);
    }
    if (this.hasListener(VectorEventType.ADDFEATURE)) {
      for (var i2 = 0, length_3 = newFeatures.length; i2 < length_3; i2++) {
        this.dispatchEvent(new VectorSourceEvent(VectorEventType.ADDFEATURE, newFeatures[i2]));
      }
    }
  };
  VectorSource2.prototype.bindFeaturesCollection_ = function(collection) {
    var modifyingCollection = false;
    this.addEventListener(VectorEventType.ADDFEATURE, function(evt) {
      if (!modifyingCollection) {
        modifyingCollection = true;
        collection.push(evt.feature);
        modifyingCollection = false;
      }
    });
    this.addEventListener(VectorEventType.REMOVEFEATURE, function(evt) {
      if (!modifyingCollection) {
        modifyingCollection = true;
        collection.remove(evt.feature);
        modifyingCollection = false;
      }
    });
    collection.addEventListener(CollectionEventType.ADD, function(evt) {
      if (!modifyingCollection) {
        modifyingCollection = true;
        this.addFeature(evt.element);
        modifyingCollection = false;
      }
    }.bind(this));
    collection.addEventListener(CollectionEventType.REMOVE, function(evt) {
      if (!modifyingCollection) {
        modifyingCollection = true;
        this.removeFeature(evt.element);
        modifyingCollection = false;
      }
    }.bind(this));
    this.featuresCollection_ = collection;
  };
  VectorSource2.prototype.clear = function(opt_fast) {
    if (opt_fast) {
      for (var featureId in this.featureChangeKeys_) {
        var keys3 = this.featureChangeKeys_[featureId];
        keys3.forEach(unlistenByKey);
      }
      if (!this.featuresCollection_) {
        this.featureChangeKeys_ = {};
        this.idIndex_ = {};
        this.uidIndex_ = {};
      }
    } else {
      if (this.featuresRtree_) {
        var removeAndIgnoreReturn = function(feature2) {
          this.removeFeatureInternal(feature2);
        }.bind(this);
        this.featuresRtree_.forEach(removeAndIgnoreReturn);
        for (var id in this.nullGeometryFeatures_) {
          this.removeFeatureInternal(this.nullGeometryFeatures_[id]);
        }
      }
    }
    if (this.featuresCollection_) {
      this.featuresCollection_.clear();
    }
    if (this.featuresRtree_) {
      this.featuresRtree_.clear();
    }
    this.nullGeometryFeatures_ = {};
    var clearEvent = new VectorSourceEvent(VectorEventType.CLEAR);
    this.dispatchEvent(clearEvent);
    this.changed();
  };
  VectorSource2.prototype.forEachFeature = function(callback) {
    if (this.featuresRtree_) {
      return this.featuresRtree_.forEach(callback);
    } else if (this.featuresCollection_) {
      this.featuresCollection_.forEach(callback);
    }
  };
  VectorSource2.prototype.forEachFeatureAtCoordinateDirect = function(coordinate, callback) {
    var extent2 = [coordinate[0], coordinate[1], coordinate[0], coordinate[1]];
    return this.forEachFeatureInExtent(extent2, function(feature2) {
      var geometry = feature2.getGeometry();
      if (geometry.intersectsCoordinate(coordinate)) {
        return callback(feature2);
      } else {
        return void 0;
      }
    });
  };
  VectorSource2.prototype.forEachFeatureInExtent = function(extent2, callback) {
    if (this.featuresRtree_) {
      return this.featuresRtree_.forEachInExtent(extent2, callback);
    } else if (this.featuresCollection_) {
      this.featuresCollection_.forEach(callback);
    }
  };
  VectorSource2.prototype.forEachFeatureIntersectingExtent = function(extent2, callback) {
    return this.forEachFeatureInExtent(extent2, function(feature2) {
      var geometry = feature2.getGeometry();
      if (geometry.intersectsExtent(extent2)) {
        var result = callback(feature2);
        if (result) {
          return result;
        }
      }
    });
  };
  VectorSource2.prototype.getFeaturesCollection = function() {
    return this.featuresCollection_;
  };
  VectorSource2.prototype.getFeatures = function() {
    var features;
    if (this.featuresCollection_) {
      features = this.featuresCollection_.getArray().slice(0);
    } else if (this.featuresRtree_) {
      features = this.featuresRtree_.getAll();
      if (!isEmpty(this.nullGeometryFeatures_)) {
        extend$3(features, getValues(this.nullGeometryFeatures_));
      }
    }
    return features;
  };
  VectorSource2.prototype.getFeaturesAtCoordinate = function(coordinate) {
    var features = [];
    this.forEachFeatureAtCoordinateDirect(coordinate, function(feature2) {
      features.push(feature2);
    });
    return features;
  };
  VectorSource2.prototype.getFeaturesInExtent = function(extent2) {
    if (this.featuresRtree_) {
      return this.featuresRtree_.getInExtent(extent2);
    } else if (this.featuresCollection_) {
      return this.featuresCollection_.getArray().slice(0);
    } else {
      return [];
    }
  };
  VectorSource2.prototype.getClosestFeatureToCoordinate = function(coordinate, opt_filter) {
    var x2 = coordinate[0];
    var y2 = coordinate[1];
    var closestFeature = null;
    var closestPoint = [NaN, NaN];
    var minSquaredDistance = Infinity;
    var extent2 = [-Infinity, -Infinity, Infinity, Infinity];
    var filter = opt_filter ? opt_filter : TRUE;
    this.featuresRtree_.forEachInExtent(extent2, function(feature2) {
      if (filter(feature2)) {
        var geometry = feature2.getGeometry();
        var previousMinSquaredDistance = minSquaredDistance;
        minSquaredDistance = geometry.closestPointXY(x2, y2, closestPoint, minSquaredDistance);
        if (minSquaredDistance < previousMinSquaredDistance) {
          closestFeature = feature2;
          var minDistance = Math.sqrt(minSquaredDistance);
          extent2[0] = x2 - minDistance;
          extent2[1] = y2 - minDistance;
          extent2[2] = x2 + minDistance;
          extent2[3] = y2 + minDistance;
        }
      }
    });
    return closestFeature;
  };
  VectorSource2.prototype.getExtent = function(opt_extent) {
    return this.featuresRtree_.getExtent(opt_extent);
  };
  VectorSource2.prototype.getFeatureById = function(id) {
    var feature2 = this.idIndex_[id.toString()];
    return feature2 !== void 0 ? feature2 : null;
  };
  VectorSource2.prototype.getFeatureByUid = function(uid2) {
    var feature2 = this.uidIndex_[uid2];
    return feature2 !== void 0 ? feature2 : null;
  };
  VectorSource2.prototype.getFormat = function() {
    return this.format_;
  };
  VectorSource2.prototype.getOverlaps = function() {
    return this.overlaps_;
  };
  VectorSource2.prototype.getUrl = function() {
    return this.url_;
  };
  VectorSource2.prototype.handleFeatureChange_ = function(event) {
    var feature2 = event.target;
    var featureKey = getUid(feature2);
    var geometry = feature2.getGeometry();
    if (!geometry) {
      if (!(featureKey in this.nullGeometryFeatures_)) {
        if (this.featuresRtree_) {
          this.featuresRtree_.remove(feature2);
        }
        this.nullGeometryFeatures_[featureKey] = feature2;
      }
    } else {
      var extent2 = geometry.getExtent();
      if (featureKey in this.nullGeometryFeatures_) {
        delete this.nullGeometryFeatures_[featureKey];
        if (this.featuresRtree_) {
          this.featuresRtree_.insert(extent2, feature2);
        }
      } else {
        if (this.featuresRtree_) {
          this.featuresRtree_.update(extent2, feature2);
        }
      }
    }
    var id = feature2.getId();
    if (id !== void 0) {
      var sid = id.toString();
      if (this.idIndex_[sid] !== feature2) {
        this.removeFromIdIndex_(feature2);
        this.idIndex_[sid] = feature2;
      }
    } else {
      this.removeFromIdIndex_(feature2);
      this.uidIndex_[featureKey] = feature2;
    }
    this.changed();
    this.dispatchEvent(new VectorSourceEvent(VectorEventType.CHANGEFEATURE, feature2));
  };
  VectorSource2.prototype.hasFeature = function(feature2) {
    var id = feature2.getId();
    if (id !== void 0) {
      return id in this.idIndex_;
    } else {
      return getUid(feature2) in this.uidIndex_;
    }
  };
  VectorSource2.prototype.isEmpty = function() {
    if (this.featuresRtree_) {
      return this.featuresRtree_.isEmpty() && isEmpty(this.nullGeometryFeatures_);
    }
    if (this.featuresCollection_) {
      return this.featuresCollection_.getLength() === 0;
    }
    return true;
  };
  VectorSource2.prototype.loadFeatures = function(extent2, resolution, projection) {
    var loadedExtentsRtree = this.loadedExtentsRtree_;
    var extentsToLoad = this.strategy_(extent2, resolution, projection);
    var _loop_1 = function(i3, ii2) {
      var extentToLoad = extentsToLoad[i3];
      var alreadyLoaded = loadedExtentsRtree.forEachInExtent(extentToLoad, function(object) {
        return containsExtent(object.extent, extentToLoad);
      });
      if (!alreadyLoaded) {
        ++this_1.loadingExtentsCount_;
        this_1.dispatchEvent(new VectorSourceEvent(VectorEventType.FEATURESLOADSTART));
        this_1.loader_.call(this_1, extentToLoad, resolution, projection, function(features) {
          --this.loadingExtentsCount_;
          this.dispatchEvent(new VectorSourceEvent(VectorEventType.FEATURESLOADEND, void 0, features));
        }.bind(this_1), function() {
          --this.loadingExtentsCount_;
          this.dispatchEvent(new VectorSourceEvent(VectorEventType.FEATURESLOADERROR));
        }.bind(this_1));
        loadedExtentsRtree.insert(extentToLoad, { extent: extentToLoad.slice() });
      }
    };
    var this_1 = this;
    for (var i2 = 0, ii = extentsToLoad.length; i2 < ii; ++i2) {
      _loop_1(i2);
    }
    this.loading = this.loader_.length < 4 ? false : this.loadingExtentsCount_ > 0;
  };
  VectorSource2.prototype.refresh = function() {
    this.clear(true);
    this.loadedExtentsRtree_.clear();
    _super.prototype.refresh.call(this);
  };
  VectorSource2.prototype.removeLoadedExtent = function(extent2) {
    var loadedExtentsRtree = this.loadedExtentsRtree_;
    var obj;
    loadedExtentsRtree.forEachInExtent(extent2, function(object) {
      if (equals$1(object.extent, extent2)) {
        obj = object;
        return true;
      }
    });
    if (obj) {
      loadedExtentsRtree.remove(obj);
    }
  };
  VectorSource2.prototype.removeFeature = function(feature2) {
    if (!feature2) {
      return;
    }
    var featureKey = getUid(feature2);
    if (featureKey in this.nullGeometryFeatures_) {
      delete this.nullGeometryFeatures_[featureKey];
    } else {
      if (this.featuresRtree_) {
        this.featuresRtree_.remove(feature2);
      }
    }
    var result = this.removeFeatureInternal(feature2);
    if (result) {
      this.changed();
    }
  };
  VectorSource2.prototype.removeFeatureInternal = function(feature2) {
    var featureKey = getUid(feature2);
    var featureChangeKeys = this.featureChangeKeys_[featureKey];
    if (!featureChangeKeys) {
      return;
    }
    featureChangeKeys.forEach(unlistenByKey);
    delete this.featureChangeKeys_[featureKey];
    var id = feature2.getId();
    if (id !== void 0) {
      delete this.idIndex_[id.toString()];
    }
    delete this.uidIndex_[featureKey];
    this.dispatchEvent(new VectorSourceEvent(VectorEventType.REMOVEFEATURE, feature2));
    return feature2;
  };
  VectorSource2.prototype.removeFromIdIndex_ = function(feature2) {
    var removed = false;
    for (var id in this.idIndex_) {
      if (this.idIndex_[id] === feature2) {
        delete this.idIndex_[id];
        removed = true;
        break;
      }
    }
    return removed;
  };
  VectorSource2.prototype.setLoader = function(loader) {
    this.loader_ = loader;
  };
  VectorSource2.prototype.setUrl = function(url) {
    assert(this.format_, 7);
    this.url_ = url;
    this.setLoader(xhr(url, this.format_));
  };
  return VectorSource2;
}(ol_source_Source);
var ol_source_Vector = VectorSource;
var __extends$14 = globalThis && globalThis.__extends || function() {
  var extendStatics2 = function(d2, b2) {
    extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {
      d3.__proto__ = b3;
    } || function(d3, b3) {
      for (var p5 in b3)
        if (Object.prototype.hasOwnProperty.call(b3, p5))
          d3[p5] = b3[p5];
    };
    return extendStatics2(d2, b2);
  };
  return function(d2, b2) {
    if (typeof b2 !== "function" && b2 !== null)
      throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
    extendStatics2(d2, b2);
    function __() {
      this.constructor = d2;
    }
    d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
  };
}();
var Mode = {
  POINT: "Point",
  LINE_STRING: "LineString",
  POLYGON: "Polygon",
  CIRCLE: "Circle"
};
var DrawEventType = {
  DRAWSTART: "drawstart",
  DRAWEND: "drawend",
  DRAWABORT: "drawabort"
};
var DrawEvent = function(_super) {
  __extends$14(DrawEvent2, _super);
  function DrawEvent2(type, feature2) {
    var _this = _super.call(this, type) || this;
    _this.feature = feature2;
    return _this;
  }
  return DrawEvent2;
}(Event$1);
var Draw = function(_super) {
  __extends$14(Draw2, _super);
  function Draw2(options) {
    var _this = this;
    var pointerOptions = options;
    if (!pointerOptions.stopDown) {
      pointerOptions.stopDown = FALSE;
    }
    _this = _super.call(this, pointerOptions) || this;
    _this.on;
    _this.once;
    _this.un;
    _this.shouldHandle_ = false;
    _this.downPx_ = null;
    _this.downTimeout_;
    _this.lastDragTime_;
    _this.pointerType_;
    _this.freehand_ = false;
    _this.source_ = options.source ? options.source : null;
    _this.features_ = options.features ? options.features : null;
    _this.snapTolerance_ = options.snapTolerance ? options.snapTolerance : 12;
    _this.type_ = options.type;
    _this.mode_ = getMode(_this.type_);
    _this.stopClick_ = !!options.stopClick;
    _this.minPoints_ = options.minPoints ? options.minPoints : _this.mode_ === Mode.POLYGON ? 3 : 2;
    _this.maxPoints_ = _this.mode_ === Mode.CIRCLE ? 2 : options.maxPoints ? options.maxPoints : Infinity;
    _this.finishCondition_ = options.finishCondition ? options.finishCondition : TRUE;
    var geometryFunction = options.geometryFunction;
    if (!geometryFunction) {
      var mode_1 = _this.mode_;
      if (mode_1 === Mode.CIRCLE) {
        geometryFunction = function(coordinates2, geometry, projection) {
          var circle = geometry ? geometry : new ol_geom_Circle([NaN, NaN]);
          var center = fromUserCoordinate(coordinates2[0]);
          var squaredLength = squaredDistance(center, fromUserCoordinate(coordinates2[coordinates2.length - 1]));
          circle.setCenterAndRadius(center, Math.sqrt(squaredLength));
          return circle;
        };
      } else {
        var Constructor_1;
        if (mode_1 === Mode.POINT) {
          Constructor_1 = Point$4;
        } else if (mode_1 === Mode.LINE_STRING) {
          Constructor_1 = LineString$2;
        } else if (mode_1 === Mode.POLYGON) {
          Constructor_1 = Polygon$2;
        }
        geometryFunction = function(coordinates2, geometry, projection) {
          if (geometry) {
            if (mode_1 === Mode.POLYGON) {
              if (coordinates2[0].length) {
                geometry.setCoordinates([
                  coordinates2[0].concat([coordinates2[0][0]])
                ]);
              } else {
                geometry.setCoordinates([]);
              }
            } else {
              geometry.setCoordinates(coordinates2);
            }
          } else {
            geometry = new Constructor_1(coordinates2);
          }
          return geometry;
        };
      }
    }
    _this.geometryFunction_ = geometryFunction;
    _this.dragVertexDelay_ = options.dragVertexDelay !== void 0 ? options.dragVertexDelay : 500;
    _this.finishCoordinate_ = null;
    _this.sketchFeature_ = null;
    _this.sketchPoint_ = null;
    _this.sketchCoords_ = null;
    _this.sketchLine_ = null;
    _this.sketchLineCoords_ = null;
    _this.squaredClickTolerance_ = options.clickTolerance ? options.clickTolerance * options.clickTolerance : 36;
    _this.overlay_ = new ol_layer_Vector({
      source: new ol_source_Vector({
        useSpatialIndex: false,
        wrapX: options.wrapX ? options.wrapX : false
      }),
      style: options.style ? options.style : getDefaultStyleFunction$2(),
      updateWhileInteracting: true
    });
    _this.geometryName_ = options.geometryName;
    _this.condition_ = options.condition ? options.condition : noModifierKeys;
    _this.freehandCondition_;
    if (options.freehand) {
      _this.freehandCondition_ = always;
    } else {
      _this.freehandCondition_ = options.freehandCondition ? options.freehandCondition : shiftKeyOnly;
    }
    _this.addChangeListener(InteractionProperty.ACTIVE, _this.updateState_);
    return _this;
  }
  Draw2.prototype.setMap = function(map) {
    _super.prototype.setMap.call(this, map);
    this.updateState_();
  };
  Draw2.prototype.getOverlay = function() {
    return this.overlay_;
  };
  Draw2.prototype.handleEvent = function(event) {
    if (event.originalEvent.type === EventType.CONTEXTMENU) {
      event.originalEvent.preventDefault();
    }
    this.freehand_ = this.mode_ !== Mode.POINT && this.freehandCondition_(event);
    var move = event.type === MapBrowserEventType.POINTERMOVE;
    var pass = true;
    if (!this.freehand_ && this.lastDragTime_ && event.type === MapBrowserEventType.POINTERDRAG) {
      var now2 = Date.now();
      if (now2 - this.lastDragTime_ >= this.dragVertexDelay_) {
        this.downPx_ = event.pixel;
        this.shouldHandle_ = !this.freehand_;
        move = true;
      } else {
        this.lastDragTime_ = void 0;
      }
      if (this.shouldHandle_ && this.downTimeout_ !== void 0) {
        clearTimeout(this.downTimeout_);
        this.downTimeout_ = void 0;
      }
    }
    if (this.freehand_ && event.type === MapBrowserEventType.POINTERDRAG && this.sketchFeature_ !== null) {
      this.addToDrawing_(event.coordinate);
      pass = false;
    } else if (this.freehand_ && event.type === MapBrowserEventType.POINTERDOWN) {
      pass = false;
    } else if (move && this.getPointerCount() < 2) {
      pass = event.type === MapBrowserEventType.POINTERMOVE;
      if (pass && this.freehand_) {
        this.handlePointerMove_(event);
        if (this.shouldHandle_) {
          event.originalEvent.preventDefault();
        }
      } else if (event.originalEvent.pointerType === "mouse" || event.type === MapBrowserEventType.POINTERDRAG && this.downTimeout_ === void 0) {
        this.handlePointerMove_(event);
      }
    } else if (event.type === MapBrowserEventType.DBLCLICK) {
      pass = false;
    }
    return _super.prototype.handleEvent.call(this, event) && pass;
  };
  Draw2.prototype.handleDownEvent = function(event) {
    this.shouldHandle_ = !this.freehand_;
    if (this.freehand_) {
      this.downPx_ = event.pixel;
      if (!this.finishCoordinate_) {
        this.startDrawing_(event.coordinate);
      }
      return true;
    } else if (this.condition_(event)) {
      this.lastDragTime_ = Date.now();
      this.downTimeout_ = setTimeout(function() {
        this.handlePointerMove_(new MapBrowserEvent$1(MapBrowserEventType.POINTERMOVE, event.map, event.originalEvent, false, event.frameState));
      }.bind(this), this.dragVertexDelay_);
      this.downPx_ = event.pixel;
      return true;
    } else {
      this.lastDragTime_ = void 0;
      return false;
    }
  };
  Draw2.prototype.handleUpEvent = function(event) {
    var pass = true;
    if (this.getPointerCount() === 0) {
      if (this.downTimeout_) {
        clearTimeout(this.downTimeout_);
        this.downTimeout_ = void 0;
      }
      this.handlePointerMove_(event);
      if (this.shouldHandle_) {
        var startingToDraw = !this.finishCoordinate_;
        if (startingToDraw) {
          this.startDrawing_(event.coordinate);
        }
        if (!startingToDraw && this.freehand_) {
          this.finishDrawing();
        } else if (!this.freehand_ && (!startingToDraw || this.mode_ === Mode.POINT)) {
          if (this.atFinish_(event.pixel)) {
            if (this.finishCondition_(event)) {
              this.finishDrawing();
            }
          } else {
            this.addToDrawing_(event.coordinate);
          }
        }
        pass = false;
      } else if (this.freehand_) {
        this.abortDrawing();
      }
    }
    if (!pass && this.stopClick_) {
      event.preventDefault();
    }
    return pass;
  };
  Draw2.prototype.handlePointerMove_ = function(event) {
    this.pointerType_ = event.originalEvent.pointerType;
    if (this.downPx_ && (!this.freehand_ && this.shouldHandle_ || this.freehand_ && !this.shouldHandle_)) {
      var downPx = this.downPx_;
      var clickPx = event.pixel;
      var dx = downPx[0] - clickPx[0];
      var dy = downPx[1] - clickPx[1];
      var squaredDistance2 = dx * dx + dy * dy;
      this.shouldHandle_ = this.freehand_ ? squaredDistance2 > this.squaredClickTolerance_ : squaredDistance2 <= this.squaredClickTolerance_;
      if (!this.shouldHandle_) {
        return;
      }
    }
    if (this.finishCoordinate_) {
      this.modifyDrawing_(event.coordinate);
    } else {
      this.createOrUpdateSketchPoint_(event.coordinate.slice());
    }
  };
  Draw2.prototype.atFinish_ = function(pixel) {
    var at2 = false;
    if (this.sketchFeature_) {
      var potentiallyDone = false;
      var potentiallyFinishCoordinates = [this.finishCoordinate_];
      var mode2 = this.mode_;
      if (mode2 === Mode.POINT) {
        at2 = true;
      } else if (mode2 === Mode.CIRCLE) {
        at2 = this.sketchCoords_.length === 2;
      } else if (mode2 === Mode.LINE_STRING) {
        potentiallyDone = this.sketchCoords_.length > this.minPoints_;
      } else if (mode2 === Mode.POLYGON) {
        var sketchCoords = this.sketchCoords_;
        potentiallyDone = sketchCoords[0].length > this.minPoints_;
        potentiallyFinishCoordinates = [
          sketchCoords[0][0],
          sketchCoords[0][sketchCoords[0].length - 2]
        ];
      }
      if (potentiallyDone) {
        var map = this.getMap();
        for (var i2 = 0, ii = potentiallyFinishCoordinates.length; i2 < ii; i2++) {
          var finishCoordinate = potentiallyFinishCoordinates[i2];
          var finishPixel = map.getPixelFromCoordinate(finishCoordinate);
          var dx = pixel[0] - finishPixel[0];
          var dy = pixel[1] - finishPixel[1];
          var snapTolerance = this.freehand_ ? 1 : this.snapTolerance_;
          at2 = Math.sqrt(dx * dx + dy * dy) <= snapTolerance;
          if (at2) {
            this.finishCoordinate_ = finishCoordinate;
            break;
          }
        }
      }
    }
    return at2;
  };
  Draw2.prototype.createOrUpdateSketchPoint_ = function(coordinates2) {
    if (!this.sketchPoint_) {
      this.sketchPoint_ = new feature(new Point$4(coordinates2));
      this.updateSketchFeatures_();
    } else {
      var sketchPointGeom = this.sketchPoint_.getGeometry();
      sketchPointGeom.setCoordinates(coordinates2);
    }
  };
  Draw2.prototype.createOrUpdateCustomSketchLine_ = function(geometry) {
    if (!this.sketchLine_) {
      this.sketchLine_ = new feature();
    }
    var ring = geometry.getLinearRing(0);
    var sketchLineGeom = this.sketchLine_.getGeometry();
    if (!sketchLineGeom) {
      sketchLineGeom = new LineString$2(ring.getFlatCoordinates(), ring.getLayout());
      this.sketchLine_.setGeometry(sketchLineGeom);
    } else {
      sketchLineGeom.setFlatCoordinates(ring.getLayout(), ring.getFlatCoordinates());
      sketchLineGeom.changed();
    }
  };
  Draw2.prototype.startDrawing_ = function(start2) {
    var projection = this.getMap().getView().getProjection();
    this.finishCoordinate_ = start2;
    if (this.mode_ === Mode.POINT) {
      this.sketchCoords_ = start2.slice();
    } else if (this.mode_ === Mode.POLYGON) {
      this.sketchCoords_ = [[start2.slice(), start2.slice()]];
      this.sketchLineCoords_ = this.sketchCoords_[0];
    } else {
      this.sketchCoords_ = [start2.slice(), start2.slice()];
    }
    if (this.sketchLineCoords_) {
      this.sketchLine_ = new feature(new LineString$2(this.sketchLineCoords_));
    }
    var geometry = this.geometryFunction_(this.sketchCoords_, void 0, projection);
    this.sketchFeature_ = new feature();
    if (this.geometryName_) {
      this.sketchFeature_.setGeometryName(this.geometryName_);
    }
    this.sketchFeature_.setGeometry(geometry);
    this.updateSketchFeatures_();
    this.dispatchEvent(new DrawEvent(DrawEventType.DRAWSTART, this.sketchFeature_));
  };
  Draw2.prototype.modifyDrawing_ = function(coordinate) {
    var map = this.getMap();
    var geometry = this.sketchFeature_.getGeometry();
    var projection = map.getView().getProjection();
    var coordinates2, last;
    if (this.mode_ === Mode.POINT) {
      last = this.sketchCoords_;
    } else if (this.mode_ === Mode.POLYGON) {
      coordinates2 = this.sketchCoords_[0];
      last = coordinates2[coordinates2.length - 1];
      if (this.atFinish_(map.getPixelFromCoordinate(coordinate))) {
        coordinate = this.finishCoordinate_.slice();
      }
    } else {
      coordinates2 = this.sketchCoords_;
      last = coordinates2[coordinates2.length - 1];
    }
    last[0] = coordinate[0];
    last[1] = coordinate[1];
    this.geometryFunction_(this.sketchCoords_, geometry, projection);
    if (this.sketchPoint_) {
      var sketchPointGeom = this.sketchPoint_.getGeometry();
      sketchPointGeom.setCoordinates(coordinate);
    }
    if (geometry.getType() === GeometryType.POLYGON && this.mode_ !== Mode.POLYGON) {
      this.createOrUpdateCustomSketchLine_(geometry);
    } else if (this.sketchLineCoords_) {
      var sketchLineGeom = this.sketchLine_.getGeometry();
      sketchLineGeom.setCoordinates(this.sketchLineCoords_);
    }
    this.updateSketchFeatures_();
  };
  Draw2.prototype.addToDrawing_ = function(coordinate) {
    var geometry = this.sketchFeature_.getGeometry();
    var projection = this.getMap().getView().getProjection();
    var done;
    var coordinates2;
    var mode2 = this.mode_;
    if (mode2 === Mode.LINE_STRING || mode2 === Mode.CIRCLE) {
      this.finishCoordinate_ = coordinate.slice();
      coordinates2 = this.sketchCoords_;
      if (coordinates2.length >= this.maxPoints_) {
        if (this.freehand_) {
          coordinates2.pop();
        } else {
          done = true;
        }
      }
      coordinates2.push(coordinate.slice());
      this.geometryFunction_(coordinates2, geometry, projection);
    } else if (mode2 === Mode.POLYGON) {
      coordinates2 = this.sketchCoords_[0];
      if (coordinates2.length >= this.maxPoints_) {
        if (this.freehand_) {
          coordinates2.pop();
        } else {
          done = true;
        }
      }
      coordinates2.push(coordinate.slice());
      if (done) {
        this.finishCoordinate_ = coordinates2[0];
      }
      this.geometryFunction_(this.sketchCoords_, geometry, projection);
    }
    this.createOrUpdateSketchPoint_(coordinate.slice());
    this.updateSketchFeatures_();
    if (done) {
      this.finishDrawing();
    }
  };
  Draw2.prototype.removeLastPoint = function() {
    if (!this.sketchFeature_) {
      return;
    }
    var geometry = this.sketchFeature_.getGeometry();
    var projection = this.getMap().getView().getProjection();
    var coordinates2;
    var mode2 = this.mode_;
    if (mode2 === Mode.LINE_STRING || mode2 === Mode.CIRCLE) {
      coordinates2 = this.sketchCoords_;
      coordinates2.splice(-2, 1);
      if (coordinates2.length >= 2) {
        this.finishCoordinate_ = coordinates2[coordinates2.length - 2].slice();
        var finishCoordinate = this.finishCoordinate_.slice();
        coordinates2[coordinates2.length - 1] = finishCoordinate;
        this.createOrUpdateSketchPoint_(finishCoordinate);
      }
      this.geometryFunction_(coordinates2, geometry, projection);
      if (geometry.getType() === GeometryType.POLYGON && this.sketchLine_) {
        this.createOrUpdateCustomSketchLine_(geometry);
      }
    } else if (mode2 === Mode.POLYGON) {
      coordinates2 = this.sketchCoords_[0];
      coordinates2.splice(-2, 1);
      var sketchLineGeom = this.sketchLine_.getGeometry();
      if (coordinates2.length >= 2) {
        var finishCoordinate = coordinates2[coordinates2.length - 2].slice();
        coordinates2[coordinates2.length - 1] = finishCoordinate;
        this.createOrUpdateSketchPoint_(finishCoordinate);
      }
      sketchLineGeom.setCoordinates(coordinates2);
      this.geometryFunction_(this.sketchCoords_, geometry, projection);
    }
    if (coordinates2.length === 1) {
      this.abortDrawing();
    }
    this.updateSketchFeatures_();
  };
  Draw2.prototype.finishDrawing = function() {
    var sketchFeature = this.abortDrawing_();
    if (!sketchFeature) {
      return;
    }
    var coordinates2 = this.sketchCoords_;
    var geometry = sketchFeature.getGeometry();
    var projection = this.getMap().getView().getProjection();
    if (this.mode_ === Mode.LINE_STRING) {
      coordinates2.pop();
      this.geometryFunction_(coordinates2, geometry, projection);
    } else if (this.mode_ === Mode.POLYGON) {
      coordinates2[0].pop();
      this.geometryFunction_(coordinates2, geometry, projection);
      coordinates2 = geometry.getCoordinates();
    }
    if (this.type_ === GeometryType.MULTI_POINT) {
      sketchFeature.setGeometry(new MultiPoint$2([coordinates2]));
    } else if (this.type_ === GeometryType.MULTI_LINE_STRING) {
      sketchFeature.setGeometry(new MultiLineString$2([coordinates2]));
    } else if (this.type_ === GeometryType.MULTI_POLYGON) {
      sketchFeature.setGeometry(new MultiPolygon$2([coordinates2]));
    }
    this.dispatchEvent(new DrawEvent(DrawEventType.DRAWEND, sketchFeature));
    if (this.features_) {
      this.features_.push(sketchFeature);
    }
    if (this.source_) {
      this.source_.addFeature(sketchFeature);
    }
  };
  Draw2.prototype.abortDrawing_ = function() {
    this.finishCoordinate_ = null;
    var sketchFeature = this.sketchFeature_;
    this.sketchFeature_ = null;
    this.sketchPoint_ = null;
    this.sketchLine_ = null;
    this.overlay_.getSource().clear(true);
    return sketchFeature;
  };
  Draw2.prototype.abortDrawing = function() {
    var sketchFeature = this.abortDrawing_();
    if (sketchFeature) {
      this.dispatchEvent(new DrawEvent(DrawEventType.DRAWABORT, sketchFeature));
    }
  };
  Draw2.prototype.appendCoordinates = function(coordinates2) {
    var mode2 = this.mode_;
    var newDrawing = !this.sketchFeature_;
    if (newDrawing) {
      this.startDrawing_(coordinates2[0]);
    }
    var sketchCoords;
    if (mode2 === Mode.LINE_STRING || mode2 === Mode.CIRCLE) {
      sketchCoords = this.sketchCoords_;
    } else if (mode2 === Mode.POLYGON) {
      sketchCoords = this.sketchCoords_ && this.sketchCoords_.length ? this.sketchCoords_[0] : [];
    } else {
      return;
    }
    if (newDrawing) {
      sketchCoords.shift();
    }
    sketchCoords.pop();
    for (var i2 = 0; i2 < coordinates2.length; i2++) {
      this.addToDrawing_(coordinates2[i2]);
    }
    var ending = coordinates2[coordinates2.length - 1];
    this.addToDrawing_(ending);
    this.modifyDrawing_(ending);
  };
  Draw2.prototype.extend = function(feature$1) {
    var geometry = feature$1.getGeometry();
    var lineString = geometry;
    this.sketchFeature_ = feature$1;
    this.sketchCoords_ = lineString.getCoordinates();
    var last = this.sketchCoords_[this.sketchCoords_.length - 1];
    this.finishCoordinate_ = last.slice();
    this.sketchCoords_.push(last.slice());
    this.sketchPoint_ = new feature(new Point$4(last));
    this.updateSketchFeatures_();
    this.dispatchEvent(new DrawEvent(DrawEventType.DRAWSTART, this.sketchFeature_));
  };
  Draw2.prototype.updateSketchFeatures_ = function() {
    var sketchFeatures = [];
    if (this.sketchFeature_) {
      sketchFeatures.push(this.sketchFeature_);
    }
    if (this.sketchLine_) {
      sketchFeatures.push(this.sketchLine_);
    }
    if (this.sketchPoint_) {
      sketchFeatures.push(this.sketchPoint_);
    }
    var overlaySource = this.overlay_.getSource();
    overlaySource.clear(true);
    overlaySource.addFeatures(sketchFeatures);
  };
  Draw2.prototype.updateState_ = function() {
    var map = this.getMap();
    var active = this.getActive();
    if (!map || !active) {
      this.abortDrawing();
    }
    this.overlay_.setMap(active ? map : null);
  };
  return Draw2;
}(ol_interaction_Pointer);
function getDefaultStyleFunction$2() {
  var styles = createEditingStyle();
  return function(feature2, resolution) {
    return styles[feature2.getGeometry().getType()];
  };
}
function getMode(type) {
  switch (type) {
    case GeometryType.POINT:
    case GeometryType.MULTI_POINT:
      return Mode.POINT;
    case GeometryType.LINE_STRING:
    case GeometryType.MULTI_LINE_STRING:
      return Mode.LINE_STRING;
    case GeometryType.POLYGON:
    case GeometryType.MULTI_POLYGON:
      return Mode.POLYGON;
    case GeometryType.CIRCLE:
      return Mode.CIRCLE;
    default:
      throw new Error("Invalid type: " + type);
  }
}
var Draw$1 = Draw;
var __extends$13 = globalThis && globalThis.__extends || function() {
  var extendStatics2 = function(d2, b2) {
    extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {
      d3.__proto__ = b3;
    } || function(d3, b3) {
      for (var p5 in b3)
        if (Object.prototype.hasOwnProperty.call(b3, p5))
          d3[p5] = b3[p5];
    };
    return extendStatics2(d2, b2);
  };
  return function(d2, b2) {
    if (typeof b2 !== "function" && b2 !== null)
      throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
    extendStatics2(d2, b2);
    function __() {
      this.constructor = d2;
    }
    d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
  };
}();
var CIRCLE_CENTER_INDEX = 0;
var CIRCLE_CIRCUMFERENCE_INDEX = 1;
var tempExtent = [0, 0, 0, 0];
var tempSegment$1 = [];
var ModifyEventType = {
  MODIFYSTART: "modifystart",
  MODIFYEND: "modifyend"
};
var ModifyEvent = function(_super) {
  __extends$13(ModifyEvent2, _super);
  function ModifyEvent2(type, features, mapBrowserEvent) {
    var _this = _super.call(this, type) || this;
    _this.features = features;
    _this.mapBrowserEvent = mapBrowserEvent;
    return _this;
  }
  return ModifyEvent2;
}(Event$1);
var Modify = function(_super) {
  __extends$13(Modify2, _super);
  function Modify2(options) {
    var _this = _super.call(this, options) || this;
    _this.on;
    _this.once;
    _this.un;
    _this.boundHandleFeatureChange_ = _this.handleFeatureChange_.bind(_this);
    _this.condition_ = options.condition ? options.condition : primaryAction;
    _this.defaultDeleteCondition_ = function(mapBrowserEvent) {
      return altKeyOnly(mapBrowserEvent) && singleClick(mapBrowserEvent);
    };
    _this.deleteCondition_ = options.deleteCondition ? options.deleteCondition : _this.defaultDeleteCondition_;
    _this.insertVertexCondition_ = options.insertVertexCondition ? options.insertVertexCondition : always;
    _this.vertexFeature_ = null;
    _this.vertexSegments_ = null;
    _this.lastPixel_ = [0, 0];
    _this.ignoreNextSingleClick_ = false;
    _this.featuresBeingModified_ = null;
    _this.rBush_ = new RBush$1();
    _this.pixelTolerance_ = options.pixelTolerance !== void 0 ? options.pixelTolerance : 10;
    _this.snappedToVertex_ = false;
    _this.changingFeature_ = false;
    _this.dragSegments_ = [];
    _this.overlay_ = new ol_layer_Vector({
      source: new ol_source_Vector({
        useSpatialIndex: false,
        wrapX: !!options.wrapX
      }),
      style: options.style ? options.style : getDefaultStyleFunction$1(),
      updateWhileAnimating: true,
      updateWhileInteracting: true
    });
    _this.SEGMENT_WRITERS_ = {
      "Point": _this.writePointGeometry_.bind(_this),
      "LineString": _this.writeLineStringGeometry_.bind(_this),
      "LinearRing": _this.writeLineStringGeometry_.bind(_this),
      "Polygon": _this.writePolygonGeometry_.bind(_this),
      "MultiPoint": _this.writeMultiPointGeometry_.bind(_this),
      "MultiLineString": _this.writeMultiLineStringGeometry_.bind(_this),
      "MultiPolygon": _this.writeMultiPolygonGeometry_.bind(_this),
      "Circle": _this.writeCircleGeometry_.bind(_this),
      "GeometryCollection": _this.writeGeometryCollectionGeometry_.bind(_this)
    };
    _this.source_ = null;
    _this.hitDetection_ = null;
    var features;
    if (options.features) {
      features = options.features;
    } else if (options.source) {
      _this.source_ = options.source;
      features = new ol_Collection(_this.source_.getFeatures());
      _this.source_.addEventListener(VectorEventType.ADDFEATURE, _this.handleSourceAdd_.bind(_this));
      _this.source_.addEventListener(VectorEventType.REMOVEFEATURE, _this.handleSourceRemove_.bind(_this));
    }
    if (!features) {
      throw new Error("The modify interaction requires features, a source or a layer");
    }
    if (options.hitDetection) {
      _this.hitDetection_ = options.hitDetection;
    }
    _this.features_ = features;
    _this.features_.forEach(_this.addFeature_.bind(_this));
    _this.features_.addEventListener(CollectionEventType.ADD, _this.handleFeatureAdd_.bind(_this));
    _this.features_.addEventListener(CollectionEventType.REMOVE, _this.handleFeatureRemove_.bind(_this));
    _this.lastPointerEvent_ = null;
    _this.delta_ = [0, 0];
    _this.snapToPointer_ = options.snapToPointer === void 0 ? !_this.hitDetection_ : options.snapToPointer;
    return _this;
  }
  Modify2.prototype.addFeature_ = function(feature2) {
    var geometry = feature2.getGeometry();
    if (geometry) {
      var writer = this.SEGMENT_WRITERS_[geometry.getType()];
      if (writer) {
        writer(feature2, geometry);
      }
    }
    var map = this.getMap();
    if (map && map.isRendered() && this.getActive()) {
      this.handlePointerAtPixel_(this.lastPixel_, map);
    }
    feature2.addEventListener(EventType.CHANGE, this.boundHandleFeatureChange_);
  };
  Modify2.prototype.willModifyFeatures_ = function(evt, segments) {
    if (!this.featuresBeingModified_) {
      this.featuresBeingModified_ = new ol_Collection();
      var features = this.featuresBeingModified_.getArray();
      for (var i2 = 0, ii = segments.length; i2 < ii; ++i2) {
        var segment = segments[i2];
        for (var s2 = 0, ss = segment.length; s2 < ss; ++s2) {
          var feature2 = segment[s2].feature;
          if (feature2 && features.indexOf(feature2) === -1) {
            this.featuresBeingModified_.push(feature2);
          }
        }
      }
      if (this.featuresBeingModified_.getLength() === 0) {
        this.featuresBeingModified_ = null;
      } else {
        this.dispatchEvent(new ModifyEvent(ModifyEventType.MODIFYSTART, this.featuresBeingModified_, evt));
      }
    }
  };
  Modify2.prototype.removeFeature_ = function(feature2) {
    this.removeFeatureSegmentData_(feature2);
    if (this.vertexFeature_ && this.features_.getLength() === 0) {
      this.overlay_.getSource().removeFeature(this.vertexFeature_);
      this.vertexFeature_ = null;
    }
    feature2.removeEventListener(EventType.CHANGE, this.boundHandleFeatureChange_);
  };
  Modify2.prototype.removeFeatureSegmentData_ = function(feature2) {
    var rBush = this.rBush_;
    var nodesToRemove = [];
    rBush.forEach(function(node2) {
      if (feature2 === node2.feature) {
        nodesToRemove.push(node2);
      }
    });
    for (var i2 = nodesToRemove.length - 1; i2 >= 0; --i2) {
      var nodeToRemove = nodesToRemove[i2];
      for (var j2 = this.dragSegments_.length - 1; j2 >= 0; --j2) {
        if (this.dragSegments_[j2][0] === nodeToRemove) {
          this.dragSegments_.splice(j2, 1);
        }
      }
      rBush.remove(nodeToRemove);
    }
  };
  Modify2.prototype.setActive = function(active) {
    if (this.vertexFeature_ && !active) {
      this.overlay_.getSource().removeFeature(this.vertexFeature_);
      this.vertexFeature_ = null;
    }
    _super.prototype.setActive.call(this, active);
  };
  Modify2.prototype.setMap = function(map) {
    this.overlay_.setMap(map);
    _super.prototype.setMap.call(this, map);
  };
  Modify2.prototype.getOverlay = function() {
    return this.overlay_;
  };
  Modify2.prototype.handleSourceAdd_ = function(event) {
    if (event.feature) {
      this.features_.push(event.feature);
    }
  };
  Modify2.prototype.handleSourceRemove_ = function(event) {
    if (event.feature) {
      this.features_.remove(event.feature);
    }
  };
  Modify2.prototype.handleFeatureAdd_ = function(evt) {
    this.addFeature_(evt.element);
  };
  Modify2.prototype.handleFeatureChange_ = function(evt) {
    if (!this.changingFeature_) {
      var feature2 = evt.target;
      this.removeFeature_(feature2);
      this.addFeature_(feature2);
    }
  };
  Modify2.prototype.handleFeatureRemove_ = function(evt) {
    var feature2 = evt.element;
    this.removeFeature_(feature2);
  };
  Modify2.prototype.writePointGeometry_ = function(feature2, geometry) {
    var coordinates2 = geometry.getCoordinates();
    var segmentData = {
      feature: feature2,
      geometry,
      segment: [coordinates2, coordinates2]
    };
    this.rBush_.insert(geometry.getExtent(), segmentData);
  };
  Modify2.prototype.writeMultiPointGeometry_ = function(feature2, geometry) {
    var points = geometry.getCoordinates();
    for (var i2 = 0, ii = points.length; i2 < ii; ++i2) {
      var coordinates2 = points[i2];
      var segmentData = {
        feature: feature2,
        geometry,
        depth: [i2],
        index: i2,
        segment: [coordinates2, coordinates2]
      };
      this.rBush_.insert(geometry.getExtent(), segmentData);
    }
  };
  Modify2.prototype.writeLineStringGeometry_ = function(feature2, geometry) {
    var coordinates2 = geometry.getCoordinates();
    for (var i2 = 0, ii = coordinates2.length - 1; i2 < ii; ++i2) {
      var segment = coordinates2.slice(i2, i2 + 2);
      var segmentData = {
        feature: feature2,
        geometry,
        index: i2,
        segment
      };
      this.rBush_.insert(boundingExtent(segment), segmentData);
    }
  };
  Modify2.prototype.writeMultiLineStringGeometry_ = function(feature2, geometry) {
    var lines = geometry.getCoordinates();
    for (var j2 = 0, jj = lines.length; j2 < jj; ++j2) {
      var coordinates2 = lines[j2];
      for (var i2 = 0, ii = coordinates2.length - 1; i2 < ii; ++i2) {
        var segment = coordinates2.slice(i2, i2 + 2);
        var segmentData = {
          feature: feature2,
          geometry,
          depth: [j2],
          index: i2,
          segment
        };
        this.rBush_.insert(boundingExtent(segment), segmentData);
      }
    }
  };
  Modify2.prototype.writePolygonGeometry_ = function(feature2, geometry) {
    var rings = geometry.getCoordinates();
    for (var j2 = 0, jj = rings.length; j2 < jj; ++j2) {
      var coordinates2 = rings[j2];
      for (var i2 = 0, ii = coordinates2.length - 1; i2 < ii; ++i2) {
        var segment = coordinates2.slice(i2, i2 + 2);
        var segmentData = {
          feature: feature2,
          geometry,
          depth: [j2],
          index: i2,
          segment
        };
        this.rBush_.insert(boundingExtent(segment), segmentData);
      }
    }
  };
  Modify2.prototype.writeMultiPolygonGeometry_ = function(feature2, geometry) {
    var polygons = geometry.getCoordinates();
    for (var k2 = 0, kk = polygons.length; k2 < kk; ++k2) {
      var rings = polygons[k2];
      for (var j2 = 0, jj = rings.length; j2 < jj; ++j2) {
        var coordinates2 = rings[j2];
        for (var i2 = 0, ii = coordinates2.length - 1; i2 < ii; ++i2) {
          var segment = coordinates2.slice(i2, i2 + 2);
          var segmentData = {
            feature: feature2,
            geometry,
            depth: [j2, k2],
            index: i2,
            segment
          };
          this.rBush_.insert(boundingExtent(segment), segmentData);
        }
      }
    }
  };
  Modify2.prototype.writeCircleGeometry_ = function(feature2, geometry) {
    var coordinates2 = geometry.getCenter();
    var centerSegmentData = {
      feature: feature2,
      geometry,
      index: CIRCLE_CENTER_INDEX,
      segment: [coordinates2, coordinates2]
    };
    var circumferenceSegmentData = {
      feature: feature2,
      geometry,
      index: CIRCLE_CIRCUMFERENCE_INDEX,
      segment: [coordinates2, coordinates2]
    };
    var featureSegments = [centerSegmentData, circumferenceSegmentData];
    centerSegmentData.featureSegments = featureSegments;
    circumferenceSegmentData.featureSegments = featureSegments;
    this.rBush_.insert(createOrUpdateFromCoordinate(coordinates2), centerSegmentData);
    var circleGeometry = geometry;
    this.rBush_.insert(circleGeometry.getExtent(), circumferenceSegmentData);
  };
  Modify2.prototype.writeGeometryCollectionGeometry_ = function(feature2, geometry) {
    var geometries = geometry.getGeometriesArray();
    for (var i2 = 0; i2 < geometries.length; ++i2) {
      var geometry_1 = geometries[i2];
      var writer = this.SEGMENT_WRITERS_[geometry_1.getType()];
      writer(feature2, geometry_1);
    }
  };
  Modify2.prototype.createOrUpdateVertexFeature_ = function(coordinates2, features, geometries) {
    var vertexFeature = this.vertexFeature_;
    if (!vertexFeature) {
      vertexFeature = new feature(new Point$4(coordinates2));
      this.vertexFeature_ = vertexFeature;
      this.overlay_.getSource().addFeature(vertexFeature);
    } else {
      var geometry = vertexFeature.getGeometry();
      geometry.setCoordinates(coordinates2);
    }
    vertexFeature.set("features", features);
    vertexFeature.set("geometries", geometries);
    return vertexFeature;
  };
  Modify2.prototype.handleEvent = function(mapBrowserEvent) {
    if (!mapBrowserEvent.originalEvent) {
      return true;
    }
    this.lastPointerEvent_ = mapBrowserEvent;
    var handled;
    if (!mapBrowserEvent.map.getView().getInteracting() && mapBrowserEvent.type == MapBrowserEventType.POINTERMOVE && !this.handlingDownUpSequence) {
      this.handlePointerMove_(mapBrowserEvent);
    }
    if (this.vertexFeature_ && this.deleteCondition_(mapBrowserEvent)) {
      if (mapBrowserEvent.type != MapBrowserEventType.SINGLECLICK || !this.ignoreNextSingleClick_) {
        handled = this.removePoint();
      } else {
        handled = true;
      }
    }
    if (mapBrowserEvent.type == MapBrowserEventType.SINGLECLICK) {
      this.ignoreNextSingleClick_ = false;
    }
    return _super.prototype.handleEvent.call(this, mapBrowserEvent) && !handled;
  };
  Modify2.prototype.handleDragEvent = function(evt) {
    this.ignoreNextSingleClick_ = false;
    this.willModifyFeatures_(evt, this.dragSegments_);
    var vertex = [
      evt.coordinate[0] + this.delta_[0],
      evt.coordinate[1] + this.delta_[1]
    ];
    var features = [];
    var geometries = [];
    for (var i2 = 0, ii = this.dragSegments_.length; i2 < ii; ++i2) {
      var dragSegment = this.dragSegments_[i2];
      var segmentData = dragSegment[0];
      var feature2 = segmentData.feature;
      if (features.indexOf(feature2) === -1) {
        features.push(feature2);
      }
      var geometry = segmentData.geometry;
      if (geometries.indexOf(geometry) === -1) {
        geometries.push(geometry);
      }
      var depth = segmentData.depth;
      var coordinates2 = void 0;
      var segment = segmentData.segment;
      var index2 = dragSegment[1];
      while (vertex.length < geometry.getStride()) {
        vertex.push(segment[index2][vertex.length]);
      }
      switch (geometry.getType()) {
        case GeometryType.POINT:
          coordinates2 = vertex;
          segment[0] = vertex;
          segment[1] = vertex;
          break;
        case GeometryType.MULTI_POINT:
          coordinates2 = geometry.getCoordinates();
          coordinates2[segmentData.index] = vertex;
          segment[0] = vertex;
          segment[1] = vertex;
          break;
        case GeometryType.LINE_STRING:
          coordinates2 = geometry.getCoordinates();
          coordinates2[segmentData.index + index2] = vertex;
          segment[index2] = vertex;
          break;
        case GeometryType.MULTI_LINE_STRING:
          coordinates2 = geometry.getCoordinates();
          coordinates2[depth[0]][segmentData.index + index2] = vertex;
          segment[index2] = vertex;
          break;
        case GeometryType.POLYGON:
          coordinates2 = geometry.getCoordinates();
          coordinates2[depth[0]][segmentData.index + index2] = vertex;
          segment[index2] = vertex;
          break;
        case GeometryType.MULTI_POLYGON:
          coordinates2 = geometry.getCoordinates();
          coordinates2[depth[1]][depth[0]][segmentData.index + index2] = vertex;
          segment[index2] = vertex;
          break;
        case GeometryType.CIRCLE:
          segment[0] = vertex;
          segment[1] = vertex;
          if (segmentData.index === CIRCLE_CENTER_INDEX) {
            this.changingFeature_ = true;
            geometry.setCenter(vertex);
            this.changingFeature_ = false;
          } else {
            this.changingFeature_ = true;
            var projection = evt.map.getView().getProjection();
            var radius = distance$1(fromUserCoordinate(geometry.getCenter()), fromUserCoordinate(vertex));
            var userProjection2 = getUserProjection();
            if (userProjection2) {
              var circleGeometry = geometry.clone().transform(userProjection2, projection);
              circleGeometry.setRadius(radius);
              radius = circleGeometry.transform(projection, userProjection2).getRadius();
            }
            geometry.setRadius(radius);
            this.changingFeature_ = false;
          }
          break;
      }
      if (coordinates2) {
        this.setGeometryCoordinates_(geometry, coordinates2);
      }
    }
    this.createOrUpdateVertexFeature_(vertex, features, geometries);
  };
  Modify2.prototype.handleDownEvent = function(evt) {
    if (!this.condition_(evt)) {
      return false;
    }
    var pixelCoordinate = evt.coordinate;
    this.handlePointerAtPixel_(evt.pixel, evt.map, pixelCoordinate);
    this.dragSegments_.length = 0;
    this.featuresBeingModified_ = null;
    var vertexFeature = this.vertexFeature_;
    if (vertexFeature) {
      var projection = evt.map.getView().getProjection();
      var insertVertices = [];
      var vertex = vertexFeature.getGeometry().getCoordinates();
      var vertexExtent = boundingExtent([vertex]);
      var segmentDataMatches = this.rBush_.getInExtent(vertexExtent);
      var componentSegments = {};
      segmentDataMatches.sort(compareIndexes);
      for (var i2 = 0, ii = segmentDataMatches.length; i2 < ii; ++i2) {
        var segmentDataMatch = segmentDataMatches[i2];
        var segment = segmentDataMatch.segment;
        var uid2 = getUid(segmentDataMatch.geometry);
        var depth = segmentDataMatch.depth;
        if (depth) {
          uid2 += "-" + depth.join("-");
        }
        if (!componentSegments[uid2]) {
          componentSegments[uid2] = new Array(2);
        }
        if (segmentDataMatch.geometry.getType() === GeometryType.CIRCLE && segmentDataMatch.index === CIRCLE_CIRCUMFERENCE_INDEX) {
          var closestVertex = closestOnSegmentData(pixelCoordinate, segmentDataMatch, projection);
          if (equals(closestVertex, vertex) && !componentSegments[uid2][0]) {
            this.dragSegments_.push([segmentDataMatch, 0]);
            componentSegments[uid2][0] = segmentDataMatch;
          }
          continue;
        }
        if (equals(segment[0], vertex) && !componentSegments[uid2][0]) {
          this.dragSegments_.push([segmentDataMatch, 0]);
          componentSegments[uid2][0] = segmentDataMatch;
          continue;
        }
        if (equals(segment[1], vertex) && !componentSegments[uid2][1]) {
          if ((segmentDataMatch.geometry.getType() === GeometryType.LINE_STRING || segmentDataMatch.geometry.getType() === GeometryType.MULTI_LINE_STRING) && componentSegments[uid2][0] && componentSegments[uid2][0].index === 0) {
            continue;
          }
          this.dragSegments_.push([segmentDataMatch, 1]);
          componentSegments[uid2][1] = segmentDataMatch;
          continue;
        }
        if (getUid(segment) in this.vertexSegments_ && !componentSegments[uid2][0] && !componentSegments[uid2][1] && this.insertVertexCondition_(evt)) {
          insertVertices.push(segmentDataMatch);
        }
      }
      if (insertVertices.length) {
        this.willModifyFeatures_(evt, [insertVertices]);
      }
      for (var j2 = insertVertices.length - 1; j2 >= 0; --j2) {
        this.insertVertex_(insertVertices[j2], vertex);
      }
    }
    return !!this.vertexFeature_;
  };
  Modify2.prototype.handleUpEvent = function(evt) {
    for (var i2 = this.dragSegments_.length - 1; i2 >= 0; --i2) {
      var segmentData = this.dragSegments_[i2][0];
      var geometry = segmentData.geometry;
      if (geometry.getType() === GeometryType.CIRCLE) {
        var coordinates2 = geometry.getCenter();
        var centerSegmentData = segmentData.featureSegments[0];
        var circumferenceSegmentData = segmentData.featureSegments[1];
        centerSegmentData.segment[0] = coordinates2;
        centerSegmentData.segment[1] = coordinates2;
        circumferenceSegmentData.segment[0] = coordinates2;
        circumferenceSegmentData.segment[1] = coordinates2;
        this.rBush_.update(createOrUpdateFromCoordinate(coordinates2), centerSegmentData);
        var circleGeometry = geometry;
        var userProjection2 = getUserProjection();
        if (userProjection2) {
          var projection = evt.map.getView().getProjection();
          circleGeometry = circleGeometry.clone().transform(userProjection2, projection);
          circleGeometry = fromCircle(circleGeometry).transform(projection, userProjection2);
        }
        this.rBush_.update(circleGeometry.getExtent(), circumferenceSegmentData);
      } else {
        this.rBush_.update(boundingExtent(segmentData.segment), segmentData);
      }
    }
    if (this.featuresBeingModified_) {
      this.dispatchEvent(new ModifyEvent(ModifyEventType.MODIFYEND, this.featuresBeingModified_, evt));
      this.featuresBeingModified_ = null;
    }
    return false;
  };
  Modify2.prototype.handlePointerMove_ = function(evt) {
    this.lastPixel_ = evt.pixel;
    this.handlePointerAtPixel_(evt.pixel, evt.map, evt.coordinate);
  };
  Modify2.prototype.handlePointerAtPixel_ = function(pixel, map, opt_coordinate) {
    var _this = this;
    var pixelCoordinate = opt_coordinate || map.getCoordinateFromPixel(pixel);
    var projection = map.getView().getProjection();
    var sortByDistance = function(a2, b2) {
      return projectedDistanceToSegmentDataSquared(pixelCoordinate, a2, projection) - projectedDistanceToSegmentDataSquared(pixelCoordinate, b2, projection);
    };
    var nodes;
    var hitPointGeometry;
    if (this.hitDetection_) {
      var layerFilter = typeof this.hitDetection_ === "object" ? function(layer) {
        return layer === _this.hitDetection_;
      } : void 0;
      map.forEachFeatureAtPixel(pixel, function(feature2, layer, geometry) {
        geometry = geometry || feature2.getGeometry();
        if (geometry.getType() === GeometryType.POINT && includes(_this.features_.getArray(), feature2)) {
          hitPointGeometry = geometry;
          var coordinate = geometry.getFlatCoordinates().slice(0, 2);
          nodes = [
            {
              feature: feature2,
              geometry,
              segment: [coordinate, coordinate]
            }
          ];
        }
        return true;
      }, { layerFilter });
    }
    if (!nodes) {
      var viewExtent = fromUserExtent(createOrUpdateFromCoordinate(pixelCoordinate, tempExtent));
      var buffer2 = map.getView().getResolution() * this.pixelTolerance_;
      var box = toUserExtent(buffer$1(viewExtent, buffer2, tempExtent));
      nodes = this.rBush_.getInExtent(box);
    }
    if (nodes && nodes.length > 0) {
      var node2 = nodes.sort(sortByDistance)[0];
      var closestSegment = node2.segment;
      var vertex = closestOnSegmentData(pixelCoordinate, node2, projection);
      var vertexPixel = map.getPixelFromCoordinate(vertex);
      var dist = distance$1(pixel, vertexPixel);
      if (hitPointGeometry || dist <= this.pixelTolerance_) {
        var vertexSegments = {};
        vertexSegments[getUid(closestSegment)] = true;
        if (!this.snapToPointer_) {
          this.delta_[0] = vertex[0] - pixelCoordinate[0];
          this.delta_[1] = vertex[1] - pixelCoordinate[1];
        }
        if (node2.geometry.getType() === GeometryType.CIRCLE && node2.index === CIRCLE_CIRCUMFERENCE_INDEX) {
          this.snappedToVertex_ = true;
          this.createOrUpdateVertexFeature_(vertex, [node2.feature], [node2.geometry]);
        } else {
          var pixel1 = map.getPixelFromCoordinate(closestSegment[0]);
          var pixel2 = map.getPixelFromCoordinate(closestSegment[1]);
          var squaredDist1 = squaredDistance(vertexPixel, pixel1);
          var squaredDist2 = squaredDistance(vertexPixel, pixel2);
          dist = Math.sqrt(Math.min(squaredDist1, squaredDist2));
          this.snappedToVertex_ = dist <= this.pixelTolerance_;
          if (this.snappedToVertex_) {
            vertex = squaredDist1 > squaredDist2 ? closestSegment[1] : closestSegment[0];
          }
          this.createOrUpdateVertexFeature_(vertex, [node2.feature], [node2.geometry]);
          var geometries = {};
          geometries[getUid(node2.geometry)] = true;
          for (var i2 = 1, ii = nodes.length; i2 < ii; ++i2) {
            var segment = nodes[i2].segment;
            if (equals(closestSegment[0], segment[0]) && equals(closestSegment[1], segment[1]) || equals(closestSegment[0], segment[1]) && equals(closestSegment[1], segment[0])) {
              var geometryUid = getUid(nodes[i2].geometry);
              if (!(geometryUid in geometries)) {
                geometries[geometryUid] = true;
                vertexSegments[getUid(segment)] = true;
              }
            } else {
              break;
            }
          }
        }
        this.vertexSegments_ = vertexSegments;
        return;
      }
    }
    if (this.vertexFeature_) {
      this.overlay_.getSource().removeFeature(this.vertexFeature_);
      this.vertexFeature_ = null;
    }
  };
  Modify2.prototype.insertVertex_ = function(segmentData, vertex) {
    var segment = segmentData.segment;
    var feature2 = segmentData.feature;
    var geometry = segmentData.geometry;
    var depth = segmentData.depth;
    var index2 = segmentData.index;
    var coordinates2;
    while (vertex.length < geometry.getStride()) {
      vertex.push(0);
    }
    switch (geometry.getType()) {
      case GeometryType.MULTI_LINE_STRING:
        coordinates2 = geometry.getCoordinates();
        coordinates2[depth[0]].splice(index2 + 1, 0, vertex);
        break;
      case GeometryType.POLYGON:
        coordinates2 = geometry.getCoordinates();
        coordinates2[depth[0]].splice(index2 + 1, 0, vertex);
        break;
      case GeometryType.MULTI_POLYGON:
        coordinates2 = geometry.getCoordinates();
        coordinates2[depth[1]][depth[0]].splice(index2 + 1, 0, vertex);
        break;
      case GeometryType.LINE_STRING:
        coordinates2 = geometry.getCoordinates();
        coordinates2.splice(index2 + 1, 0, vertex);
        break;
      default:
        return;
    }
    this.setGeometryCoordinates_(geometry, coordinates2);
    var rTree = this.rBush_;
    rTree.remove(segmentData);
    this.updateSegmentIndices_(geometry, index2, depth, 1);
    var newSegmentData = {
      segment: [segment[0], vertex],
      feature: feature2,
      geometry,
      depth,
      index: index2
    };
    rTree.insert(boundingExtent(newSegmentData.segment), newSegmentData);
    this.dragSegments_.push([newSegmentData, 1]);
    var newSegmentData2 = {
      segment: [vertex, segment[1]],
      feature: feature2,
      geometry,
      depth,
      index: index2 + 1
    };
    rTree.insert(boundingExtent(newSegmentData2.segment), newSegmentData2);
    this.dragSegments_.push([newSegmentData2, 0]);
    this.ignoreNextSingleClick_ = true;
  };
  Modify2.prototype.removePoint = function() {
    if (this.lastPointerEvent_ && this.lastPointerEvent_.type != MapBrowserEventType.POINTERDRAG) {
      var evt = this.lastPointerEvent_;
      this.willModifyFeatures_(evt, this.dragSegments_);
      var removed = this.removeVertex_();
      if (this.featuresBeingModified_) {
        this.dispatchEvent(new ModifyEvent(ModifyEventType.MODIFYEND, this.featuresBeingModified_, evt));
      }
      this.featuresBeingModified_ = null;
      return removed;
    }
    return false;
  };
  Modify2.prototype.removeVertex_ = function() {
    var dragSegments = this.dragSegments_;
    var segmentsByFeature = {};
    var deleted = false;
    var component, coordinates2, dragSegment, geometry, i2, index2, left;
    var newIndex, right, segmentData, uid2;
    for (i2 = dragSegments.length - 1; i2 >= 0; --i2) {
      dragSegment = dragSegments[i2];
      segmentData = dragSegment[0];
      uid2 = getUid(segmentData.feature);
      if (segmentData.depth) {
        uid2 += "-" + segmentData.depth.join("-");
      }
      if (!(uid2 in segmentsByFeature)) {
        segmentsByFeature[uid2] = {};
      }
      if (dragSegment[1] === 0) {
        segmentsByFeature[uid2].right = segmentData;
        segmentsByFeature[uid2].index = segmentData.index;
      } else if (dragSegment[1] == 1) {
        segmentsByFeature[uid2].left = segmentData;
        segmentsByFeature[uid2].index = segmentData.index + 1;
      }
    }
    for (uid2 in segmentsByFeature) {
      right = segmentsByFeature[uid2].right;
      left = segmentsByFeature[uid2].left;
      index2 = segmentsByFeature[uid2].index;
      newIndex = index2 - 1;
      if (left !== void 0) {
        segmentData = left;
      } else {
        segmentData = right;
      }
      if (newIndex < 0) {
        newIndex = 0;
      }
      geometry = segmentData.geometry;
      coordinates2 = geometry.getCoordinates();
      component = coordinates2;
      deleted = false;
      switch (geometry.getType()) {
        case GeometryType.MULTI_LINE_STRING:
          if (coordinates2[segmentData.depth[0]].length > 2) {
            coordinates2[segmentData.depth[0]].splice(index2, 1);
            deleted = true;
          }
          break;
        case GeometryType.LINE_STRING:
          if (coordinates2.length > 2) {
            coordinates2.splice(index2, 1);
            deleted = true;
          }
          break;
        case GeometryType.MULTI_POLYGON:
          component = component[segmentData.depth[1]];
        case GeometryType.POLYGON:
          component = component[segmentData.depth[0]];
          if (component.length > 4) {
            if (index2 == component.length - 1) {
              index2 = 0;
            }
            component.splice(index2, 1);
            deleted = true;
            if (index2 === 0) {
              component.pop();
              component.push(component[0]);
              newIndex = component.length - 1;
            }
          }
          break;
      }
      if (deleted) {
        this.setGeometryCoordinates_(geometry, coordinates2);
        var segments = [];
        if (left !== void 0) {
          this.rBush_.remove(left);
          segments.push(left.segment[0]);
        }
        if (right !== void 0) {
          this.rBush_.remove(right);
          segments.push(right.segment[1]);
        }
        if (left !== void 0 && right !== void 0) {
          var newSegmentData = {
            depth: segmentData.depth,
            feature: segmentData.feature,
            geometry: segmentData.geometry,
            index: newIndex,
            segment: segments
          };
          this.rBush_.insert(boundingExtent(newSegmentData.segment), newSegmentData);
        }
        this.updateSegmentIndices_(geometry, index2, segmentData.depth, -1);
        if (this.vertexFeature_) {
          this.overlay_.getSource().removeFeature(this.vertexFeature_);
          this.vertexFeature_ = null;
        }
        dragSegments.length = 0;
      }
    }
    return deleted;
  };
  Modify2.prototype.setGeometryCoordinates_ = function(geometry, coordinates2) {
    this.changingFeature_ = true;
    geometry.setCoordinates(coordinates2);
    this.changingFeature_ = false;
  };
  Modify2.prototype.updateSegmentIndices_ = function(geometry, index2, depth, delta) {
    this.rBush_.forEachInExtent(geometry.getExtent(), function(segmentDataMatch) {
      if (segmentDataMatch.geometry === geometry && (depth === void 0 || segmentDataMatch.depth === void 0 || equals$2(segmentDataMatch.depth, depth)) && segmentDataMatch.index > index2) {
        segmentDataMatch.index += delta;
      }
    });
  };
  return Modify2;
}(ol_interaction_Pointer);
function compareIndexes(a2, b2) {
  return a2.index - b2.index;
}
function projectedDistanceToSegmentDataSquared(pointCoordinates, segmentData, projection) {
  var geometry = segmentData.geometry;
  if (geometry.getType() === GeometryType.CIRCLE) {
    var circleGeometry = geometry;
    if (segmentData.index === CIRCLE_CIRCUMFERENCE_INDEX) {
      var userProjection2 = getUserProjection();
      if (userProjection2) {
        circleGeometry = circleGeometry.clone().transform(userProjection2, projection);
      }
      var distanceToCenterSquared = squaredDistance(circleGeometry.getCenter(), fromUserCoordinate(pointCoordinates));
      var distanceToCircumference = Math.sqrt(distanceToCenterSquared) - circleGeometry.getRadius();
      return distanceToCircumference * distanceToCircumference;
    }
  }
  var coordinate = fromUserCoordinate(pointCoordinates);
  tempSegment$1[0] = fromUserCoordinate(segmentData.segment[0]);
  tempSegment$1[1] = fromUserCoordinate(segmentData.segment[1]);
  return squaredDistanceToSegment(coordinate, tempSegment$1);
}
function closestOnSegmentData(pointCoordinates, segmentData, projection) {
  var geometry = segmentData.geometry;
  if (geometry.getType() === GeometryType.CIRCLE && segmentData.index === CIRCLE_CIRCUMFERENCE_INDEX) {
    var circleGeometry = geometry;
    var userProjection2 = getUserProjection();
    if (userProjection2) {
      circleGeometry = circleGeometry.clone().transform(userProjection2, projection);
    }
    return toUserCoordinate(circleGeometry.getClosestPoint(fromUserCoordinate(pointCoordinates)));
  }
  var coordinate = fromUserCoordinate(pointCoordinates);
  tempSegment$1[0] = fromUserCoordinate(segmentData.segment[0]);
  tempSegment$1[1] = fromUserCoordinate(segmentData.segment[1]);
  return toUserCoordinate(closestOnSegment(coordinate, tempSegment$1));
}
function getDefaultStyleFunction$1() {
  var style2 = createEditingStyle();
  return function(feature2, resolution) {
    return style2[GeometryType.POINT];
  };
}
var Modify$1 = Modify;
var __extends$12 = globalThis && globalThis.__extends || function() {
  var extendStatics2 = function(d2, b2) {
    extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {
      d3.__proto__ = b3;
    } || function(d3, b3) {
      for (var p5 in b3)
        if (Object.prototype.hasOwnProperty.call(b3, p5))
          d3[p5] = b3[p5];
    };
    return extendStatics2(d2, b2);
  };
  return function(d2, b2) {
    if (typeof b2 !== "function" && b2 !== null)
      throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
    extendStatics2(d2, b2);
    function __() {
      this.constructor = d2;
    }
    d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
  };
}();
var SelectEventType = {
  SELECT: "select"
};
var SelectEvent = function(_super) {
  __extends$12(SelectEvent2, _super);
  function SelectEvent2(type, selected, deselected, mapBrowserEvent) {
    var _this = _super.call(this, type) || this;
    _this.selected = selected;
    _this.deselected = deselected;
    _this.mapBrowserEvent = mapBrowserEvent;
    return _this;
  }
  return SelectEvent2;
}(Event$1);
var originalFeatureStyles = {};
var Select = function(_super) {
  __extends$12(Select2, _super);
  function Select2(opt_options) {
    var _this = _super.call(this) || this;
    _this.on;
    _this.once;
    _this.un;
    var options = opt_options ? opt_options : {};
    _this.boundAddFeature_ = _this.addFeature_.bind(_this);
    _this.boundRemoveFeature_ = _this.removeFeature_.bind(_this);
    _this.condition_ = options.condition ? options.condition : singleClick;
    _this.addCondition_ = options.addCondition ? options.addCondition : never;
    _this.removeCondition_ = options.removeCondition ? options.removeCondition : never;
    _this.toggleCondition_ = options.toggleCondition ? options.toggleCondition : shiftKeyOnly;
    _this.multi_ = options.multi ? options.multi : false;
    _this.filter_ = options.filter ? options.filter : TRUE;
    _this.hitTolerance_ = options.hitTolerance ? options.hitTolerance : 0;
    _this.style_ = options.style !== void 0 ? options.style : getDefaultStyleFunction();
    _this.features_ = options.features || new ol_Collection();
    var layerFilter;
    if (options.layers) {
      if (typeof options.layers === "function") {
        layerFilter = options.layers;
      } else {
        var layers_1 = options.layers;
        layerFilter = function(layer) {
          return includes(layers_1, layer);
        };
      }
    } else {
      layerFilter = TRUE;
    }
    _this.layerFilter_ = layerFilter;
    _this.featureLayerAssociation_ = {};
    return _this;
  }
  Select2.prototype.addFeatureLayerAssociation_ = function(feature2, layer) {
    this.featureLayerAssociation_[getUid(feature2)] = layer;
  };
  Select2.prototype.getFeatures = function() {
    return this.features_;
  };
  Select2.prototype.getHitTolerance = function() {
    return this.hitTolerance_;
  };
  Select2.prototype.getLayer = function(feature2) {
    return this.featureLayerAssociation_[getUid(feature2)];
  };
  Select2.prototype.setHitTolerance = function(hitTolerance) {
    this.hitTolerance_ = hitTolerance;
  };
  Select2.prototype.setMap = function(map) {
    var currentMap = this.getMap();
    if (currentMap && this.style_) {
      this.features_.forEach(this.restorePreviousStyle_.bind(this));
    }
    _super.prototype.setMap.call(this, map);
    if (map) {
      this.features_.addEventListener(CollectionEventType.ADD, this.boundAddFeature_);
      this.features_.addEventListener(CollectionEventType.REMOVE, this.boundRemoveFeature_);
      if (this.style_) {
        this.features_.forEach(this.applySelectedStyle_.bind(this));
      }
    } else {
      this.features_.removeEventListener(CollectionEventType.ADD, this.boundAddFeature_);
      this.features_.removeEventListener(CollectionEventType.REMOVE, this.boundRemoveFeature_);
    }
  };
  Select2.prototype.addFeature_ = function(evt) {
    var feature2 = evt.element;
    if (this.style_) {
      this.applySelectedStyle_(feature2);
    }
    if (!this.getLayer(feature2)) {
      var layer = this.getMap().getAllLayers().find(function(layer2) {
        if (layer2 instanceof ol_layer_Vector && layer2.getSource() && layer2.getSource().hasFeature(feature2)) {
          return layer2;
        }
      });
      if (layer) {
        this.addFeatureLayerAssociation_(feature2, layer);
      }
    }
  };
  Select2.prototype.removeFeature_ = function(evt) {
    var feature2 = evt.element;
    if (this.style_) {
      this.restorePreviousStyle_(feature2);
    }
  };
  Select2.prototype.getStyle = function() {
    return this.style_;
  };
  Select2.prototype.applySelectedStyle_ = function(feature2) {
    var key = getUid(feature2);
    if (!(key in originalFeatureStyles)) {
      originalFeatureStyles[key] = feature2.getStyle();
    }
    feature2.setStyle(this.style_);
  };
  Select2.prototype.restorePreviousStyle_ = function(feature2) {
    var interactions = this.getMap().getInteractions().getArray();
    for (var i2 = interactions.length - 1; i2 >= 0; --i2) {
      var interaction = interactions[i2];
      if (interaction !== this && interaction instanceof Select2 && interaction.getStyle() && interaction.getFeatures().getArray().lastIndexOf(feature2) !== -1) {
        feature2.setStyle(interaction.getStyle());
        return;
      }
    }
    var key = getUid(feature2);
    feature2.setStyle(originalFeatureStyles[key]);
    delete originalFeatureStyles[key];
  };
  Select2.prototype.removeFeatureLayerAssociation_ = function(feature2) {
    delete this.featureLayerAssociation_[getUid(feature2)];
  };
  Select2.prototype.handleEvent = function(mapBrowserEvent) {
    if (!this.condition_(mapBrowserEvent)) {
      return true;
    }
    var add2 = this.addCondition_(mapBrowserEvent);
    var remove = this.removeCondition_(mapBrowserEvent);
    var toggle2 = this.toggleCondition_(mapBrowserEvent);
    var set2 = !add2 && !remove && !toggle2;
    var map = mapBrowserEvent.map;
    var features = this.getFeatures();
    var deselected = [];
    var selected = [];
    if (set2) {
      clear$1(this.featureLayerAssociation_);
      map.forEachFeatureAtPixel(mapBrowserEvent.pixel, function(feature3, layer) {
        if (this.filter_(feature3, layer)) {
          this.addFeatureLayerAssociation_(feature3, layer);
          selected.push(feature3);
          return !this.multi_;
        }
      }.bind(this), {
        layerFilter: this.layerFilter_,
        hitTolerance: this.hitTolerance_
      });
      for (var i2 = features.getLength() - 1; i2 >= 0; --i2) {
        var feature2 = features.item(i2);
        var index2 = selected.indexOf(feature2);
        if (index2 > -1) {
          selected.splice(index2, 1);
        } else {
          features.remove(feature2);
          deselected.push(feature2);
        }
      }
      if (selected.length !== 0) {
        features.extend(selected);
      }
    } else {
      map.forEachFeatureAtPixel(mapBrowserEvent.pixel, function(feature3, layer) {
        if (this.filter_(feature3, layer)) {
          if ((add2 || toggle2) && !includes(features.getArray(), feature3)) {
            this.addFeatureLayerAssociation_(feature3, layer);
            selected.push(feature3);
          } else if ((remove || toggle2) && includes(features.getArray(), feature3)) {
            deselected.push(feature3);
            this.removeFeatureLayerAssociation_(feature3);
          }
          return !this.multi_;
        }
      }.bind(this), {
        layerFilter: this.layerFilter_,
        hitTolerance: this.hitTolerance_
      });
      for (var j2 = deselected.length - 1; j2 >= 0; --j2) {
        features.remove(deselected[j2]);
      }
      features.extend(selected);
    }
    if (selected.length > 0 || deselected.length > 0) {
      this.dispatchEvent(new SelectEvent(SelectEventType.SELECT, selected, deselected, mapBrowserEvent));
    }
    return true;
  };
  return Select2;
}(Interaction$1);
function getDefaultStyleFunction() {
  var styles = createEditingStyle();
  extend$3(styles[GeometryType.POLYGON], styles[GeometryType.LINE_STRING]);
  extend$3(styles[GeometryType.GEOMETRY_COLLECTION], styles[GeometryType.LINE_STRING]);
  return function(feature2) {
    if (!feature2.getGeometry()) {
      return null;
    }
    return styles[feature2.getGeometry().getType()];
  };
}
var ol_interaction_Select = Select;
var __extends$11 = globalThis && globalThis.__extends || function() {
  var extendStatics2 = function(d2, b2) {
    extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {
      d3.__proto__ = b3;
    } || function(d3, b3) {
      for (var p5 in b3)
        if (Object.prototype.hasOwnProperty.call(b3, p5))
          d3[p5] = b3[p5];
    };
    return extendStatics2(d2, b2);
  };
  return function(d2, b2) {
    if (typeof b2 !== "function" && b2 !== null)
      throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
    extendStatics2(d2, b2);
    function __() {
      this.constructor = d2;
    }
    d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
  };
}();
function getFeatureFromEvent(evt) {
  if (evt.feature) {
    return evt.feature;
  } else if (evt.element) {
    return evt.element;
  }
}
var tempSegment = [];
var Snap = function(_super) {
  __extends$11(Snap2, _super);
  function Snap2(opt_options) {
    var _this = this;
    var options = opt_options ? opt_options : {};
    var pointerOptions = options;
    if (!pointerOptions.handleDownEvent) {
      pointerOptions.handleDownEvent = TRUE;
    }
    if (!pointerOptions.stopDown) {
      pointerOptions.stopDown = FALSE;
    }
    _this = _super.call(this, pointerOptions) || this;
    _this.source_ = options.source ? options.source : null;
    _this.vertex_ = options.vertex !== void 0 ? options.vertex : true;
    _this.edge_ = options.edge !== void 0 ? options.edge : true;
    _this.features_ = options.features ? options.features : null;
    _this.featuresListenerKeys_ = [];
    _this.featureChangeListenerKeys_ = {};
    _this.indexedFeaturesExtents_ = {};
    _this.pendingFeatures_ = {};
    _this.pixelTolerance_ = options.pixelTolerance !== void 0 ? options.pixelTolerance : 10;
    _this.rBush_ = new RBush$1();
    _this.GEOMETRY_SEGMENTERS_ = {
      "Point": _this.segmentPointGemetry_.bind(_this),
      "LineString": _this.segmentLineStringGemetry_.bind(_this),
      "LinearRing": _this.segmentLineStringGemetry_.bind(_this),
      "Polygon": _this.segmentPolygonGemetry_.bind(_this),
      "MultiPoint": _this.segmentMultiPointGemetry_.bind(_this),
      "MultiLineString": _this.segmentMultiLineStringGemetry_.bind(_this),
      "MultiPolygon": _this.segmentMultiPolygonGemetry_.bind(_this),
      "GeometryCollection": _this.segmentGeometryCollectionGemetry_.bind(_this),
      "Circle": _this.segmentCircleGemetry_.bind(_this)
    };
    return _this;
  }
  Snap2.prototype.addFeature = function(feature2, opt_listen) {
    var register2 = opt_listen !== void 0 ? opt_listen : true;
    var feature_uid = getUid(feature2);
    var geometry = feature2.getGeometry();
    if (geometry) {
      var segmenter = this.GEOMETRY_SEGMENTERS_[geometry.getType()];
      if (segmenter) {
        this.indexedFeaturesExtents_[feature_uid] = geometry.getExtent(createEmpty());
        var segments = [];
        segmenter(segments, geometry);
        if (segments.length === 1) {
          this.rBush_.insert(boundingExtent(segments[0]), {
            feature: feature2,
            segment: segments[0]
          });
        } else if (segments.length > 1) {
          var extents = segments.map(function(s2) {
            return boundingExtent(s2);
          });
          var segmentsData = segments.map(function(segment) {
            return {
              feature: feature2,
              segment
            };
          });
          this.rBush_.load(extents, segmentsData);
        }
      }
    }
    if (register2) {
      this.featureChangeListenerKeys_[feature_uid] = listen(feature2, EventType.CHANGE, this.handleFeatureChange_, this);
    }
  };
  Snap2.prototype.forEachFeatureAdd_ = function(feature2) {
    this.addFeature(feature2);
  };
  Snap2.prototype.forEachFeatureRemove_ = function(feature2) {
    this.removeFeature(feature2);
  };
  Snap2.prototype.getFeatures_ = function() {
    var features;
    if (this.features_) {
      features = this.features_;
    } else if (this.source_) {
      features = this.source_.getFeatures();
    }
    return features;
  };
  Snap2.prototype.handleEvent = function(evt) {
    var result = this.snapTo(evt.pixel, evt.coordinate, evt.map);
    if (result) {
      evt.coordinate = result.vertex.slice(0, 2);
      evt.pixel = result.vertexPixel;
    }
    return _super.prototype.handleEvent.call(this, evt);
  };
  Snap2.prototype.handleFeatureAdd_ = function(evt) {
    var feature2 = getFeatureFromEvent(evt);
    this.addFeature(feature2);
  };
  Snap2.prototype.handleFeatureRemove_ = function(evt) {
    var feature2 = getFeatureFromEvent(evt);
    this.removeFeature(feature2);
  };
  Snap2.prototype.handleFeatureChange_ = function(evt) {
    var feature2 = evt.target;
    if (this.handlingDownUpSequence) {
      var uid2 = getUid(feature2);
      if (!(uid2 in this.pendingFeatures_)) {
        this.pendingFeatures_[uid2] = feature2;
      }
    } else {
      this.updateFeature_(feature2);
    }
  };
  Snap2.prototype.handleUpEvent = function(evt) {
    var featuresToUpdate = getValues(this.pendingFeatures_);
    if (featuresToUpdate.length) {
      featuresToUpdate.forEach(this.updateFeature_.bind(this));
      this.pendingFeatures_ = {};
    }
    return false;
  };
  Snap2.prototype.removeFeature = function(feature2, opt_unlisten) {
    var unregister = opt_unlisten !== void 0 ? opt_unlisten : true;
    var feature_uid = getUid(feature2);
    var extent2 = this.indexedFeaturesExtents_[feature_uid];
    if (extent2) {
      var rBush = this.rBush_;
      var nodesToRemove_1 = [];
      rBush.forEachInExtent(extent2, function(node2) {
        if (feature2 === node2.feature) {
          nodesToRemove_1.push(node2);
        }
      });
      for (var i2 = nodesToRemove_1.length - 1; i2 >= 0; --i2) {
        rBush.remove(nodesToRemove_1[i2]);
      }
    }
    if (unregister) {
      unlistenByKey(this.featureChangeListenerKeys_[feature_uid]);
      delete this.featureChangeListenerKeys_[feature_uid];
    }
  };
  Snap2.prototype.setMap = function(map) {
    var currentMap = this.getMap();
    var keys3 = this.featuresListenerKeys_;
    var features = this.getFeatures_();
    if (currentMap) {
      keys3.forEach(unlistenByKey);
      keys3.length = 0;
      features.forEach(this.forEachFeatureRemove_.bind(this));
    }
    _super.prototype.setMap.call(this, map);
    if (map) {
      if (this.features_) {
        keys3.push(listen(this.features_, CollectionEventType.ADD, this.handleFeatureAdd_, this), listen(this.features_, CollectionEventType.REMOVE, this.handleFeatureRemove_, this));
      } else if (this.source_) {
        keys3.push(listen(this.source_, VectorEventType.ADDFEATURE, this.handleFeatureAdd_, this), listen(this.source_, VectorEventType.REMOVEFEATURE, this.handleFeatureRemove_, this));
      }
      features.forEach(this.forEachFeatureAdd_.bind(this));
    }
  };
  Snap2.prototype.snapTo = function(pixel, pixelCoordinate, map) {
    var lowerLeft = map.getCoordinateFromPixel([
      pixel[0] - this.pixelTolerance_,
      pixel[1] + this.pixelTolerance_
    ]);
    var upperRight = map.getCoordinateFromPixel([
      pixel[0] + this.pixelTolerance_,
      pixel[1] - this.pixelTolerance_
    ]);
    var box = boundingExtent([lowerLeft, upperRight]);
    var segments = this.rBush_.getInExtent(box);
    var segmentsLength = segments.length;
    if (segmentsLength === 0) {
      return null;
    }
    var projection = map.getView().getProjection();
    var projectedCoordinate = fromUserCoordinate(pixelCoordinate);
    var closestVertex;
    var minSquaredDistance = Infinity;
    var squaredPixelTolerance = this.pixelTolerance_ * this.pixelTolerance_;
    var getResult = function() {
      if (closestVertex) {
        var vertexPixel = map.getPixelFromCoordinate(closestVertex);
        var squaredPixelDistance = squaredDistance(pixel, vertexPixel);
        if (squaredPixelDistance <= squaredPixelTolerance) {
          return {
            vertex: closestVertex,
            vertexPixel: [
              Math.round(vertexPixel[0]),
              Math.round(vertexPixel[1])
            ]
          };
        }
      }
      return null;
    };
    if (this.vertex_) {
      for (var i2 = 0; i2 < segmentsLength; ++i2) {
        var segmentData = segments[i2];
        if (segmentData.feature.getGeometry().getType() !== GeometryType.CIRCLE) {
          segmentData.segment.forEach(function(vertex2) {
            var tempVertexCoord = fromUserCoordinate(vertex2);
            var delta2 = squaredDistance(projectedCoordinate, tempVertexCoord);
            if (delta2 < minSquaredDistance) {
              closestVertex = vertex2;
              minSquaredDistance = delta2;
            }
          });
        }
      }
      var result = getResult();
      if (result) {
        return result;
      }
    }
    if (this.edge_) {
      for (var i2 = 0; i2 < segmentsLength; ++i2) {
        var vertex = null;
        var segmentData = segments[i2];
        if (segmentData.feature.getGeometry().getType() === GeometryType.CIRCLE) {
          var circleGeometry = segmentData.feature.getGeometry();
          var userProjection2 = getUserProjection();
          if (userProjection2) {
            circleGeometry = circleGeometry.clone().transform(userProjection2, projection);
          }
          vertex = toUserCoordinate(closestOnCircle(projectedCoordinate, circleGeometry));
        } else {
          var _a2 = segmentData.segment, segmentStart = _a2[0], segmentEnd = _a2[1];
          if (segmentEnd) {
            tempSegment[0] = fromUserCoordinate(segmentStart);
            tempSegment[1] = fromUserCoordinate(segmentEnd);
            vertex = closestOnSegment(projectedCoordinate, tempSegment);
          }
        }
        if (vertex) {
          var delta = squaredDistance(projectedCoordinate, vertex);
          if (delta < minSquaredDistance) {
            closestVertex = vertex;
            minSquaredDistance = delta;
          }
        }
      }
      var result = getResult();
      if (result) {
        return result;
      }
    }
    return null;
  };
  Snap2.prototype.updateFeature_ = function(feature2) {
    this.removeFeature(feature2, false);
    this.addFeature(feature2, false);
  };
  Snap2.prototype.segmentCircleGemetry_ = function(segments, geometry) {
    this.getMap().getView().getProjection();
    var circleGeometry = geometry;
    var polygon = fromCircle(circleGeometry);
    var coordinates2 = polygon.getCoordinates()[0];
    for (var i2 = 0, ii = coordinates2.length - 1; i2 < ii; ++i2) {
      segments.push(coordinates2.slice(i2, i2 + 2));
    }
  };
  Snap2.prototype.segmentGeometryCollectionGemetry_ = function(segments, geometry) {
    var geometries = geometry.getGeometriesArray();
    for (var i2 = 0; i2 < geometries.length; ++i2) {
      var segmenter = this.GEOMETRY_SEGMENTERS_[geometries[i2].getType()];
      if (segmenter) {
        segmenter(segments, geometries[i2]);
      }
    }
  };
  Snap2.prototype.segmentLineStringGemetry_ = function(segments, geometry) {
    var coordinates2 = geometry.getCoordinates();
    for (var i2 = 0, ii = coordinates2.length - 1; i2 < ii; ++i2) {
      segments.push(coordinates2.slice(i2, i2 + 2));
    }
  };
  Snap2.prototype.segmentMultiLineStringGemetry_ = function(segments, geometry) {
    var lines = geometry.getCoordinates();
    for (var j2 = 0, jj = lines.length; j2 < jj; ++j2) {
      var coordinates2 = lines[j2];
      for (var i2 = 0, ii = coordinates2.length - 1; i2 < ii; ++i2) {
        segments.push(coordinates2.slice(i2, i2 + 2));
      }
    }
  };
  Snap2.prototype.segmentMultiPointGemetry_ = function(segments, geometry) {
    geometry.getCoordinates().forEach(function(point) {
      segments.push([point]);
    });
  };
  Snap2.prototype.segmentMultiPolygonGemetry_ = function(segments, geometry) {
    var polygons = geometry.getCoordinates();
    for (var k2 = 0, kk = polygons.length; k2 < kk; ++k2) {
      var rings = polygons[k2];
      for (var j2 = 0, jj = rings.length; j2 < jj; ++j2) {
        var coordinates2 = rings[j2];
        for (var i2 = 0, ii = coordinates2.length - 1; i2 < ii; ++i2) {
          segments.push(coordinates2.slice(i2, i2 + 2));
        }
      }
    }
  };
  Snap2.prototype.segmentPointGemetry_ = function(segments, geometry) {
    segments.push([geometry.getCoordinates()]);
  };
  Snap2.prototype.segmentPolygonGemetry_ = function(segments, geometry) {
    var rings = geometry.getCoordinates();
    for (var j2 = 0, jj = rings.length; j2 < jj; ++j2) {
      var coordinates2 = rings[j2];
      for (var i2 = 0, ii = coordinates2.length - 1; i2 < ii; ++i2) {
        segments.push(coordinates2.slice(i2, i2 + 2));
      }
    }
  };
  return Snap2;
}(ol_interaction_Pointer);
var Snap$1 = Snap;
function defaults(opt_options) {
  var options = opt_options ? opt_options : {};
  var interactions = new ol_Collection();
  var kinetic = new Kinetic$1(-5e-3, 0.05, 100);
  var altShiftDragRotate = options.altShiftDragRotate !== void 0 ? options.altShiftDragRotate : true;
  if (altShiftDragRotate) {
    interactions.push(new DragRotate$1());
  }
  var doubleClickZoom = options.doubleClickZoom !== void 0 ? options.doubleClickZoom : true;
  if (doubleClickZoom) {
    interactions.push(new DoubleClickZoom$1({
      delta: options.zoomDelta,
      duration: options.zoomDuration
    }));
  }
  var dragPan = options.dragPan !== void 0 ? options.dragPan : true;
  if (dragPan) {
    interactions.push(new DragPan$1({
      onFocusOnly: options.onFocusOnly,
      kinetic
    }));
  }
  var pinchRotate = options.pinchRotate !== void 0 ? options.pinchRotate : true;
  if (pinchRotate) {
    interactions.push(new PinchRotate$1());
  }
  var pinchZoom = options.pinchZoom !== void 0 ? options.pinchZoom : true;
  if (pinchZoom) {
    interactions.push(new PinchZoom$1({
      duration: options.zoomDuration
    }));
  }
  var keyboard = options.keyboard !== void 0 ? options.keyboard : true;
  if (keyboard) {
    interactions.push(new KeyboardPan$1());
    interactions.push(new KeyboardZoom$1({
      delta: options.zoomDelta,
      duration: options.zoomDuration
    }));
  }
  var mouseWheelZoom = options.mouseWheelZoom !== void 0 ? options.mouseWheelZoom : true;
  if (mouseWheelZoom) {
    interactions.push(new MouseWheelZoom$1({
      onFocusOnly: options.onFocusOnly,
      duration: options.zoomDuration
    }));
  }
  var shiftDragZoom = options.shiftDragZoom !== void 0 ? options.shiftDragZoom : true;
  if (shiftDragZoom) {
    interactions.push(new DragZoom$1({
      duration: options.zoomDuration
    }));
  }
  return interactions;
}
var __extends$10 = globalThis && globalThis.__extends || function() {
  var extendStatics2 = function(d2, b2) {
    extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {
      d3.__proto__ = b3;
    } || function(d3, b3) {
      for (var p5 in b3)
        if (Object.prototype.hasOwnProperty.call(b3, p5))
          d3[p5] = b3[p5];
    };
    return extendStatics2(d2, b2);
  };
  return function(d2, b2) {
    if (typeof b2 !== "function" && b2 !== null)
      throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
    extendStatics2(d2, b2);
    function __() {
      this.constructor = d2;
    }
    d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
  };
}();
var Map$3 = function(_super) {
  __extends$10(Map2, _super);
  function Map2(options) {
    options = assign({}, options);
    if (!options.controls) {
      options.controls = defaults$1();
    }
    if (!options.interactions) {
      options.interactions = defaults({
        onFocusOnly: true
      });
    }
    return _super.call(this, options) || this;
  }
  Map2.prototype.createRenderer = function() {
    return new CompositeMapRenderer$1(this);
  };
  return Map2;
}(PluggableMap$1);
var ol_Map = Map$3;
function usePropsAsObjectProperties(props, ignoredKeys = []) {
  let options = toRefs(props);
  Object.keys(options).forEach((key) => {
    options[key] = options[key].value;
  });
  const properties = reactive(__spreadValues({}, options));
  watch(props, () => {
    options = toRefs(props);
    Object.keys(options).forEach((key) => {
      if (properties[key] != options[key].value && !ignoredKeys.includes(key)) {
        properties[key] = options[key].value;
      }
    });
  });
  return {
    properties
  };
}
var _export_sfc = (sfc, props) => {
  const target = sfc.__vccOpts || sfc;
  for (const [key, val] of props) {
    target[key] = val;
  }
  return target;
};
var _sfc_main$16 = {
  name: "ol-map",
  setup(props, {
    emit
  }) {
    const {
      properties
    } = usePropsAsObjectProperties(props);
    const mapRef = ref(null);
    let map = new ol_Map(properties);
    watch(properties, () => {
      map.setProperties(properties);
    });
    onMounted(() => {
      map.setTarget(mapRef.value);
    });
    onUnmounted(() => {
      map.setTarget(null);
      map = null;
    });
    provide("map", map);
    const focus2 = () => map.focus();
    const forEachFeatureAtPixel = (pixel, callback, options = {}) => map.forEachFeatureAtPixel(pixel, callback, options);
    const forEachLayerAtPixel = (pixel, callback, layerFilter) => map.forEachLayerAtPixel(pixel, callback, layerFilter);
    const getCoordinateFromPixel = (pixel) => map.getCoordinateFromPixel(pixel);
    const refresh = () => map.refresh();
    const render2 = () => map.render();
    const updateSize = () => map.updateSize();
    map.on("click", (event) => emit("click", event));
    map.on("dblclick", (event) => emit("dblclick", event));
    map.on("singleclick", (event) => emit("singleclick", event));
    map.on("pointerdrag", (event) => emit("pointerdrag", event));
    map.on("pointermove", (event) => emit("pointermove", event));
    map.on("movestart", (event) => emit("movestart", event));
    map.on("moveend", (event) => emit("moveend", event));
    map.on("postrender", (event) => emit("postrender", event));
    map.on("precompose", (event) => emit("precompose", event));
    map.on("postcompose", (event) => emit("postcompose", event));
    return {
      map,
      mapRef,
      focus: focus2,
      forEachFeatureAtPixel,
      forEachLayerAtPixel,
      getCoordinateFromPixel,
      refresh,
      render: render2,
      updateSize
    };
  },
  props: {
    loadTilesWhileAnimating: {
      type: Boolean,
      default: false
    },
    loadTilesWhileInteracting: {
      type: Boolean,
      default: false
    },
    moveTolerance: {
      type: Number,
      default: 1
    },
    pixelRatio: {
      type: Number,
      default: 1
    },
    controls: {
      type: Array,
      default: () => []
    }
  }
};
function _sfc_render$16(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", {
    ref: (el) => $setup.mapRef = el
  }, [
    renderSlot(_ctx.$slots, "default")
  ], 512);
}
var Map$2 = _export_sfc(_sfc_main$16, [["render", _sfc_render$16]]);
function useView(props, emit) {
  const map = inject("map");
  const {
    properties
  } = usePropsAsObjectProperties(props);
  const createProp = () => {
    return __spreadProps(__spreadValues({}, properties), {
      projection: typeof properties.projection == "string" ? properties.projection : new Projection$3(__spreadValues({}, properties.projection))
    });
  };
  let view = new ol_View(createProp());
  onMounted(() => {
    map.setView(view);
  });
  view.on("change:center", () => {
    emit("centerChanged", getCenter2());
    emit("zoomChanged", getZoom());
  });
  view.on("change:resolution", () => emit("resolutionChanged", getResolution()));
  view.on("change:rotation", () => emit("rotationChanged", getRotation()));
  watch(properties, () => {
    let pr = createProp();
    view.setProperties(pr);
    view.applyOptions_(pr);
  });
  const adjustCenter = (deltaCoordinates) => view.adjustCenter(deltaCoordinates);
  const adjustResolution = (ratio, opt_anchor) => view.adjustResolution(ratio, opt_anchor);
  const adjustRotation = (delta, opt_anchor) => view.adjustRotation(delta, opt_anchor);
  const adjustZoom = (delta, opt_anchor) => view.adjustZoom(delta, opt_anchor);
  const animate = (var_args) => view.animate(var_args);
  const beginInteraction = () => view.beginInteraction();
  const calculateExtent = (opt_size) => view.calculateExtent(opt_size);
  const cancelAnimations = () => view.cancelAnimations();
  const centerOn = (coordinate, size, position2) => view.centerOn(coordinate, size, position2);
  const changed = () => view.changed();
  const dispatchEvent2 = (event) => view.dispatchEvent(event);
  const endInteraction = (opt_duration, opt_resolutionDirection, opt_anchor) => view.endInteraction(opt_duration, opt_resolutionDirection, opt_anchor);
  const fit = (geometryOrExtent, opt_options) => view.fit(geometryOrExtent, opt_options);
  const get2 = (key) => view.get(key);
  const getAnimating = () => view.getAnimating();
  const getCenter2 = () => view.getCenter();
  const getInteracting = () => view.getInteracting();
  const getKeys = () => view.getKeys();
  const getMaxResolution = () => view.getMaxResolution();
  const getMaxZoom = () => view.getMaxZoom();
  const getMinResolution = () => view.getMinResolution();
  const getMinZoom = () => view.getMinZoom();
  const getProjection = () => view.getProjection();
  const getProperties = () => view.getProperties();
  const getResolution = () => view.getResolution();
  const getResolutionForExtent = (extent2, opt_size) => view.getResolutionForExtent(extent2, opt_size);
  const getResolutionForZoom = (zoom) => view.getResolutionForZoom(zoom);
  const getResolutions = () => view.getResolutions();
  const getRevision = () => view.getRevision();
  const getRotation = () => view.getRotation();
  const getZoom = () => view.getZoom();
  const getZoomForResolution = (resolution) => view.getZoomForResolution(resolution);
  const setCenter = (center) => view.setCenter(center);
  const setConstrainResolution = (enabled) => view.setConstrainResolution(enabled);
  const setMaxZoom = (zoom) => view.setMaxZoom(zoom);
  const setMinZoom = (zoom) => view.setMinZoom(zoom);
  const setResolution = (resolution) => view.setResolution(resolution);
  const setRotation = (rotation) => view.setRotation(rotation);
  const setZoom = (zoom) => view.setZoom(zoom);
  return {
    view,
    adjustCenter,
    adjustResolution,
    adjustRotation,
    adjustZoom,
    animate,
    beginInteraction,
    calculateExtent,
    cancelAnimations,
    centerOn,
    changed,
    dispatchEvent: dispatchEvent2,
    endInteraction,
    fit,
    get: get2,
    getAnimating,
    getCenter: getCenter2,
    getInteracting,
    getKeys,
    getMaxResolution,
    getMaxZoom,
    getMinResolution,
    getMinZoom,
    getProjection,
    getProperties,
    getResolution,
    getResolutionForExtent,
    getResolutionForZoom,
    getResolutions,
    getRevision,
    getRotation,
    getZoom,
    getZoomForResolution,
    setCenter,
    setConstrainResolution,
    setMaxZoom,
    setMinZoom,
    setResolution,
    setRotation,
    setZoom
  };
}
var _sfc_main$15 = {
  name: "ol-view",
  setup(props, {
    emit
  }) {
    const view = useView(props, emit);
    return __spreadValues({}, view);
  },
  props: {
    center: {
      type: Array,
      default: () => [0, 0]
    },
    constrainRotation: {
      type: Boolean,
      default: true
    },
    enableRotation: {
      type: Boolean,
      default: true
    },
    extent: {
      type: Array
    },
    constrainOnlyCenter: {
      type: Boolean,
      default: false
    },
    smoothExtentConstraint: {
      type: Boolean,
      default: true
    },
    maxResolution: {
      type: Number
    },
    minResolution: {
      type: Number
    },
    maxZoom: {
      type: Number,
      default: 28
    },
    minZoom: {
      type: Number,
      default: 0
    },
    multiWorld: {
      type: Boolean,
      default: false
    },
    constrainResolution: {
      type: Boolean,
      default: false
    },
    smoothResolutionConstraint: {
      type: Boolean,
      default: true
    },
    showFullExtent: {
      type: Boolean,
      default: false
    },
    projection: {
      type: [String, Object],
      default: "EPSG:3857"
    },
    resolution: {
      type: Number
    },
    resolutions: {
      type: Array
    },
    rotation: {
      type: Number
    },
    zoom: {
      type: Number,
      default: 0
    },
    zoomFactor: {
      type: Number,
      default: 2
    },
    padding: {
      type: Array,
      default: () => [0, 0, 0, 0]
    }
  }
};
function _sfc_render$15(_ctx, _cache, $props, $setup, $data, $options) {
  return createCommentVNode("", true);
}
var View = _export_sfc(_sfc_main$15, [["render", _sfc_render$15]]);
var _sfc_main$14 = {
  name: "ol-feature",
  setup(props) {
    const vectorSource = inject("vectorSource");
    const vectorLayer = inject("vectorLayer");
    const animation = inject("animation", null);
    const {
      properties
    } = usePropsAsObjectProperties(props);
    let feature$1 = computed(() => {
      let f2 = new feature(__spreadValues({}, properties.properties));
      return f2;
    });
    watch(feature$1, (newVal, oldVal) => {
      vectorSource.value.removeFeature(oldVal);
      vectorSource.value.addFeature(newVal);
      vectorSource.value.changed();
    });
    watch(vectorSource, (newVal, oldVal) => {
      oldVal.removeFeature(feature$1.value);
      newVal.addFeature(feature$1.value);
      newVal.changed();
    });
    onMounted(() => {
      vectorSource.value.addFeature(feature$1.value);
      if (animation != null) {
        vectorLayer.value.animateFeature(feature$1.value, animation.value);
      }
    });
    onUnmounted(() => {
      vectorSource.value.removeFeature(feature$1.value);
    });
    provide("feature", feature$1);
    provide("stylable", feature$1);
    return {
      feature: feature$1
    };
  },
  props: {
    properties: {
      type: [Geometry$1, Object, Array]
    }
  }
};
function _sfc_render$14(_ctx, _cache, $props, $setup, $data, $options) {
  return renderSlot(_ctx.$slots, "default");
}
var Feature = _export_sfc(_sfc_main$14, [["render", _sfc_render$14]]);
function useOverlay(props, emit) {
  const map = inject("map");
  const htmlContent = ref(null);
  const {
    properties
  } = usePropsAsObjectProperties(props);
  let overlay = computed(() => new Overlay$2(properties));
  onMounted(() => {
    map.addOverlay(overlay.value);
  });
  onUnmounted(() => {
    map.removeOverlay(overlay.value);
  });
  watch(overlay, (newVal, oldVal) => {
    map.removeOverlay(oldVal);
    map.addOverlay(newVal);
  });
  watchEffect(() => {
    setElement(htmlContent.value);
  }, {
    flush: "post"
  });
  overlay.value.on("change:element", () => emit("elementChanged", getElement()));
  overlay.value.on("change:offset", () => emit("offsetChanged", getOffset()));
  overlay.value.on("change:position", () => emit("positionChanged", getPosition()));
  overlay.value.on("change:positioning", () => emit("positioningChanged", getPositioning()));
  const getElement = () => overlay.value.getElement();
  const getOffset = () => overlay.value.getOffset();
  const getPosition = () => overlay.value.getPosition();
  const getPositioning = () => overlay.value.getPositioning();
  const panIntoView = (opt_panIntoViewOptions) => overlay.value.panIntoView(opt_panIntoViewOptions);
  const setElement = (element) => overlay.value.setElement(element);
  const setOffset = (offset2) => overlay.value.setOffset(offset2);
  const setPosition = (position2) => overlay.value.setPosition(position2);
  const setPositioning = (positioning) => overlay.value.setPositioning(positioning);
  return {
    overlay,
    htmlContent,
    getOffset,
    getPosition,
    getPositioning,
    panIntoView,
    setElement,
    setOffset,
    setPosition,
    setPositioning
  };
}
var _sfc_main$13 = {
  name: "ol-overlay",
  setup(props, { emit }) {
    const overlay = new useOverlay(props, emit);
    return __spreadValues({}, overlay);
  },
  props: {
    position: {
      type: Array
    },
    offset: {
      type: Array
    },
    positioning: {
      type: String
    },
    stopEvent: {
      type: Boolean,
      default: true
    },
    insertFirst: {
      type: Boolean,
      default: true
    },
    autoPan: {
      type: Boolean,
      default: false
    },
    autoPanMargin: {
      type: Number,
      default: 20
    },
    autoPanAnimation: {
      type: Object,
      default: void 0
    }
  }
};
var _hoisted_1 = { ref: "htmlContent" };
function _sfc_render$13(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", _hoisted_1, [
    renderSlot(_ctx.$slots, "default", { position: $props.position })
  ], 512);
}
var Overlay = _export_sfc(_sfc_main$13, [["render", _sfc_render$13]]);
var __extends$$ = globalThis && globalThis.__extends || function() {
  var extendStatics2 = function(d2, b2) {
    extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {
      d3.__proto__ = b3;
    } || function(d3, b3) {
      for (var p5 in b3)
        if (Object.prototype.hasOwnProperty.call(b3, p5))
          d3[p5] = b3[p5];
    };
    return extendStatics2(d2, b2);
  };
  return function(d2, b2) {
    if (typeof b2 !== "function" && b2 !== null)
      throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
    extendStatics2(d2, b2);
    function __() {
      this.constructor = d2;
    }
    d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
  };
}();
var Property$2 = {
  ACCURACY: "accuracy",
  ACCURACY_GEOMETRY: "accuracyGeometry",
  ALTITUDE: "altitude",
  ALTITUDE_ACCURACY: "altitudeAccuracy",
  HEADING: "heading",
  POSITION: "position",
  PROJECTION: "projection",
  SPEED: "speed",
  TRACKING: "tracking",
  TRACKING_OPTIONS: "trackingOptions"
};
var GeolocationError = function(_super) {
  __extends$$(GeolocationError2, _super);
  function GeolocationError2(error) {
    var _this = _super.call(this, EventType.ERROR) || this;
    _this.code = error.code;
    _this.message = error.message;
    return _this;
  }
  return GeolocationError2;
}(Event$1);
var Geolocation = function(_super) {
  __extends$$(Geolocation2, _super);
  function Geolocation2(opt_options) {
    var _this = _super.call(this) || this;
    _this.on;
    _this.once;
    _this.un;
    var options = opt_options || {};
    _this.position_ = null;
    _this.transform_ = identityTransform;
    _this.watchId_ = void 0;
    _this.addChangeListener(Property$2.PROJECTION, _this.handleProjectionChanged_);
    _this.addChangeListener(Property$2.TRACKING, _this.handleTrackingChanged_);
    if (options.projection !== void 0) {
      _this.setProjection(options.projection);
    }
    if (options.trackingOptions !== void 0) {
      _this.setTrackingOptions(options.trackingOptions);
    }
    _this.setTracking(options.tracking !== void 0 ? options.tracking : false);
    return _this;
  }
  Geolocation2.prototype.disposeInternal = function() {
    this.setTracking(false);
    _super.prototype.disposeInternal.call(this);
  };
  Geolocation2.prototype.handleProjectionChanged_ = function() {
    var projection = this.getProjection();
    if (projection) {
      this.transform_ = getTransformFromProjections(get$3("EPSG:4326"), projection);
      if (this.position_) {
        this.set(Property$2.POSITION, this.transform_(this.position_));
      }
    }
  };
  Geolocation2.prototype.handleTrackingChanged_ = function() {
    if ("geolocation" in navigator) {
      var tracking = this.getTracking();
      if (tracking && this.watchId_ === void 0) {
        this.watchId_ = navigator.geolocation.watchPosition(this.positionChange_.bind(this), this.positionError_.bind(this), this.getTrackingOptions());
      } else if (!tracking && this.watchId_ !== void 0) {
        navigator.geolocation.clearWatch(this.watchId_);
        this.watchId_ = void 0;
      }
    }
  };
  Geolocation2.prototype.positionChange_ = function(position2) {
    var coords = position2.coords;
    this.set(Property$2.ACCURACY, coords.accuracy);
    this.set(Property$2.ALTITUDE, coords.altitude === null ? void 0 : coords.altitude);
    this.set(Property$2.ALTITUDE_ACCURACY, coords.altitudeAccuracy === null ? void 0 : coords.altitudeAccuracy);
    this.set(Property$2.HEADING, coords.heading === null ? void 0 : toRadians(coords.heading));
    if (!this.position_) {
      this.position_ = [coords.longitude, coords.latitude];
    } else {
      this.position_[0] = coords.longitude;
      this.position_[1] = coords.latitude;
    }
    var projectedPosition = this.transform_(this.position_);
    this.set(Property$2.POSITION, projectedPosition);
    this.set(Property$2.SPEED, coords.speed === null ? void 0 : coords.speed);
    var geometry = circular(this.position_, coords.accuracy);
    geometry.applyTransform(this.transform_);
    this.set(Property$2.ACCURACY_GEOMETRY, geometry);
    this.changed();
  };
  Geolocation2.prototype.positionError_ = function(error) {
    this.dispatchEvent(new GeolocationError(error));
  };
  Geolocation2.prototype.getAccuracy = function() {
    return this.get(Property$2.ACCURACY);
  };
  Geolocation2.prototype.getAccuracyGeometry = function() {
    return this.get(Property$2.ACCURACY_GEOMETRY) || null;
  };
  Geolocation2.prototype.getAltitude = function() {
    return this.get(Property$2.ALTITUDE);
  };
  Geolocation2.prototype.getAltitudeAccuracy = function() {
    return this.get(Property$2.ALTITUDE_ACCURACY);
  };
  Geolocation2.prototype.getHeading = function() {
    return this.get(Property$2.HEADING);
  };
  Geolocation2.prototype.getPosition = function() {
    return this.get(Property$2.POSITION);
  };
  Geolocation2.prototype.getProjection = function() {
    return this.get(Property$2.PROJECTION);
  };
  Geolocation2.prototype.getSpeed = function() {
    return this.get(Property$2.SPEED);
  };
  Geolocation2.prototype.getTracking = function() {
    return this.get(Property$2.TRACKING);
  };
  Geolocation2.prototype.getTrackingOptions = function() {
    return this.get(Property$2.TRACKING_OPTIONS);
  };
  Geolocation2.prototype.setProjection = function(projection) {
    this.set(Property$2.PROJECTION, get$3(projection));
  };
  Geolocation2.prototype.setTracking = function(tracking) {
    this.set(Property$2.TRACKING, tracking);
  };
  Geolocation2.prototype.setTrackingOptions = function(options) {
    this.set(Property$2.TRACKING_OPTIONS, options);
  };
  return Geolocation2;
}(ol_Object);
var Geolocation$1 = Geolocation;
var _sfc_main$12 = {
  name: "ol-geolocation",
  emits: ["positionChanged", "speedChanged", "headingChanged", "altitudeChanged", "altitudeAccuracyChanged", "accuracyGeometryChanged"],
  setup(props, {
    emit
  }) {
    const {
      properties
    } = usePropsAsObjectProperties(props);
    let geoLoc = computed(() => {
      let g2 = new Geolocation$1(properties);
      g2.on("change", changeEvt);
      return g2;
    });
    const position2 = ref([]);
    const accuracy = ref(0);
    const altitude = ref(0);
    const altitudeAccuracy = ref(0);
    const speed = ref(0);
    const heading = ref(0);
    const accuracyGeometry = ref({});
    watch(position2, () => {
      emit("positionChanged", position2.value);
    });
    watch(speed, () => {
      emit("speedChanged", speed.value);
    });
    watch(heading, () => {
      emit("headingChanged", heading.value);
    });
    watch(altitude, () => {
      emit("altitudeChanged", altitude.value);
    });
    watch(altitudeAccuracy, () => {
      emit("altitudeAccuracyChanged", altitudeAccuracy.value);
    });
    watch(accuracyGeometry, () => {
      emit("accuracyGeometryChanged", accuracyGeometry.value);
    });
    const changeEvt = () => {
      position2.value = geoLoc.value.getPosition();
      speed.value = geoLoc.value.getSpeed();
      heading.value = geoLoc.value.getHeading();
      accuracy.value = geoLoc.value.getAccuracy();
      altitude.value = geoLoc.value.getAltitude();
      altitudeAccuracy.value = geoLoc.value.getAltitudeAccuracy();
      accuracyGeometry.value = geoLoc.value.getAccuracyGeometry();
    };
    watch(geoLoc, (newVal, oldVal) => {
      oldVal.un("change", changeEvt);
      newVal.on("change", changeEvt);
    });
    return {
      geoLoc,
      position: position2,
      accuracy,
      altitude,
      altitudeAccuracy,
      speed,
      heading,
      accuracyGeometry
    };
  },
  props: {
    projection: {
      type: [String, Object],
      default: "EPSG:3857"
    },
    tracking: {
      type: Boolean,
      default: true
    },
    trackingOptions: {
      type: Object,
      default: () => {
        return {
          enableHighAccuracy: true
        };
      }
    }
  }
};
function _sfc_render$12(_ctx, _cache, $props, $setup, $data, $options) {
  return renderSlot(_ctx.$slots, "default", {
    position: $setup.position,
    speed: $setup.speed,
    heading: $setup.heading,
    accuracy: $setup.accuracy,
    altitude: $setup.altitude,
    altitudeAccuracy: $setup.altitudeAccuracy,
    accuracyGeometry: $setup.accuracyGeometry
  });
}
var GeoLocation = _export_sfc(_sfc_main$12, [["render", _sfc_render$12]]);
function globals(defs2) {
  defs2("EPSG:4326", "+title=WGS 84 (long/lat) +proj=longlat +ellps=WGS84 +datum=WGS84 +units=degrees");
  defs2("EPSG:4269", "+title=NAD83 (long/lat) +proj=longlat +a=6378137.0 +b=6356752.31414036 +ellps=GRS80 +datum=NAD83 +units=degrees");
  defs2("EPSG:3857", "+title=WGS 84 / Pseudo-Mercator +proj=merc +a=6378137 +b=6378137 +lat_ts=0.0 +lon_0=0.0 +x_0=0.0 +y_0=0 +k=1.0 +units=m +nadgrids=@null +no_defs");
  defs2.WGS84 = defs2["EPSG:4326"];
  defs2["EPSG:3785"] = defs2["EPSG:3857"];
  defs2.GOOGLE = defs2["EPSG:3857"];
  defs2["EPSG:900913"] = defs2["EPSG:3857"];
  defs2["EPSG:102113"] = defs2["EPSG:3857"];
}
var PJD_3PARAM = 1;
var PJD_7PARAM = 2;
var PJD_GRIDSHIFT = 3;
var PJD_WGS84 = 4;
var PJD_NODATUM = 5;
var SRS_WGS84_SEMIMAJOR = 6378137;
var SRS_WGS84_SEMIMINOR = 6356752314e-3;
var SRS_WGS84_ESQUARED = 0.0066943799901413165;
var SEC_TO_RAD = 484813681109536e-20;
var HALF_PI = Math.PI / 2;
var SIXTH = 0.16666666666666666;
var RA4 = 0.04722222222222222;
var RA6 = 0.022156084656084655;
var EPSLN = 1e-10;
var D2R$1 = 0.017453292519943295;
var R2D = 57.29577951308232;
var FORTPI = Math.PI / 4;
var TWO_PI = Math.PI * 2;
var SPI = 3.14159265359;
var exports$2 = {};
exports$2.greenwich = 0;
exports$2.lisbon = -9.131906111111;
exports$2.paris = 2.337229166667;
exports$2.bogota = -74.080916666667;
exports$2.madrid = -3.687938888889;
exports$2.rome = 12.452333333333;
exports$2.bern = 7.439583333333;
exports$2.jakarta = 106.807719444444;
exports$2.ferro = -17.666666666667;
exports$2.brussels = 4.367975;
exports$2.stockholm = 18.058277777778;
exports$2.athens = 23.7163375;
exports$2.oslo = 10.722916666667;
var units = {
  ft: { to_meter: 0.3048 },
  "us-ft": { to_meter: 1200 / 3937 }
};
var ignoredChar = /[\s_\-\/\(\)]/g;
function match$1(obj, key) {
  if (obj[key]) {
    return obj[key];
  }
  var keys3 = Object.keys(obj);
  var lkey = key.toLowerCase().replace(ignoredChar, "");
  var i2 = -1;
  var testkey, processedKey;
  while (++i2 < keys3.length) {
    testkey = keys3[i2];
    processedKey = testkey.toLowerCase().replace(ignoredChar, "");
    if (processedKey === lkey) {
      return obj[testkey];
    }
  }
}
function projStr(defData) {
  var self2 = {};
  var paramObj = defData.split("+").map(function(v2) {
    return v2.trim();
  }).filter(function(a2) {
    return a2;
  }).reduce(function(p5, a2) {
    var split2 = a2.split("=");
    split2.push(true);
    p5[split2[0].toLowerCase()] = split2[1];
    return p5;
  }, {});
  var paramName, paramVal, paramOutname;
  var params2 = {
    proj: "projName",
    datum: "datumCode",
    rf: function(v2) {
      self2.rf = parseFloat(v2);
    },
    lat_0: function(v2) {
      self2.lat0 = v2 * D2R$1;
    },
    lat_1: function(v2) {
      self2.lat1 = v2 * D2R$1;
    },
    lat_2: function(v2) {
      self2.lat2 = v2 * D2R$1;
    },
    lat_ts: function(v2) {
      self2.lat_ts = v2 * D2R$1;
    },
    lon_0: function(v2) {
      self2.long0 = v2 * D2R$1;
    },
    lon_1: function(v2) {
      self2.long1 = v2 * D2R$1;
    },
    lon_2: function(v2) {
      self2.long2 = v2 * D2R$1;
    },
    alpha: function(v2) {
      self2.alpha = parseFloat(v2) * D2R$1;
    },
    gamma: function(v2) {
      self2.rectified_grid_angle = parseFloat(v2);
    },
    lonc: function(v2) {
      self2.longc = v2 * D2R$1;
    },
    x_0: function(v2) {
      self2.x0 = parseFloat(v2);
    },
    y_0: function(v2) {
      self2.y0 = parseFloat(v2);
    },
    k_0: function(v2) {
      self2.k0 = parseFloat(v2);
    },
    k: function(v2) {
      self2.k0 = parseFloat(v2);
    },
    a: function(v2) {
      self2.a = parseFloat(v2);
    },
    b: function(v2) {
      self2.b = parseFloat(v2);
    },
    r_a: function() {
      self2.R_A = true;
    },
    zone: function(v2) {
      self2.zone = parseInt(v2, 10);
    },
    south: function() {
      self2.utmSouth = true;
    },
    towgs84: function(v2) {
      self2.datum_params = v2.split(",").map(function(a2) {
        return parseFloat(a2);
      });
    },
    to_meter: function(v2) {
      self2.to_meter = parseFloat(v2);
    },
    units: function(v2) {
      self2.units = v2;
      var unit = match$1(units, v2);
      if (unit) {
        self2.to_meter = unit.to_meter;
      }
    },
    from_greenwich: function(v2) {
      self2.from_greenwich = v2 * D2R$1;
    },
    pm: function(v2) {
      var pm = match$1(exports$2, v2);
      self2.from_greenwich = (pm ? pm : parseFloat(v2)) * D2R$1;
    },
    nadgrids: function(v2) {
      if (v2 === "@null") {
        self2.datumCode = "none";
      } else {
        self2.nadgrids = v2;
      }
    },
    axis: function(v2) {
      var legalAxis = "ewnsud";
      if (v2.length === 3 && legalAxis.indexOf(v2.substr(0, 1)) !== -1 && legalAxis.indexOf(v2.substr(1, 1)) !== -1 && legalAxis.indexOf(v2.substr(2, 1)) !== -1) {
        self2.axis = v2;
      }
    },
    approx: function() {
      self2.approx = true;
    }
  };
  for (paramName in paramObj) {
    paramVal = paramObj[paramName];
    if (paramName in params2) {
      paramOutname = params2[paramName];
      if (typeof paramOutname === "function") {
        paramOutname(paramVal);
      } else {
        self2[paramOutname] = paramVal;
      }
    } else {
      self2[paramName] = paramVal;
    }
  }
  if (typeof self2.datumCode === "string" && self2.datumCode !== "WGS84") {
    self2.datumCode = self2.datumCode.toLowerCase();
  }
  return self2;
}
var NEUTRAL = 1;
var KEYWORD = 2;
var NUMBER = 3;
var QUOTED = 4;
var AFTERQUOTE = 5;
var ENDED = -1;
var whitespace$1 = /\s/;
var latin = /[A-Za-z]/;
var keyword = /[A-Za-z84_]/;
var endThings = /[,\]]/;
var digets = /[\d\.E\-\+]/;
function Parser$3(text2) {
  if (typeof text2 !== "string") {
    throw new Error("not a string");
  }
  this.text = text2.trim();
  this.level = 0;
  this.place = 0;
  this.root = null;
  this.stack = [];
  this.currentObject = null;
  this.state = NEUTRAL;
}
Parser$3.prototype.readCharicter = function() {
  var char = this.text[this.place++];
  if (this.state !== QUOTED) {
    while (whitespace$1.test(char)) {
      if (this.place >= this.text.length) {
        return;
      }
      char = this.text[this.place++];
    }
  }
  switch (this.state) {
    case NEUTRAL:
      return this.neutral(char);
    case KEYWORD:
      return this.keyword(char);
    case QUOTED:
      return this.quoted(char);
    case AFTERQUOTE:
      return this.afterquote(char);
    case NUMBER:
      return this.number(char);
    case ENDED:
      return;
  }
};
Parser$3.prototype.afterquote = function(char) {
  if (char === '"') {
    this.word += '"';
    this.state = QUOTED;
    return;
  }
  if (endThings.test(char)) {
    this.word = this.word.trim();
    this.afterItem(char);
    return;
  }
  throw new Error(`havn't handled "` + char + '" in afterquote yet, index ' + this.place);
};
Parser$3.prototype.afterItem = function(char) {
  if (char === ",") {
    if (this.word !== null) {
      this.currentObject.push(this.word);
    }
    this.word = null;
    this.state = NEUTRAL;
    return;
  }
  if (char === "]") {
    this.level--;
    if (this.word !== null) {
      this.currentObject.push(this.word);
      this.word = null;
    }
    this.state = NEUTRAL;
    this.currentObject = this.stack.pop();
    if (!this.currentObject) {
      this.state = ENDED;
    }
    return;
  }
};
Parser$3.prototype.number = function(char) {
  if (digets.test(char)) {
    this.word += char;
    return;
  }
  if (endThings.test(char)) {
    this.word = parseFloat(this.word);
    this.afterItem(char);
    return;
  }
  throw new Error(`havn't handled "` + char + '" in number yet, index ' + this.place);
};
Parser$3.prototype.quoted = function(char) {
  if (char === '"') {
    this.state = AFTERQUOTE;
    return;
  }
  this.word += char;
  return;
};
Parser$3.prototype.keyword = function(char) {
  if (keyword.test(char)) {
    this.word += char;
    return;
  }
  if (char === "[") {
    var newObjects = [];
    newObjects.push(this.word);
    this.level++;
    if (this.root === null) {
      this.root = newObjects;
    } else {
      this.currentObject.push(newObjects);
    }
    this.stack.push(this.currentObject);
    this.currentObject = newObjects;
    this.state = NEUTRAL;
    return;
  }
  if (endThings.test(char)) {
    this.afterItem(char);
    return;
  }
  throw new Error(`havn't handled "` + char + '" in keyword yet, index ' + this.place);
};
Parser$3.prototype.neutral = function(char) {
  if (latin.test(char)) {
    this.word = char;
    this.state = KEYWORD;
    return;
  }
  if (char === '"') {
    this.word = "";
    this.state = QUOTED;
    return;
  }
  if (digets.test(char)) {
    this.word = char;
    this.state = NUMBER;
    return;
  }
  if (endThings.test(char)) {
    this.afterItem(char);
    return;
  }
  throw new Error(`havn't handled "` + char + '" in neutral yet, index ' + this.place);
};
Parser$3.prototype.output = function() {
  while (this.place < this.text.length) {
    this.readCharicter();
  }
  if (this.state === ENDED) {
    return this.root;
  }
  throw new Error('unable to parse string "' + this.text + '". State is ' + this.state);
};
function parseString(txt) {
  var parser = new Parser$3(txt);
  return parser.output();
}
function mapit(obj, key, value) {
  if (Array.isArray(key)) {
    value.unshift(key);
    key = null;
  }
  var thing = key ? {} : obj;
  var out = value.reduce(function(newObj, item) {
    sExpr(item, newObj);
    return newObj;
  }, thing);
  if (key) {
    obj[key] = out;
  }
}
function sExpr(v2, obj) {
  if (!Array.isArray(v2)) {
    obj[v2] = true;
    return;
  }
  var key = v2.shift();
  if (key === "PARAMETER") {
    key = v2.shift();
  }
  if (v2.length === 1) {
    if (Array.isArray(v2[0])) {
      obj[key] = {};
      sExpr(v2[0], obj[key]);
      return;
    }
    obj[key] = v2[0];
    return;
  }
  if (!v2.length) {
    obj[key] = true;
    return;
  }
  if (key === "TOWGS84") {
    obj[key] = v2;
    return;
  }
  if (key === "AXIS") {
    if (!(key in obj)) {
      obj[key] = [];
    }
    obj[key].push(v2);
    return;
  }
  if (!Array.isArray(key)) {
    obj[key] = {};
  }
  var i2;
  switch (key) {
    case "UNIT":
    case "PRIMEM":
    case "VERT_DATUM":
      obj[key] = {
        name: v2[0].toLowerCase(),
        convert: v2[1]
      };
      if (v2.length === 3) {
        sExpr(v2[2], obj[key]);
      }
      return;
    case "SPHEROID":
    case "ELLIPSOID":
      obj[key] = {
        name: v2[0],
        a: v2[1],
        rf: v2[2]
      };
      if (v2.length === 4) {
        sExpr(v2[3], obj[key]);
      }
      return;
    case "PROJECTEDCRS":
    case "PROJCRS":
    case "GEOGCS":
    case "GEOCCS":
    case "PROJCS":
    case "LOCAL_CS":
    case "GEODCRS":
    case "GEODETICCRS":
    case "GEODETICDATUM":
    case "EDATUM":
    case "ENGINEERINGDATUM":
    case "VERT_CS":
    case "VERTCRS":
    case "VERTICALCRS":
    case "COMPD_CS":
    case "COMPOUNDCRS":
    case "ENGINEERINGCRS":
    case "ENGCRS":
    case "FITTED_CS":
    case "LOCAL_DATUM":
    case "DATUM":
      v2[0] = ["name", v2[0]];
      mapit(obj, key, v2);
      return;
    default:
      i2 = -1;
      while (++i2 < v2.length) {
        if (!Array.isArray(v2[i2])) {
          return sExpr(v2, obj[key]);
        }
      }
      return mapit(obj, key, v2);
  }
}
var D2R = 0.017453292519943295;
function rename(obj, params2) {
  var outName = params2[0];
  var inName = params2[1];
  if (!(outName in obj) && inName in obj) {
    obj[outName] = obj[inName];
    if (params2.length === 3) {
      obj[outName] = params2[2](obj[outName]);
    }
  }
}
function d2r(input) {
  return input * D2R;
}
function cleanWKT(wkt2) {
  if (wkt2.type === "GEOGCS") {
    wkt2.projName = "longlat";
  } else if (wkt2.type === "LOCAL_CS") {
    wkt2.projName = "identity";
    wkt2.local = true;
  } else {
    if (typeof wkt2.PROJECTION === "object") {
      wkt2.projName = Object.keys(wkt2.PROJECTION)[0];
    } else {
      wkt2.projName = wkt2.PROJECTION;
    }
  }
  if (wkt2.AXIS) {
    var axisOrder = "";
    for (var i2 = 0, ii = wkt2.AXIS.length; i2 < ii; ++i2) {
      var axis = [wkt2.AXIS[i2][0].toLowerCase(), wkt2.AXIS[i2][1].toLowerCase()];
      if (axis[0].indexOf("north") !== -1 || (axis[0] === "y" || axis[0] === "lat") && axis[1] === "north") {
        axisOrder += "n";
      } else if (axis[0].indexOf("south") !== -1 || (axis[0] === "y" || axis[0] === "lat") && axis[1] === "south") {
        axisOrder += "s";
      } else if (axis[0].indexOf("east") !== -1 || (axis[0] === "x" || axis[0] === "lon") && axis[1] === "east") {
        axisOrder += "e";
      } else if (axis[0].indexOf("west") !== -1 || (axis[0] === "x" || axis[0] === "lon") && axis[1] === "west") {
        axisOrder += "w";
      }
    }
    if (axisOrder.length === 2) {
      axisOrder += "u";
    }
    if (axisOrder.length === 3) {
      wkt2.axis = axisOrder;
    }
  }
  if (wkt2.UNIT) {
    wkt2.units = wkt2.UNIT.name.toLowerCase();
    if (wkt2.units === "metre") {
      wkt2.units = "meter";
    }
    if (wkt2.UNIT.convert) {
      if (wkt2.type === "GEOGCS") {
        if (wkt2.DATUM && wkt2.DATUM.SPHEROID) {
          wkt2.to_meter = wkt2.UNIT.convert * wkt2.DATUM.SPHEROID.a;
        }
      } else {
        wkt2.to_meter = wkt2.UNIT.convert;
      }
    }
  }
  var geogcs = wkt2.GEOGCS;
  if (wkt2.type === "GEOGCS") {
    geogcs = wkt2;
  }
  if (geogcs) {
    if (geogcs.DATUM) {
      wkt2.datumCode = geogcs.DATUM.name.toLowerCase();
    } else {
      wkt2.datumCode = geogcs.name.toLowerCase();
    }
    if (wkt2.datumCode.slice(0, 2) === "d_") {
      wkt2.datumCode = wkt2.datumCode.slice(2);
    }
    if (wkt2.datumCode === "new_zealand_geodetic_datum_1949" || wkt2.datumCode === "new_zealand_1949") {
      wkt2.datumCode = "nzgd49";
    }
    if (wkt2.datumCode === "wgs_1984" || wkt2.datumCode === "world_geodetic_system_1984") {
      if (wkt2.PROJECTION === "Mercator_Auxiliary_Sphere") {
        wkt2.sphere = true;
      }
      wkt2.datumCode = "wgs84";
    }
    if (wkt2.datumCode.slice(-6) === "_ferro") {
      wkt2.datumCode = wkt2.datumCode.slice(0, -6);
    }
    if (wkt2.datumCode.slice(-8) === "_jakarta") {
      wkt2.datumCode = wkt2.datumCode.slice(0, -8);
    }
    if (~wkt2.datumCode.indexOf("belge")) {
      wkt2.datumCode = "rnb72";
    }
    if (geogcs.DATUM && geogcs.DATUM.SPHEROID) {
      wkt2.ellps = geogcs.DATUM.SPHEROID.name.replace("_19", "").replace(/[Cc]larke\_18/, "clrk");
      if (wkt2.ellps.toLowerCase().slice(0, 13) === "international") {
        wkt2.ellps = "intl";
      }
      wkt2.a = geogcs.DATUM.SPHEROID.a;
      wkt2.rf = parseFloat(geogcs.DATUM.SPHEROID.rf, 10);
    }
    if (geogcs.DATUM && geogcs.DATUM.TOWGS84) {
      wkt2.datum_params = geogcs.DATUM.TOWGS84;
    }
    if (~wkt2.datumCode.indexOf("osgb_1936")) {
      wkt2.datumCode = "osgb36";
    }
    if (~wkt2.datumCode.indexOf("osni_1952")) {
      wkt2.datumCode = "osni52";
    }
    if (~wkt2.datumCode.indexOf("tm65") || ~wkt2.datumCode.indexOf("geodetic_datum_of_1965")) {
      wkt2.datumCode = "ire65";
    }
    if (wkt2.datumCode === "ch1903+") {
      wkt2.datumCode = "ch1903";
    }
    if (~wkt2.datumCode.indexOf("israel")) {
      wkt2.datumCode = "isr93";
    }
  }
  if (wkt2.b && !isFinite(wkt2.b)) {
    wkt2.b = wkt2.a;
  }
  function toMeter(input) {
    var ratio = wkt2.to_meter || 1;
    return input * ratio;
  }
  var renamer = function(a2) {
    return rename(wkt2, a2);
  };
  var list = [
    ["standard_parallel_1", "Standard_Parallel_1"],
    ["standard_parallel_1", "Latitude of 1st standard parallel"],
    ["standard_parallel_2", "Standard_Parallel_2"],
    ["standard_parallel_2", "Latitude of 2nd standard parallel"],
    ["false_easting", "False_Easting"],
    ["false_easting", "False easting"],
    ["false-easting", "Easting at false origin"],
    ["false_northing", "False_Northing"],
    ["false_northing", "False northing"],
    ["false_northing", "Northing at false origin"],
    ["central_meridian", "Central_Meridian"],
    ["central_meridian", "Longitude of natural origin"],
    ["central_meridian", "Longitude of false origin"],
    ["latitude_of_origin", "Latitude_Of_Origin"],
    ["latitude_of_origin", "Central_Parallel"],
    ["latitude_of_origin", "Latitude of natural origin"],
    ["latitude_of_origin", "Latitude of false origin"],
    ["scale_factor", "Scale_Factor"],
    ["k0", "scale_factor"],
    ["latitude_of_center", "Latitude_Of_Center"],
    ["latitude_of_center", "Latitude_of_center"],
    ["lat0", "latitude_of_center", d2r],
    ["longitude_of_center", "Longitude_Of_Center"],
    ["longitude_of_center", "Longitude_of_center"],
    ["longc", "longitude_of_center", d2r],
    ["x0", "false_easting", toMeter],
    ["y0", "false_northing", toMeter],
    ["long0", "central_meridian", d2r],
    ["lat0", "latitude_of_origin", d2r],
    ["lat0", "standard_parallel_1", d2r],
    ["lat1", "standard_parallel_1", d2r],
    ["lat2", "standard_parallel_2", d2r],
    ["azimuth", "Azimuth"],
    ["alpha", "azimuth", d2r],
    ["srsCode", "name"]
  ];
  list.forEach(renamer);
  if (!wkt2.long0 && wkt2.longc && (wkt2.projName === "Albers_Conic_Equal_Area" || wkt2.projName === "Lambert_Azimuthal_Equal_Area")) {
    wkt2.long0 = wkt2.longc;
  }
  if (!wkt2.lat_ts && wkt2.lat1 && (wkt2.projName === "Stereographic_South_Pole" || wkt2.projName === "Polar Stereographic (variant B)")) {
    wkt2.lat0 = d2r(wkt2.lat1 > 0 ? 90 : -90);
    wkt2.lat_ts = wkt2.lat1;
  }
}
function wkt(wkt2) {
  var lisp = parseString(wkt2);
  var type = lisp.shift();
  var name = lisp.shift();
  lisp.unshift(["name", name]);
  lisp.unshift(["type", type]);
  var obj = {};
  sExpr(lisp, obj);
  cleanWKT(obj);
  return obj;
}
function defs(name) {
  var that = this;
  if (arguments.length === 2) {
    var def = arguments[1];
    if (typeof def === "string") {
      if (def.charAt(0) === "+") {
        defs[name] = projStr(arguments[1]);
      } else {
        defs[name] = wkt(arguments[1]);
      }
    } else {
      defs[name] = def;
    }
  } else if (arguments.length === 1) {
    if (Array.isArray(name)) {
      return name.map(function(v2) {
        if (Array.isArray(v2)) {
          defs.apply(that, v2);
        } else {
          defs(v2);
        }
      });
    } else if (typeof name === "string") {
      if (name in defs) {
        return defs[name];
      }
    } else if ("EPSG" in name) {
      defs["EPSG:" + name.EPSG] = name;
    } else if ("ESRI" in name) {
      defs["ESRI:" + name.ESRI] = name;
    } else if ("IAU2000" in name) {
      defs["IAU2000:" + name.IAU2000] = name;
    } else {
      console.log(name);
    }
    return;
  }
}
globals(defs);
function testObj(code) {
  return typeof code === "string";
}
function testDef(code) {
  return code in defs;
}
var codeWords = ["PROJECTEDCRS", "PROJCRS", "GEOGCS", "GEOCCS", "PROJCS", "LOCAL_CS", "GEODCRS", "GEODETICCRS", "GEODETICDATUM", "ENGCRS", "ENGINEERINGCRS"];
function testWKT(code) {
  return codeWords.some(function(word) {
    return code.indexOf(word) > -1;
  });
}
var codes = ["3857", "900913", "3785", "102113"];
function checkMercator(item) {
  var auth = match$1(item, "authority");
  if (!auth) {
    return;
  }
  var code = match$1(auth, "epsg");
  return code && codes.indexOf(code) > -1;
}
function checkProjStr(item) {
  var ext = match$1(item, "extension");
  if (!ext) {
    return;
  }
  return match$1(ext, "proj4");
}
function testProj(code) {
  return code[0] === "+";
}
function parse$2(code) {
  if (testObj(code)) {
    if (testDef(code)) {
      return defs[code];
    }
    if (testWKT(code)) {
      var out = wkt(code);
      if (checkMercator(out)) {
        return defs["EPSG:3857"];
      }
      var maybeProjStr = checkProjStr(out);
      if (maybeProjStr) {
        return projStr(maybeProjStr);
      }
      return out;
    }
    if (testProj(code)) {
      return projStr(code);
    }
  } else {
    return code;
  }
}
function extend(destination, source) {
  destination = destination || {};
  var value, property;
  if (!source) {
    return destination;
  }
  for (property in source) {
    value = source[property];
    if (value !== void 0) {
      destination[property] = value;
    }
  }
  return destination;
}
function msfnz(eccent, sinphi, cosphi) {
  var con = eccent * sinphi;
  return cosphi / Math.sqrt(1 - con * con);
}
function sign(x2) {
  return x2 < 0 ? -1 : 1;
}
function adjust_lon(x2) {
  return Math.abs(x2) <= SPI ? x2 : x2 - sign(x2) * TWO_PI;
}
function tsfnz(eccent, phi, sinphi) {
  var con = eccent * sinphi;
  var com = 0.5 * eccent;
  con = Math.pow((1 - con) / (1 + con), com);
  return Math.tan(0.5 * (HALF_PI - phi)) / con;
}
function phi2z(eccent, ts) {
  var eccnth = 0.5 * eccent;
  var con, dphi;
  var phi = HALF_PI - 2 * Math.atan(ts);
  for (var i2 = 0; i2 <= 15; i2++) {
    con = eccent * Math.sin(phi);
    dphi = HALF_PI - 2 * Math.atan(ts * Math.pow((1 - con) / (1 + con), eccnth)) - phi;
    phi += dphi;
    if (Math.abs(dphi) <= 1e-10) {
      return phi;
    }
  }
  return -9999;
}
function init$u() {
  var con = this.b / this.a;
  this.es = 1 - con * con;
  if (!("x0" in this)) {
    this.x0 = 0;
  }
  if (!("y0" in this)) {
    this.y0 = 0;
  }
  this.e = Math.sqrt(this.es);
  if (this.lat_ts) {
    if (this.sphere) {
      this.k0 = Math.cos(this.lat_ts);
    } else {
      this.k0 = msfnz(this.e, Math.sin(this.lat_ts), Math.cos(this.lat_ts));
    }
  } else {
    if (!this.k0) {
      if (this.k) {
        this.k0 = this.k;
      } else {
        this.k0 = 1;
      }
    }
  }
}
function forward$t(p5) {
  var lon = p5.x;
  var lat = p5.y;
  if (lat * R2D > 90 && lat * R2D < -90 && lon * R2D > 180 && lon * R2D < -180) {
    return null;
  }
  var x2, y2;
  if (Math.abs(Math.abs(lat) - HALF_PI) <= EPSLN) {
    return null;
  } else {
    if (this.sphere) {
      x2 = this.x0 + this.a * this.k0 * adjust_lon(lon - this.long0);
      y2 = this.y0 + this.a * this.k0 * Math.log(Math.tan(FORTPI + 0.5 * lat));
    } else {
      var sinphi = Math.sin(lat);
      var ts = tsfnz(this.e, lat, sinphi);
      x2 = this.x0 + this.a * this.k0 * adjust_lon(lon - this.long0);
      y2 = this.y0 - this.a * this.k0 * Math.log(ts);
    }
    p5.x = x2;
    p5.y = y2;
    return p5;
  }
}
function inverse$t(p5) {
  var x2 = p5.x - this.x0;
  var y2 = p5.y - this.y0;
  var lon, lat;
  if (this.sphere) {
    lat = HALF_PI - 2 * Math.atan(Math.exp(-y2 / (this.a * this.k0)));
  } else {
    var ts = Math.exp(-y2 / (this.a * this.k0));
    lat = phi2z(this.e, ts);
    if (lat === -9999) {
      return null;
    }
  }
  lon = adjust_lon(this.long0 + x2 / (this.a * this.k0));
  p5.x = lon;
  p5.y = lat;
  return p5;
}
var names$v = ["Mercator", "Popular Visualisation Pseudo Mercator", "Mercator_1SP", "Mercator_Auxiliary_Sphere", "merc"];
var merc = {
  init: init$u,
  forward: forward$t,
  inverse: inverse$t,
  names: names$v
};
function init$t() {
}
function identity(pt2) {
  return pt2;
}
var names$u = ["longlat", "identity"];
var longlat = {
  init: init$t,
  forward: identity,
  inverse: identity,
  names: names$u
};
var projs = [merc, longlat];
var names$t = {};
var projStore = [];
function add(proj, i2) {
  var len = projStore.length;
  if (!proj.names) {
    console.log(i2);
    return true;
  }
  projStore[len] = proj;
  proj.names.forEach(function(n2) {
    names$t[n2.toLowerCase()] = len;
  });
  return this;
}
function get$1(name) {
  if (!name) {
    return false;
  }
  var n2 = name.toLowerCase();
  if (typeof names$t[n2] !== "undefined" && projStore[names$t[n2]]) {
    return projStore[names$t[n2]];
  }
}
function start() {
  projs.forEach(add);
}
var projections = {
  start,
  add,
  get: get$1
};
var exports$1 = {};
exports$1.MERIT = {
  a: 6378137,
  rf: 298.257,
  ellipseName: "MERIT 1983"
};
exports$1.SGS85 = {
  a: 6378136,
  rf: 298.257,
  ellipseName: "Soviet Geodetic System 85"
};
exports$1.GRS80 = {
  a: 6378137,
  rf: 298.257222101,
  ellipseName: "GRS 1980(IUGG, 1980)"
};
exports$1.IAU76 = {
  a: 6378140,
  rf: 298.257,
  ellipseName: "IAU 1976"
};
exports$1.airy = {
  a: 6377563396e-3,
  b: 635625691e-2,
  ellipseName: "Airy 1830"
};
exports$1.APL4 = {
  a: 6378137,
  rf: 298.25,
  ellipseName: "Appl. Physics. 1965"
};
exports$1.NWL9D = {
  a: 6378145,
  rf: 298.25,
  ellipseName: "Naval Weapons Lab., 1965"
};
exports$1.mod_airy = {
  a: 6377340189e-3,
  b: 6356034446e-3,
  ellipseName: "Modified Airy"
};
exports$1.andrae = {
  a: 637710443e-2,
  rf: 300,
  ellipseName: "Andrae 1876 (Den., Iclnd.)"
};
exports$1.aust_SA = {
  a: 6378160,
  rf: 298.25,
  ellipseName: "Australian Natl & S. Amer. 1969"
};
exports$1.GRS67 = {
  a: 6378160,
  rf: 298.247167427,
  ellipseName: "GRS 67(IUGG 1967)"
};
exports$1.bessel = {
  a: 6377397155e-3,
  rf: 299.1528128,
  ellipseName: "Bessel 1841"
};
exports$1.bess_nam = {
  a: 6377483865e-3,
  rf: 299.1528128,
  ellipseName: "Bessel 1841 (Namibia)"
};
exports$1.clrk66 = {
  a: 63782064e-1,
  b: 63565838e-1,
  ellipseName: "Clarke 1866"
};
exports$1.clrk80 = {
  a: 6378249145e-3,
  rf: 293.4663,
  ellipseName: "Clarke 1880 mod."
};
exports$1.clrk58 = {
  a: 6378293645208759e-9,
  rf: 294.2606763692654,
  ellipseName: "Clarke 1858"
};
exports$1.CPM = {
  a: 63757387e-1,
  rf: 334.29,
  ellipseName: "Comm. des Poids et Mesures 1799"
};
exports$1.delmbr = {
  a: 6376428,
  rf: 311.5,
  ellipseName: "Delambre 1810 (Belgium)"
};
exports$1.engelis = {
  a: 637813605e-2,
  rf: 298.2566,
  ellipseName: "Engelis 1985"
};
exports$1.evrst30 = {
  a: 6377276345e-3,
  rf: 300.8017,
  ellipseName: "Everest 1830"
};
exports$1.evrst48 = {
  a: 6377304063e-3,
  rf: 300.8017,
  ellipseName: "Everest 1948"
};
exports$1.evrst56 = {
  a: 6377301243e-3,
  rf: 300.8017,
  ellipseName: "Everest 1956"
};
exports$1.evrst69 = {
  a: 6377295664e-3,
  rf: 300.8017,
  ellipseName: "Everest 1969"
};
exports$1.evrstSS = {
  a: 6377298556e-3,
  rf: 300.8017,
  ellipseName: "Everest (Sabah & Sarawak)"
};
exports$1.fschr60 = {
  a: 6378166,
  rf: 298.3,
  ellipseName: "Fischer (Mercury Datum) 1960"
};
exports$1.fschr60m = {
  a: 6378155,
  rf: 298.3,
  ellipseName: "Fischer 1960"
};
exports$1.fschr68 = {
  a: 6378150,
  rf: 298.3,
  ellipseName: "Fischer 1968"
};
exports$1.helmert = {
  a: 6378200,
  rf: 298.3,
  ellipseName: "Helmert 1906"
};
exports$1.hough = {
  a: 6378270,
  rf: 297,
  ellipseName: "Hough"
};
exports$1.intl = {
  a: 6378388,
  rf: 297,
  ellipseName: "International 1909 (Hayford)"
};
exports$1.kaula = {
  a: 6378163,
  rf: 298.24,
  ellipseName: "Kaula 1961"
};
exports$1.lerch = {
  a: 6378139,
  rf: 298.257,
  ellipseName: "Lerch 1979"
};
exports$1.mprts = {
  a: 6397300,
  rf: 191,
  ellipseName: "Maupertius 1738"
};
exports$1.new_intl = {
  a: 63781575e-1,
  b: 63567722e-1,
  ellipseName: "New International 1967"
};
exports$1.plessis = {
  a: 6376523,
  rf: 6355863,
  ellipseName: "Plessis 1817 (France)"
};
exports$1.krass = {
  a: 6378245,
  rf: 298.3,
  ellipseName: "Krassovsky, 1942"
};
exports$1.SEasia = {
  a: 6378155,
  b: 63567733205e-4,
  ellipseName: "Southeast Asia"
};
exports$1.walbeck = {
  a: 6376896,
  b: 63558348467e-4,
  ellipseName: "Walbeck"
};
exports$1.WGS60 = {
  a: 6378165,
  rf: 298.3,
  ellipseName: "WGS 60"
};
exports$1.WGS66 = {
  a: 6378145,
  rf: 298.25,
  ellipseName: "WGS 66"
};
exports$1.WGS7 = {
  a: 6378135,
  rf: 298.26,
  ellipseName: "WGS 72"
};
var WGS84 = exports$1.WGS84 = {
  a: 6378137,
  rf: 298.257223563,
  ellipseName: "WGS 84"
};
exports$1.sphere = {
  a: 6370997,
  b: 6370997,
  ellipseName: "Normal Sphere (r=6370997)"
};
function eccentricity(a2, b2, rf, R_A) {
  var a22 = a2 * a2;
  var b22 = b2 * b2;
  var es = (a22 - b22) / a22;
  var e2 = 0;
  if (R_A) {
    a2 *= 1 - es * (SIXTH + es * (RA4 + es * RA6));
    a22 = a2 * a2;
    es = 0;
  } else {
    e2 = Math.sqrt(es);
  }
  var ep2 = (a22 - b22) / b22;
  return {
    es,
    e: e2,
    ep2
  };
}
function sphere(a2, b2, rf, ellps, sphere2) {
  if (!a2) {
    var ellipse = match$1(exports$1, ellps);
    if (!ellipse) {
      ellipse = WGS84;
    }
    a2 = ellipse.a;
    b2 = ellipse.b;
    rf = ellipse.rf;
  }
  if (rf && !b2) {
    b2 = (1 - 1 / rf) * a2;
  }
  if (rf === 0 || Math.abs(a2 - b2) < EPSLN) {
    sphere2 = true;
    b2 = a2;
  }
  return {
    a: a2,
    b: b2,
    rf,
    sphere: sphere2
  };
}
var exports = {};
exports.wgs84 = {
  towgs84: "0,0,0",
  ellipse: "WGS84",
  datumName: "WGS84"
};
exports.ch1903 = {
  towgs84: "674.374,15.056,405.346",
  ellipse: "bessel",
  datumName: "swiss"
};
exports.ggrs87 = {
  towgs84: "-199.87,74.79,246.62",
  ellipse: "GRS80",
  datumName: "Greek_Geodetic_Reference_System_1987"
};
exports.nad83 = {
  towgs84: "0,0,0",
  ellipse: "GRS80",
  datumName: "North_American_Datum_1983"
};
exports.nad27 = {
  nadgrids: "@conus,@alaska,@ntv2_0.gsb,@ntv1_can.dat",
  ellipse: "clrk66",
  datumName: "North_American_Datum_1927"
};
exports.potsdam = {
  towgs84: "598.1,73.7,418.2,0.202,0.045,-2.455,6.7",
  ellipse: "bessel",
  datumName: "Potsdam Rauenberg 1950 DHDN"
};
exports.carthage = {
  towgs84: "-263.0,6.0,431.0",
  ellipse: "clark80",
  datumName: "Carthage 1934 Tunisia"
};
exports.hermannskogel = {
  towgs84: "577.326,90.129,463.919,5.137,1.474,5.297,2.4232",
  ellipse: "bessel",
  datumName: "Hermannskogel"
};
exports.osni52 = {
  towgs84: "482.530,-130.596,564.557,-1.042,-0.214,-0.631,8.15",
  ellipse: "airy",
  datumName: "Irish National"
};
exports.ire65 = {
  towgs84: "482.530,-130.596,564.557,-1.042,-0.214,-0.631,8.15",
  ellipse: "mod_airy",
  datumName: "Ireland 1965"
};
exports.rassadiran = {
  towgs84: "-133.63,-157.5,-158.62",
  ellipse: "intl",
  datumName: "Rassadiran"
};
exports.nzgd49 = {
  towgs84: "59.47,-5.04,187.44,0.47,-0.1,1.024,-4.5993",
  ellipse: "intl",
  datumName: "New Zealand Geodetic Datum 1949"
};
exports.osgb36 = {
  towgs84: "446.448,-125.157,542.060,0.1502,0.2470,0.8421,-20.4894",
  ellipse: "airy",
  datumName: "Airy 1830"
};
exports.s_jtsk = {
  towgs84: "589,76,480",
  ellipse: "bessel",
  datumName: "S-JTSK (Ferro)"
};
exports.beduaram = {
  towgs84: "-106,-87,188",
  ellipse: "clrk80",
  datumName: "Beduaram"
};
exports.gunung_segara = {
  towgs84: "-403,684,41",
  ellipse: "bessel",
  datumName: "Gunung Segara Jakarta"
};
exports.rnb72 = {
  towgs84: "106.869,-52.2978,103.724,-0.33657,0.456955,-1.84218,1",
  ellipse: "intl",
  datumName: "Reseau National Belge 1972"
};
function datum(datumCode, datum_params, a2, b2, es, ep2, nadgrids) {
  var out = {};
  if (datumCode === void 0 || datumCode === "none") {
    out.datum_type = PJD_NODATUM;
  } else {
    out.datum_type = PJD_WGS84;
  }
  if (datum_params) {
    out.datum_params = datum_params.map(parseFloat);
    if (out.datum_params[0] !== 0 || out.datum_params[1] !== 0 || out.datum_params[2] !== 0) {
      out.datum_type = PJD_3PARAM;
    }
    if (out.datum_params.length > 3) {
      if (out.datum_params[3] !== 0 || out.datum_params[4] !== 0 || out.datum_params[5] !== 0 || out.datum_params[6] !== 0) {
        out.datum_type = PJD_7PARAM;
        out.datum_params[3] *= SEC_TO_RAD;
        out.datum_params[4] *= SEC_TO_RAD;
        out.datum_params[5] *= SEC_TO_RAD;
        out.datum_params[6] = out.datum_params[6] / 1e6 + 1;
      }
    }
  }
  if (nadgrids) {
    out.datum_type = PJD_GRIDSHIFT;
    out.grids = nadgrids;
  }
  out.a = a2;
  out.b = b2;
  out.es = es;
  out.ep2 = ep2;
  return out;
}
var loadedNadgrids = {};
function nadgrid(key, data2) {
  var view = new DataView(data2);
  var isLittleEndian = detectLittleEndian(view);
  var header = readHeader(view, isLittleEndian);
  if (header.nSubgrids > 1) {
    console.log("Only single NTv2 subgrids are currently supported, subsequent sub grids are ignored");
  }
  var subgrids = readSubgrids(view, header, isLittleEndian);
  var nadgrid2 = { header, subgrids };
  loadedNadgrids[key] = nadgrid2;
  return nadgrid2;
}
function getNadgrids(nadgrids) {
  if (nadgrids === void 0) {
    return null;
  }
  var grids = nadgrids.split(",");
  return grids.map(parseNadgridString);
}
function parseNadgridString(value) {
  if (value.length === 0) {
    return null;
  }
  var optional = value[0] === "@";
  if (optional) {
    value = value.slice(1);
  }
  if (value === "null") {
    return { name: "null", mandatory: !optional, grid: null, isNull: true };
  }
  return {
    name: value,
    mandatory: !optional,
    grid: loadedNadgrids[value] || null,
    isNull: false
  };
}
function secondsToRadians(seconds) {
  return seconds / 3600 * Math.PI / 180;
}
function detectLittleEndian(view) {
  var nFields = view.getInt32(8, false);
  if (nFields === 11) {
    return false;
  }
  nFields = view.getInt32(8, true);
  if (nFields !== 11) {
    console.warn("Failed to detect nadgrid endian-ness, defaulting to little-endian");
  }
  return true;
}
function readHeader(view, isLittleEndian) {
  return {
    nFields: view.getInt32(8, isLittleEndian),
    nSubgridFields: view.getInt32(24, isLittleEndian),
    nSubgrids: view.getInt32(40, isLittleEndian),
    shiftType: decodeString(view, 56, 56 + 8).trim(),
    fromSemiMajorAxis: view.getFloat64(120, isLittleEndian),
    fromSemiMinorAxis: view.getFloat64(136, isLittleEndian),
    toSemiMajorAxis: view.getFloat64(152, isLittleEndian),
    toSemiMinorAxis: view.getFloat64(168, isLittleEndian)
  };
}
function decodeString(view, start2, end) {
  return String.fromCharCode.apply(null, new Uint8Array(view.buffer.slice(start2, end)));
}
function readSubgrids(view, header, isLittleEndian) {
  var gridOffset = 176;
  var grids = [];
  for (var i2 = 0; i2 < header.nSubgrids; i2++) {
    var subHeader = readGridHeader(view, gridOffset, isLittleEndian);
    var nodes = readGridNodes(view, gridOffset, subHeader, isLittleEndian);
    var lngColumnCount = Math.round(1 + (subHeader.upperLongitude - subHeader.lowerLongitude) / subHeader.longitudeInterval);
    var latColumnCount = Math.round(1 + (subHeader.upperLatitude - subHeader.lowerLatitude) / subHeader.latitudeInterval);
    grids.push({
      ll: [secondsToRadians(subHeader.lowerLongitude), secondsToRadians(subHeader.lowerLatitude)],
      del: [secondsToRadians(subHeader.longitudeInterval), secondsToRadians(subHeader.latitudeInterval)],
      lim: [lngColumnCount, latColumnCount],
      count: subHeader.gridNodeCount,
      cvs: mapNodes(nodes)
    });
  }
  return grids;
}
function mapNodes(nodes) {
  return nodes.map(function(r2) {
    return [secondsToRadians(r2.longitudeShift), secondsToRadians(r2.latitudeShift)];
  });
}
function readGridHeader(view, offset2, isLittleEndian) {
  return {
    name: decodeString(view, offset2 + 8, offset2 + 16).trim(),
    parent: decodeString(view, offset2 + 24, offset2 + 24 + 8).trim(),
    lowerLatitude: view.getFloat64(offset2 + 72, isLittleEndian),
    upperLatitude: view.getFloat64(offset2 + 88, isLittleEndian),
    lowerLongitude: view.getFloat64(offset2 + 104, isLittleEndian),
    upperLongitude: view.getFloat64(offset2 + 120, isLittleEndian),
    latitudeInterval: view.getFloat64(offset2 + 136, isLittleEndian),
    longitudeInterval: view.getFloat64(offset2 + 152, isLittleEndian),
    gridNodeCount: view.getInt32(offset2 + 168, isLittleEndian)
  };
}
function readGridNodes(view, offset2, gridHeader, isLittleEndian) {
  var nodesOffset = offset2 + 176;
  var gridRecordLength = 16;
  var gridShiftRecords = [];
  for (var i2 = 0; i2 < gridHeader.gridNodeCount; i2++) {
    var record = {
      latitudeShift: view.getFloat32(nodesOffset + i2 * gridRecordLength, isLittleEndian),
      longitudeShift: view.getFloat32(nodesOffset + i2 * gridRecordLength + 4, isLittleEndian),
      latitudeAccuracy: view.getFloat32(nodesOffset + i2 * gridRecordLength + 8, isLittleEndian),
      longitudeAccuracy: view.getFloat32(nodesOffset + i2 * gridRecordLength + 12, isLittleEndian)
    };
    gridShiftRecords.push(record);
  }
  return gridShiftRecords;
}
function Projection$1(srsCode, callback) {
  if (!(this instanceof Projection$1)) {
    return new Projection$1(srsCode);
  }
  callback = callback || function(error) {
    if (error) {
      throw error;
    }
  };
  var json = parse$2(srsCode);
  if (typeof json !== "object") {
    callback(srsCode);
    return;
  }
  var ourProj = Projection$1.projections.get(json.projName);
  if (!ourProj) {
    callback(srsCode);
    return;
  }
  if (json.datumCode && json.datumCode !== "none") {
    var datumDef = match$1(exports, json.datumCode);
    if (datumDef) {
      json.datum_params = json.datum_params || (datumDef.towgs84 ? datumDef.towgs84.split(",") : null);
      json.ellps = datumDef.ellipse;
      json.datumName = datumDef.datumName ? datumDef.datumName : json.datumCode;
    }
  }
  json.k0 = json.k0 || 1;
  json.axis = json.axis || "enu";
  json.ellps = json.ellps || "wgs84";
  json.lat1 = json.lat1 || json.lat0;
  var sphere_ = sphere(json.a, json.b, json.rf, json.ellps, json.sphere);
  var ecc = eccentricity(sphere_.a, sphere_.b, sphere_.rf, json.R_A);
  var nadgrids = getNadgrids(json.nadgrids);
  var datumObj = json.datum || datum(json.datumCode, json.datum_params, sphere_.a, sphere_.b, ecc.es, ecc.ep2, nadgrids);
  extend(this, json);
  extend(this, ourProj);
  this.a = sphere_.a;
  this.b = sphere_.b;
  this.rf = sphere_.rf;
  this.sphere = sphere_.sphere;
  this.es = ecc.es;
  this.e = ecc.e;
  this.ep2 = ecc.ep2;
  this.datum = datumObj;
  this.init();
  callback(null, this);
}
Projection$1.projections = projections;
Projection$1.projections.start();
function compareDatums(source, dest) {
  if (source.datum_type !== dest.datum_type) {
    return false;
  } else if (source.a !== dest.a || Math.abs(source.es - dest.es) > 5e-11) {
    return false;
  } else if (source.datum_type === PJD_3PARAM) {
    return source.datum_params[0] === dest.datum_params[0] && source.datum_params[1] === dest.datum_params[1] && source.datum_params[2] === dest.datum_params[2];
  } else if (source.datum_type === PJD_7PARAM) {
    return source.datum_params[0] === dest.datum_params[0] && source.datum_params[1] === dest.datum_params[1] && source.datum_params[2] === dest.datum_params[2] && source.datum_params[3] === dest.datum_params[3] && source.datum_params[4] === dest.datum_params[4] && source.datum_params[5] === dest.datum_params[5] && source.datum_params[6] === dest.datum_params[6];
  } else {
    return true;
  }
}
function geodeticToGeocentric(p5, es, a2) {
  var Longitude = p5.x;
  var Latitude = p5.y;
  var Height = p5.z ? p5.z : 0;
  var Rn;
  var Sin_Lat;
  var Sin2_Lat;
  var Cos_Lat;
  if (Latitude < -HALF_PI && Latitude > -1.001 * HALF_PI) {
    Latitude = -HALF_PI;
  } else if (Latitude > HALF_PI && Latitude < 1.001 * HALF_PI) {
    Latitude = HALF_PI;
  } else if (Latitude < -HALF_PI) {
    return { x: -Infinity, y: -Infinity, z: p5.z };
  } else if (Latitude > HALF_PI) {
    return { x: Infinity, y: Infinity, z: p5.z };
  }
  if (Longitude > Math.PI) {
    Longitude -= 2 * Math.PI;
  }
  Sin_Lat = Math.sin(Latitude);
  Cos_Lat = Math.cos(Latitude);
  Sin2_Lat = Sin_Lat * Sin_Lat;
  Rn = a2 / Math.sqrt(1 - es * Sin2_Lat);
  return {
    x: (Rn + Height) * Cos_Lat * Math.cos(Longitude),
    y: (Rn + Height) * Cos_Lat * Math.sin(Longitude),
    z: (Rn * (1 - es) + Height) * Sin_Lat
  };
}
function geocentricToGeodetic(p5, es, a2, b2) {
  var genau = 1e-12;
  var genau2 = genau * genau;
  var maxiter = 30;
  var P2;
  var RR;
  var CT;
  var ST;
  var RX;
  var RK;
  var RN;
  var CPHI0;
  var SPHI0;
  var CPHI;
  var SPHI;
  var SDPHI;
  var iter;
  var X2 = p5.x;
  var Y2 = p5.y;
  var Z2 = p5.z ? p5.z : 0;
  var Longitude;
  var Latitude;
  var Height;
  P2 = Math.sqrt(X2 * X2 + Y2 * Y2);
  RR = Math.sqrt(X2 * X2 + Y2 * Y2 + Z2 * Z2);
  if (P2 / a2 < genau) {
    Longitude = 0;
    if (RR / a2 < genau) {
      Latitude = HALF_PI;
      Height = -b2;
      return {
        x: p5.x,
        y: p5.y,
        z: p5.z
      };
    }
  } else {
    Longitude = Math.atan2(Y2, X2);
  }
  CT = Z2 / RR;
  ST = P2 / RR;
  RX = 1 / Math.sqrt(1 - es * (2 - es) * ST * ST);
  CPHI0 = ST * (1 - es) * RX;
  SPHI0 = CT * RX;
  iter = 0;
  do {
    iter++;
    RN = a2 / Math.sqrt(1 - es * SPHI0 * SPHI0);
    Height = P2 * CPHI0 + Z2 * SPHI0 - RN * (1 - es * SPHI0 * SPHI0);
    RK = es * RN / (RN + Height);
    RX = 1 / Math.sqrt(1 - RK * (2 - RK) * ST * ST);
    CPHI = ST * (1 - RK) * RX;
    SPHI = CT * RX;
    SDPHI = SPHI * CPHI0 - CPHI * SPHI0;
    CPHI0 = CPHI;
    SPHI0 = SPHI;
  } while (SDPHI * SDPHI > genau2 && iter < maxiter);
  Latitude = Math.atan(SPHI / Math.abs(CPHI));
  return {
    x: Longitude,
    y: Latitude,
    z: Height
  };
}
function geocentricToWgs84(p5, datum_type, datum_params) {
  if (datum_type === PJD_3PARAM) {
    return {
      x: p5.x + datum_params[0],
      y: p5.y + datum_params[1],
      z: p5.z + datum_params[2]
    };
  } else if (datum_type === PJD_7PARAM) {
    var Dx_BF = datum_params[0];
    var Dy_BF = datum_params[1];
    var Dz_BF = datum_params[2];
    var Rx_BF = datum_params[3];
    var Ry_BF = datum_params[4];
    var Rz_BF = datum_params[5];
    var M_BF = datum_params[6];
    return {
      x: M_BF * (p5.x - Rz_BF * p5.y + Ry_BF * p5.z) + Dx_BF,
      y: M_BF * (Rz_BF * p5.x + p5.y - Rx_BF * p5.z) + Dy_BF,
      z: M_BF * (-Ry_BF * p5.x + Rx_BF * p5.y + p5.z) + Dz_BF
    };
  }
}
function geocentricFromWgs84(p5, datum_type, datum_params) {
  if (datum_type === PJD_3PARAM) {
    return {
      x: p5.x - datum_params[0],
      y: p5.y - datum_params[1],
      z: p5.z - datum_params[2]
    };
  } else if (datum_type === PJD_7PARAM) {
    var Dx_BF = datum_params[0];
    var Dy_BF = datum_params[1];
    var Dz_BF = datum_params[2];
    var Rx_BF = datum_params[3];
    var Ry_BF = datum_params[4];
    var Rz_BF = datum_params[5];
    var M_BF = datum_params[6];
    var x_tmp = (p5.x - Dx_BF) / M_BF;
    var y_tmp = (p5.y - Dy_BF) / M_BF;
    var z_tmp = (p5.z - Dz_BF) / M_BF;
    return {
      x: x_tmp + Rz_BF * y_tmp - Ry_BF * z_tmp,
      y: -Rz_BF * x_tmp + y_tmp + Rx_BF * z_tmp,
      z: Ry_BF * x_tmp - Rx_BF * y_tmp + z_tmp
    };
  }
}
function checkParams(type) {
  return type === PJD_3PARAM || type === PJD_7PARAM;
}
function datum_transform(source, dest, point) {
  if (compareDatums(source, dest)) {
    return point;
  }
  if (source.datum_type === PJD_NODATUM || dest.datum_type === PJD_NODATUM) {
    return point;
  }
  var source_a = source.a;
  var source_es = source.es;
  if (source.datum_type === PJD_GRIDSHIFT) {
    var gridShiftCode = applyGridShift(source, false, point);
    if (gridShiftCode !== 0) {
      return void 0;
    }
    source_a = SRS_WGS84_SEMIMAJOR;
    source_es = SRS_WGS84_ESQUARED;
  }
  var dest_a = dest.a;
  var dest_b = dest.b;
  var dest_es = dest.es;
  if (dest.datum_type === PJD_GRIDSHIFT) {
    dest_a = SRS_WGS84_SEMIMAJOR;
    dest_b = SRS_WGS84_SEMIMINOR;
    dest_es = SRS_WGS84_ESQUARED;
  }
  if (source_es === dest_es && source_a === dest_a && !checkParams(source.datum_type) && !checkParams(dest.datum_type)) {
    return point;
  }
  point = geodeticToGeocentric(point, source_es, source_a);
  if (checkParams(source.datum_type)) {
    point = geocentricToWgs84(point, source.datum_type, source.datum_params);
  }
  if (checkParams(dest.datum_type)) {
    point = geocentricFromWgs84(point, dest.datum_type, dest.datum_params);
  }
  point = geocentricToGeodetic(point, dest_es, dest_a, dest_b);
  if (dest.datum_type === PJD_GRIDSHIFT) {
    var destGridShiftResult = applyGridShift(dest, true, point);
    if (destGridShiftResult !== 0) {
      return void 0;
    }
  }
  return point;
}
function applyGridShift(source, inverse2, point) {
  if (source.grids === null || source.grids.length === 0) {
    console.log("Grid shift grids not found");
    return -1;
  }
  var input = { x: -point.x, y: point.y };
  var output = { x: Number.NaN, y: Number.NaN };
  var attemptedGrids = [];
  for (var i2 = 0; i2 < source.grids.length; i2++) {
    var grid = source.grids[i2];
    attemptedGrids.push(grid.name);
    if (grid.isNull) {
      output = input;
      break;
    }
    if (grid.grid === null) {
      if (grid.mandatory) {
        console.log("Unable to find mandatory grid '" + grid.name + "'");
        return -1;
      }
      continue;
    }
    var subgrid = grid.grid.subgrids[0];
    var epsilon = (Math.abs(subgrid.del[1]) + Math.abs(subgrid.del[0])) / 1e4;
    var minX = subgrid.ll[0] - epsilon;
    var minY = subgrid.ll[1] - epsilon;
    var maxX = subgrid.ll[0] + (subgrid.lim[0] - 1) * subgrid.del[0] + epsilon;
    var maxY = subgrid.ll[1] + (subgrid.lim[1] - 1) * subgrid.del[1] + epsilon;
    if (minY > input.y || minX > input.x || maxY < input.y || maxX < input.x) {
      continue;
    }
    output = applySubgridShift(input, inverse2, subgrid);
    if (!isNaN(output.x)) {
      break;
    }
  }
  if (isNaN(output.x)) {
    console.log("Failed to find a grid shift table for location '" + -input.x * R2D + " " + input.y * R2D + " tried: '" + attemptedGrids + "'");
    return -1;
  }
  point.x = -output.x;
  point.y = output.y;
  return 0;
}
function applySubgridShift(pin, inverse2, ct2) {
  var val = { x: Number.NaN, y: Number.NaN };
  if (isNaN(pin.x)) {
    return val;
  }
  var tb = { x: pin.x, y: pin.y };
  tb.x -= ct2.ll[0];
  tb.y -= ct2.ll[1];
  tb.x = adjust_lon(tb.x - Math.PI) + Math.PI;
  var t3 = nadInterpolate(tb, ct2);
  if (inverse2) {
    if (isNaN(t3.x)) {
      return val;
    }
    t3.x = tb.x - t3.x;
    t3.y = tb.y - t3.y;
    var i2 = 9, tol = 1e-12;
    var dif, del;
    do {
      del = nadInterpolate(t3, ct2);
      if (isNaN(del.x)) {
        console.log("Inverse grid shift iteration failed, presumably at grid edge.  Using first approximation.");
        break;
      }
      dif = { x: tb.x - (del.x + t3.x), y: tb.y - (del.y + t3.y) };
      t3.x += dif.x;
      t3.y += dif.y;
    } while (i2-- && Math.abs(dif.x) > tol && Math.abs(dif.y) > tol);
    if (i2 < 0) {
      console.log("Inverse grid shift iterator failed to converge.");
      return val;
    }
    val.x = adjust_lon(t3.x + ct2.ll[0]);
    val.y = t3.y + ct2.ll[1];
  } else {
    if (!isNaN(t3.x)) {
      val.x = pin.x + t3.x;
      val.y = pin.y + t3.y;
    }
  }
  return val;
}
function nadInterpolate(pin, ct2) {
  var t3 = { x: pin.x / ct2.del[0], y: pin.y / ct2.del[1] };
  var indx = { x: Math.floor(t3.x), y: Math.floor(t3.y) };
  var frct = { x: t3.x - 1 * indx.x, y: t3.y - 1 * indx.y };
  var val = { x: Number.NaN, y: Number.NaN };
  var inx;
  if (indx.x < 0 || indx.x >= ct2.lim[0]) {
    return val;
  }
  if (indx.y < 0 || indx.y >= ct2.lim[1]) {
    return val;
  }
  inx = indx.y * ct2.lim[0] + indx.x;
  var f00 = { x: ct2.cvs[inx][0], y: ct2.cvs[inx][1] };
  inx++;
  var f10 = { x: ct2.cvs[inx][0], y: ct2.cvs[inx][1] };
  inx += ct2.lim[0];
  var f11 = { x: ct2.cvs[inx][0], y: ct2.cvs[inx][1] };
  inx--;
  var f01 = { x: ct2.cvs[inx][0], y: ct2.cvs[inx][1] };
  var m11 = frct.x * frct.y, m10 = frct.x * (1 - frct.y), m00 = (1 - frct.x) * (1 - frct.y), m01 = (1 - frct.x) * frct.y;
  val.x = m00 * f00.x + m10 * f10.x + m01 * f01.x + m11 * f11.x;
  val.y = m00 * f00.y + m10 * f10.y + m01 * f01.y + m11 * f11.y;
  return val;
}
function adjust_axis(crs, denorm, point) {
  var xin = point.x, yin = point.y, zin = point.z || 0;
  var v2, t3, i2;
  var out = {};
  for (i2 = 0; i2 < 3; i2++) {
    if (denorm && i2 === 2 && point.z === void 0) {
      continue;
    }
    if (i2 === 0) {
      v2 = xin;
      if ("ew".indexOf(crs.axis[i2]) !== -1) {
        t3 = "x";
      } else {
        t3 = "y";
      }
    } else if (i2 === 1) {
      v2 = yin;
      if ("ns".indexOf(crs.axis[i2]) !== -1) {
        t3 = "y";
      } else {
        t3 = "x";
      }
    } else {
      v2 = zin;
      t3 = "z";
    }
    switch (crs.axis[i2]) {
      case "e":
        out[t3] = v2;
        break;
      case "w":
        out[t3] = -v2;
        break;
      case "n":
        out[t3] = v2;
        break;
      case "s":
        out[t3] = -v2;
        break;
      case "u":
        if (point[t3] !== void 0) {
          out.z = v2;
        }
        break;
      case "d":
        if (point[t3] !== void 0) {
          out.z = -v2;
        }
        break;
      default:
        return null;
    }
  }
  return out;
}
function common(array) {
  var out = {
    x: array[0],
    y: array[1]
  };
  if (array.length > 2) {
    out.z = array[2];
  }
  if (array.length > 3) {
    out.m = array[3];
  }
  return out;
}
function checkSanity(point) {
  checkCoord(point.x);
  checkCoord(point.y);
}
function checkCoord(num) {
  if (typeof Number.isFinite === "function") {
    if (Number.isFinite(num)) {
      return;
    }
    throw new TypeError("coordinates must be finite numbers");
  }
  if (typeof num !== "number" || num !== num || !isFinite(num)) {
    throw new TypeError("coordinates must be finite numbers");
  }
}
function checkNotWGS(source, dest) {
  return (source.datum.datum_type === PJD_3PARAM || source.datum.datum_type === PJD_7PARAM) && dest.datumCode !== "WGS84" || (dest.datum.datum_type === PJD_3PARAM || dest.datum.datum_type === PJD_7PARAM) && source.datumCode !== "WGS84";
}
function transform$2(source, dest, point, enforceAxis) {
  var wgs842;
  if (Array.isArray(point)) {
    point = common(point);
  }
  checkSanity(point);
  if (source.datum && dest.datum && checkNotWGS(source, dest)) {
    wgs842 = new Projection$1("WGS84");
    point = transform$2(source, wgs842, point, enforceAxis);
    source = wgs842;
  }
  if (enforceAxis && source.axis !== "enu") {
    point = adjust_axis(source, false, point);
  }
  if (source.projName === "longlat") {
    point = {
      x: point.x * D2R$1,
      y: point.y * D2R$1,
      z: point.z || 0
    };
  } else {
    if (source.to_meter) {
      point = {
        x: point.x * source.to_meter,
        y: point.y * source.to_meter,
        z: point.z || 0
      };
    }
    point = source.inverse(point);
    if (!point) {
      return;
    }
  }
  if (source.from_greenwich) {
    point.x += source.from_greenwich;
  }
  point = datum_transform(source.datum, dest.datum, point);
  if (!point) {
    return;
  }
  if (dest.from_greenwich) {
    point = {
      x: point.x - dest.from_greenwich,
      y: point.y,
      z: point.z || 0
    };
  }
  if (dest.projName === "longlat") {
    point = {
      x: point.x * R2D,
      y: point.y * R2D,
      z: point.z || 0
    };
  } else {
    point = dest.forward(point);
    if (dest.to_meter) {
      point = {
        x: point.x / dest.to_meter,
        y: point.y / dest.to_meter,
        z: point.z || 0
      };
    }
  }
  if (enforceAxis && dest.axis !== "enu") {
    return adjust_axis(dest, true, point);
  }
  return point;
}
var wgs84 = Projection$1("WGS84");
function transformer(from, to, coords, enforceAxis) {
  var transformedArray, out, keys3;
  if (Array.isArray(coords)) {
    transformedArray = transform$2(from, to, coords, enforceAxis) || { x: NaN, y: NaN };
    if (coords.length > 2) {
      if (typeof from.name !== "undefined" && from.name === "geocent" || typeof to.name !== "undefined" && to.name === "geocent") {
        if (typeof transformedArray.z === "number") {
          return [transformedArray.x, transformedArray.y, transformedArray.z].concat(coords.splice(3));
        } else {
          return [transformedArray.x, transformedArray.y, coords[2]].concat(coords.splice(3));
        }
      } else {
        return [transformedArray.x, transformedArray.y].concat(coords.splice(2));
      }
    } else {
      return [transformedArray.x, transformedArray.y];
    }
  } else {
    out = transform$2(from, to, coords, enforceAxis);
    keys3 = Object.keys(coords);
    if (keys3.length === 2) {
      return out;
    }
    keys3.forEach(function(key) {
      if (typeof from.name !== "undefined" && from.name === "geocent" || typeof to.name !== "undefined" && to.name === "geocent") {
        if (key === "x" || key === "y" || key === "z") {
          return;
        }
      } else {
        if (key === "x" || key === "y") {
          return;
        }
      }
      out[key] = coords[key];
    });
    return out;
  }
}
function checkProj(item) {
  if (item instanceof Projection$1) {
    return item;
  }
  if (item.oProj) {
    return item.oProj;
  }
  return Projection$1(item);
}
function proj4(fromProj, toProj, coord) {
  fromProj = checkProj(fromProj);
  var single = false;
  var obj;
  if (typeof toProj === "undefined") {
    toProj = fromProj;
    fromProj = wgs84;
    single = true;
  } else if (typeof toProj.x !== "undefined" || Array.isArray(toProj)) {
    coord = toProj;
    toProj = fromProj;
    fromProj = wgs84;
    single = true;
  }
  toProj = checkProj(toProj);
  if (coord) {
    return transformer(fromProj, toProj, coord);
  } else {
    obj = {
      forward: function(coords, enforceAxis) {
        return transformer(fromProj, toProj, coords, enforceAxis);
      },
      inverse: function(coords, enforceAxis) {
        return transformer(toProj, fromProj, coords, enforceAxis);
      }
    };
    if (single) {
      obj.oProj = toProj;
    }
    return obj;
  }
}
var NUM_100K_SETS = 6;
var SET_ORIGIN_COLUMN_LETTERS = "AJSAJS";
var SET_ORIGIN_ROW_LETTERS = "AFAFAF";
var A$2 = 65;
var I$1 = 73;
var O$2 = 79;
var V$2 = 86;
var Z$3 = 90;
var mgrs = {
  forward: forward$s,
  inverse: inverse$s,
  toPoint
};
function forward$s(ll, accuracy) {
  accuracy = accuracy || 5;
  return encode$1(LLtoUTM({
    lat: ll[1],
    lon: ll[0]
  }), accuracy);
}
function inverse$s(mgrs2) {
  var bbox2 = UTMtoLL(decode$2(mgrs2.toUpperCase()));
  if (bbox2.lat && bbox2.lon) {
    return [bbox2.lon, bbox2.lat, bbox2.lon, bbox2.lat];
  }
  return [bbox2.left, bbox2.bottom, bbox2.right, bbox2.top];
}
function toPoint(mgrs2) {
  var bbox2 = UTMtoLL(decode$2(mgrs2.toUpperCase()));
  if (bbox2.lat && bbox2.lon) {
    return [bbox2.lon, bbox2.lat];
  }
  return [(bbox2.left + bbox2.right) / 2, (bbox2.top + bbox2.bottom) / 2];
}
function degToRad(deg2) {
  return deg2 * (Math.PI / 180);
}
function radToDeg(rad) {
  return 180 * (rad / Math.PI);
}
function LLtoUTM(ll) {
  var Lat = ll.lat;
  var Long = ll.lon;
  var a2 = 6378137;
  var eccSquared = 669438e-8;
  var k0 = 0.9996;
  var LongOrigin;
  var eccPrimeSquared;
  var N2, T2, C2, A2, M2;
  var LatRad = degToRad(Lat);
  var LongRad = degToRad(Long);
  var LongOriginRad;
  var ZoneNumber;
  ZoneNumber = Math.floor((Long + 180) / 6) + 1;
  if (Long === 180) {
    ZoneNumber = 60;
  }
  if (Lat >= 56 && Lat < 64 && Long >= 3 && Long < 12) {
    ZoneNumber = 32;
  }
  if (Lat >= 72 && Lat < 84) {
    if (Long >= 0 && Long < 9) {
      ZoneNumber = 31;
    } else if (Long >= 9 && Long < 21) {
      ZoneNumber = 33;
    } else if (Long >= 21 && Long < 33) {
      ZoneNumber = 35;
    } else if (Long >= 33 && Long < 42) {
      ZoneNumber = 37;
    }
  }
  LongOrigin = (ZoneNumber - 1) * 6 - 180 + 3;
  LongOriginRad = degToRad(LongOrigin);
  eccPrimeSquared = eccSquared / (1 - eccSquared);
  N2 = a2 / Math.sqrt(1 - eccSquared * Math.sin(LatRad) * Math.sin(LatRad));
  T2 = Math.tan(LatRad) * Math.tan(LatRad);
  C2 = eccPrimeSquared * Math.cos(LatRad) * Math.cos(LatRad);
  A2 = Math.cos(LatRad) * (LongRad - LongOriginRad);
  M2 = a2 * ((1 - eccSquared / 4 - 3 * eccSquared * eccSquared / 64 - 5 * eccSquared * eccSquared * eccSquared / 256) * LatRad - (3 * eccSquared / 8 + 3 * eccSquared * eccSquared / 32 + 45 * eccSquared * eccSquared * eccSquared / 1024) * Math.sin(2 * LatRad) + (15 * eccSquared * eccSquared / 256 + 45 * eccSquared * eccSquared * eccSquared / 1024) * Math.sin(4 * LatRad) - 35 * eccSquared * eccSquared * eccSquared / 3072 * Math.sin(6 * LatRad));
  var UTMEasting = k0 * N2 * (A2 + (1 - T2 + C2) * A2 * A2 * A2 / 6 + (5 - 18 * T2 + T2 * T2 + 72 * C2 - 58 * eccPrimeSquared) * A2 * A2 * A2 * A2 * A2 / 120) + 5e5;
  var UTMNorthing = k0 * (M2 + N2 * Math.tan(LatRad) * (A2 * A2 / 2 + (5 - T2 + 9 * C2 + 4 * C2 * C2) * A2 * A2 * A2 * A2 / 24 + (61 - 58 * T2 + T2 * T2 + 600 * C2 - 330 * eccPrimeSquared) * A2 * A2 * A2 * A2 * A2 * A2 / 720));
  if (Lat < 0) {
    UTMNorthing += 1e7;
  }
  return {
    northing: Math.round(UTMNorthing),
    easting: Math.round(UTMEasting),
    zoneNumber: ZoneNumber,
    zoneLetter: getLetterDesignator(Lat)
  };
}
function UTMtoLL(utm2) {
  var UTMNorthing = utm2.northing;
  var UTMEasting = utm2.easting;
  var zoneLetter = utm2.zoneLetter;
  var zoneNumber = utm2.zoneNumber;
  if (zoneNumber < 0 || zoneNumber > 60) {
    return null;
  }
  var k0 = 0.9996;
  var a2 = 6378137;
  var eccSquared = 669438e-8;
  var eccPrimeSquared;
  var e1 = (1 - Math.sqrt(1 - eccSquared)) / (1 + Math.sqrt(1 - eccSquared));
  var N1, T1, C12, R1, D2, M2;
  var LongOrigin;
  var mu, phi1Rad;
  var x2 = UTMEasting - 5e5;
  var y2 = UTMNorthing;
  if (zoneLetter < "N") {
    y2 -= 1e7;
  }
  LongOrigin = (zoneNumber - 1) * 6 - 180 + 3;
  eccPrimeSquared = eccSquared / (1 - eccSquared);
  M2 = y2 / k0;
  mu = M2 / (a2 * (1 - eccSquared / 4 - 3 * eccSquared * eccSquared / 64 - 5 * eccSquared * eccSquared * eccSquared / 256));
  phi1Rad = mu + (3 * e1 / 2 - 27 * e1 * e1 * e1 / 32) * Math.sin(2 * mu) + (21 * e1 * e1 / 16 - 55 * e1 * e1 * e1 * e1 / 32) * Math.sin(4 * mu) + 151 * e1 * e1 * e1 / 96 * Math.sin(6 * mu);
  N1 = a2 / Math.sqrt(1 - eccSquared * Math.sin(phi1Rad) * Math.sin(phi1Rad));
  T1 = Math.tan(phi1Rad) * Math.tan(phi1Rad);
  C12 = eccPrimeSquared * Math.cos(phi1Rad) * Math.cos(phi1Rad);
  R1 = a2 * (1 - eccSquared) / Math.pow(1 - eccSquared * Math.sin(phi1Rad) * Math.sin(phi1Rad), 1.5);
  D2 = x2 / (N1 * k0);
  var lat = phi1Rad - N1 * Math.tan(phi1Rad) / R1 * (D2 * D2 / 2 - (5 + 3 * T1 + 10 * C12 - 4 * C12 * C12 - 9 * eccPrimeSquared) * D2 * D2 * D2 * D2 / 24 + (61 + 90 * T1 + 298 * C12 + 45 * T1 * T1 - 252 * eccPrimeSquared - 3 * C12 * C12) * D2 * D2 * D2 * D2 * D2 * D2 / 720);
  lat = radToDeg(lat);
  var lon = (D2 - (1 + 2 * T1 + C12) * D2 * D2 * D2 / 6 + (5 - 2 * C12 + 28 * T1 - 3 * C12 * C12 + 8 * eccPrimeSquared + 24 * T1 * T1) * D2 * D2 * D2 * D2 * D2 / 120) / Math.cos(phi1Rad);
  lon = LongOrigin + radToDeg(lon);
  var result;
  if (utm2.accuracy) {
    var topRight = UTMtoLL({
      northing: utm2.northing + utm2.accuracy,
      easting: utm2.easting + utm2.accuracy,
      zoneLetter: utm2.zoneLetter,
      zoneNumber: utm2.zoneNumber
    });
    result = {
      top: topRight.lat,
      right: topRight.lon,
      bottom: lat,
      left: lon
    };
  } else {
    result = {
      lat,
      lon
    };
  }
  return result;
}
function getLetterDesignator(lat) {
  var LetterDesignator = "Z";
  if (84 >= lat && lat >= 72) {
    LetterDesignator = "X";
  } else if (72 > lat && lat >= 64) {
    LetterDesignator = "W";
  } else if (64 > lat && lat >= 56) {
    LetterDesignator = "V";
  } else if (56 > lat && lat >= 48) {
    LetterDesignator = "U";
  } else if (48 > lat && lat >= 40) {
    LetterDesignator = "T";
  } else if (40 > lat && lat >= 32) {
    LetterDesignator = "S";
  } else if (32 > lat && lat >= 24) {
    LetterDesignator = "R";
  } else if (24 > lat && lat >= 16) {
    LetterDesignator = "Q";
  } else if (16 > lat && lat >= 8) {
    LetterDesignator = "P";
  } else if (8 > lat && lat >= 0) {
    LetterDesignator = "N";
  } else if (0 > lat && lat >= -8) {
    LetterDesignator = "M";
  } else if (-8 > lat && lat >= -16) {
    LetterDesignator = "L";
  } else if (-16 > lat && lat >= -24) {
    LetterDesignator = "K";
  } else if (-24 > lat && lat >= -32) {
    LetterDesignator = "J";
  } else if (-32 > lat && lat >= -40) {
    LetterDesignator = "H";
  } else if (-40 > lat && lat >= -48) {
    LetterDesignator = "G";
  } else if (-48 > lat && lat >= -56) {
    LetterDesignator = "F";
  } else if (-56 > lat && lat >= -64) {
    LetterDesignator = "E";
  } else if (-64 > lat && lat >= -72) {
    LetterDesignator = "D";
  } else if (-72 > lat && lat >= -80) {
    LetterDesignator = "C";
  }
  return LetterDesignator;
}
function encode$1(utm2, accuracy) {
  var seasting = "00000" + utm2.easting, snorthing = "00000" + utm2.northing;
  return utm2.zoneNumber + utm2.zoneLetter + get100kID(utm2.easting, utm2.northing, utm2.zoneNumber) + seasting.substr(seasting.length - 5, accuracy) + snorthing.substr(snorthing.length - 5, accuracy);
}
function get100kID(easting, northing, zoneNumber) {
  var setParm = get100kSetForZone(zoneNumber);
  var setColumn = Math.floor(easting / 1e5);
  var setRow = Math.floor(northing / 1e5) % 20;
  return getLetter100kID(setColumn, setRow, setParm);
}
function get100kSetForZone(i2) {
  var setParm = i2 % NUM_100K_SETS;
  if (setParm === 0) {
    setParm = NUM_100K_SETS;
  }
  return setParm;
}
function getLetter100kID(column, row, parm) {
  var index2 = parm - 1;
  var colOrigin = SET_ORIGIN_COLUMN_LETTERS.charCodeAt(index2);
  var rowOrigin = SET_ORIGIN_ROW_LETTERS.charCodeAt(index2);
  var colInt = colOrigin + column - 1;
  var rowInt = rowOrigin + row;
  var rollover = false;
  if (colInt > Z$3) {
    colInt = colInt - Z$3 + A$2 - 1;
    rollover = true;
  }
  if (colInt === I$1 || colOrigin < I$1 && colInt > I$1 || (colInt > I$1 || colOrigin < I$1) && rollover) {
    colInt++;
  }
  if (colInt === O$2 || colOrigin < O$2 && colInt > O$2 || (colInt > O$2 || colOrigin < O$2) && rollover) {
    colInt++;
    if (colInt === I$1) {
      colInt++;
    }
  }
  if (colInt > Z$3) {
    colInt = colInt - Z$3 + A$2 - 1;
  }
  if (rowInt > V$2) {
    rowInt = rowInt - V$2 + A$2 - 1;
    rollover = true;
  } else {
    rollover = false;
  }
  if (rowInt === I$1 || rowOrigin < I$1 && rowInt > I$1 || (rowInt > I$1 || rowOrigin < I$1) && rollover) {
    rowInt++;
  }
  if (rowInt === O$2 || rowOrigin < O$2 && rowInt > O$2 || (rowInt > O$2 || rowOrigin < O$2) && rollover) {
    rowInt++;
    if (rowInt === I$1) {
      rowInt++;
    }
  }
  if (rowInt > V$2) {
    rowInt = rowInt - V$2 + A$2 - 1;
  }
  var twoLetter = String.fromCharCode(colInt) + String.fromCharCode(rowInt);
  return twoLetter;
}
function decode$2(mgrsString) {
  if (mgrsString && mgrsString.length === 0) {
    throw "MGRSPoint coverting from nothing";
  }
  var length = mgrsString.length;
  var hunK = null;
  var sb = "";
  var testChar;
  var i2 = 0;
  while (!/[A-Z]/.test(testChar = mgrsString.charAt(i2))) {
    if (i2 >= 2) {
      throw "MGRSPoint bad conversion from: " + mgrsString;
    }
    sb += testChar;
    i2++;
  }
  var zoneNumber = parseInt(sb, 10);
  if (i2 === 0 || i2 + 3 > length) {
    throw "MGRSPoint bad conversion from: " + mgrsString;
  }
  var zoneLetter = mgrsString.charAt(i2++);
  if (zoneLetter <= "A" || zoneLetter === "B" || zoneLetter === "Y" || zoneLetter >= "Z" || zoneLetter === "I" || zoneLetter === "O") {
    throw "MGRSPoint zone letter " + zoneLetter + " not handled: " + mgrsString;
  }
  hunK = mgrsString.substring(i2, i2 += 2);
  var set2 = get100kSetForZone(zoneNumber);
  var east100k = getEastingFromChar(hunK.charAt(0), set2);
  var north100k = getNorthingFromChar(hunK.charAt(1), set2);
  while (north100k < getMinNorthing(zoneLetter)) {
    north100k += 2e6;
  }
  var remainder = length - i2;
  if (remainder % 2 !== 0) {
    throw "MGRSPoint has to have an even number \nof digits after the zone letter and two 100km letters - front \nhalf for easting meters, second half for \nnorthing meters" + mgrsString;
  }
  var sep = remainder / 2;
  var sepEasting = 0;
  var sepNorthing = 0;
  var accuracyBonus, sepEastingString, sepNorthingString, easting, northing;
  if (sep > 0) {
    accuracyBonus = 1e5 / Math.pow(10, sep);
    sepEastingString = mgrsString.substring(i2, i2 + sep);
    sepEasting = parseFloat(sepEastingString) * accuracyBonus;
    sepNorthingString = mgrsString.substring(i2 + sep);
    sepNorthing = parseFloat(sepNorthingString) * accuracyBonus;
  }
  easting = sepEasting + east100k;
  northing = sepNorthing + north100k;
  return {
    easting,
    northing,
    zoneLetter,
    zoneNumber,
    accuracy: accuracyBonus
  };
}
function getEastingFromChar(e2, set2) {
  var curCol = SET_ORIGIN_COLUMN_LETTERS.charCodeAt(set2 - 1);
  var eastingValue = 1e5;
  var rewindMarker = false;
  while (curCol !== e2.charCodeAt(0)) {
    curCol++;
    if (curCol === I$1) {
      curCol++;
    }
    if (curCol === O$2) {
      curCol++;
    }
    if (curCol > Z$3) {
      if (rewindMarker) {
        throw "Bad character: " + e2;
      }
      curCol = A$2;
      rewindMarker = true;
    }
    eastingValue += 1e5;
  }
  return eastingValue;
}
function getNorthingFromChar(n2, set2) {
  if (n2 > "V") {
    throw "MGRSPoint given invalid Northing " + n2;
  }
  var curRow = SET_ORIGIN_ROW_LETTERS.charCodeAt(set2 - 1);
  var northingValue = 0;
  var rewindMarker = false;
  while (curRow !== n2.charCodeAt(0)) {
    curRow++;
    if (curRow === I$1) {
      curRow++;
    }
    if (curRow === O$2) {
      curRow++;
    }
    if (curRow > V$2) {
      if (rewindMarker) {
        throw "Bad character: " + n2;
      }
      curRow = A$2;
      rewindMarker = true;
    }
    northingValue += 1e5;
  }
  return northingValue;
}
function getMinNorthing(zoneLetter) {
  var northing;
  switch (zoneLetter) {
    case "C":
      northing = 11e5;
      break;
    case "D":
      northing = 2e6;
      break;
    case "E":
      northing = 28e5;
      break;
    case "F":
      northing = 37e5;
      break;
    case "G":
      northing = 46e5;
      break;
    case "H":
      northing = 55e5;
      break;
    case "J":
      northing = 64e5;
      break;
    case "K":
      northing = 73e5;
      break;
    case "L":
      northing = 82e5;
      break;
    case "M":
      northing = 91e5;
      break;
    case "N":
      northing = 0;
      break;
    case "P":
      northing = 8e5;
      break;
    case "Q":
      northing = 17e5;
      break;
    case "R":
      northing = 26e5;
      break;
    case "S":
      northing = 35e5;
      break;
    case "T":
      northing = 44e5;
      break;
    case "U":
      northing = 53e5;
      break;
    case "V":
      northing = 62e5;
      break;
    case "W":
      northing = 7e6;
      break;
    case "X":
      northing = 79e5;
      break;
    default:
      northing = -1;
  }
  if (northing >= 0) {
    return northing;
  } else {
    throw "Invalid zone letter: " + zoneLetter;
  }
}
function Point$2(x2, y2, z2) {
  if (!(this instanceof Point$2)) {
    return new Point$2(x2, y2, z2);
  }
  if (Array.isArray(x2)) {
    this.x = x2[0];
    this.y = x2[1];
    this.z = x2[2] || 0;
  } else if (typeof x2 === "object") {
    this.x = x2.x;
    this.y = x2.y;
    this.z = x2.z || 0;
  } else if (typeof x2 === "string" && typeof y2 === "undefined") {
    var coords = x2.split(",");
    this.x = parseFloat(coords[0], 10);
    this.y = parseFloat(coords[1], 10);
    this.z = parseFloat(coords[2], 10) || 0;
  } else {
    this.x = x2;
    this.y = y2;
    this.z = z2 || 0;
  }
  console.warn("proj4.Point will be removed in version 3, use proj4.toPoint");
}
Point$2.fromMGRS = function(mgrsStr) {
  return new Point$2(toPoint(mgrsStr));
};
Point$2.prototype.toMGRS = function(accuracy) {
  return forward$s([this.x, this.y], accuracy);
};
var C00 = 1;
var C02 = 0.25;
var C04 = 0.046875;
var C06 = 0.01953125;
var C08 = 0.01068115234375;
var C22 = 0.75;
var C44 = 0.46875;
var C46 = 0.013020833333333334;
var C48 = 0.007120768229166667;
var C66 = 0.3645833333333333;
var C68 = 0.005696614583333333;
var C88 = 0.3076171875;
function pj_enfn(es) {
  var en = [];
  en[0] = C00 - es * (C02 + es * (C04 + es * (C06 + es * C08)));
  en[1] = es * (C22 - es * (C04 + es * (C06 + es * C08)));
  var t3 = es * es;
  en[2] = t3 * (C44 - es * (C46 + es * C48));
  t3 *= es;
  en[3] = t3 * (C66 - es * C68);
  en[4] = t3 * es * C88;
  return en;
}
function pj_mlfn(phi, sphi, cphi, en) {
  cphi *= sphi;
  sphi *= sphi;
  return en[0] * phi - cphi * (en[1] + sphi * (en[2] + sphi * (en[3] + sphi * en[4])));
}
var MAX_ITER$3 = 20;
function pj_inv_mlfn(arg, es, en) {
  var k2 = 1 / (1 - es);
  var phi = arg;
  for (var i2 = MAX_ITER$3; i2; --i2) {
    var s2 = Math.sin(phi);
    var t3 = 1 - es * s2 * s2;
    t3 = (pj_mlfn(phi, s2, Math.cos(phi), en) - arg) * (t3 * Math.sqrt(t3)) * k2;
    phi -= t3;
    if (Math.abs(t3) < EPSLN) {
      return phi;
    }
  }
  return phi;
}
function init$s() {
  this.x0 = this.x0 !== void 0 ? this.x0 : 0;
  this.y0 = this.y0 !== void 0 ? this.y0 : 0;
  this.long0 = this.long0 !== void 0 ? this.long0 : 0;
  this.lat0 = this.lat0 !== void 0 ? this.lat0 : 0;
  if (this.es) {
    this.en = pj_enfn(this.es);
    this.ml0 = pj_mlfn(this.lat0, Math.sin(this.lat0), Math.cos(this.lat0), this.en);
  }
}
function forward$r(p5) {
  var lon = p5.x;
  var lat = p5.y;
  var delta_lon = adjust_lon(lon - this.long0);
  var con;
  var x2, y2;
  var sin_phi = Math.sin(lat);
  var cos_phi = Math.cos(lat);
  if (!this.es) {
    var b2 = cos_phi * Math.sin(delta_lon);
    if (Math.abs(Math.abs(b2) - 1) < EPSLN) {
      return 93;
    } else {
      x2 = 0.5 * this.a * this.k0 * Math.log((1 + b2) / (1 - b2)) + this.x0;
      y2 = cos_phi * Math.cos(delta_lon) / Math.sqrt(1 - Math.pow(b2, 2));
      b2 = Math.abs(y2);
      if (b2 >= 1) {
        if (b2 - 1 > EPSLN) {
          return 93;
        } else {
          y2 = 0;
        }
      } else {
        y2 = Math.acos(y2);
      }
      if (lat < 0) {
        y2 = -y2;
      }
      y2 = this.a * this.k0 * (y2 - this.lat0) + this.y0;
    }
  } else {
    var al = cos_phi * delta_lon;
    var als = Math.pow(al, 2);
    var c2 = this.ep2 * Math.pow(cos_phi, 2);
    var cs = Math.pow(c2, 2);
    var tq = Math.abs(cos_phi) > EPSLN ? Math.tan(lat) : 0;
    var t3 = Math.pow(tq, 2);
    var ts = Math.pow(t3, 2);
    con = 1 - this.es * Math.pow(sin_phi, 2);
    al = al / Math.sqrt(con);
    var ml = pj_mlfn(lat, sin_phi, cos_phi, this.en);
    x2 = this.a * (this.k0 * al * (1 + als / 6 * (1 - t3 + c2 + als / 20 * (5 - 18 * t3 + ts + 14 * c2 - 58 * t3 * c2 + als / 42 * (61 + 179 * ts - ts * t3 - 479 * t3))))) + this.x0;
    y2 = this.a * (this.k0 * (ml - this.ml0 + sin_phi * delta_lon * al / 2 * (1 + als / 12 * (5 - t3 + 9 * c2 + 4 * cs + als / 30 * (61 + ts - 58 * t3 + 270 * c2 - 330 * t3 * c2 + als / 56 * (1385 + 543 * ts - ts * t3 - 3111 * t3)))))) + this.y0;
  }
  p5.x = x2;
  p5.y = y2;
  return p5;
}
function inverse$r(p5) {
  var con, phi;
  var lat, lon;
  var x2 = (p5.x - this.x0) * (1 / this.a);
  var y2 = (p5.y - this.y0) * (1 / this.a);
  if (!this.es) {
    var f2 = Math.exp(x2 / this.k0);
    var g2 = 0.5 * (f2 - 1 / f2);
    var temp = this.lat0 + y2 / this.k0;
    var h2 = Math.cos(temp);
    con = Math.sqrt((1 - Math.pow(h2, 2)) / (1 + Math.pow(g2, 2)));
    lat = Math.asin(con);
    if (y2 < 0) {
      lat = -lat;
    }
    if (g2 === 0 && h2 === 0) {
      lon = 0;
    } else {
      lon = adjust_lon(Math.atan2(g2, h2) + this.long0);
    }
  } else {
    con = this.ml0 + y2 / this.k0;
    phi = pj_inv_mlfn(con, this.es, this.en);
    if (Math.abs(phi) < HALF_PI) {
      var sin_phi = Math.sin(phi);
      var cos_phi = Math.cos(phi);
      var tan_phi = Math.abs(cos_phi) > EPSLN ? Math.tan(phi) : 0;
      var c2 = this.ep2 * Math.pow(cos_phi, 2);
      var cs = Math.pow(c2, 2);
      var t3 = Math.pow(tan_phi, 2);
      var ts = Math.pow(t3, 2);
      con = 1 - this.es * Math.pow(sin_phi, 2);
      var d2 = x2 * Math.sqrt(con) / this.k0;
      var ds = Math.pow(d2, 2);
      con = con * tan_phi;
      lat = phi - con * ds / (1 - this.es) * 0.5 * (1 - ds / 12 * (5 + 3 * t3 - 9 * c2 * t3 + c2 - 4 * cs - ds / 30 * (61 + 90 * t3 - 252 * c2 * t3 + 45 * ts + 46 * c2 - ds / 56 * (1385 + 3633 * t3 + 4095 * ts + 1574 * ts * t3))));
      lon = adjust_lon(this.long0 + d2 * (1 - ds / 6 * (1 + 2 * t3 + c2 - ds / 20 * (5 + 28 * t3 + 24 * ts + 8 * c2 * t3 + 6 * c2 - ds / 42 * (61 + 662 * t3 + 1320 * ts + 720 * ts * t3)))) / cos_phi);
    } else {
      lat = HALF_PI * sign(y2);
      lon = 0;
    }
  }
  p5.x = lon;
  p5.y = lat;
  return p5;
}
var names$s = ["Fast_Transverse_Mercator", "Fast Transverse Mercator"];
var tmerc = {
  init: init$s,
  forward: forward$r,
  inverse: inverse$r,
  names: names$s
};
function sinh(x2) {
  var r2 = Math.exp(x2);
  r2 = (r2 - 1 / r2) / 2;
  return r2;
}
function hypot(x2, y2) {
  x2 = Math.abs(x2);
  y2 = Math.abs(y2);
  var a2 = Math.max(x2, y2);
  var b2 = Math.min(x2, y2) / (a2 ? a2 : 1);
  return a2 * Math.sqrt(1 + Math.pow(b2, 2));
}
function log1py(x2) {
  var y2 = 1 + x2;
  var z2 = y2 - 1;
  return z2 === 0 ? x2 : x2 * Math.log(y2) / z2;
}
function asinhy(x2) {
  var y2 = Math.abs(x2);
  y2 = log1py(y2 * (1 + y2 / (hypot(1, y2) + 1)));
  return x2 < 0 ? -y2 : y2;
}
function gatg(pp, B3) {
  var cos_2B = 2 * Math.cos(2 * B3);
  var i2 = pp.length - 1;
  var h1 = pp[i2];
  var h2 = 0;
  var h3;
  while (--i2 >= 0) {
    h3 = -h2 + cos_2B * h1 + pp[i2];
    h2 = h1;
    h1 = h3;
  }
  return B3 + h3 * Math.sin(2 * B3);
}
function clens(pp, arg_r) {
  var r2 = 2 * Math.cos(arg_r);
  var i2 = pp.length - 1;
  var hr1 = pp[i2];
  var hr2 = 0;
  var hr;
  while (--i2 >= 0) {
    hr = -hr2 + r2 * hr1 + pp[i2];
    hr2 = hr1;
    hr1 = hr;
  }
  return Math.sin(arg_r) * hr;
}
function cosh(x2) {
  var r2 = Math.exp(x2);
  r2 = (r2 + 1 / r2) / 2;
  return r2;
}
function clens_cmplx(pp, arg_r, arg_i) {
  var sin_arg_r = Math.sin(arg_r);
  var cos_arg_r = Math.cos(arg_r);
  var sinh_arg_i = sinh(arg_i);
  var cosh_arg_i = cosh(arg_i);
  var r2 = 2 * cos_arg_r * cosh_arg_i;
  var i2 = -2 * sin_arg_r * sinh_arg_i;
  var j2 = pp.length - 1;
  var hr = pp[j2];
  var hi1 = 0;
  var hr1 = 0;
  var hi = 0;
  var hr2;
  var hi2;
  while (--j2 >= 0) {
    hr2 = hr1;
    hi2 = hi1;
    hr1 = hr;
    hi1 = hi;
    hr = -hr2 + r2 * hr1 - i2 * hi1 + pp[j2];
    hi = -hi2 + i2 * hr1 + r2 * hi1;
  }
  r2 = sin_arg_r * cosh_arg_i;
  i2 = cos_arg_r * sinh_arg_i;
  return [r2 * hr - i2 * hi, r2 * hi + i2 * hr];
}
function init$r() {
  if (!this.approx && (isNaN(this.es) || this.es <= 0)) {
    throw new Error('Incorrect elliptical usage. Try using the +approx option in the proj string, or PROJECTION["Fast_Transverse_Mercator"] in the WKT.');
  }
  if (this.approx) {
    tmerc.init.apply(this);
    this.forward = tmerc.forward;
    this.inverse = tmerc.inverse;
  }
  this.x0 = this.x0 !== void 0 ? this.x0 : 0;
  this.y0 = this.y0 !== void 0 ? this.y0 : 0;
  this.long0 = this.long0 !== void 0 ? this.long0 : 0;
  this.lat0 = this.lat0 !== void 0 ? this.lat0 : 0;
  this.cgb = [];
  this.cbg = [];
  this.utg = [];
  this.gtu = [];
  var f2 = this.es / (1 + Math.sqrt(1 - this.es));
  var n2 = f2 / (2 - f2);
  var np = n2;
  this.cgb[0] = n2 * (2 + n2 * (-2 / 3 + n2 * (-2 + n2 * (116 / 45 + n2 * (26 / 45 + n2 * (-2854 / 675))))));
  this.cbg[0] = n2 * (-2 + n2 * (2 / 3 + n2 * (4 / 3 + n2 * (-82 / 45 + n2 * (32 / 45 + n2 * (4642 / 4725))))));
  np = np * n2;
  this.cgb[1] = np * (7 / 3 + n2 * (-8 / 5 + n2 * (-227 / 45 + n2 * (2704 / 315 + n2 * (2323 / 945)))));
  this.cbg[1] = np * (5 / 3 + n2 * (-16 / 15 + n2 * (-13 / 9 + n2 * (904 / 315 + n2 * (-1522 / 945)))));
  np = np * n2;
  this.cgb[2] = np * (56 / 15 + n2 * (-136 / 35 + n2 * (-1262 / 105 + n2 * (73814 / 2835))));
  this.cbg[2] = np * (-26 / 15 + n2 * (34 / 21 + n2 * (8 / 5 + n2 * (-12686 / 2835))));
  np = np * n2;
  this.cgb[3] = np * (4279 / 630 + n2 * (-332 / 35 + n2 * (-399572 / 14175)));
  this.cbg[3] = np * (1237 / 630 + n2 * (-12 / 5 + n2 * (-24832 / 14175)));
  np = np * n2;
  this.cgb[4] = np * (4174 / 315 + n2 * (-144838 / 6237));
  this.cbg[4] = np * (-734 / 315 + n2 * (109598 / 31185));
  np = np * n2;
  this.cgb[5] = np * (601676 / 22275);
  this.cbg[5] = np * (444337 / 155925);
  np = Math.pow(n2, 2);
  this.Qn = this.k0 / (1 + n2) * (1 + np * (1 / 4 + np * (1 / 64 + np / 256)));
  this.utg[0] = n2 * (-0.5 + n2 * (2 / 3 + n2 * (-37 / 96 + n2 * (1 / 360 + n2 * (81 / 512 + n2 * (-96199 / 604800))))));
  this.gtu[0] = n2 * (0.5 + n2 * (-2 / 3 + n2 * (5 / 16 + n2 * (41 / 180 + n2 * (-127 / 288 + n2 * (7891 / 37800))))));
  this.utg[1] = np * (-1 / 48 + n2 * (-1 / 15 + n2 * (437 / 1440 + n2 * (-46 / 105 + n2 * (1118711 / 3870720)))));
  this.gtu[1] = np * (13 / 48 + n2 * (-3 / 5 + n2 * (557 / 1440 + n2 * (281 / 630 + n2 * (-1983433 / 1935360)))));
  np = np * n2;
  this.utg[2] = np * (-17 / 480 + n2 * (37 / 840 + n2 * (209 / 4480 + n2 * (-5569 / 90720))));
  this.gtu[2] = np * (61 / 240 + n2 * (-103 / 140 + n2 * (15061 / 26880 + n2 * (167603 / 181440))));
  np = np * n2;
  this.utg[3] = np * (-4397 / 161280 + n2 * (11 / 504 + n2 * (830251 / 7257600)));
  this.gtu[3] = np * (49561 / 161280 + n2 * (-179 / 168 + n2 * (6601661 / 7257600)));
  np = np * n2;
  this.utg[4] = np * (-4583 / 161280 + n2 * (108847 / 3991680));
  this.gtu[4] = np * (34729 / 80640 + n2 * (-3418889 / 1995840));
  np = np * n2;
  this.utg[5] = np * (-20648693 / 638668800);
  this.gtu[5] = np * (212378941 / 319334400);
  var Z2 = gatg(this.cbg, this.lat0);
  this.Zb = -this.Qn * (Z2 + clens(this.gtu, 2 * Z2));
}
function forward$q(p5) {
  var Ce = adjust_lon(p5.x - this.long0);
  var Cn = p5.y;
  Cn = gatg(this.cbg, Cn);
  var sin_Cn = Math.sin(Cn);
  var cos_Cn = Math.cos(Cn);
  var sin_Ce = Math.sin(Ce);
  var cos_Ce = Math.cos(Ce);
  Cn = Math.atan2(sin_Cn, cos_Ce * cos_Cn);
  Ce = Math.atan2(sin_Ce * cos_Cn, hypot(sin_Cn, cos_Cn * cos_Ce));
  Ce = asinhy(Math.tan(Ce));
  var tmp = clens_cmplx(this.gtu, 2 * Cn, 2 * Ce);
  Cn = Cn + tmp[0];
  Ce = Ce + tmp[1];
  var x2;
  var y2;
  if (Math.abs(Ce) <= 2.623395162778) {
    x2 = this.a * (this.Qn * Ce) + this.x0;
    y2 = this.a * (this.Qn * Cn + this.Zb) + this.y0;
  } else {
    x2 = Infinity;
    y2 = Infinity;
  }
  p5.x = x2;
  p5.y = y2;
  return p5;
}
function inverse$q(p5) {
  var Ce = (p5.x - this.x0) * (1 / this.a);
  var Cn = (p5.y - this.y0) * (1 / this.a);
  Cn = (Cn - this.Zb) / this.Qn;
  Ce = Ce / this.Qn;
  var lon;
  var lat;
  if (Math.abs(Ce) <= 2.623395162778) {
    var tmp = clens_cmplx(this.utg, 2 * Cn, 2 * Ce);
    Cn = Cn + tmp[0];
    Ce = Ce + tmp[1];
    Ce = Math.atan(sinh(Ce));
    var sin_Cn = Math.sin(Cn);
    var cos_Cn = Math.cos(Cn);
    var sin_Ce = Math.sin(Ce);
    var cos_Ce = Math.cos(Ce);
    Cn = Math.atan2(sin_Cn * cos_Ce, hypot(sin_Ce, cos_Ce * cos_Cn));
    Ce = Math.atan2(sin_Ce, cos_Ce * cos_Cn);
    lon = adjust_lon(Ce + this.long0);
    lat = gatg(this.cgb, Cn);
  } else {
    lon = Infinity;
    lat = Infinity;
  }
  p5.x = lon;
  p5.y = lat;
  return p5;
}
var names$r = ["Extended_Transverse_Mercator", "Extended Transverse Mercator", "etmerc", "Transverse_Mercator", "Transverse Mercator", "tmerc"];
var etmerc = {
  init: init$r,
  forward: forward$q,
  inverse: inverse$q,
  names: names$r
};
function adjust_zone(zone, lon) {
  if (zone === void 0) {
    zone = Math.floor((adjust_lon(lon) + Math.PI) * 30 / Math.PI) + 1;
    if (zone < 0) {
      return 0;
    } else if (zone > 60) {
      return 60;
    }
  }
  return zone;
}
var dependsOn = "etmerc";
function init$q() {
  var zone = adjust_zone(this.zone, this.long0);
  if (zone === void 0) {
    throw new Error("unknown utm zone");
  }
  this.lat0 = 0;
  this.long0 = (6 * Math.abs(zone) - 183) * D2R$1;
  this.x0 = 5e5;
  this.y0 = this.utmSouth ? 1e7 : 0;
  this.k0 = 0.9996;
  etmerc.init.apply(this);
  this.forward = etmerc.forward;
  this.inverse = etmerc.inverse;
}
var names$q = ["Universal Transverse Mercator System", "utm"];
var utm = {
  init: init$q,
  names: names$q,
  dependsOn
};
function srat(esinp, exp) {
  return Math.pow((1 - esinp) / (1 + esinp), exp);
}
var MAX_ITER$2 = 20;
function init$p() {
  var sphi = Math.sin(this.lat0);
  var cphi = Math.cos(this.lat0);
  cphi *= cphi;
  this.rc = Math.sqrt(1 - this.es) / (1 - this.es * sphi * sphi);
  this.C = Math.sqrt(1 + this.es * cphi * cphi / (1 - this.es));
  this.phic0 = Math.asin(sphi / this.C);
  this.ratexp = 0.5 * this.C * this.e;
  this.K = Math.tan(0.5 * this.phic0 + FORTPI) / (Math.pow(Math.tan(0.5 * this.lat0 + FORTPI), this.C) * srat(this.e * sphi, this.ratexp));
}
function forward$p(p5) {
  var lon = p5.x;
  var lat = p5.y;
  p5.y = 2 * Math.atan(this.K * Math.pow(Math.tan(0.5 * lat + FORTPI), this.C) * srat(this.e * Math.sin(lat), this.ratexp)) - HALF_PI;
  p5.x = this.C * lon;
  return p5;
}
function inverse$p(p5) {
  var DEL_TOL = 1e-14;
  var lon = p5.x / this.C;
  var lat = p5.y;
  var num = Math.pow(Math.tan(0.5 * lat + FORTPI) / this.K, 1 / this.C);
  for (var i2 = MAX_ITER$2; i2 > 0; --i2) {
    lat = 2 * Math.atan(num * srat(this.e * Math.sin(p5.y), -0.5 * this.e)) - HALF_PI;
    if (Math.abs(lat - p5.y) < DEL_TOL) {
      break;
    }
    p5.y = lat;
  }
  if (!i2) {
    return null;
  }
  p5.x = lon;
  p5.y = lat;
  return p5;
}
var names$p = ["gauss"];
var gauss = {
  init: init$p,
  forward: forward$p,
  inverse: inverse$p,
  names: names$p
};
function init$o() {
  gauss.init.apply(this);
  if (!this.rc) {
    return;
  }
  this.sinc0 = Math.sin(this.phic0);
  this.cosc0 = Math.cos(this.phic0);
  this.R2 = 2 * this.rc;
  if (!this.title) {
    this.title = "Oblique Stereographic Alternative";
  }
}
function forward$o(p5) {
  var sinc, cosc, cosl, k2;
  p5.x = adjust_lon(p5.x - this.long0);
  gauss.forward.apply(this, [p5]);
  sinc = Math.sin(p5.y);
  cosc = Math.cos(p5.y);
  cosl = Math.cos(p5.x);
  k2 = this.k0 * this.R2 / (1 + this.sinc0 * sinc + this.cosc0 * cosc * cosl);
  p5.x = k2 * cosc * Math.sin(p5.x);
  p5.y = k2 * (this.cosc0 * sinc - this.sinc0 * cosc * cosl);
  p5.x = this.a * p5.x + this.x0;
  p5.y = this.a * p5.y + this.y0;
  return p5;
}
function inverse$o(p5) {
  var sinc, cosc, lon, lat, rho;
  p5.x = (p5.x - this.x0) / this.a;
  p5.y = (p5.y - this.y0) / this.a;
  p5.x /= this.k0;
  p5.y /= this.k0;
  if (rho = Math.sqrt(p5.x * p5.x + p5.y * p5.y)) {
    var c2 = 2 * Math.atan2(rho, this.R2);
    sinc = Math.sin(c2);
    cosc = Math.cos(c2);
    lat = Math.asin(cosc * this.sinc0 + p5.y * sinc * this.cosc0 / rho);
    lon = Math.atan2(p5.x * sinc, rho * this.cosc0 * cosc - p5.y * this.sinc0 * sinc);
  } else {
    lat = this.phic0;
    lon = 0;
  }
  p5.x = lon;
  p5.y = lat;
  gauss.inverse.apply(this, [p5]);
  p5.x = adjust_lon(p5.x + this.long0);
  return p5;
}
var names$o = ["Stereographic_North_Pole", "Oblique_Stereographic", "Polar_Stereographic", "sterea", "Oblique Stereographic Alternative", "Double_Stereographic"];
var sterea = {
  init: init$o,
  forward: forward$o,
  inverse: inverse$o,
  names: names$o
};
function ssfn_(phit, sinphi, eccen) {
  sinphi *= eccen;
  return Math.tan(0.5 * (HALF_PI + phit)) * Math.pow((1 - sinphi) / (1 + sinphi), 0.5 * eccen);
}
function init$n() {
  this.coslat0 = Math.cos(this.lat0);
  this.sinlat0 = Math.sin(this.lat0);
  if (this.sphere) {
    if (this.k0 === 1 && !isNaN(this.lat_ts) && Math.abs(this.coslat0) <= EPSLN) {
      this.k0 = 0.5 * (1 + sign(this.lat0) * Math.sin(this.lat_ts));
    }
  } else {
    if (Math.abs(this.coslat0) <= EPSLN) {
      if (this.lat0 > 0) {
        this.con = 1;
      } else {
        this.con = -1;
      }
    }
    this.cons = Math.sqrt(Math.pow(1 + this.e, 1 + this.e) * Math.pow(1 - this.e, 1 - this.e));
    if (this.k0 === 1 && !isNaN(this.lat_ts) && Math.abs(this.coslat0) <= EPSLN) {
      this.k0 = 0.5 * this.cons * msfnz(this.e, Math.sin(this.lat_ts), Math.cos(this.lat_ts)) / tsfnz(this.e, this.con * this.lat_ts, this.con * Math.sin(this.lat_ts));
    }
    this.ms1 = msfnz(this.e, this.sinlat0, this.coslat0);
    this.X0 = 2 * Math.atan(this.ssfn_(this.lat0, this.sinlat0, this.e)) - HALF_PI;
    this.cosX0 = Math.cos(this.X0);
    this.sinX0 = Math.sin(this.X0);
  }
}
function forward$n(p5) {
  var lon = p5.x;
  var lat = p5.y;
  var sinlat = Math.sin(lat);
  var coslat = Math.cos(lat);
  var A2, X2, sinX, cosX, ts, rh;
  var dlon = adjust_lon(lon - this.long0);
  if (Math.abs(Math.abs(lon - this.long0) - Math.PI) <= EPSLN && Math.abs(lat + this.lat0) <= EPSLN) {
    p5.x = NaN;
    p5.y = NaN;
    return p5;
  }
  if (this.sphere) {
    A2 = 2 * this.k0 / (1 + this.sinlat0 * sinlat + this.coslat0 * coslat * Math.cos(dlon));
    p5.x = this.a * A2 * coslat * Math.sin(dlon) + this.x0;
    p5.y = this.a * A2 * (this.coslat0 * sinlat - this.sinlat0 * coslat * Math.cos(dlon)) + this.y0;
    return p5;
  } else {
    X2 = 2 * Math.atan(this.ssfn_(lat, sinlat, this.e)) - HALF_PI;
    cosX = Math.cos(X2);
    sinX = Math.sin(X2);
    if (Math.abs(this.coslat0) <= EPSLN) {
      ts = tsfnz(this.e, lat * this.con, this.con * sinlat);
      rh = 2 * this.a * this.k0 * ts / this.cons;
      p5.x = this.x0 + rh * Math.sin(lon - this.long0);
      p5.y = this.y0 - this.con * rh * Math.cos(lon - this.long0);
      return p5;
    } else if (Math.abs(this.sinlat0) < EPSLN) {
      A2 = 2 * this.a * this.k0 / (1 + cosX * Math.cos(dlon));
      p5.y = A2 * sinX;
    } else {
      A2 = 2 * this.a * this.k0 * this.ms1 / (this.cosX0 * (1 + this.sinX0 * sinX + this.cosX0 * cosX * Math.cos(dlon)));
      p5.y = A2 * (this.cosX0 * sinX - this.sinX0 * cosX * Math.cos(dlon)) + this.y0;
    }
    p5.x = A2 * cosX * Math.sin(dlon) + this.x0;
  }
  return p5;
}
function inverse$n(p5) {
  p5.x -= this.x0;
  p5.y -= this.y0;
  var lon, lat, ts, ce2, Chi;
  var rh = Math.sqrt(p5.x * p5.x + p5.y * p5.y);
  if (this.sphere) {
    var c2 = 2 * Math.atan(rh / (2 * this.a * this.k0));
    lon = this.long0;
    lat = this.lat0;
    if (rh <= EPSLN) {
      p5.x = lon;
      p5.y = lat;
      return p5;
    }
    lat = Math.asin(Math.cos(c2) * this.sinlat0 + p5.y * Math.sin(c2) * this.coslat0 / rh);
    if (Math.abs(this.coslat0) < EPSLN) {
      if (this.lat0 > 0) {
        lon = adjust_lon(this.long0 + Math.atan2(p5.x, -1 * p5.y));
      } else {
        lon = adjust_lon(this.long0 + Math.atan2(p5.x, p5.y));
      }
    } else {
      lon = adjust_lon(this.long0 + Math.atan2(p5.x * Math.sin(c2), rh * this.coslat0 * Math.cos(c2) - p5.y * this.sinlat0 * Math.sin(c2)));
    }
    p5.x = lon;
    p5.y = lat;
    return p5;
  } else {
    if (Math.abs(this.coslat0) <= EPSLN) {
      if (rh <= EPSLN) {
        lat = this.lat0;
        lon = this.long0;
        p5.x = lon;
        p5.y = lat;
        return p5;
      }
      p5.x *= this.con;
      p5.y *= this.con;
      ts = rh * this.cons / (2 * this.a * this.k0);
      lat = this.con * phi2z(this.e, ts);
      lon = this.con * adjust_lon(this.con * this.long0 + Math.atan2(p5.x, -1 * p5.y));
    } else {
      ce2 = 2 * Math.atan(rh * this.cosX0 / (2 * this.a * this.k0 * this.ms1));
      lon = this.long0;
      if (rh <= EPSLN) {
        Chi = this.X0;
      } else {
        Chi = Math.asin(Math.cos(ce2) * this.sinX0 + p5.y * Math.sin(ce2) * this.cosX0 / rh);
        lon = adjust_lon(this.long0 + Math.atan2(p5.x * Math.sin(ce2), rh * this.cosX0 * Math.cos(ce2) - p5.y * this.sinX0 * Math.sin(ce2)));
      }
      lat = -1 * phi2z(this.e, Math.tan(0.5 * (HALF_PI + Chi)));
    }
  }
  p5.x = lon;
  p5.y = lat;
  return p5;
}
var names$n = ["stere", "Stereographic_South_Pole", "Polar Stereographic (variant B)"];
var stere = {
  init: init$n,
  forward: forward$n,
  inverse: inverse$n,
  names: names$n,
  ssfn_
};
function init$m() {
  var phy0 = this.lat0;
  this.lambda0 = this.long0;
  var sinPhy0 = Math.sin(phy0);
  var semiMajorAxis = this.a;
  var invF = this.rf;
  var flattening = 1 / invF;
  var e2 = 2 * flattening - Math.pow(flattening, 2);
  var e3 = this.e = Math.sqrt(e2);
  this.R = this.k0 * semiMajorAxis * Math.sqrt(1 - e2) / (1 - e2 * Math.pow(sinPhy0, 2));
  this.alpha = Math.sqrt(1 + e2 / (1 - e2) * Math.pow(Math.cos(phy0), 4));
  this.b0 = Math.asin(sinPhy0 / this.alpha);
  var k1 = Math.log(Math.tan(Math.PI / 4 + this.b0 / 2));
  var k2 = Math.log(Math.tan(Math.PI / 4 + phy0 / 2));
  var k3 = Math.log((1 + e3 * sinPhy0) / (1 - e3 * sinPhy0));
  this.K = k1 - this.alpha * k2 + this.alpha * e3 / 2 * k3;
}
function forward$m(p5) {
  var Sa1 = Math.log(Math.tan(Math.PI / 4 - p5.y / 2));
  var Sa2 = this.e / 2 * Math.log((1 + this.e * Math.sin(p5.y)) / (1 - this.e * Math.sin(p5.y)));
  var S2 = -this.alpha * (Sa1 + Sa2) + this.K;
  var b2 = 2 * (Math.atan(Math.exp(S2)) - Math.PI / 4);
  var I2 = this.alpha * (p5.x - this.lambda0);
  var rotI = Math.atan(Math.sin(I2) / (Math.sin(this.b0) * Math.tan(b2) + Math.cos(this.b0) * Math.cos(I2)));
  var rotB = Math.asin(Math.cos(this.b0) * Math.sin(b2) - Math.sin(this.b0) * Math.cos(b2) * Math.cos(I2));
  p5.y = this.R / 2 * Math.log((1 + Math.sin(rotB)) / (1 - Math.sin(rotB))) + this.y0;
  p5.x = this.R * rotI + this.x0;
  return p5;
}
function inverse$m(p5) {
  var Y2 = p5.x - this.x0;
  var X2 = p5.y - this.y0;
  var rotI = Y2 / this.R;
  var rotB = 2 * (Math.atan(Math.exp(X2 / this.R)) - Math.PI / 4);
  var b2 = Math.asin(Math.cos(this.b0) * Math.sin(rotB) + Math.sin(this.b0) * Math.cos(rotB) * Math.cos(rotI));
  var I2 = Math.atan(Math.sin(rotI) / (Math.cos(this.b0) * Math.cos(rotI) - Math.sin(this.b0) * Math.tan(rotB)));
  var lambda = this.lambda0 + I2 / this.alpha;
  var S2 = 0;
  var phy = b2;
  var prevPhy = -1e3;
  var iteration = 0;
  while (Math.abs(phy - prevPhy) > 1e-7) {
    if (++iteration > 20) {
      return;
    }
    S2 = 1 / this.alpha * (Math.log(Math.tan(Math.PI / 4 + b2 / 2)) - this.K) + this.e * Math.log(Math.tan(Math.PI / 4 + Math.asin(this.e * Math.sin(phy)) / 2));
    prevPhy = phy;
    phy = 2 * Math.atan(Math.exp(S2)) - Math.PI / 2;
  }
  p5.x = lambda;
  p5.y = phy;
  return p5;
}
var names$m = ["somerc"];
var somerc = {
  init: init$m,
  forward: forward$m,
  inverse: inverse$m,
  names: names$m
};
var TOL = 1e-7;
function isTypeA(P2) {
  var typeAProjections = ["Hotine_Oblique_Mercator", "Hotine_Oblique_Mercator_Azimuth_Natural_Origin"];
  var projectionName = typeof P2.PROJECTION === "object" ? Object.keys(P2.PROJECTION)[0] : P2.PROJECTION;
  return "no_uoff" in P2 || "no_off" in P2 || typeAProjections.indexOf(projectionName) !== -1;
}
function init$l() {
  var con, com, cosph0, D2, F2, H4, L2, sinph0, p5, J2, gamma = 0, gamma0, lamc = 0, lam1 = 0, lam2 = 0, phi1 = 0, phi2 = 0, alpha_c = 0;
  this.no_off = isTypeA(this);
  this.no_rot = "no_rot" in this;
  var alp = false;
  if ("alpha" in this) {
    alp = true;
  }
  var gam = false;
  if ("rectified_grid_angle" in this) {
    gam = true;
  }
  if (alp) {
    alpha_c = this.alpha;
  }
  if (gam) {
    gamma = this.rectified_grid_angle * D2R$1;
  }
  if (alp || gam) {
    lamc = this.longc;
  } else {
    lam1 = this.long1;
    phi1 = this.lat1;
    lam2 = this.long2;
    phi2 = this.lat2;
    if (Math.abs(phi1 - phi2) <= TOL || (con = Math.abs(phi1)) <= TOL || Math.abs(con - HALF_PI) <= TOL || Math.abs(Math.abs(this.lat0) - HALF_PI) <= TOL || Math.abs(Math.abs(phi2) - HALF_PI) <= TOL) {
      throw new Error();
    }
  }
  var one_es = 1 - this.es;
  com = Math.sqrt(one_es);
  if (Math.abs(this.lat0) > EPSLN) {
    sinph0 = Math.sin(this.lat0);
    cosph0 = Math.cos(this.lat0);
    con = 1 - this.es * sinph0 * sinph0;
    this.B = cosph0 * cosph0;
    this.B = Math.sqrt(1 + this.es * this.B * this.B / one_es);
    this.A = this.B * this.k0 * com / con;
    D2 = this.B * com / (cosph0 * Math.sqrt(con));
    F2 = D2 * D2 - 1;
    if (F2 <= 0) {
      F2 = 0;
    } else {
      F2 = Math.sqrt(F2);
      if (this.lat0 < 0) {
        F2 = -F2;
      }
    }
    this.E = F2 += D2;
    this.E *= Math.pow(tsfnz(this.e, this.lat0, sinph0), this.B);
  } else {
    this.B = 1 / com;
    this.A = this.k0;
    this.E = D2 = F2 = 1;
  }
  if (alp || gam) {
    if (alp) {
      gamma0 = Math.asin(Math.sin(alpha_c) / D2);
      if (!gam) {
        gamma = alpha_c;
      }
    } else {
      gamma0 = gamma;
      alpha_c = Math.asin(D2 * Math.sin(gamma0));
    }
    this.lam0 = lamc - Math.asin(0.5 * (F2 - 1 / F2) * Math.tan(gamma0)) / this.B;
  } else {
    H4 = Math.pow(tsfnz(this.e, phi1, Math.sin(phi1)), this.B);
    L2 = Math.pow(tsfnz(this.e, phi2, Math.sin(phi2)), this.B);
    F2 = this.E / H4;
    p5 = (L2 - H4) / (L2 + H4);
    J2 = this.E * this.E;
    J2 = (J2 - L2 * H4) / (J2 + L2 * H4);
    con = lam1 - lam2;
    if (con < -Math.pi) {
      lam2 -= TWO_PI;
    } else if (con > Math.pi) {
      lam2 += TWO_PI;
    }
    this.lam0 = adjust_lon(0.5 * (lam1 + lam2) - Math.atan(J2 * Math.tan(0.5 * this.B * (lam1 - lam2)) / p5) / this.B);
    gamma0 = Math.atan(2 * Math.sin(this.B * adjust_lon(lam1 - this.lam0)) / (F2 - 1 / F2));
    gamma = alpha_c = Math.asin(D2 * Math.sin(gamma0));
  }
  this.singam = Math.sin(gamma0);
  this.cosgam = Math.cos(gamma0);
  this.sinrot = Math.sin(gamma);
  this.cosrot = Math.cos(gamma);
  this.rB = 1 / this.B;
  this.ArB = this.A * this.rB;
  this.BrA = 1 / this.ArB;
  this.A * this.B;
  if (this.no_off) {
    this.u_0 = 0;
  } else {
    this.u_0 = Math.abs(this.ArB * Math.atan(Math.sqrt(D2 * D2 - 1) / Math.cos(alpha_c)));
    if (this.lat0 < 0) {
      this.u_0 = -this.u_0;
    }
  }
  F2 = 0.5 * gamma0;
  this.v_pole_n = this.ArB * Math.log(Math.tan(FORTPI - F2));
  this.v_pole_s = this.ArB * Math.log(Math.tan(FORTPI + F2));
}
function forward$l(p5) {
  var coords = {};
  var S2, T2, U2, V2, W2, temp, u2, v2;
  p5.x = p5.x - this.lam0;
  if (Math.abs(Math.abs(p5.y) - HALF_PI) > EPSLN) {
    W2 = this.E / Math.pow(tsfnz(this.e, p5.y, Math.sin(p5.y)), this.B);
    temp = 1 / W2;
    S2 = 0.5 * (W2 - temp);
    T2 = 0.5 * (W2 + temp);
    V2 = Math.sin(this.B * p5.x);
    U2 = (S2 * this.singam - V2 * this.cosgam) / T2;
    if (Math.abs(Math.abs(U2) - 1) < EPSLN) {
      throw new Error();
    }
    v2 = 0.5 * this.ArB * Math.log((1 - U2) / (1 + U2));
    temp = Math.cos(this.B * p5.x);
    if (Math.abs(temp) < TOL) {
      u2 = this.A * p5.x;
    } else {
      u2 = this.ArB * Math.atan2(S2 * this.cosgam + V2 * this.singam, temp);
    }
  } else {
    v2 = p5.y > 0 ? this.v_pole_n : this.v_pole_s;
    u2 = this.ArB * p5.y;
  }
  if (this.no_rot) {
    coords.x = u2;
    coords.y = v2;
  } else {
    u2 -= this.u_0;
    coords.x = v2 * this.cosrot + u2 * this.sinrot;
    coords.y = u2 * this.cosrot - v2 * this.sinrot;
  }
  coords.x = this.a * coords.x + this.x0;
  coords.y = this.a * coords.y + this.y0;
  return coords;
}
function inverse$l(p5) {
  var u2, v2, Qp, Sp, Tp, Vp, Up;
  var coords = {};
  p5.x = (p5.x - this.x0) * (1 / this.a);
  p5.y = (p5.y - this.y0) * (1 / this.a);
  if (this.no_rot) {
    v2 = p5.y;
    u2 = p5.x;
  } else {
    v2 = p5.x * this.cosrot - p5.y * this.sinrot;
    u2 = p5.y * this.cosrot + p5.x * this.sinrot + this.u_0;
  }
  Qp = Math.exp(-this.BrA * v2);
  Sp = 0.5 * (Qp - 1 / Qp);
  Tp = 0.5 * (Qp + 1 / Qp);
  Vp = Math.sin(this.BrA * u2);
  Up = (Vp * this.cosgam + Sp * this.singam) / Tp;
  if (Math.abs(Math.abs(Up) - 1) < EPSLN) {
    coords.x = 0;
    coords.y = Up < 0 ? -HALF_PI : HALF_PI;
  } else {
    coords.y = this.E / Math.sqrt((1 + Up) / (1 - Up));
    coords.y = phi2z(this.e, Math.pow(coords.y, 1 / this.B));
    if (coords.y === Infinity) {
      throw new Error();
    }
    coords.x = -this.rB * Math.atan2(Sp * this.cosgam - Vp * this.singam, Math.cos(this.BrA * u2));
  }
  coords.x += this.lam0;
  return coords;
}
var names$l = ["Hotine_Oblique_Mercator", "Hotine Oblique Mercator", "Hotine_Oblique_Mercator_Azimuth_Natural_Origin", "Hotine_Oblique_Mercator_Two_Point_Natural_Origin", "Hotine_Oblique_Mercator_Azimuth_Center", "Oblique_Mercator", "omerc"];
var omerc = {
  init: init$l,
  forward: forward$l,
  inverse: inverse$l,
  names: names$l
};
function init$k() {
  if (!this.lat2) {
    this.lat2 = this.lat1;
  }
  if (!this.k0) {
    this.k0 = 1;
  }
  this.x0 = this.x0 || 0;
  this.y0 = this.y0 || 0;
  if (Math.abs(this.lat1 + this.lat2) < EPSLN) {
    return;
  }
  var temp = this.b / this.a;
  this.e = Math.sqrt(1 - temp * temp);
  var sin1 = Math.sin(this.lat1);
  var cos1 = Math.cos(this.lat1);
  var ms1 = msfnz(this.e, sin1, cos1);
  var ts1 = tsfnz(this.e, this.lat1, sin1);
  var sin2 = Math.sin(this.lat2);
  var cos2 = Math.cos(this.lat2);
  var ms2 = msfnz(this.e, sin2, cos2);
  var ts2 = tsfnz(this.e, this.lat2, sin2);
  var ts0 = tsfnz(this.e, this.lat0, Math.sin(this.lat0));
  if (Math.abs(this.lat1 - this.lat2) > EPSLN) {
    this.ns = Math.log(ms1 / ms2) / Math.log(ts1 / ts2);
  } else {
    this.ns = sin1;
  }
  if (isNaN(this.ns)) {
    this.ns = sin1;
  }
  this.f0 = ms1 / (this.ns * Math.pow(ts1, this.ns));
  this.rh = this.a * this.f0 * Math.pow(ts0, this.ns);
  if (!this.title) {
    this.title = "Lambert Conformal Conic";
  }
}
function forward$k(p5) {
  var lon = p5.x;
  var lat = p5.y;
  if (Math.abs(2 * Math.abs(lat) - Math.PI) <= EPSLN) {
    lat = sign(lat) * (HALF_PI - 2 * EPSLN);
  }
  var con = Math.abs(Math.abs(lat) - HALF_PI);
  var ts, rh1;
  if (con > EPSLN) {
    ts = tsfnz(this.e, lat, Math.sin(lat));
    rh1 = this.a * this.f0 * Math.pow(ts, this.ns);
  } else {
    con = lat * this.ns;
    if (con <= 0) {
      return null;
    }
    rh1 = 0;
  }
  var theta = this.ns * adjust_lon(lon - this.long0);
  p5.x = this.k0 * (rh1 * Math.sin(theta)) + this.x0;
  p5.y = this.k0 * (this.rh - rh1 * Math.cos(theta)) + this.y0;
  return p5;
}
function inverse$k(p5) {
  var rh1, con, ts;
  var lat, lon;
  var x2 = (p5.x - this.x0) / this.k0;
  var y2 = this.rh - (p5.y - this.y0) / this.k0;
  if (this.ns > 0) {
    rh1 = Math.sqrt(x2 * x2 + y2 * y2);
    con = 1;
  } else {
    rh1 = -Math.sqrt(x2 * x2 + y2 * y2);
    con = -1;
  }
  var theta = 0;
  if (rh1 !== 0) {
    theta = Math.atan2(con * x2, con * y2);
  }
  if (rh1 !== 0 || this.ns > 0) {
    con = 1 / this.ns;
    ts = Math.pow(rh1 / (this.a * this.f0), con);
    lat = phi2z(this.e, ts);
    if (lat === -9999) {
      return null;
    }
  } else {
    lat = -HALF_PI;
  }
  lon = adjust_lon(theta / this.ns + this.long0);
  p5.x = lon;
  p5.y = lat;
  return p5;
}
var names$k = [
  "Lambert Tangential Conformal Conic Projection",
  "Lambert_Conformal_Conic",
  "Lambert_Conformal_Conic_1SP",
  "Lambert_Conformal_Conic_2SP",
  "lcc"
];
var lcc = {
  init: init$k,
  forward: forward$k,
  inverse: inverse$k,
  names: names$k
};
function init$j() {
  this.a = 6377397155e-3;
  this.es = 0.006674372230614;
  this.e = Math.sqrt(this.es);
  if (!this.lat0) {
    this.lat0 = 0.863937979737193;
  }
  if (!this.long0) {
    this.long0 = 0.7417649320975901 - 0.308341501185665;
  }
  if (!this.k0) {
    this.k0 = 0.9999;
  }
  this.s45 = 0.785398163397448;
  this.s90 = 2 * this.s45;
  this.fi0 = this.lat0;
  this.e2 = this.es;
  this.e = Math.sqrt(this.e2);
  this.alfa = Math.sqrt(1 + this.e2 * Math.pow(Math.cos(this.fi0), 4) / (1 - this.e2));
  this.uq = 1.04216856380474;
  this.u0 = Math.asin(Math.sin(this.fi0) / this.alfa);
  this.g = Math.pow((1 + this.e * Math.sin(this.fi0)) / (1 - this.e * Math.sin(this.fi0)), this.alfa * this.e / 2);
  this.k = Math.tan(this.u0 / 2 + this.s45) / Math.pow(Math.tan(this.fi0 / 2 + this.s45), this.alfa) * this.g;
  this.k1 = this.k0;
  this.n0 = this.a * Math.sqrt(1 - this.e2) / (1 - this.e2 * Math.pow(Math.sin(this.fi0), 2));
  this.s0 = 1.37008346281555;
  this.n = Math.sin(this.s0);
  this.ro0 = this.k1 * this.n0 / Math.tan(this.s0);
  this.ad = this.s90 - this.uq;
}
function forward$j(p5) {
  var gfi, u2, deltav, s2, d2, eps, ro;
  var lon = p5.x;
  var lat = p5.y;
  var delta_lon = adjust_lon(lon - this.long0);
  gfi = Math.pow((1 + this.e * Math.sin(lat)) / (1 - this.e * Math.sin(lat)), this.alfa * this.e / 2);
  u2 = 2 * (Math.atan(this.k * Math.pow(Math.tan(lat / 2 + this.s45), this.alfa) / gfi) - this.s45);
  deltav = -delta_lon * this.alfa;
  s2 = Math.asin(Math.cos(this.ad) * Math.sin(u2) + Math.sin(this.ad) * Math.cos(u2) * Math.cos(deltav));
  d2 = Math.asin(Math.cos(u2) * Math.sin(deltav) / Math.cos(s2));
  eps = this.n * d2;
  ro = this.ro0 * Math.pow(Math.tan(this.s0 / 2 + this.s45), this.n) / Math.pow(Math.tan(s2 / 2 + this.s45), this.n);
  p5.y = ro * Math.cos(eps) / 1;
  p5.x = ro * Math.sin(eps) / 1;
  if (!this.czech) {
    p5.y *= -1;
    p5.x *= -1;
  }
  return p5;
}
function inverse$j(p5) {
  var u2, deltav, s2, d2, eps, ro, fi1;
  var ok;
  var tmp = p5.x;
  p5.x = p5.y;
  p5.y = tmp;
  if (!this.czech) {
    p5.y *= -1;
    p5.x *= -1;
  }
  ro = Math.sqrt(p5.x * p5.x + p5.y * p5.y);
  eps = Math.atan2(p5.y, p5.x);
  d2 = eps / Math.sin(this.s0);
  s2 = 2 * (Math.atan(Math.pow(this.ro0 / ro, 1 / this.n) * Math.tan(this.s0 / 2 + this.s45)) - this.s45);
  u2 = Math.asin(Math.cos(this.ad) * Math.sin(s2) - Math.sin(this.ad) * Math.cos(s2) * Math.cos(d2));
  deltav = Math.asin(Math.cos(s2) * Math.sin(d2) / Math.cos(u2));
  p5.x = this.long0 - deltav / this.alfa;
  fi1 = u2;
  ok = 0;
  var iter = 0;
  do {
    p5.y = 2 * (Math.atan(Math.pow(this.k, -1 / this.alfa) * Math.pow(Math.tan(u2 / 2 + this.s45), 1 / this.alfa) * Math.pow((1 + this.e * Math.sin(fi1)) / (1 - this.e * Math.sin(fi1)), this.e / 2)) - this.s45);
    if (Math.abs(fi1 - p5.y) < 1e-10) {
      ok = 1;
    }
    fi1 = p5.y;
    iter += 1;
  } while (ok === 0 && iter < 15);
  if (iter >= 15) {
    return null;
  }
  return p5;
}
var names$j = ["Krovak", "krovak"];
var krovak = {
  init: init$j,
  forward: forward$j,
  inverse: inverse$j,
  names: names$j
};
function mlfn(e0, e1, e2, e3, phi) {
  return e0 * phi - e1 * Math.sin(2 * phi) + e2 * Math.sin(4 * phi) - e3 * Math.sin(6 * phi);
}
function e0fn(x2) {
  return 1 - 0.25 * x2 * (1 + x2 / 16 * (3 + 1.25 * x2));
}
function e1fn(x2) {
  return 0.375 * x2 * (1 + 0.25 * x2 * (1 + 0.46875 * x2));
}
function e2fn(x2) {
  return 0.05859375 * x2 * x2 * (1 + 0.75 * x2);
}
function e3fn(x2) {
  return x2 * x2 * x2 * (35 / 3072);
}
function gN(a2, e2, sinphi) {
  var temp = e2 * sinphi;
  return a2 / Math.sqrt(1 - temp * temp);
}
function adjust_lat(x2) {
  return Math.abs(x2) < HALF_PI ? x2 : x2 - sign(x2) * Math.PI;
}
function imlfn(ml, e0, e1, e2, e3) {
  var phi;
  var dphi;
  phi = ml / e0;
  for (var i2 = 0; i2 < 15; i2++) {
    dphi = (ml - (e0 * phi - e1 * Math.sin(2 * phi) + e2 * Math.sin(4 * phi) - e3 * Math.sin(6 * phi))) / (e0 - 2 * e1 * Math.cos(2 * phi) + 4 * e2 * Math.cos(4 * phi) - 6 * e3 * Math.cos(6 * phi));
    phi += dphi;
    if (Math.abs(dphi) <= 1e-10) {
      return phi;
    }
  }
  return NaN;
}
function init$i() {
  if (!this.sphere) {
    this.e0 = e0fn(this.es);
    this.e1 = e1fn(this.es);
    this.e2 = e2fn(this.es);
    this.e3 = e3fn(this.es);
    this.ml0 = this.a * mlfn(this.e0, this.e1, this.e2, this.e3, this.lat0);
  }
}
function forward$i(p5) {
  var x2, y2;
  var lam = p5.x;
  var phi = p5.y;
  lam = adjust_lon(lam - this.long0);
  if (this.sphere) {
    x2 = this.a * Math.asin(Math.cos(phi) * Math.sin(lam));
    y2 = this.a * (Math.atan2(Math.tan(phi), Math.cos(lam)) - this.lat0);
  } else {
    var sinphi = Math.sin(phi);
    var cosphi = Math.cos(phi);
    var nl = gN(this.a, this.e, sinphi);
    var tl = Math.tan(phi) * Math.tan(phi);
    var al = lam * Math.cos(phi);
    var asq = al * al;
    var cl = this.es * cosphi * cosphi / (1 - this.es);
    var ml = this.a * mlfn(this.e0, this.e1, this.e2, this.e3, phi);
    x2 = nl * al * (1 - asq * tl * (1 / 6 - (8 - tl + 8 * cl) * asq / 120));
    y2 = ml - this.ml0 + nl * sinphi / cosphi * asq * (0.5 + (5 - tl + 6 * cl) * asq / 24);
  }
  p5.x = x2 + this.x0;
  p5.y = y2 + this.y0;
  return p5;
}
function inverse$i(p5) {
  p5.x -= this.x0;
  p5.y -= this.y0;
  var x2 = p5.x / this.a;
  var y2 = p5.y / this.a;
  var phi, lam;
  if (this.sphere) {
    var dd = y2 + this.lat0;
    phi = Math.asin(Math.sin(dd) * Math.cos(x2));
    lam = Math.atan2(Math.tan(x2), Math.cos(dd));
  } else {
    var ml1 = this.ml0 / this.a + y2;
    var phi1 = imlfn(ml1, this.e0, this.e1, this.e2, this.e3);
    if (Math.abs(Math.abs(phi1) - HALF_PI) <= EPSLN) {
      p5.x = this.long0;
      p5.y = HALF_PI;
      if (y2 < 0) {
        p5.y *= -1;
      }
      return p5;
    }
    var nl1 = gN(this.a, this.e, Math.sin(phi1));
    var rl1 = nl1 * nl1 * nl1 / this.a / this.a * (1 - this.es);
    var tl1 = Math.pow(Math.tan(phi1), 2);
    var dl = x2 * this.a / nl1;
    var dsq = dl * dl;
    phi = phi1 - nl1 * Math.tan(phi1) / rl1 * dl * dl * (0.5 - (1 + 3 * tl1) * dl * dl / 24);
    lam = dl * (1 - dsq * (tl1 / 3 + (1 + 3 * tl1) * tl1 * dsq / 15)) / Math.cos(phi1);
  }
  p5.x = adjust_lon(lam + this.long0);
  p5.y = adjust_lat(phi);
  return p5;
}
var names$i = ["Cassini", "Cassini_Soldner", "cass"];
var cass = {
  init: init$i,
  forward: forward$i,
  inverse: inverse$i,
  names: names$i
};
function qsfnz(eccent, sinphi) {
  var con;
  if (eccent > 1e-7) {
    con = eccent * sinphi;
    return (1 - eccent * eccent) * (sinphi / (1 - con * con) - 0.5 / eccent * Math.log((1 - con) / (1 + con)));
  } else {
    return 2 * sinphi;
  }
}
var S_POLE = 1;
var N_POLE = 2;
var EQUIT = 3;
var OBLIQ = 4;
function init$h() {
  var t3 = Math.abs(this.lat0);
  if (Math.abs(t3 - HALF_PI) < EPSLN) {
    this.mode = this.lat0 < 0 ? this.S_POLE : this.N_POLE;
  } else if (Math.abs(t3) < EPSLN) {
    this.mode = this.EQUIT;
  } else {
    this.mode = this.OBLIQ;
  }
  if (this.es > 0) {
    var sinphi;
    this.qp = qsfnz(this.e, 1);
    this.mmf = 0.5 / (1 - this.es);
    this.apa = authset(this.es);
    switch (this.mode) {
      case this.N_POLE:
        this.dd = 1;
        break;
      case this.S_POLE:
        this.dd = 1;
        break;
      case this.EQUIT:
        this.rq = Math.sqrt(0.5 * this.qp);
        this.dd = 1 / this.rq;
        this.xmf = 1;
        this.ymf = 0.5 * this.qp;
        break;
      case this.OBLIQ:
        this.rq = Math.sqrt(0.5 * this.qp);
        sinphi = Math.sin(this.lat0);
        this.sinb1 = qsfnz(this.e, sinphi) / this.qp;
        this.cosb1 = Math.sqrt(1 - this.sinb1 * this.sinb1);
        this.dd = Math.cos(this.lat0) / (Math.sqrt(1 - this.es * sinphi * sinphi) * this.rq * this.cosb1);
        this.ymf = (this.xmf = this.rq) / this.dd;
        this.xmf *= this.dd;
        break;
    }
  } else {
    if (this.mode === this.OBLIQ) {
      this.sinph0 = Math.sin(this.lat0);
      this.cosph0 = Math.cos(this.lat0);
    }
  }
}
function forward$h(p5) {
  var x2, y2, coslam, sinlam, sinphi, q2, sinb, cosb, b2, cosphi;
  var lam = p5.x;
  var phi = p5.y;
  lam = adjust_lon(lam - this.long0);
  if (this.sphere) {
    sinphi = Math.sin(phi);
    cosphi = Math.cos(phi);
    coslam = Math.cos(lam);
    if (this.mode === this.OBLIQ || this.mode === this.EQUIT) {
      y2 = this.mode === this.EQUIT ? 1 + cosphi * coslam : 1 + this.sinph0 * sinphi + this.cosph0 * cosphi * coslam;
      if (y2 <= EPSLN) {
        return null;
      }
      y2 = Math.sqrt(2 / y2);
      x2 = y2 * cosphi * Math.sin(lam);
      y2 *= this.mode === this.EQUIT ? sinphi : this.cosph0 * sinphi - this.sinph0 * cosphi * coslam;
    } else if (this.mode === this.N_POLE || this.mode === this.S_POLE) {
      if (this.mode === this.N_POLE) {
        coslam = -coslam;
      }
      if (Math.abs(phi + this.lat0) < EPSLN) {
        return null;
      }
      y2 = FORTPI - phi * 0.5;
      y2 = 2 * (this.mode === this.S_POLE ? Math.cos(y2) : Math.sin(y2));
      x2 = y2 * Math.sin(lam);
      y2 *= coslam;
    }
  } else {
    sinb = 0;
    cosb = 0;
    b2 = 0;
    coslam = Math.cos(lam);
    sinlam = Math.sin(lam);
    sinphi = Math.sin(phi);
    q2 = qsfnz(this.e, sinphi);
    if (this.mode === this.OBLIQ || this.mode === this.EQUIT) {
      sinb = q2 / this.qp;
      cosb = Math.sqrt(1 - sinb * sinb);
    }
    switch (this.mode) {
      case this.OBLIQ:
        b2 = 1 + this.sinb1 * sinb + this.cosb1 * cosb * coslam;
        break;
      case this.EQUIT:
        b2 = 1 + cosb * coslam;
        break;
      case this.N_POLE:
        b2 = HALF_PI + phi;
        q2 = this.qp - q2;
        break;
      case this.S_POLE:
        b2 = phi - HALF_PI;
        q2 = this.qp + q2;
        break;
    }
    if (Math.abs(b2) < EPSLN) {
      return null;
    }
    switch (this.mode) {
      case this.OBLIQ:
      case this.EQUIT:
        b2 = Math.sqrt(2 / b2);
        if (this.mode === this.OBLIQ) {
          y2 = this.ymf * b2 * (this.cosb1 * sinb - this.sinb1 * cosb * coslam);
        } else {
          y2 = (b2 = Math.sqrt(2 / (1 + cosb * coslam))) * sinb * this.ymf;
        }
        x2 = this.xmf * b2 * cosb * sinlam;
        break;
      case this.N_POLE:
      case this.S_POLE:
        if (q2 >= 0) {
          x2 = (b2 = Math.sqrt(q2)) * sinlam;
          y2 = coslam * (this.mode === this.S_POLE ? b2 : -b2);
        } else {
          x2 = y2 = 0;
        }
        break;
    }
  }
  p5.x = this.a * x2 + this.x0;
  p5.y = this.a * y2 + this.y0;
  return p5;
}
function inverse$h(p5) {
  p5.x -= this.x0;
  p5.y -= this.y0;
  var x2 = p5.x / this.a;
  var y2 = p5.y / this.a;
  var lam, phi, cCe, sCe, q2, rho, ab;
  if (this.sphere) {
    var cosz = 0, rh, sinz = 0;
    rh = Math.sqrt(x2 * x2 + y2 * y2);
    phi = rh * 0.5;
    if (phi > 1) {
      return null;
    }
    phi = 2 * Math.asin(phi);
    if (this.mode === this.OBLIQ || this.mode === this.EQUIT) {
      sinz = Math.sin(phi);
      cosz = Math.cos(phi);
    }
    switch (this.mode) {
      case this.EQUIT:
        phi = Math.abs(rh) <= EPSLN ? 0 : Math.asin(y2 * sinz / rh);
        x2 *= sinz;
        y2 = cosz * rh;
        break;
      case this.OBLIQ:
        phi = Math.abs(rh) <= EPSLN ? this.lat0 : Math.asin(cosz * this.sinph0 + y2 * sinz * this.cosph0 / rh);
        x2 *= sinz * this.cosph0;
        y2 = (cosz - Math.sin(phi) * this.sinph0) * rh;
        break;
      case this.N_POLE:
        y2 = -y2;
        phi = HALF_PI - phi;
        break;
      case this.S_POLE:
        phi -= HALF_PI;
        break;
    }
    lam = y2 === 0 && (this.mode === this.EQUIT || this.mode === this.OBLIQ) ? 0 : Math.atan2(x2, y2);
  } else {
    ab = 0;
    if (this.mode === this.OBLIQ || this.mode === this.EQUIT) {
      x2 /= this.dd;
      y2 *= this.dd;
      rho = Math.sqrt(x2 * x2 + y2 * y2);
      if (rho < EPSLN) {
        p5.x = this.long0;
        p5.y = this.lat0;
        return p5;
      }
      sCe = 2 * Math.asin(0.5 * rho / this.rq);
      cCe = Math.cos(sCe);
      x2 *= sCe = Math.sin(sCe);
      if (this.mode === this.OBLIQ) {
        ab = cCe * this.sinb1 + y2 * sCe * this.cosb1 / rho;
        q2 = this.qp * ab;
        y2 = rho * this.cosb1 * cCe - y2 * this.sinb1 * sCe;
      } else {
        ab = y2 * sCe / rho;
        q2 = this.qp * ab;
        y2 = rho * cCe;
      }
    } else if (this.mode === this.N_POLE || this.mode === this.S_POLE) {
      if (this.mode === this.N_POLE) {
        y2 = -y2;
      }
      q2 = x2 * x2 + y2 * y2;
      if (!q2) {
        p5.x = this.long0;
        p5.y = this.lat0;
        return p5;
      }
      ab = 1 - q2 / this.qp;
      if (this.mode === this.S_POLE) {
        ab = -ab;
      }
    }
    lam = Math.atan2(x2, y2);
    phi = authlat(Math.asin(ab), this.apa);
  }
  p5.x = adjust_lon(this.long0 + lam);
  p5.y = phi;
  return p5;
}
var P00 = 0.3333333333333333;
var P01 = 0.17222222222222222;
var P02 = 0.10257936507936508;
var P10 = 0.06388888888888888;
var P11 = 0.0664021164021164;
var P20 = 0.016415012942191543;
function authset(es) {
  var t3;
  var APA = [];
  APA[0] = es * P00;
  t3 = es * es;
  APA[0] += t3 * P01;
  APA[1] = t3 * P10;
  t3 *= es;
  APA[0] += t3 * P02;
  APA[1] += t3 * P11;
  APA[2] = t3 * P20;
  return APA;
}
function authlat(beta, APA) {
  var t3 = beta + beta;
  return beta + APA[0] * Math.sin(t3) + APA[1] * Math.sin(t3 + t3) + APA[2] * Math.sin(t3 + t3 + t3);
}
var names$h = ["Lambert Azimuthal Equal Area", "Lambert_Azimuthal_Equal_Area", "laea"];
var laea = {
  init: init$h,
  forward: forward$h,
  inverse: inverse$h,
  names: names$h,
  S_POLE,
  N_POLE,
  EQUIT,
  OBLIQ
};
function asinz(x2) {
  if (Math.abs(x2) > 1) {
    x2 = x2 > 1 ? 1 : -1;
  }
  return Math.asin(x2);
}
function init$g() {
  if (Math.abs(this.lat1 + this.lat2) < EPSLN) {
    return;
  }
  this.temp = this.b / this.a;
  this.es = 1 - Math.pow(this.temp, 2);
  this.e3 = Math.sqrt(this.es);
  this.sin_po = Math.sin(this.lat1);
  this.cos_po = Math.cos(this.lat1);
  this.t1 = this.sin_po;
  this.con = this.sin_po;
  this.ms1 = msfnz(this.e3, this.sin_po, this.cos_po);
  this.qs1 = qsfnz(this.e3, this.sin_po, this.cos_po);
  this.sin_po = Math.sin(this.lat2);
  this.cos_po = Math.cos(this.lat2);
  this.t2 = this.sin_po;
  this.ms2 = msfnz(this.e3, this.sin_po, this.cos_po);
  this.qs2 = qsfnz(this.e3, this.sin_po, this.cos_po);
  this.sin_po = Math.sin(this.lat0);
  this.cos_po = Math.cos(this.lat0);
  this.t3 = this.sin_po;
  this.qs0 = qsfnz(this.e3, this.sin_po, this.cos_po);
  if (Math.abs(this.lat1 - this.lat2) > EPSLN) {
    this.ns0 = (this.ms1 * this.ms1 - this.ms2 * this.ms2) / (this.qs2 - this.qs1);
  } else {
    this.ns0 = this.con;
  }
  this.c = this.ms1 * this.ms1 + this.ns0 * this.qs1;
  this.rh = this.a * Math.sqrt(this.c - this.ns0 * this.qs0) / this.ns0;
}
function forward$g(p5) {
  var lon = p5.x;
  var lat = p5.y;
  this.sin_phi = Math.sin(lat);
  this.cos_phi = Math.cos(lat);
  var qs = qsfnz(this.e3, this.sin_phi, this.cos_phi);
  var rh1 = this.a * Math.sqrt(this.c - this.ns0 * qs) / this.ns0;
  var theta = this.ns0 * adjust_lon(lon - this.long0);
  var x2 = rh1 * Math.sin(theta) + this.x0;
  var y2 = this.rh - rh1 * Math.cos(theta) + this.y0;
  p5.x = x2;
  p5.y = y2;
  return p5;
}
function inverse$g(p5) {
  var rh1, qs, con, theta, lon, lat;
  p5.x -= this.x0;
  p5.y = this.rh - p5.y + this.y0;
  if (this.ns0 >= 0) {
    rh1 = Math.sqrt(p5.x * p5.x + p5.y * p5.y);
    con = 1;
  } else {
    rh1 = -Math.sqrt(p5.x * p5.x + p5.y * p5.y);
    con = -1;
  }
  theta = 0;
  if (rh1 !== 0) {
    theta = Math.atan2(con * p5.x, con * p5.y);
  }
  con = rh1 * this.ns0 / this.a;
  if (this.sphere) {
    lat = Math.asin((this.c - con * con) / (2 * this.ns0));
  } else {
    qs = (this.c - con * con) / this.ns0;
    lat = this.phi1z(this.e3, qs);
  }
  lon = adjust_lon(theta / this.ns0 + this.long0);
  p5.x = lon;
  p5.y = lat;
  return p5;
}
function phi1z(eccent, qs) {
  var sinphi, cosphi, con, com, dphi;
  var phi = asinz(0.5 * qs);
  if (eccent < EPSLN) {
    return phi;
  }
  var eccnts = eccent * eccent;
  for (var i2 = 1; i2 <= 25; i2++) {
    sinphi = Math.sin(phi);
    cosphi = Math.cos(phi);
    con = eccent * sinphi;
    com = 1 - con * con;
    dphi = 0.5 * com * com / cosphi * (qs / (1 - eccnts) - sinphi / com + 0.5 / eccent * Math.log((1 - con) / (1 + con)));
    phi = phi + dphi;
    if (Math.abs(dphi) <= 1e-7) {
      return phi;
    }
  }
  return null;
}
var names$g = ["Albers_Conic_Equal_Area", "Albers", "aea"];
var aea = {
  init: init$g,
  forward: forward$g,
  inverse: inverse$g,
  names: names$g,
  phi1z
};
function init$f() {
  this.sin_p14 = Math.sin(this.lat0);
  this.cos_p14 = Math.cos(this.lat0);
  this.infinity_dist = 1e3 * this.a;
  this.rc = 1;
}
function forward$f(p5) {
  var sinphi, cosphi;
  var dlon;
  var coslon;
  var ksp;
  var g2;
  var x2, y2;
  var lon = p5.x;
  var lat = p5.y;
  dlon = adjust_lon(lon - this.long0);
  sinphi = Math.sin(lat);
  cosphi = Math.cos(lat);
  coslon = Math.cos(dlon);
  g2 = this.sin_p14 * sinphi + this.cos_p14 * cosphi * coslon;
  ksp = 1;
  if (g2 > 0 || Math.abs(g2) <= EPSLN) {
    x2 = this.x0 + this.a * ksp * cosphi * Math.sin(dlon) / g2;
    y2 = this.y0 + this.a * ksp * (this.cos_p14 * sinphi - this.sin_p14 * cosphi * coslon) / g2;
  } else {
    x2 = this.x0 + this.infinity_dist * cosphi * Math.sin(dlon);
    y2 = this.y0 + this.infinity_dist * (this.cos_p14 * sinphi - this.sin_p14 * cosphi * coslon);
  }
  p5.x = x2;
  p5.y = y2;
  return p5;
}
function inverse$f(p5) {
  var rh;
  var sinc, cosc;
  var c2;
  var lon, lat;
  p5.x = (p5.x - this.x0) / this.a;
  p5.y = (p5.y - this.y0) / this.a;
  p5.x /= this.k0;
  p5.y /= this.k0;
  if (rh = Math.sqrt(p5.x * p5.x + p5.y * p5.y)) {
    c2 = Math.atan2(rh, this.rc);
    sinc = Math.sin(c2);
    cosc = Math.cos(c2);
    lat = asinz(cosc * this.sin_p14 + p5.y * sinc * this.cos_p14 / rh);
    lon = Math.atan2(p5.x * sinc, rh * this.cos_p14 * cosc - p5.y * this.sin_p14 * sinc);
    lon = adjust_lon(this.long0 + lon);
  } else {
    lat = this.phic0;
    lon = 0;
  }
  p5.x = lon;
  p5.y = lat;
  return p5;
}
var names$f = ["gnom"];
var gnom = {
  init: init$f,
  forward: forward$f,
  inverse: inverse$f,
  names: names$f
};
function iqsfnz(eccent, q2) {
  var temp = 1 - (1 - eccent * eccent) / (2 * eccent) * Math.log((1 - eccent) / (1 + eccent));
  if (Math.abs(Math.abs(q2) - temp) < 1e-6) {
    if (q2 < 0) {
      return -1 * HALF_PI;
    } else {
      return HALF_PI;
    }
  }
  var phi = Math.asin(0.5 * q2);
  var dphi;
  var sin_phi;
  var cos_phi;
  var con;
  for (var i2 = 0; i2 < 30; i2++) {
    sin_phi = Math.sin(phi);
    cos_phi = Math.cos(phi);
    con = eccent * sin_phi;
    dphi = Math.pow(1 - con * con, 2) / (2 * cos_phi) * (q2 / (1 - eccent * eccent) - sin_phi / (1 - con * con) + 0.5 / eccent * Math.log((1 - con) / (1 + con)));
    phi += dphi;
    if (Math.abs(dphi) <= 1e-10) {
      return phi;
    }
  }
  return NaN;
}
function init$e() {
  if (!this.sphere) {
    this.k0 = msfnz(this.e, Math.sin(this.lat_ts), Math.cos(this.lat_ts));
  }
}
function forward$e(p5) {
  var lon = p5.x;
  var lat = p5.y;
  var x2, y2;
  var dlon = adjust_lon(lon - this.long0);
  if (this.sphere) {
    x2 = this.x0 + this.a * dlon * Math.cos(this.lat_ts);
    y2 = this.y0 + this.a * Math.sin(lat) / Math.cos(this.lat_ts);
  } else {
    var qs = qsfnz(this.e, Math.sin(lat));
    x2 = this.x0 + this.a * this.k0 * dlon;
    y2 = this.y0 + this.a * qs * 0.5 / this.k0;
  }
  p5.x = x2;
  p5.y = y2;
  return p5;
}
function inverse$e(p5) {
  p5.x -= this.x0;
  p5.y -= this.y0;
  var lon, lat;
  if (this.sphere) {
    lon = adjust_lon(this.long0 + p5.x / this.a / Math.cos(this.lat_ts));
    lat = Math.asin(p5.y / this.a * Math.cos(this.lat_ts));
  } else {
    lat = iqsfnz(this.e, 2 * p5.y * this.k0 / this.a);
    lon = adjust_lon(this.long0 + p5.x / (this.a * this.k0));
  }
  p5.x = lon;
  p5.y = lat;
  return p5;
}
var names$e = ["cea"];
var cea = {
  init: init$e,
  forward: forward$e,
  inverse: inverse$e,
  names: names$e
};
function init$d() {
  this.x0 = this.x0 || 0;
  this.y0 = this.y0 || 0;
  this.lat0 = this.lat0 || 0;
  this.long0 = this.long0 || 0;
  this.lat_ts = this.lat_ts || 0;
  this.title = this.title || "Equidistant Cylindrical (Plate Carre)";
  this.rc = Math.cos(this.lat_ts);
}
function forward$d(p5) {
  var lon = p5.x;
  var lat = p5.y;
  var dlon = adjust_lon(lon - this.long0);
  var dlat = adjust_lat(lat - this.lat0);
  p5.x = this.x0 + this.a * dlon * this.rc;
  p5.y = this.y0 + this.a * dlat;
  return p5;
}
function inverse$d(p5) {
  var x2 = p5.x;
  var y2 = p5.y;
  p5.x = adjust_lon(this.long0 + (x2 - this.x0) / (this.a * this.rc));
  p5.y = adjust_lat(this.lat0 + (y2 - this.y0) / this.a);
  return p5;
}
var names$d = ["Equirectangular", "Equidistant_Cylindrical", "eqc"];
var eqc = {
  init: init$d,
  forward: forward$d,
  inverse: inverse$d,
  names: names$d
};
var MAX_ITER$1 = 20;
function init$c() {
  this.temp = this.b / this.a;
  this.es = 1 - Math.pow(this.temp, 2);
  this.e = Math.sqrt(this.es);
  this.e0 = e0fn(this.es);
  this.e1 = e1fn(this.es);
  this.e2 = e2fn(this.es);
  this.e3 = e3fn(this.es);
  this.ml0 = this.a * mlfn(this.e0, this.e1, this.e2, this.e3, this.lat0);
}
function forward$c(p5) {
  var lon = p5.x;
  var lat = p5.y;
  var x2, y2, el;
  var dlon = adjust_lon(lon - this.long0);
  el = dlon * Math.sin(lat);
  if (this.sphere) {
    if (Math.abs(lat) <= EPSLN) {
      x2 = this.a * dlon;
      y2 = -1 * this.a * this.lat0;
    } else {
      x2 = this.a * Math.sin(el) / Math.tan(lat);
      y2 = this.a * (adjust_lat(lat - this.lat0) + (1 - Math.cos(el)) / Math.tan(lat));
    }
  } else {
    if (Math.abs(lat) <= EPSLN) {
      x2 = this.a * dlon;
      y2 = -1 * this.ml0;
    } else {
      var nl = gN(this.a, this.e, Math.sin(lat)) / Math.tan(lat);
      x2 = nl * Math.sin(el);
      y2 = this.a * mlfn(this.e0, this.e1, this.e2, this.e3, lat) - this.ml0 + nl * (1 - Math.cos(el));
    }
  }
  p5.x = x2 + this.x0;
  p5.y = y2 + this.y0;
  return p5;
}
function inverse$c(p5) {
  var lon, lat, x2, y2, i2;
  var al, bl;
  var phi, dphi;
  x2 = p5.x - this.x0;
  y2 = p5.y - this.y0;
  if (this.sphere) {
    if (Math.abs(y2 + this.a * this.lat0) <= EPSLN) {
      lon = adjust_lon(x2 / this.a + this.long0);
      lat = 0;
    } else {
      al = this.lat0 + y2 / this.a;
      bl = x2 * x2 / this.a / this.a + al * al;
      phi = al;
      var tanphi;
      for (i2 = MAX_ITER$1; i2; --i2) {
        tanphi = Math.tan(phi);
        dphi = -1 * (al * (phi * tanphi + 1) - phi - 0.5 * (phi * phi + bl) * tanphi) / ((phi - al) / tanphi - 1);
        phi += dphi;
        if (Math.abs(dphi) <= EPSLN) {
          lat = phi;
          break;
        }
      }
      lon = adjust_lon(this.long0 + Math.asin(x2 * Math.tan(phi) / this.a) / Math.sin(lat));
    }
  } else {
    if (Math.abs(y2 + this.ml0) <= EPSLN) {
      lat = 0;
      lon = adjust_lon(this.long0 + x2 / this.a);
    } else {
      al = (this.ml0 + y2) / this.a;
      bl = x2 * x2 / this.a / this.a + al * al;
      phi = al;
      var cl, mln, mlnp, ma;
      var con;
      for (i2 = MAX_ITER$1; i2; --i2) {
        con = this.e * Math.sin(phi);
        cl = Math.sqrt(1 - con * con) * Math.tan(phi);
        mln = this.a * mlfn(this.e0, this.e1, this.e2, this.e3, phi);
        mlnp = this.e0 - 2 * this.e1 * Math.cos(2 * phi) + 4 * this.e2 * Math.cos(4 * phi) - 6 * this.e3 * Math.cos(6 * phi);
        ma = mln / this.a;
        dphi = (al * (cl * ma + 1) - ma - 0.5 * cl * (ma * ma + bl)) / (this.es * Math.sin(2 * phi) * (ma * ma + bl - 2 * al * ma) / (4 * cl) + (al - ma) * (cl * mlnp - 2 / Math.sin(2 * phi)) - mlnp);
        phi -= dphi;
        if (Math.abs(dphi) <= EPSLN) {
          lat = phi;
          break;
        }
      }
      cl = Math.sqrt(1 - this.es * Math.pow(Math.sin(lat), 2)) * Math.tan(lat);
      lon = adjust_lon(this.long0 + Math.asin(x2 * cl / this.a) / Math.sin(lat));
    }
  }
  p5.x = lon;
  p5.y = lat;
  return p5;
}
var names$c = ["Polyconic", "poly"];
var poly = {
  init: init$c,
  forward: forward$c,
  inverse: inverse$c,
  names: names$c
};
function init$b() {
  this.A = [];
  this.A[1] = 0.6399175073;
  this.A[2] = -0.1358797613;
  this.A[3] = 0.063294409;
  this.A[4] = -0.02526853;
  this.A[5] = 0.0117879;
  this.A[6] = -55161e-7;
  this.A[7] = 26906e-7;
  this.A[8] = -1333e-6;
  this.A[9] = 67e-5;
  this.A[10] = -34e-5;
  this.B_re = [];
  this.B_im = [];
  this.B_re[1] = 0.7557853228;
  this.B_im[1] = 0;
  this.B_re[2] = 0.249204646;
  this.B_im[2] = 3371507e-9;
  this.B_re[3] = -1541739e-9;
  this.B_im[3] = 0.04105856;
  this.B_re[4] = -0.10162907;
  this.B_im[4] = 0.01727609;
  this.B_re[5] = -0.26623489;
  this.B_im[5] = -0.36249218;
  this.B_re[6] = -0.6870983;
  this.B_im[6] = -1.1651967;
  this.C_re = [];
  this.C_im = [];
  this.C_re[1] = 1.3231270439;
  this.C_im[1] = 0;
  this.C_re[2] = -0.577245789;
  this.C_im[2] = -7809598e-9;
  this.C_re[3] = 0.508307513;
  this.C_im[3] = -0.112208952;
  this.C_re[4] = -0.15094762;
  this.C_im[4] = 0.18200602;
  this.C_re[5] = 1.01418179;
  this.C_im[5] = 1.64497696;
  this.C_re[6] = 1.9660549;
  this.C_im[6] = 2.5127645;
  this.D = [];
  this.D[1] = 1.5627014243;
  this.D[2] = 0.5185406398;
  this.D[3] = -0.03333098;
  this.D[4] = -0.1052906;
  this.D[5] = -0.0368594;
  this.D[6] = 7317e-6;
  this.D[7] = 0.0122;
  this.D[8] = 394e-5;
  this.D[9] = -13e-4;
}
function forward$b(p5) {
  var n2;
  var lon = p5.x;
  var lat = p5.y;
  var delta_lat = lat - this.lat0;
  var delta_lon = lon - this.long0;
  var d_phi = delta_lat / SEC_TO_RAD * 1e-5;
  var d_lambda = delta_lon;
  var d_phi_n = 1;
  var d_psi = 0;
  for (n2 = 1; n2 <= 10; n2++) {
    d_phi_n = d_phi_n * d_phi;
    d_psi = d_psi + this.A[n2] * d_phi_n;
  }
  var th_re = d_psi;
  var th_im = d_lambda;
  var th_n_re = 1;
  var th_n_im = 0;
  var th_n_re1;
  var th_n_im1;
  var z_re = 0;
  var z_im = 0;
  for (n2 = 1; n2 <= 6; n2++) {
    th_n_re1 = th_n_re * th_re - th_n_im * th_im;
    th_n_im1 = th_n_im * th_re + th_n_re * th_im;
    th_n_re = th_n_re1;
    th_n_im = th_n_im1;
    z_re = z_re + this.B_re[n2] * th_n_re - this.B_im[n2] * th_n_im;
    z_im = z_im + this.B_im[n2] * th_n_re + this.B_re[n2] * th_n_im;
  }
  p5.x = z_im * this.a + this.x0;
  p5.y = z_re * this.a + this.y0;
  return p5;
}
function inverse$b(p5) {
  var n2;
  var x2 = p5.x;
  var y2 = p5.y;
  var delta_x = x2 - this.x0;
  var delta_y = y2 - this.y0;
  var z_re = delta_y / this.a;
  var z_im = delta_x / this.a;
  var z_n_re = 1;
  var z_n_im = 0;
  var z_n_re1;
  var z_n_im1;
  var th_re = 0;
  var th_im = 0;
  for (n2 = 1; n2 <= 6; n2++) {
    z_n_re1 = z_n_re * z_re - z_n_im * z_im;
    z_n_im1 = z_n_im * z_re + z_n_re * z_im;
    z_n_re = z_n_re1;
    z_n_im = z_n_im1;
    th_re = th_re + this.C_re[n2] * z_n_re - this.C_im[n2] * z_n_im;
    th_im = th_im + this.C_im[n2] * z_n_re + this.C_re[n2] * z_n_im;
  }
  for (var i2 = 0; i2 < this.iterations; i2++) {
    var th_n_re = th_re;
    var th_n_im = th_im;
    var th_n_re1;
    var th_n_im1;
    var num_re = z_re;
    var num_im = z_im;
    for (n2 = 2; n2 <= 6; n2++) {
      th_n_re1 = th_n_re * th_re - th_n_im * th_im;
      th_n_im1 = th_n_im * th_re + th_n_re * th_im;
      th_n_re = th_n_re1;
      th_n_im = th_n_im1;
      num_re = num_re + (n2 - 1) * (this.B_re[n2] * th_n_re - this.B_im[n2] * th_n_im);
      num_im = num_im + (n2 - 1) * (this.B_im[n2] * th_n_re + this.B_re[n2] * th_n_im);
    }
    th_n_re = 1;
    th_n_im = 0;
    var den_re = this.B_re[1];
    var den_im = this.B_im[1];
    for (n2 = 2; n2 <= 6; n2++) {
      th_n_re1 = th_n_re * th_re - th_n_im * th_im;
      th_n_im1 = th_n_im * th_re + th_n_re * th_im;
      th_n_re = th_n_re1;
      th_n_im = th_n_im1;
      den_re = den_re + n2 * (this.B_re[n2] * th_n_re - this.B_im[n2] * th_n_im);
      den_im = den_im + n2 * (this.B_im[n2] * th_n_re + this.B_re[n2] * th_n_im);
    }
    var den2 = den_re * den_re + den_im * den_im;
    th_re = (num_re * den_re + num_im * den_im) / den2;
    th_im = (num_im * den_re - num_re * den_im) / den2;
  }
  var d_psi = th_re;
  var d_lambda = th_im;
  var d_psi_n = 1;
  var d_phi = 0;
  for (n2 = 1; n2 <= 9; n2++) {
    d_psi_n = d_psi_n * d_psi;
    d_phi = d_phi + this.D[n2] * d_psi_n;
  }
  var lat = this.lat0 + d_phi * SEC_TO_RAD * 1e5;
  var lon = this.long0 + d_lambda;
  p5.x = lon;
  p5.y = lat;
  return p5;
}
var names$b = ["New_Zealand_Map_Grid", "nzmg"];
var nzmg = {
  init: init$b,
  forward: forward$b,
  inverse: inverse$b,
  names: names$b
};
function init$a() {
}
function forward$a(p5) {
  var lon = p5.x;
  var lat = p5.y;
  var dlon = adjust_lon(lon - this.long0);
  var x2 = this.x0 + this.a * dlon;
  var y2 = this.y0 + this.a * Math.log(Math.tan(Math.PI / 4 + lat / 2.5)) * 1.25;
  p5.x = x2;
  p5.y = y2;
  return p5;
}
function inverse$a(p5) {
  p5.x -= this.x0;
  p5.y -= this.y0;
  var lon = adjust_lon(this.long0 + p5.x / this.a);
  var lat = 2.5 * (Math.atan(Math.exp(0.8 * p5.y / this.a)) - Math.PI / 4);
  p5.x = lon;
  p5.y = lat;
  return p5;
}
var names$a = ["Miller_Cylindrical", "mill"];
var mill = {
  init: init$a,
  forward: forward$a,
  inverse: inverse$a,
  names: names$a
};
var MAX_ITER = 20;
function init$9() {
  if (!this.sphere) {
    this.en = pj_enfn(this.es);
  } else {
    this.n = 1;
    this.m = 0;
    this.es = 0;
    this.C_y = Math.sqrt((this.m + 1) / this.n);
    this.C_x = this.C_y / (this.m + 1);
  }
}
function forward$9(p5) {
  var x2, y2;
  var lon = p5.x;
  var lat = p5.y;
  lon = adjust_lon(lon - this.long0);
  if (this.sphere) {
    if (!this.m) {
      lat = this.n !== 1 ? Math.asin(this.n * Math.sin(lat)) : lat;
    } else {
      var k2 = this.n * Math.sin(lat);
      for (var i2 = MAX_ITER; i2; --i2) {
        var V2 = (this.m * lat + Math.sin(lat) - k2) / (this.m + Math.cos(lat));
        lat -= V2;
        if (Math.abs(V2) < EPSLN) {
          break;
        }
      }
    }
    x2 = this.a * this.C_x * lon * (this.m + Math.cos(lat));
    y2 = this.a * this.C_y * lat;
  } else {
    var s2 = Math.sin(lat);
    var c2 = Math.cos(lat);
    y2 = this.a * pj_mlfn(lat, s2, c2, this.en);
    x2 = this.a * lon * c2 / Math.sqrt(1 - this.es * s2 * s2);
  }
  p5.x = x2;
  p5.y = y2;
  return p5;
}
function inverse$9(p5) {
  var lat, temp, lon, s2;
  p5.x -= this.x0;
  lon = p5.x / this.a;
  p5.y -= this.y0;
  lat = p5.y / this.a;
  if (this.sphere) {
    lat /= this.C_y;
    lon = lon / (this.C_x * (this.m + Math.cos(lat)));
    if (this.m) {
      lat = asinz((this.m * lat + Math.sin(lat)) / this.n);
    } else if (this.n !== 1) {
      lat = asinz(Math.sin(lat) / this.n);
    }
    lon = adjust_lon(lon + this.long0);
    lat = adjust_lat(lat);
  } else {
    lat = pj_inv_mlfn(p5.y / this.a, this.es, this.en);
    s2 = Math.abs(lat);
    if (s2 < HALF_PI) {
      s2 = Math.sin(lat);
      temp = this.long0 + p5.x * Math.sqrt(1 - this.es * s2 * s2) / (this.a * Math.cos(lat));
      lon = adjust_lon(temp);
    } else if (s2 - EPSLN < HALF_PI) {
      lon = this.long0;
    }
  }
  p5.x = lon;
  p5.y = lat;
  return p5;
}
var names$9 = ["Sinusoidal", "sinu"];
var sinu = {
  init: init$9,
  forward: forward$9,
  inverse: inverse$9,
  names: names$9
};
function init$8() {
}
function forward$8(p5) {
  var lon = p5.x;
  var lat = p5.y;
  var delta_lon = adjust_lon(lon - this.long0);
  var theta = lat;
  var con = Math.PI * Math.sin(lat);
  while (true) {
    var delta_theta = -(theta + Math.sin(theta) - con) / (1 + Math.cos(theta));
    theta += delta_theta;
    if (Math.abs(delta_theta) < EPSLN) {
      break;
    }
  }
  theta /= 2;
  if (Math.PI / 2 - Math.abs(lat) < EPSLN) {
    delta_lon = 0;
  }
  var x2 = 0.900316316158 * this.a * delta_lon * Math.cos(theta) + this.x0;
  var y2 = 1.4142135623731 * this.a * Math.sin(theta) + this.y0;
  p5.x = x2;
  p5.y = y2;
  return p5;
}
function inverse$8(p5) {
  var theta;
  var arg;
  p5.x -= this.x0;
  p5.y -= this.y0;
  arg = p5.y / (1.4142135623731 * this.a);
  if (Math.abs(arg) > 0.999999999999) {
    arg = 0.999999999999;
  }
  theta = Math.asin(arg);
  var lon = adjust_lon(this.long0 + p5.x / (0.900316316158 * this.a * Math.cos(theta)));
  if (lon < -Math.PI) {
    lon = -Math.PI;
  }
  if (lon > Math.PI) {
    lon = Math.PI;
  }
  arg = (2 * theta + Math.sin(2 * theta)) / Math.PI;
  if (Math.abs(arg) > 1) {
    arg = 1;
  }
  var lat = Math.asin(arg);
  p5.x = lon;
  p5.y = lat;
  return p5;
}
var names$8 = ["Mollweide", "moll"];
var moll = {
  init: init$8,
  forward: forward$8,
  inverse: inverse$8,
  names: names$8
};
function init$7() {
  if (Math.abs(this.lat1 + this.lat2) < EPSLN) {
    return;
  }
  this.lat2 = this.lat2 || this.lat1;
  this.temp = this.b / this.a;
  this.es = 1 - Math.pow(this.temp, 2);
  this.e = Math.sqrt(this.es);
  this.e0 = e0fn(this.es);
  this.e1 = e1fn(this.es);
  this.e2 = e2fn(this.es);
  this.e3 = e3fn(this.es);
  this.sinphi = Math.sin(this.lat1);
  this.cosphi = Math.cos(this.lat1);
  this.ms1 = msfnz(this.e, this.sinphi, this.cosphi);
  this.ml1 = mlfn(this.e0, this.e1, this.e2, this.e3, this.lat1);
  if (Math.abs(this.lat1 - this.lat2) < EPSLN) {
    this.ns = this.sinphi;
  } else {
    this.sinphi = Math.sin(this.lat2);
    this.cosphi = Math.cos(this.lat2);
    this.ms2 = msfnz(this.e, this.sinphi, this.cosphi);
    this.ml2 = mlfn(this.e0, this.e1, this.e2, this.e3, this.lat2);
    this.ns = (this.ms1 - this.ms2) / (this.ml2 - this.ml1);
  }
  this.g = this.ml1 + this.ms1 / this.ns;
  this.ml0 = mlfn(this.e0, this.e1, this.e2, this.e3, this.lat0);
  this.rh = this.a * (this.g - this.ml0);
}
function forward$7(p5) {
  var lon = p5.x;
  var lat = p5.y;
  var rh1;
  if (this.sphere) {
    rh1 = this.a * (this.g - lat);
  } else {
    var ml = mlfn(this.e0, this.e1, this.e2, this.e3, lat);
    rh1 = this.a * (this.g - ml);
  }
  var theta = this.ns * adjust_lon(lon - this.long0);
  var x2 = this.x0 + rh1 * Math.sin(theta);
  var y2 = this.y0 + this.rh - rh1 * Math.cos(theta);
  p5.x = x2;
  p5.y = y2;
  return p5;
}
function inverse$7(p5) {
  p5.x -= this.x0;
  p5.y = this.rh - p5.y + this.y0;
  var con, rh1, lat, lon;
  if (this.ns >= 0) {
    rh1 = Math.sqrt(p5.x * p5.x + p5.y * p5.y);
    con = 1;
  } else {
    rh1 = -Math.sqrt(p5.x * p5.x + p5.y * p5.y);
    con = -1;
  }
  var theta = 0;
  if (rh1 !== 0) {
    theta = Math.atan2(con * p5.x, con * p5.y);
  }
  if (this.sphere) {
    lon = adjust_lon(this.long0 + theta / this.ns);
    lat = adjust_lat(this.g - rh1 / this.a);
    p5.x = lon;
    p5.y = lat;
    return p5;
  } else {
    var ml = this.g - rh1 / this.a;
    lat = imlfn(ml, this.e0, this.e1, this.e2, this.e3);
    lon = adjust_lon(this.long0 + theta / this.ns);
    p5.x = lon;
    p5.y = lat;
    return p5;
  }
}
var names$7 = ["Equidistant_Conic", "eqdc"];
var eqdc = {
  init: init$7,
  forward: forward$7,
  inverse: inverse$7,
  names: names$7
};
function init$6() {
  this.R = this.a;
}
function forward$6(p5) {
  var lon = p5.x;
  var lat = p5.y;
  var dlon = adjust_lon(lon - this.long0);
  var x2, y2;
  if (Math.abs(lat) <= EPSLN) {
    x2 = this.x0 + this.R * dlon;
    y2 = this.y0;
  }
  var theta = asinz(2 * Math.abs(lat / Math.PI));
  if (Math.abs(dlon) <= EPSLN || Math.abs(Math.abs(lat) - HALF_PI) <= EPSLN) {
    x2 = this.x0;
    if (lat >= 0) {
      y2 = this.y0 + Math.PI * this.R * Math.tan(0.5 * theta);
    } else {
      y2 = this.y0 + Math.PI * this.R * -Math.tan(0.5 * theta);
    }
  }
  var al = 0.5 * Math.abs(Math.PI / dlon - dlon / Math.PI);
  var asq = al * al;
  var sinth = Math.sin(theta);
  var costh = Math.cos(theta);
  var g2 = costh / (sinth + costh - 1);
  var gsq = g2 * g2;
  var m2 = g2 * (2 / sinth - 1);
  var msq = m2 * m2;
  var con = Math.PI * this.R * (al * (g2 - msq) + Math.sqrt(asq * (g2 - msq) * (g2 - msq) - (msq + asq) * (gsq - msq))) / (msq + asq);
  if (dlon < 0) {
    con = -con;
  }
  x2 = this.x0 + con;
  var q2 = asq + g2;
  con = Math.PI * this.R * (m2 * q2 - al * Math.sqrt((msq + asq) * (asq + 1) - q2 * q2)) / (msq + asq);
  if (lat >= 0) {
    y2 = this.y0 + con;
  } else {
    y2 = this.y0 - con;
  }
  p5.x = x2;
  p5.y = y2;
  return p5;
}
function inverse$6(p5) {
  var lon, lat;
  var xx, yy, xys, c1, c2, c3;
  var a1;
  var m1;
  var con;
  var th1;
  var d2;
  p5.x -= this.x0;
  p5.y -= this.y0;
  con = Math.PI * this.R;
  xx = p5.x / con;
  yy = p5.y / con;
  xys = xx * xx + yy * yy;
  c1 = -Math.abs(yy) * (1 + xys);
  c2 = c1 - 2 * yy * yy + xx * xx;
  c3 = -2 * c1 + 1 + 2 * yy * yy + xys * xys;
  d2 = yy * yy / c3 + (2 * c2 * c2 * c2 / c3 / c3 / c3 - 9 * c1 * c2 / c3 / c3) / 27;
  a1 = (c1 - c2 * c2 / 3 / c3) / c3;
  m1 = 2 * Math.sqrt(-a1 / 3);
  con = 3 * d2 / a1 / m1;
  if (Math.abs(con) > 1) {
    if (con >= 0) {
      con = 1;
    } else {
      con = -1;
    }
  }
  th1 = Math.acos(con) / 3;
  if (p5.y >= 0) {
    lat = (-m1 * Math.cos(th1 + Math.PI / 3) - c2 / 3 / c3) * Math.PI;
  } else {
    lat = -(-m1 * Math.cos(th1 + Math.PI / 3) - c2 / 3 / c3) * Math.PI;
  }
  if (Math.abs(xx) < EPSLN) {
    lon = this.long0;
  } else {
    lon = adjust_lon(this.long0 + Math.PI * (xys - 1 + Math.sqrt(1 + 2 * (xx * xx - yy * yy) + xys * xys)) / 2 / xx);
  }
  p5.x = lon;
  p5.y = lat;
  return p5;
}
var names$6 = ["Van_der_Grinten_I", "VanDerGrinten", "vandg"];
var vandg = {
  init: init$6,
  forward: forward$6,
  inverse: inverse$6,
  names: names$6
};
function init$5() {
  this.sin_p12 = Math.sin(this.lat0);
  this.cos_p12 = Math.cos(this.lat0);
}
function forward$5(p5) {
  var lon = p5.x;
  var lat = p5.y;
  var sinphi = Math.sin(p5.y);
  var cosphi = Math.cos(p5.y);
  var dlon = adjust_lon(lon - this.long0);
  var e0, e1, e2, e3, Mlp, Ml, tanphi, Nl1, Nl, psi, Az, G2, H4, GH, Hs, c2, kp, cos_c, s2, s22, s3, s4, s5;
  if (this.sphere) {
    if (Math.abs(this.sin_p12 - 1) <= EPSLN) {
      p5.x = this.x0 + this.a * (HALF_PI - lat) * Math.sin(dlon);
      p5.y = this.y0 - this.a * (HALF_PI - lat) * Math.cos(dlon);
      return p5;
    } else if (Math.abs(this.sin_p12 + 1) <= EPSLN) {
      p5.x = this.x0 + this.a * (HALF_PI + lat) * Math.sin(dlon);
      p5.y = this.y0 + this.a * (HALF_PI + lat) * Math.cos(dlon);
      return p5;
    } else {
      cos_c = this.sin_p12 * sinphi + this.cos_p12 * cosphi * Math.cos(dlon);
      c2 = Math.acos(cos_c);
      kp = c2 ? c2 / Math.sin(c2) : 1;
      p5.x = this.x0 + this.a * kp * cosphi * Math.sin(dlon);
      p5.y = this.y0 + this.a * kp * (this.cos_p12 * sinphi - this.sin_p12 * cosphi * Math.cos(dlon));
      return p5;
    }
  } else {
    e0 = e0fn(this.es);
    e1 = e1fn(this.es);
    e2 = e2fn(this.es);
    e3 = e3fn(this.es);
    if (Math.abs(this.sin_p12 - 1) <= EPSLN) {
      Mlp = this.a * mlfn(e0, e1, e2, e3, HALF_PI);
      Ml = this.a * mlfn(e0, e1, e2, e3, lat);
      p5.x = this.x0 + (Mlp - Ml) * Math.sin(dlon);
      p5.y = this.y0 - (Mlp - Ml) * Math.cos(dlon);
      return p5;
    } else if (Math.abs(this.sin_p12 + 1) <= EPSLN) {
      Mlp = this.a * mlfn(e0, e1, e2, e3, HALF_PI);
      Ml = this.a * mlfn(e0, e1, e2, e3, lat);
      p5.x = this.x0 + (Mlp + Ml) * Math.sin(dlon);
      p5.y = this.y0 + (Mlp + Ml) * Math.cos(dlon);
      return p5;
    } else {
      tanphi = sinphi / cosphi;
      Nl1 = gN(this.a, this.e, this.sin_p12);
      Nl = gN(this.a, this.e, sinphi);
      psi = Math.atan((1 - this.es) * tanphi + this.es * Nl1 * this.sin_p12 / (Nl * cosphi));
      Az = Math.atan2(Math.sin(dlon), this.cos_p12 * Math.tan(psi) - this.sin_p12 * Math.cos(dlon));
      if (Az === 0) {
        s2 = Math.asin(this.cos_p12 * Math.sin(psi) - this.sin_p12 * Math.cos(psi));
      } else if (Math.abs(Math.abs(Az) - Math.PI) <= EPSLN) {
        s2 = -Math.asin(this.cos_p12 * Math.sin(psi) - this.sin_p12 * Math.cos(psi));
      } else {
        s2 = Math.asin(Math.sin(dlon) * Math.cos(psi) / Math.sin(Az));
      }
      G2 = this.e * this.sin_p12 / Math.sqrt(1 - this.es);
      H4 = this.e * this.cos_p12 * Math.cos(Az) / Math.sqrt(1 - this.es);
      GH = G2 * H4;
      Hs = H4 * H4;
      s22 = s2 * s2;
      s3 = s22 * s2;
      s4 = s3 * s2;
      s5 = s4 * s2;
      c2 = Nl1 * s2 * (1 - s22 * Hs * (1 - Hs) / 6 + s3 / 8 * GH * (1 - 2 * Hs) + s4 / 120 * (Hs * (4 - 7 * Hs) - 3 * G2 * G2 * (1 - 7 * Hs)) - s5 / 48 * GH);
      p5.x = this.x0 + c2 * Math.sin(Az);
      p5.y = this.y0 + c2 * Math.cos(Az);
      return p5;
    }
  }
}
function inverse$5(p5) {
  p5.x -= this.x0;
  p5.y -= this.y0;
  var rh, z2, sinz, cosz, lon, lat, con, e0, e1, e2, e3, Mlp, M2, N1, psi, Az, cosAz, tmp, A2, B3, D2, Ee, F2, sinpsi;
  if (this.sphere) {
    rh = Math.sqrt(p5.x * p5.x + p5.y * p5.y);
    if (rh > 2 * HALF_PI * this.a) {
      return;
    }
    z2 = rh / this.a;
    sinz = Math.sin(z2);
    cosz = Math.cos(z2);
    lon = this.long0;
    if (Math.abs(rh) <= EPSLN) {
      lat = this.lat0;
    } else {
      lat = asinz(cosz * this.sin_p12 + p5.y * sinz * this.cos_p12 / rh);
      con = Math.abs(this.lat0) - HALF_PI;
      if (Math.abs(con) <= EPSLN) {
        if (this.lat0 >= 0) {
          lon = adjust_lon(this.long0 + Math.atan2(p5.x, -p5.y));
        } else {
          lon = adjust_lon(this.long0 - Math.atan2(-p5.x, p5.y));
        }
      } else {
        lon = adjust_lon(this.long0 + Math.atan2(p5.x * sinz, rh * this.cos_p12 * cosz - p5.y * this.sin_p12 * sinz));
      }
    }
    p5.x = lon;
    p5.y = lat;
    return p5;
  } else {
    e0 = e0fn(this.es);
    e1 = e1fn(this.es);
    e2 = e2fn(this.es);
    e3 = e3fn(this.es);
    if (Math.abs(this.sin_p12 - 1) <= EPSLN) {
      Mlp = this.a * mlfn(e0, e1, e2, e3, HALF_PI);
      rh = Math.sqrt(p5.x * p5.x + p5.y * p5.y);
      M2 = Mlp - rh;
      lat = imlfn(M2 / this.a, e0, e1, e2, e3);
      lon = adjust_lon(this.long0 + Math.atan2(p5.x, -1 * p5.y));
      p5.x = lon;
      p5.y = lat;
      return p5;
    } else if (Math.abs(this.sin_p12 + 1) <= EPSLN) {
      Mlp = this.a * mlfn(e0, e1, e2, e3, HALF_PI);
      rh = Math.sqrt(p5.x * p5.x + p5.y * p5.y);
      M2 = rh - Mlp;
      lat = imlfn(M2 / this.a, e0, e1, e2, e3);
      lon = adjust_lon(this.long0 + Math.atan2(p5.x, p5.y));
      p5.x = lon;
      p5.y = lat;
      return p5;
    } else {
      rh = Math.sqrt(p5.x * p5.x + p5.y * p5.y);
      Az = Math.atan2(p5.x, p5.y);
      N1 = gN(this.a, this.e, this.sin_p12);
      cosAz = Math.cos(Az);
      tmp = this.e * this.cos_p12 * cosAz;
      A2 = -tmp * tmp / (1 - this.es);
      B3 = 3 * this.es * (1 - A2) * this.sin_p12 * this.cos_p12 * cosAz / (1 - this.es);
      D2 = rh / N1;
      Ee = D2 - A2 * (1 + A2) * Math.pow(D2, 3) / 6 - B3 * (1 + 3 * A2) * Math.pow(D2, 4) / 24;
      F2 = 1 - A2 * Ee * Ee / 2 - D2 * Ee * Ee * Ee / 6;
      psi = Math.asin(this.sin_p12 * Math.cos(Ee) + this.cos_p12 * Math.sin(Ee) * cosAz);
      lon = adjust_lon(this.long0 + Math.asin(Math.sin(Az) * Math.sin(Ee) / Math.cos(psi)));
      sinpsi = Math.sin(psi);
      lat = Math.atan2((sinpsi - this.es * F2 * this.sin_p12) * Math.tan(psi), sinpsi * (1 - this.es));
      p5.x = lon;
      p5.y = lat;
      return p5;
    }
  }
}
var names$5 = ["Azimuthal_Equidistant", "aeqd"];
var aeqd = {
  init: init$5,
  forward: forward$5,
  inverse: inverse$5,
  names: names$5
};
function init$4() {
  this.sin_p14 = Math.sin(this.lat0);
  this.cos_p14 = Math.cos(this.lat0);
}
function forward$4(p5) {
  var sinphi, cosphi;
  var dlon;
  var coslon;
  var ksp;
  var g2, x2, y2;
  var lon = p5.x;
  var lat = p5.y;
  dlon = adjust_lon(lon - this.long0);
  sinphi = Math.sin(lat);
  cosphi = Math.cos(lat);
  coslon = Math.cos(dlon);
  g2 = this.sin_p14 * sinphi + this.cos_p14 * cosphi * coslon;
  ksp = 1;
  if (g2 > 0 || Math.abs(g2) <= EPSLN) {
    x2 = this.a * ksp * cosphi * Math.sin(dlon);
    y2 = this.y0 + this.a * ksp * (this.cos_p14 * sinphi - this.sin_p14 * cosphi * coslon);
  }
  p5.x = x2;
  p5.y = y2;
  return p5;
}
function inverse$4(p5) {
  var rh;
  var z2;
  var sinz, cosz;
  var con;
  var lon, lat;
  p5.x -= this.x0;
  p5.y -= this.y0;
  rh = Math.sqrt(p5.x * p5.x + p5.y * p5.y);
  z2 = asinz(rh / this.a);
  sinz = Math.sin(z2);
  cosz = Math.cos(z2);
  lon = this.long0;
  if (Math.abs(rh) <= EPSLN) {
    lat = this.lat0;
    p5.x = lon;
    p5.y = lat;
    return p5;
  }
  lat = asinz(cosz * this.sin_p14 + p5.y * sinz * this.cos_p14 / rh);
  con = Math.abs(this.lat0) - HALF_PI;
  if (Math.abs(con) <= EPSLN) {
    if (this.lat0 >= 0) {
      lon = adjust_lon(this.long0 + Math.atan2(p5.x, -p5.y));
    } else {
      lon = adjust_lon(this.long0 - Math.atan2(-p5.x, p5.y));
    }
    p5.x = lon;
    p5.y = lat;
    return p5;
  }
  lon = adjust_lon(this.long0 + Math.atan2(p5.x * sinz, rh * this.cos_p14 * cosz - p5.y * this.sin_p14 * sinz));
  p5.x = lon;
  p5.y = lat;
  return p5;
}
var names$4 = ["ortho"];
var ortho = {
  init: init$4,
  forward: forward$4,
  inverse: inverse$4,
  names: names$4
};
var FACE_ENUM = {
  FRONT: 1,
  RIGHT: 2,
  BACK: 3,
  LEFT: 4,
  TOP: 5,
  BOTTOM: 6
};
var AREA_ENUM = {
  AREA_0: 1,
  AREA_1: 2,
  AREA_2: 3,
  AREA_3: 4
};
function init$3() {
  this.x0 = this.x0 || 0;
  this.y0 = this.y0 || 0;
  this.lat0 = this.lat0 || 0;
  this.long0 = this.long0 || 0;
  this.lat_ts = this.lat_ts || 0;
  this.title = this.title || "Quadrilateralized Spherical Cube";
  if (this.lat0 >= HALF_PI - FORTPI / 2) {
    this.face = FACE_ENUM.TOP;
  } else if (this.lat0 <= -(HALF_PI - FORTPI / 2)) {
    this.face = FACE_ENUM.BOTTOM;
  } else if (Math.abs(this.long0) <= FORTPI) {
    this.face = FACE_ENUM.FRONT;
  } else if (Math.abs(this.long0) <= HALF_PI + FORTPI) {
    this.face = this.long0 > 0 ? FACE_ENUM.RIGHT : FACE_ENUM.LEFT;
  } else {
    this.face = FACE_ENUM.BACK;
  }
  if (this.es !== 0) {
    this.one_minus_f = 1 - (this.a - this.b) / this.a;
    this.one_minus_f_squared = this.one_minus_f * this.one_minus_f;
  }
}
function forward$3(p5) {
  var xy = { x: 0, y: 0 };
  var lat, lon;
  var theta, phi;
  var t3, mu;
  var area = { value: 0 };
  p5.x -= this.long0;
  if (this.es !== 0) {
    lat = Math.atan(this.one_minus_f_squared * Math.tan(p5.y));
  } else {
    lat = p5.y;
  }
  lon = p5.x;
  if (this.face === FACE_ENUM.TOP) {
    phi = HALF_PI - lat;
    if (lon >= FORTPI && lon <= HALF_PI + FORTPI) {
      area.value = AREA_ENUM.AREA_0;
      theta = lon - HALF_PI;
    } else if (lon > HALF_PI + FORTPI || lon <= -(HALF_PI + FORTPI)) {
      area.value = AREA_ENUM.AREA_1;
      theta = lon > 0 ? lon - SPI : lon + SPI;
    } else if (lon > -(HALF_PI + FORTPI) && lon <= -FORTPI) {
      area.value = AREA_ENUM.AREA_2;
      theta = lon + HALF_PI;
    } else {
      area.value = AREA_ENUM.AREA_3;
      theta = lon;
    }
  } else if (this.face === FACE_ENUM.BOTTOM) {
    phi = HALF_PI + lat;
    if (lon >= FORTPI && lon <= HALF_PI + FORTPI) {
      area.value = AREA_ENUM.AREA_0;
      theta = -lon + HALF_PI;
    } else if (lon < FORTPI && lon >= -FORTPI) {
      area.value = AREA_ENUM.AREA_1;
      theta = -lon;
    } else if (lon < -FORTPI && lon >= -(HALF_PI + FORTPI)) {
      area.value = AREA_ENUM.AREA_2;
      theta = -lon - HALF_PI;
    } else {
      area.value = AREA_ENUM.AREA_3;
      theta = lon > 0 ? -lon + SPI : -lon - SPI;
    }
  } else {
    var q2, r2, s2;
    var sinlat, coslat;
    var sinlon, coslon;
    if (this.face === FACE_ENUM.RIGHT) {
      lon = qsc_shift_lon_origin(lon, +HALF_PI);
    } else if (this.face === FACE_ENUM.BACK) {
      lon = qsc_shift_lon_origin(lon, +SPI);
    } else if (this.face === FACE_ENUM.LEFT) {
      lon = qsc_shift_lon_origin(lon, -HALF_PI);
    }
    sinlat = Math.sin(lat);
    coslat = Math.cos(lat);
    sinlon = Math.sin(lon);
    coslon = Math.cos(lon);
    q2 = coslat * coslon;
    r2 = coslat * sinlon;
    s2 = sinlat;
    if (this.face === FACE_ENUM.FRONT) {
      phi = Math.acos(q2);
      theta = qsc_fwd_equat_face_theta(phi, s2, r2, area);
    } else if (this.face === FACE_ENUM.RIGHT) {
      phi = Math.acos(r2);
      theta = qsc_fwd_equat_face_theta(phi, s2, -q2, area);
    } else if (this.face === FACE_ENUM.BACK) {
      phi = Math.acos(-q2);
      theta = qsc_fwd_equat_face_theta(phi, s2, -r2, area);
    } else if (this.face === FACE_ENUM.LEFT) {
      phi = Math.acos(-r2);
      theta = qsc_fwd_equat_face_theta(phi, s2, q2, area);
    } else {
      phi = theta = 0;
      area.value = AREA_ENUM.AREA_0;
    }
  }
  mu = Math.atan(12 / SPI * (theta + Math.acos(Math.sin(theta) * Math.cos(FORTPI)) - HALF_PI));
  t3 = Math.sqrt((1 - Math.cos(phi)) / (Math.cos(mu) * Math.cos(mu)) / (1 - Math.cos(Math.atan(1 / Math.cos(theta)))));
  if (area.value === AREA_ENUM.AREA_1) {
    mu += HALF_PI;
  } else if (area.value === AREA_ENUM.AREA_2) {
    mu += SPI;
  } else if (area.value === AREA_ENUM.AREA_3) {
    mu += 1.5 * SPI;
  }
  xy.x = t3 * Math.cos(mu);
  xy.y = t3 * Math.sin(mu);
  xy.x = xy.x * this.a + this.x0;
  xy.y = xy.y * this.a + this.y0;
  p5.x = xy.x;
  p5.y = xy.y;
  return p5;
}
function inverse$3(p5) {
  var lp = { lam: 0, phi: 0 };
  var mu, nu, cosmu, tannu;
  var tantheta, theta, cosphi, phi;
  var t3;
  var area = { value: 0 };
  p5.x = (p5.x - this.x0) / this.a;
  p5.y = (p5.y - this.y0) / this.a;
  nu = Math.atan(Math.sqrt(p5.x * p5.x + p5.y * p5.y));
  mu = Math.atan2(p5.y, p5.x);
  if (p5.x >= 0 && p5.x >= Math.abs(p5.y)) {
    area.value = AREA_ENUM.AREA_0;
  } else if (p5.y >= 0 && p5.y >= Math.abs(p5.x)) {
    area.value = AREA_ENUM.AREA_1;
    mu -= HALF_PI;
  } else if (p5.x < 0 && -p5.x >= Math.abs(p5.y)) {
    area.value = AREA_ENUM.AREA_2;
    mu = mu < 0 ? mu + SPI : mu - SPI;
  } else {
    area.value = AREA_ENUM.AREA_3;
    mu += HALF_PI;
  }
  t3 = SPI / 12 * Math.tan(mu);
  tantheta = Math.sin(t3) / (Math.cos(t3) - 1 / Math.sqrt(2));
  theta = Math.atan(tantheta);
  cosmu = Math.cos(mu);
  tannu = Math.tan(nu);
  cosphi = 1 - cosmu * cosmu * tannu * tannu * (1 - Math.cos(Math.atan(1 / Math.cos(theta))));
  if (cosphi < -1) {
    cosphi = -1;
  } else if (cosphi > 1) {
    cosphi = 1;
  }
  if (this.face === FACE_ENUM.TOP) {
    phi = Math.acos(cosphi);
    lp.phi = HALF_PI - phi;
    if (area.value === AREA_ENUM.AREA_0) {
      lp.lam = theta + HALF_PI;
    } else if (area.value === AREA_ENUM.AREA_1) {
      lp.lam = theta < 0 ? theta + SPI : theta - SPI;
    } else if (area.value === AREA_ENUM.AREA_2) {
      lp.lam = theta - HALF_PI;
    } else {
      lp.lam = theta;
    }
  } else if (this.face === FACE_ENUM.BOTTOM) {
    phi = Math.acos(cosphi);
    lp.phi = phi - HALF_PI;
    if (area.value === AREA_ENUM.AREA_0) {
      lp.lam = -theta + HALF_PI;
    } else if (area.value === AREA_ENUM.AREA_1) {
      lp.lam = -theta;
    } else if (area.value === AREA_ENUM.AREA_2) {
      lp.lam = -theta - HALF_PI;
    } else {
      lp.lam = theta < 0 ? -theta - SPI : -theta + SPI;
    }
  } else {
    var q2, r2, s2;
    q2 = cosphi;
    t3 = q2 * q2;
    if (t3 >= 1) {
      s2 = 0;
    } else {
      s2 = Math.sqrt(1 - t3) * Math.sin(theta);
    }
    t3 += s2 * s2;
    if (t3 >= 1) {
      r2 = 0;
    } else {
      r2 = Math.sqrt(1 - t3);
    }
    if (area.value === AREA_ENUM.AREA_1) {
      t3 = r2;
      r2 = -s2;
      s2 = t3;
    } else if (area.value === AREA_ENUM.AREA_2) {
      r2 = -r2;
      s2 = -s2;
    } else if (area.value === AREA_ENUM.AREA_3) {
      t3 = r2;
      r2 = s2;
      s2 = -t3;
    }
    if (this.face === FACE_ENUM.RIGHT) {
      t3 = q2;
      q2 = -r2;
      r2 = t3;
    } else if (this.face === FACE_ENUM.BACK) {
      q2 = -q2;
      r2 = -r2;
    } else if (this.face === FACE_ENUM.LEFT) {
      t3 = q2;
      q2 = r2;
      r2 = -t3;
    }
    lp.phi = Math.acos(-s2) - HALF_PI;
    lp.lam = Math.atan2(r2, q2);
    if (this.face === FACE_ENUM.RIGHT) {
      lp.lam = qsc_shift_lon_origin(lp.lam, -HALF_PI);
    } else if (this.face === FACE_ENUM.BACK) {
      lp.lam = qsc_shift_lon_origin(lp.lam, -SPI);
    } else if (this.face === FACE_ENUM.LEFT) {
      lp.lam = qsc_shift_lon_origin(lp.lam, +HALF_PI);
    }
  }
  if (this.es !== 0) {
    var invert_sign;
    var tanphi, xa;
    invert_sign = lp.phi < 0 ? 1 : 0;
    tanphi = Math.tan(lp.phi);
    xa = this.b / Math.sqrt(tanphi * tanphi + this.one_minus_f_squared);
    lp.phi = Math.atan(Math.sqrt(this.a * this.a - xa * xa) / (this.one_minus_f * xa));
    if (invert_sign) {
      lp.phi = -lp.phi;
    }
  }
  lp.lam += this.long0;
  p5.x = lp.lam;
  p5.y = lp.phi;
  return p5;
}
function qsc_fwd_equat_face_theta(phi, y2, x2, area) {
  var theta;
  if (phi < EPSLN) {
    area.value = AREA_ENUM.AREA_0;
    theta = 0;
  } else {
    theta = Math.atan2(y2, x2);
    if (Math.abs(theta) <= FORTPI) {
      area.value = AREA_ENUM.AREA_0;
    } else if (theta > FORTPI && theta <= HALF_PI + FORTPI) {
      area.value = AREA_ENUM.AREA_1;
      theta -= HALF_PI;
    } else if (theta > HALF_PI + FORTPI || theta <= -(HALF_PI + FORTPI)) {
      area.value = AREA_ENUM.AREA_2;
      theta = theta >= 0 ? theta - SPI : theta + SPI;
    } else {
      area.value = AREA_ENUM.AREA_3;
      theta += HALF_PI;
    }
  }
  return theta;
}
function qsc_shift_lon_origin(lon, offset2) {
  var slon = lon + offset2;
  if (slon < -SPI) {
    slon += TWO_PI;
  } else if (slon > +SPI) {
    slon -= TWO_PI;
  }
  return slon;
}
var names$3 = ["Quadrilateralized Spherical Cube", "Quadrilateralized_Spherical_Cube", "qsc"];
var qsc = {
  init: init$3,
  forward: forward$3,
  inverse: inverse$3,
  names: names$3
};
var COEFS_X = [
  [1, 22199e-21, -715515e-10, 31103e-10],
  [0.9986, -482243e-9, -24897e-9, -13309e-10],
  [0.9954, -83103e-8, -448605e-10, -986701e-12],
  [0.99, -135364e-8, -59661e-9, 36777e-10],
  [0.9822, -167442e-8, -449547e-11, -572411e-11],
  [0.973, -214868e-8, -903571e-10, 18736e-12],
  [0.96, -305085e-8, -900761e-10, 164917e-11],
  [0.9427, -382792e-8, -653386e-10, -26154e-10],
  [0.9216, -467746e-8, -10457e-8, 481243e-11],
  [0.8962, -536223e-8, -323831e-10, -543432e-11],
  [0.8679, -609363e-8, -113898e-9, 332484e-11],
  [0.835, -698325e-8, -640253e-10, 934959e-12],
  [0.7986, -755338e-8, -500009e-10, 935324e-12],
  [0.7597, -798324e-8, -35971e-9, -227626e-11],
  [0.7186, -851367e-8, -701149e-10, -86303e-10],
  [0.6732, -986209e-8, -199569e-9, 191974e-10],
  [0.6213, -0.010418, 883923e-10, 624051e-11],
  [0.5722, -906601e-8, 182e-6, 624051e-11],
  [0.5322, -677797e-8, 275608e-9, 624051e-11]
];
var COEFS_Y = [
  [-520417e-23, 0.0124, 121431e-23, -845284e-16],
  [0.062, 0.0124, -126793e-14, 422642e-15],
  [0.124, 0.0124, 507171e-14, -160604e-14],
  [0.186, 0.0123999, -190189e-13, 600152e-14],
  [0.248, 0.0124002, 710039e-13, -224e-10],
  [0.31, 0.0123992, -264997e-12, 835986e-13],
  [0.372, 0.0124029, 988983e-12, -311994e-12],
  [0.434, 0.0123893, -369093e-11, -435621e-12],
  [0.4958, 0.0123198, -102252e-10, -345523e-12],
  [0.5571, 0.0121916, -154081e-10, -582288e-12],
  [0.6176, 0.0119938, -241424e-10, -525327e-12],
  [0.6769, 0.011713, -320223e-10, -516405e-12],
  [0.7346, 0.0113541, -397684e-10, -609052e-12],
  [0.7903, 0.0109107, -489042e-10, -104739e-11],
  [0.8435, 0.0103431, -64615e-9, -140374e-14],
  [0.8936, 969686e-8, -64636e-9, -8547e-9],
  [0.9394, 840947e-8, -192841e-9, -42106e-10],
  [0.9761, 616527e-8, -256e-6, -42106e-10],
  [1, 328947e-8, -319159e-9, -42106e-10]
];
var FXC = 0.8487;
var FYC = 1.3523;
var C1 = R2D / 5;
var RC1 = 1 / C1;
var NODES = 18;
var poly3_val = function(coefs, x2) {
  return coefs[0] + x2 * (coefs[1] + x2 * (coefs[2] + x2 * coefs[3]));
};
var poly3_der = function(coefs, x2) {
  return coefs[1] + x2 * (2 * coefs[2] + x2 * 3 * coefs[3]);
};
function newton_rapshon(f_df, start2, max_err, iters) {
  var x2 = start2;
  for (; iters; --iters) {
    var upd = f_df(x2);
    x2 -= upd;
    if (Math.abs(upd) < max_err) {
      break;
    }
  }
  return x2;
}
function init$2() {
  this.x0 = this.x0 || 0;
  this.y0 = this.y0 || 0;
  this.long0 = this.long0 || 0;
  this.es = 0;
  this.title = this.title || "Robinson";
}
function forward$2(ll) {
  var lon = adjust_lon(ll.x - this.long0);
  var dphi = Math.abs(ll.y);
  var i2 = Math.floor(dphi * C1);
  if (i2 < 0) {
    i2 = 0;
  } else if (i2 >= NODES) {
    i2 = NODES - 1;
  }
  dphi = R2D * (dphi - RC1 * i2);
  var xy = {
    x: poly3_val(COEFS_X[i2], dphi) * lon,
    y: poly3_val(COEFS_Y[i2], dphi)
  };
  if (ll.y < 0) {
    xy.y = -xy.y;
  }
  xy.x = xy.x * this.a * FXC + this.x0;
  xy.y = xy.y * this.a * FYC + this.y0;
  return xy;
}
function inverse$2(xy) {
  var ll = {
    x: (xy.x - this.x0) / (this.a * FXC),
    y: Math.abs(xy.y - this.y0) / (this.a * FYC)
  };
  if (ll.y >= 1) {
    ll.x /= COEFS_X[NODES][0];
    ll.y = xy.y < 0 ? -HALF_PI : HALF_PI;
  } else {
    var i2 = Math.floor(ll.y * NODES);
    if (i2 < 0) {
      i2 = 0;
    } else if (i2 >= NODES) {
      i2 = NODES - 1;
    }
    for (; ; ) {
      if (COEFS_Y[i2][0] > ll.y) {
        --i2;
      } else if (COEFS_Y[i2 + 1][0] <= ll.y) {
        ++i2;
      } else {
        break;
      }
    }
    var coefs = COEFS_Y[i2];
    var t3 = 5 * (ll.y - coefs[0]) / (COEFS_Y[i2 + 1][0] - coefs[0]);
    t3 = newton_rapshon(function(x2) {
      return (poly3_val(coefs, x2) - ll.y) / poly3_der(coefs, x2);
    }, t3, EPSLN, 100);
    ll.x /= poly3_val(COEFS_X[i2], t3);
    ll.y = (5 * i2 + t3) * D2R$1;
    if (xy.y < 0) {
      ll.y = -ll.y;
    }
  }
  ll.x = adjust_lon(ll.x + this.long0);
  return ll;
}
var names$2 = ["Robinson", "robin"];
var robin = {
  init: init$2,
  forward: forward$2,
  inverse: inverse$2,
  names: names$2
};
function init$1() {
  this.name = "geocent";
}
function forward$1(p5) {
  var point = geodeticToGeocentric(p5, this.es, this.a);
  return point;
}
function inverse$1(p5) {
  var point = geocentricToGeodetic(p5, this.es, this.a, this.b);
  return point;
}
var names$1 = ["Geocentric", "geocentric", "geocent", "Geocent"];
var geocent = {
  init: init$1,
  forward: forward$1,
  inverse: inverse$1,
  names: names$1
};
var mode = {
  N_POLE: 0,
  S_POLE: 1,
  EQUIT: 2,
  OBLIQ: 3
};
var params = {
  h: { def: 1e5, num: true },
  azi: { def: 0, num: true, degrees: true },
  tilt: { def: 0, num: true, degrees: true },
  long0: { def: 0, num: true },
  lat0: { def: 0, num: true }
};
function init() {
  Object.keys(params).forEach(function(p5) {
    if (typeof this[p5] === "undefined") {
      this[p5] = params[p5].def;
    } else if (params[p5].num && isNaN(this[p5])) {
      throw new Error("Invalid parameter value, must be numeric " + p5 + " = " + this[p5]);
    } else if (params[p5].num) {
      this[p5] = parseFloat(this[p5]);
    }
    if (params[p5].degrees) {
      this[p5] = this[p5] * D2R$1;
    }
  }.bind(this));
  if (Math.abs(Math.abs(this.lat0) - HALF_PI) < EPSLN) {
    this.mode = this.lat0 < 0 ? mode.S_POLE : mode.N_POLE;
  } else if (Math.abs(this.lat0) < EPSLN) {
    this.mode = mode.EQUIT;
  } else {
    this.mode = mode.OBLIQ;
    this.sinph0 = Math.sin(this.lat0);
    this.cosph0 = Math.cos(this.lat0);
  }
  this.pn1 = this.h / this.a;
  if (this.pn1 <= 0 || this.pn1 > 1e10) {
    throw new Error("Invalid height");
  }
  this.p = 1 + this.pn1;
  this.rp = 1 / this.p;
  this.h1 = 1 / this.pn1;
  this.pfact = (this.p + 1) * this.h1;
  this.es = 0;
  var omega = this.tilt;
  var gamma = this.azi;
  this.cg = Math.cos(gamma);
  this.sg = Math.sin(gamma);
  this.cw = Math.cos(omega);
  this.sw = Math.sin(omega);
}
function forward(p5) {
  p5.x -= this.long0;
  var sinphi = Math.sin(p5.y);
  var cosphi = Math.cos(p5.y);
  var coslam = Math.cos(p5.x);
  var x2, y2;
  switch (this.mode) {
    case mode.OBLIQ:
      y2 = this.sinph0 * sinphi + this.cosph0 * cosphi * coslam;
      break;
    case mode.EQUIT:
      y2 = cosphi * coslam;
      break;
    case mode.S_POLE:
      y2 = -sinphi;
      break;
    case mode.N_POLE:
      y2 = sinphi;
      break;
  }
  y2 = this.pn1 / (this.p - y2);
  x2 = y2 * cosphi * Math.sin(p5.x);
  switch (this.mode) {
    case mode.OBLIQ:
      y2 *= this.cosph0 * sinphi - this.sinph0 * cosphi * coslam;
      break;
    case mode.EQUIT:
      y2 *= sinphi;
      break;
    case mode.N_POLE:
      y2 *= -(cosphi * coslam);
      break;
    case mode.S_POLE:
      y2 *= cosphi * coslam;
      break;
  }
  var yt2, ba;
  yt2 = y2 * this.cg + x2 * this.sg;
  ba = 1 / (yt2 * this.sw * this.h1 + this.cw);
  x2 = (x2 * this.cg - y2 * this.sg) * this.cw * ba;
  y2 = yt2 * ba;
  p5.x = x2 * this.a;
  p5.y = y2 * this.a;
  return p5;
}
function inverse(p5) {
  p5.x /= this.a;
  p5.y /= this.a;
  var r2 = { x: p5.x, y: p5.y };
  var bm, bq, yt2;
  yt2 = 1 / (this.pn1 - p5.y * this.sw);
  bm = this.pn1 * p5.x * yt2;
  bq = this.pn1 * p5.y * this.cw * yt2;
  p5.x = bm * this.cg + bq * this.sg;
  p5.y = bq * this.cg - bm * this.sg;
  var rh = hypot(p5.x, p5.y);
  if (Math.abs(rh) < EPSLN) {
    r2.x = 0;
    r2.y = p5.y;
  } else {
    var cosz, sinz;
    sinz = 1 - rh * rh * this.pfact;
    sinz = (this.p - Math.sqrt(sinz)) / (this.pn1 / rh + rh / this.pn1);
    cosz = Math.sqrt(1 - sinz * sinz);
    switch (this.mode) {
      case mode.OBLIQ:
        r2.y = Math.asin(cosz * this.sinph0 + p5.y * sinz * this.cosph0 / rh);
        p5.y = (cosz - this.sinph0 * Math.sin(r2.y)) * rh;
        p5.x *= sinz * this.cosph0;
        break;
      case mode.EQUIT:
        r2.y = Math.asin(p5.y * sinz / rh);
        p5.y = cosz * rh;
        p5.x *= sinz;
        break;
      case mode.N_POLE:
        r2.y = Math.asin(cosz);
        p5.y = -p5.y;
        break;
      case mode.S_POLE:
        r2.y = -Math.asin(cosz);
        break;
    }
    r2.x = Math.atan2(p5.x, p5.y);
  }
  p5.x = r2.x + this.long0;
  p5.y = r2.y;
  return p5;
}
var names = ["Tilted_Perspective", "tpers"];
var tpers = {
  init,
  forward,
  inverse,
  names
};
function includedProjections(proj42) {
  proj42.Proj.projections.add(tmerc);
  proj42.Proj.projections.add(etmerc);
  proj42.Proj.projections.add(utm);
  proj42.Proj.projections.add(sterea);
  proj42.Proj.projections.add(stere);
  proj42.Proj.projections.add(somerc);
  proj42.Proj.projections.add(omerc);
  proj42.Proj.projections.add(lcc);
  proj42.Proj.projections.add(krovak);
  proj42.Proj.projections.add(cass);
  proj42.Proj.projections.add(laea);
  proj42.Proj.projections.add(aea);
  proj42.Proj.projections.add(gnom);
  proj42.Proj.projections.add(cea);
  proj42.Proj.projections.add(eqc);
  proj42.Proj.projections.add(poly);
  proj42.Proj.projections.add(nzmg);
  proj42.Proj.projections.add(mill);
  proj42.Proj.projections.add(sinu);
  proj42.Proj.projections.add(moll);
  proj42.Proj.projections.add(eqdc);
  proj42.Proj.projections.add(vandg);
  proj42.Proj.projections.add(aeqd);
  proj42.Proj.projections.add(ortho);
  proj42.Proj.projections.add(qsc);
  proj42.Proj.projections.add(robin);
  proj42.Proj.projections.add(geocent);
  proj42.Proj.projections.add(tpers);
}
proj4.defaultDatum = "WGS84";
proj4.Proj = Projection$1;
proj4.WGS84 = new proj4.Proj("WGS84");
proj4.Point = Point$2;
proj4.toPoint = common;
proj4.defs = defs;
proj4.nadgrid = nadgrid;
proj4.transform = transform$2;
proj4.mgrs = mgrs;
proj4.version = "__VERSION__";
includedProjections(proj4);
function register(proj42) {
  var projCodes = Object.keys(proj42.defs);
  var len = projCodes.length;
  var i2, j2;
  for (i2 = 0; i2 < len; ++i2) {
    var code = projCodes[i2];
    if (!get$3(code)) {
      var def = proj42.defs(code);
      var units2 = def.units;
      if (!units2 && def.projName === "longlat") {
        units2 = Units$2.DEGREES;
      }
      addProjection(new Projection$3({
        code,
        axisOrientation: def.axis,
        metersPerUnit: def.to_meter,
        units: units2
      }));
    }
  }
  for (i2 = 0; i2 < len; ++i2) {
    var code1 = projCodes[i2];
    var proj1 = get$3(code1);
    for (j2 = 0; j2 < len; ++j2) {
      var code2 = projCodes[j2];
      var proj2 = get$3(code2);
      if (!get$4(code1, code2)) {
        if (proj42.defs[code1] === proj42.defs[code2]) {
          addEquivalentProjections([proj1, proj2]);
        } else {
          var transform2 = proj42(code1, code2);
          addCoordinateTransforms(proj1, proj2, createSafeCoordinateTransform(proj1, proj2, transform2.forward), createSafeCoordinateTransform(proj2, proj1, transform2.inverse));
        }
      }
    }
  }
}
var _sfc_main$11 = {
  name: "ol-projection-register",
  setup(props) {
    const {
      projectionName,
      projectionDef,
      projectionExtent
    } = toRefs(props);
    proj4.defs(projectionName.value, projectionDef.value);
    register(proj4);
    const projection = new Projection$3({
      code: projectionName.value,
      extent: projectionExtent.value
    });
    return {
      projection
    };
  },
  props: {
    projectionName: {
      type: String
    },
    projectionDef: {
      type: String
    },
    projectionExtent: {
      type: Array
    }
  }
};
function _sfc_render$11(_ctx, _cache, $props, $setup, $data, $options) {
  return createCommentVNode("", true);
}
var Projection = _export_sfc(_sfc_main$11, [["render", _sfc_render$11]]);
function install$8(app) {
  if (install$8.installed) {
    return;
  }
  install$8.installed = true;
  app.component(Map$2.name, Map$2);
  app.component(View.name, View);
  app.component(Feature.name, Feature);
  app.component(Overlay.name, Overlay);
  app.component(GeoLocation.name, GeoLocation);
  app.component(Projection.name, Projection);
}
var Map$1 = Object.freeze(Object.defineProperty({
  __proto__: null,
  "default": install$8,
  install: install$8,
  Map: Map$2,
  View,
  Feature,
  Overlay,
  GeoLocation,
  Projection
}, Symbol.toStringTag, { value: "Module" }));
var TileProperty = {
  PRELOAD: "preload",
  USE_INTERIM_TILES_ON_ERROR: "useInterimTilesOnError"
};
var __extends$_ = globalThis && globalThis.__extends || function() {
  var extendStatics2 = function(d2, b2) {
    extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {
      d3.__proto__ = b3;
    } || function(d3, b3) {
      for (var p5 in b3)
        if (Object.prototype.hasOwnProperty.call(b3, p5))
          d3[p5] = b3[p5];
    };
    return extendStatics2(d2, b2);
  };
  return function(d2, b2) {
    if (typeof b2 !== "function" && b2 !== null)
      throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
    extendStatics2(d2, b2);
    function __() {
      this.constructor = d2;
    }
    d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
  };
}();
var BaseTileLayer = function(_super) {
  __extends$_(BaseTileLayer2, _super);
  function BaseTileLayer2(opt_options) {
    var _this = this;
    var options = opt_options ? opt_options : {};
    var baseOptions = assign({}, options);
    delete baseOptions.preload;
    delete baseOptions.useInterimTilesOnError;
    _this = _super.call(this, baseOptions) || this;
    _this.on;
    _this.once;
    _this.un;
    _this.setPreload(options.preload !== void 0 ? options.preload : 0);
    _this.setUseInterimTilesOnError(options.useInterimTilesOnError !== void 0 ? options.useInterimTilesOnError : true);
    return _this;
  }
  BaseTileLayer2.prototype.getPreload = function() {
    return this.get(TileProperty.PRELOAD);
  };
  BaseTileLayer2.prototype.setPreload = function(preload) {
    this.set(TileProperty.PRELOAD, preload);
  };
  BaseTileLayer2.prototype.getUseInterimTilesOnError = function() {
    return this.get(TileProperty.USE_INTERIM_TILES_ON_ERROR);
  };
  BaseTileLayer2.prototype.setUseInterimTilesOnError = function(useInterimTilesOnError) {
    this.set(TileProperty.USE_INTERIM_TILES_ON_ERROR, useInterimTilesOnError);
  };
  BaseTileLayer2.prototype.getData = function(pixel) {
    return _super.prototype.getData.call(this, pixel);
  };
  return BaseTileLayer2;
}(ol_layer_Base);
var BaseTileLayer$1 = BaseTileLayer;
var __extends$Z = globalThis && globalThis.__extends || function() {
  var extendStatics2 = function(d2, b2) {
    extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {
      d3.__proto__ = b3;
    } || function(d3, b3) {
      for (var p5 in b3)
        if (Object.prototype.hasOwnProperty.call(b3, p5))
          d3[p5] = b3[p5];
    };
    return extendStatics2(d2, b2);
  };
  return function(d2, b2) {
    if (typeof b2 !== "function" && b2 !== null)
      throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
    extendStatics2(d2, b2);
    function __() {
      this.constructor = d2;
    }
    d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
  };
}();
var Tile = function(_super) {
  __extends$Z(Tile2, _super);
  function Tile2(tileCoord, state, opt_options) {
    var _this = _super.call(this) || this;
    var options = opt_options ? opt_options : {};
    _this.tileCoord = tileCoord;
    _this.state = state;
    _this.interimTile = null;
    _this.key = "";
    _this.transition_ = options.transition === void 0 ? 250 : options.transition;
    _this.transitionStarts_ = {};
    _this.interpolate = !!options.interpolate;
    return _this;
  }
  Tile2.prototype.changed = function() {
    this.dispatchEvent(EventType.CHANGE);
  };
  Tile2.prototype.release = function() {
  };
  Tile2.prototype.getKey = function() {
    return this.key + "/" + this.tileCoord;
  };
  Tile2.prototype.getInterimTile = function() {
    if (!this.interimTile) {
      return this;
    }
    var tile2 = this.interimTile;
    do {
      if (tile2.getState() == TileState.LOADED) {
        this.transition_ = 0;
        return tile2;
      }
      tile2 = tile2.interimTile;
    } while (tile2);
    return this;
  };
  Tile2.prototype.refreshInterimChain = function() {
    if (!this.interimTile) {
      return;
    }
    var tile2 = this.interimTile;
    var prev = this;
    do {
      if (tile2.getState() == TileState.LOADED) {
        tile2.interimTile = null;
        break;
      } else if (tile2.getState() == TileState.LOADING) {
        prev = tile2;
      } else if (tile2.getState() == TileState.IDLE) {
        prev.interimTile = tile2.interimTile;
      } else {
        prev = tile2;
      }
      tile2 = prev.interimTile;
    } while (tile2);
  };
  Tile2.prototype.getTileCoord = function() {
    return this.tileCoord;
  };
  Tile2.prototype.getState = function() {
    return this.state;
  };
  Tile2.prototype.setState = function(state) {
    if (this.state !== TileState.ERROR && this.state > state) {
      throw new Error("Tile load sequence violation");
    }
    this.state = state;
    this.changed();
  };
  Tile2.prototype.load = function() {
    abstract();
  };
  Tile2.prototype.getAlpha = function(id, time2) {
    if (!this.transition_) {
      return 1;
    }
    var start2 = this.transitionStarts_[id];
    if (!start2) {
      start2 = time2;
      this.transitionStarts_[id] = start2;
    } else if (start2 === -1) {
      return 1;
    }
    var delta = time2 - start2 + 1e3 / 60;
    if (delta >= this.transition_) {
      return 1;
    }
    return easeIn(delta / this.transition_);
  };
  Tile2.prototype.inTransition = function(id) {
    if (!this.transition_) {
      return false;
    }
    return this.transitionStarts_[id] !== -1;
  };
  Tile2.prototype.endTransition = function(id) {
    if (this.transition_) {
      this.transitionStarts_[id] = -1;
    }
  };
  return Tile2;
}(EventTarget);
var Tile$1 = Tile;
var __extends$Y = globalThis && globalThis.__extends || function() {
  var extendStatics2 = function(d2, b2) {
    extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {
      d3.__proto__ = b3;
    } || function(d3, b3) {
      for (var p5 in b3)
        if (Object.prototype.hasOwnProperty.call(b3, p5))
          d3[p5] = b3[p5];
    };
    return extendStatics2(d2, b2);
  };
  return function(d2, b2) {
    if (typeof b2 !== "function" && b2 !== null)
      throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
    extendStatics2(d2, b2);
    function __() {
      this.constructor = d2;
    }
    d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
  };
}();
var ImageTile = function(_super) {
  __extends$Y(ImageTile2, _super);
  function ImageTile2(tileCoord, state, src, crossOrigin, tileLoadFunction, opt_options) {
    var _this = _super.call(this, tileCoord, state, opt_options) || this;
    _this.crossOrigin_ = crossOrigin;
    _this.src_ = src;
    _this.key = src;
    _this.image_ = new Image();
    if (crossOrigin !== null) {
      _this.image_.crossOrigin = crossOrigin;
    }
    _this.unlisten_ = null;
    _this.tileLoadFunction_ = tileLoadFunction;
    return _this;
  }
  ImageTile2.prototype.getImage = function() {
    return this.image_;
  };
  ImageTile2.prototype.setImage = function(element) {
    this.image_ = element;
    this.state = TileState.LOADED;
    this.unlistenImage_();
    this.changed();
  };
  ImageTile2.prototype.handleImageError_ = function() {
    this.state = TileState.ERROR;
    this.unlistenImage_();
    this.image_ = getBlankImage();
    this.changed();
  };
  ImageTile2.prototype.handleImageLoad_ = function() {
    var image2 = this.image_;
    if (image2.naturalWidth && image2.naturalHeight) {
      this.state = TileState.LOADED;
    } else {
      this.state = TileState.EMPTY;
    }
    this.unlistenImage_();
    this.changed();
  };
  ImageTile2.prototype.load = function() {
    if (this.state == TileState.ERROR) {
      this.state = TileState.IDLE;
      this.image_ = new Image();
      if (this.crossOrigin_ !== null) {
        this.image_.crossOrigin = this.crossOrigin_;
      }
    }
    if (this.state == TileState.IDLE) {
      this.state = TileState.LOADING;
      this.changed();
      this.tileLoadFunction_(this, this.src_);
      this.unlisten_ = listenImage(this.image_, this.handleImageLoad_.bind(this), this.handleImageError_.bind(this));
    }
  };
  ImageTile2.prototype.unlistenImage_ = function() {
    if (this.unlisten_) {
      this.unlisten_();
      this.unlisten_ = null;
    }
  };
  return ImageTile2;
}(Tile$1);
function getBlankImage() {
  var ctx = createCanvasContext2D(1, 1);
  ctx.fillStyle = "rgba(0,0,0,0)";
  ctx.fillRect(0, 0, 1, 1);
  return ctx.canvas;
}
var ImageTile$1 = ImageTile;
var ERROR_THRESHOLD = 0.5;
var ENABLE_RASTER_REPROJECTION = true;
var MAX_SUBDIVISION = 10;
var MAX_TRIANGLE_WIDTH = 0.25;
var Triangulation = function() {
  function Triangulation2(sourceProj, targetProj, targetExtent, maxSourceExtent, errorThreshold, opt_destinationResolution) {
    this.sourceProj_ = sourceProj;
    this.targetProj_ = targetProj;
    var transformInvCache = {};
    var transformInv = getTransform(this.targetProj_, this.sourceProj_);
    this.transformInv_ = function(c2) {
      var key = c2[0] + "/" + c2[1];
      if (!transformInvCache[key]) {
        transformInvCache[key] = transformInv(c2);
      }
      return transformInvCache[key];
    };
    this.maxSourceExtent_ = maxSourceExtent;
    this.errorThresholdSquared_ = errorThreshold * errorThreshold;
    this.triangles_ = [];
    this.wrapsXInSource_ = false;
    this.canWrapXInSource_ = this.sourceProj_.canWrapX() && !!maxSourceExtent && !!this.sourceProj_.getExtent() && getWidth(maxSourceExtent) == getWidth(this.sourceProj_.getExtent());
    this.sourceWorldWidth_ = this.sourceProj_.getExtent() ? getWidth(this.sourceProj_.getExtent()) : null;
    this.targetWorldWidth_ = this.targetProj_.getExtent() ? getWidth(this.targetProj_.getExtent()) : null;
    var destinationTopLeft = getTopLeft(targetExtent);
    var destinationTopRight = getTopRight(targetExtent);
    var destinationBottomRight = getBottomRight(targetExtent);
    var destinationBottomLeft = getBottomLeft(targetExtent);
    var sourceTopLeft = this.transformInv_(destinationTopLeft);
    var sourceTopRight = this.transformInv_(destinationTopRight);
    var sourceBottomRight = this.transformInv_(destinationBottomRight);
    var sourceBottomLeft = this.transformInv_(destinationBottomLeft);
    var maxSubdivision = MAX_SUBDIVISION + (opt_destinationResolution ? Math.max(0, Math.ceil(log2(getArea(targetExtent) / (opt_destinationResolution * opt_destinationResolution * 256 * 256)))) : 0);
    this.addQuad_(destinationTopLeft, destinationTopRight, destinationBottomRight, destinationBottomLeft, sourceTopLeft, sourceTopRight, sourceBottomRight, sourceBottomLeft, maxSubdivision);
    if (this.wrapsXInSource_) {
      var leftBound_1 = Infinity;
      this.triangles_.forEach(function(triangle, i2, arr) {
        leftBound_1 = Math.min(leftBound_1, triangle.source[0][0], triangle.source[1][0], triangle.source[2][0]);
      });
      this.triangles_.forEach(function(triangle) {
        if (Math.max(triangle.source[0][0], triangle.source[1][0], triangle.source[2][0]) - leftBound_1 > this.sourceWorldWidth_ / 2) {
          var newTriangle = [
            [triangle.source[0][0], triangle.source[0][1]],
            [triangle.source[1][0], triangle.source[1][1]],
            [triangle.source[2][0], triangle.source[2][1]]
          ];
          if (newTriangle[0][0] - leftBound_1 > this.sourceWorldWidth_ / 2) {
            newTriangle[0][0] -= this.sourceWorldWidth_;
          }
          if (newTriangle[1][0] - leftBound_1 > this.sourceWorldWidth_ / 2) {
            newTriangle[1][0] -= this.sourceWorldWidth_;
          }
          if (newTriangle[2][0] - leftBound_1 > this.sourceWorldWidth_ / 2) {
            newTriangle[2][0] -= this.sourceWorldWidth_;
          }
          var minX = Math.min(newTriangle[0][0], newTriangle[1][0], newTriangle[2][0]);
          var maxX = Math.max(newTriangle[0][0], newTriangle[1][0], newTriangle[2][0]);
          if (maxX - minX < this.sourceWorldWidth_ / 2) {
            triangle.source = newTriangle;
          }
        }
      }.bind(this));
    }
    transformInvCache = {};
  }
  Triangulation2.prototype.addTriangle_ = function(a2, b2, c2, aSrc, bSrc, cSrc) {
    this.triangles_.push({
      source: [aSrc, bSrc, cSrc],
      target: [a2, b2, c2]
    });
  };
  Triangulation2.prototype.addQuad_ = function(a2, b2, c2, d2, aSrc, bSrc, cSrc, dSrc, maxSubdivision) {
    var sourceQuadExtent = boundingExtent([aSrc, bSrc, cSrc, dSrc]);
    var sourceCoverageX = this.sourceWorldWidth_ ? getWidth(sourceQuadExtent) / this.sourceWorldWidth_ : null;
    var sourceWorldWidth = this.sourceWorldWidth_;
    var wrapsX = this.sourceProj_.canWrapX() && sourceCoverageX > 0.5 && sourceCoverageX < 1;
    var needsSubdivision = false;
    if (maxSubdivision > 0) {
      if (this.targetProj_.isGlobal() && this.targetWorldWidth_) {
        var targetQuadExtent = boundingExtent([a2, b2, c2, d2]);
        var targetCoverageX = getWidth(targetQuadExtent) / this.targetWorldWidth_;
        needsSubdivision = targetCoverageX > MAX_TRIANGLE_WIDTH || needsSubdivision;
      }
      if (!wrapsX && this.sourceProj_.isGlobal() && sourceCoverageX) {
        needsSubdivision = sourceCoverageX > MAX_TRIANGLE_WIDTH || needsSubdivision;
      }
    }
    if (!needsSubdivision && this.maxSourceExtent_) {
      if (isFinite(sourceQuadExtent[0]) && isFinite(sourceQuadExtent[1]) && isFinite(sourceQuadExtent[2]) && isFinite(sourceQuadExtent[3])) {
        if (!intersects$1(sourceQuadExtent, this.maxSourceExtent_)) {
          return;
        }
      }
    }
    var isNotFinite = 0;
    if (!needsSubdivision) {
      if (!isFinite(aSrc[0]) || !isFinite(aSrc[1]) || !isFinite(bSrc[0]) || !isFinite(bSrc[1]) || !isFinite(cSrc[0]) || !isFinite(cSrc[1]) || !isFinite(dSrc[0]) || !isFinite(dSrc[1])) {
        if (maxSubdivision > 0) {
          needsSubdivision = true;
        } else {
          isNotFinite = (!isFinite(aSrc[0]) || !isFinite(aSrc[1]) ? 8 : 0) + (!isFinite(bSrc[0]) || !isFinite(bSrc[1]) ? 4 : 0) + (!isFinite(cSrc[0]) || !isFinite(cSrc[1]) ? 2 : 0) + (!isFinite(dSrc[0]) || !isFinite(dSrc[1]) ? 1 : 0);
          if (isNotFinite != 1 && isNotFinite != 2 && isNotFinite != 4 && isNotFinite != 8) {
            return;
          }
        }
      }
    }
    if (maxSubdivision > 0) {
      if (!needsSubdivision) {
        var center = [(a2[0] + c2[0]) / 2, (a2[1] + c2[1]) / 2];
        var centerSrc = this.transformInv_(center);
        var dx = void 0;
        if (wrapsX) {
          var centerSrcEstimX = (modulo(aSrc[0], sourceWorldWidth) + modulo(cSrc[0], sourceWorldWidth)) / 2;
          dx = centerSrcEstimX - modulo(centerSrc[0], sourceWorldWidth);
        } else {
          dx = (aSrc[0] + cSrc[0]) / 2 - centerSrc[0];
        }
        var dy = (aSrc[1] + cSrc[1]) / 2 - centerSrc[1];
        var centerSrcErrorSquared = dx * dx + dy * dy;
        needsSubdivision = centerSrcErrorSquared > this.errorThresholdSquared_;
      }
      if (needsSubdivision) {
        if (Math.abs(a2[0] - c2[0]) <= Math.abs(a2[1] - c2[1])) {
          var bc = [(b2[0] + c2[0]) / 2, (b2[1] + c2[1]) / 2];
          var bcSrc = this.transformInv_(bc);
          var da = [(d2[0] + a2[0]) / 2, (d2[1] + a2[1]) / 2];
          var daSrc = this.transformInv_(da);
          this.addQuad_(a2, b2, bc, da, aSrc, bSrc, bcSrc, daSrc, maxSubdivision - 1);
          this.addQuad_(da, bc, c2, d2, daSrc, bcSrc, cSrc, dSrc, maxSubdivision - 1);
        } else {
          var ab = [(a2[0] + b2[0]) / 2, (a2[1] + b2[1]) / 2];
          var abSrc = this.transformInv_(ab);
          var cd = [(c2[0] + d2[0]) / 2, (c2[1] + d2[1]) / 2];
          var cdSrc = this.transformInv_(cd);
          this.addQuad_(a2, ab, cd, d2, aSrc, abSrc, cdSrc, dSrc, maxSubdivision - 1);
          this.addQuad_(ab, b2, c2, cd, abSrc, bSrc, cSrc, cdSrc, maxSubdivision - 1);
        }
        return;
      }
    }
    if (wrapsX) {
      if (!this.canWrapXInSource_) {
        return;
      }
      this.wrapsXInSource_ = true;
    }
    if ((isNotFinite & 11) == 0) {
      this.addTriangle_(a2, c2, d2, aSrc, cSrc, dSrc);
    }
    if ((isNotFinite & 14) == 0) {
      this.addTriangle_(a2, c2, b2, aSrc, cSrc, bSrc);
    }
    if (isNotFinite) {
      if ((isNotFinite & 13) == 0) {
        this.addTriangle_(b2, d2, a2, bSrc, dSrc, aSrc);
      }
      if ((isNotFinite & 7) == 0) {
        this.addTriangle_(b2, d2, c2, bSrc, dSrc, cSrc);
      }
    }
  };
  Triangulation2.prototype.calculateSourceExtent = function() {
    var extent2 = createEmpty();
    this.triangles_.forEach(function(triangle, i2, arr) {
      var src = triangle.source;
      extendCoordinate(extent2, src[0]);
      extendCoordinate(extent2, src[1]);
      extendCoordinate(extent2, src[2]);
    });
    return extent2;
  };
  Triangulation2.prototype.getTriangles = function() {
    return this.triangles_;
  };
  return Triangulation2;
}();
var Triangulation$1 = Triangulation;
var IMAGE_SMOOTHING_DISABLED = {
  imageSmoothingEnabled: false,
  msImageSmoothingEnabled: false
};
var IMAGE_SMOOTHING_ENABLED = {
  imageSmoothingEnabled: true,
  msImageSmoothingEnabled: true
};
var brokenDiagonalRendering_;
function drawTestTriangle(ctx, u1, v1, u2, v2) {
  ctx.beginPath();
  ctx.moveTo(0, 0);
  ctx.lineTo(u1, v1);
  ctx.lineTo(u2, v2);
  ctx.closePath();
  ctx.save();
  ctx.clip();
  ctx.fillRect(0, 0, Math.max(u1, u2) + 1, Math.max(v1, v2));
  ctx.restore();
}
function verifyBrokenDiagonalRendering(data2, offset2) {
  return Math.abs(data2[offset2 * 4] - 210) > 2 || Math.abs(data2[offset2 * 4 + 3] - 0.75 * 255) > 2;
}
function isBrokenDiagonalRendering() {
  if (brokenDiagonalRendering_ === void 0) {
    var ctx = document.createElement("canvas").getContext("2d");
    ctx.globalCompositeOperation = "lighter";
    ctx.fillStyle = "rgba(210, 0, 0, 0.75)";
    drawTestTriangle(ctx, 4, 5, 4, 0);
    drawTestTriangle(ctx, 4, 5, 0, 5);
    var data2 = ctx.getImageData(0, 0, 3, 3).data;
    brokenDiagonalRendering_ = verifyBrokenDiagonalRendering(data2, 0) || verifyBrokenDiagonalRendering(data2, 4) || verifyBrokenDiagonalRendering(data2, 8);
  }
  return brokenDiagonalRendering_;
}
function calculateSourceResolution(sourceProj, targetProj, targetCenter, targetResolution) {
  var sourceCenter = transform$3(targetCenter, targetProj, sourceProj);
  var sourceResolution = getPointResolution(targetProj, targetResolution, targetCenter);
  var targetMetersPerUnit = targetProj.getMetersPerUnit();
  if (targetMetersPerUnit !== void 0) {
    sourceResolution *= targetMetersPerUnit;
  }
  var sourceMetersPerUnit = sourceProj.getMetersPerUnit();
  if (sourceMetersPerUnit !== void 0) {
    sourceResolution /= sourceMetersPerUnit;
  }
  var sourceExtent = sourceProj.getExtent();
  if (!sourceExtent || containsCoordinate(sourceExtent, sourceCenter)) {
    var compensationFactor = getPointResolution(sourceProj, sourceResolution, sourceCenter) / sourceResolution;
    if (isFinite(compensationFactor) && compensationFactor > 0) {
      sourceResolution /= compensationFactor;
    }
  }
  return sourceResolution;
}
function calculateSourceExtentResolution(sourceProj, targetProj, targetExtent, targetResolution) {
  var targetCenter = getCenter(targetExtent);
  var sourceResolution = calculateSourceResolution(sourceProj, targetProj, targetCenter, targetResolution);
  if (!isFinite(sourceResolution) || sourceResolution <= 0) {
    forEachCorner(targetExtent, function(corner) {
      sourceResolution = calculateSourceResolution(sourceProj, targetProj, corner, targetResolution);
      return isFinite(sourceResolution) && sourceResolution > 0;
    });
  }
  return sourceResolution;
}
function render(width, height, pixelRatio, sourceResolution, sourceExtent, targetResolution, targetExtent, triangulation, sources, gutter, opt_renderEdges, opt_interpolate) {
  var context = createCanvasContext2D(Math.round(pixelRatio * width), Math.round(pixelRatio * height));
  if (!opt_interpolate) {
    assign(context, IMAGE_SMOOTHING_DISABLED);
  }
  if (sources.length === 0) {
    return context.canvas;
  }
  context.scale(pixelRatio, pixelRatio);
  function pixelRound(value) {
    return Math.round(value * pixelRatio) / pixelRatio;
  }
  context.globalCompositeOperation = "lighter";
  var sourceDataExtent = createEmpty();
  sources.forEach(function(src, i2, arr) {
    extend$2(sourceDataExtent, src.extent);
  });
  var canvasWidthInUnits = getWidth(sourceDataExtent);
  var canvasHeightInUnits = getHeight(sourceDataExtent);
  var stitchContext = createCanvasContext2D(Math.round(pixelRatio * canvasWidthInUnits / sourceResolution), Math.round(pixelRatio * canvasHeightInUnits / sourceResolution));
  if (!opt_interpolate) {
    assign(stitchContext, IMAGE_SMOOTHING_DISABLED);
  }
  var stitchScale = pixelRatio / sourceResolution;
  sources.forEach(function(src, i2, arr) {
    var xPos = src.extent[0] - sourceDataExtent[0];
    var yPos = -(src.extent[3] - sourceDataExtent[3]);
    var srcWidth = getWidth(src.extent);
    var srcHeight = getHeight(src.extent);
    if (src.image.width > 0 && src.image.height > 0) {
      stitchContext.drawImage(src.image, gutter, gutter, src.image.width - 2 * gutter, src.image.height - 2 * gutter, xPos * stitchScale, yPos * stitchScale, srcWidth * stitchScale, srcHeight * stitchScale);
    }
  });
  var targetTopLeft = getTopLeft(targetExtent);
  triangulation.getTriangles().forEach(function(triangle, i2, arr) {
    var source = triangle.source;
    var target = triangle.target;
    var x0 = source[0][0], y0 = source[0][1];
    var x1 = source[1][0], y1 = source[1][1];
    var x2 = source[2][0], y2 = source[2][1];
    var u0 = pixelRound((target[0][0] - targetTopLeft[0]) / targetResolution);
    var v0 = pixelRound(-(target[0][1] - targetTopLeft[1]) / targetResolution);
    var u1 = pixelRound((target[1][0] - targetTopLeft[0]) / targetResolution);
    var v1 = pixelRound(-(target[1][1] - targetTopLeft[1]) / targetResolution);
    var u2 = pixelRound((target[2][0] - targetTopLeft[0]) / targetResolution);
    var v2 = pixelRound(-(target[2][1] - targetTopLeft[1]) / targetResolution);
    var sourceNumericalShiftX = x0;
    var sourceNumericalShiftY = y0;
    x0 = 0;
    y0 = 0;
    x1 -= sourceNumericalShiftX;
    y1 -= sourceNumericalShiftY;
    x2 -= sourceNumericalShiftX;
    y2 -= sourceNumericalShiftY;
    var augmentedMatrix = [
      [x1, y1, 0, 0, u1 - u0],
      [x2, y2, 0, 0, u2 - u0],
      [0, 0, x1, y1, v1 - v0],
      [0, 0, x2, y2, v2 - v0]
    ];
    var affineCoefs = solveLinearSystem(augmentedMatrix);
    if (!affineCoefs) {
      return;
    }
    context.save();
    context.beginPath();
    if (isBrokenDiagonalRendering() || !opt_interpolate) {
      context.moveTo(u1, v1);
      var steps = 4;
      var ud = u0 - u1;
      var vd = v0 - v1;
      for (var step = 0; step < steps; step++) {
        context.lineTo(u1 + pixelRound((step + 1) * ud / steps), v1 + pixelRound(step * vd / (steps - 1)));
        if (step != steps - 1) {
          context.lineTo(u1 + pixelRound((step + 1) * ud / steps), v1 + pixelRound((step + 1) * vd / (steps - 1)));
        }
      }
      context.lineTo(u2, v2);
    } else {
      context.moveTo(u1, v1);
      context.lineTo(u0, v0);
      context.lineTo(u2, v2);
    }
    context.clip();
    context.transform(affineCoefs[0], affineCoefs[2], affineCoefs[1], affineCoefs[3], u0, v0);
    context.translate(sourceDataExtent[0] - sourceNumericalShiftX, sourceDataExtent[3] - sourceNumericalShiftY);
    context.scale(sourceResolution / pixelRatio, -sourceResolution / pixelRatio);
    context.drawImage(stitchContext.canvas, 0, 0);
    context.restore();
  });
  if (opt_renderEdges) {
    context.save();
    context.globalCompositeOperation = "source-over";
    context.strokeStyle = "black";
    context.lineWidth = 1;
    triangulation.getTriangles().forEach(function(triangle, i2, arr) {
      var target = triangle.target;
      var u0 = (target[0][0] - targetTopLeft[0]) / targetResolution;
      var v0 = -(target[0][1] - targetTopLeft[1]) / targetResolution;
      var u1 = (target[1][0] - targetTopLeft[0]) / targetResolution;
      var v1 = -(target[1][1] - targetTopLeft[1]) / targetResolution;
      var u2 = (target[2][0] - targetTopLeft[0]) / targetResolution;
      var v2 = -(target[2][1] - targetTopLeft[1]) / targetResolution;
      context.beginPath();
      context.moveTo(u1, v1);
      context.lineTo(u0, v0);
      context.lineTo(u2, v2);
      context.closePath();
      context.stroke();
    });
    context.restore();
  }
  return context.canvas;
}
var __extends$X = globalThis && globalThis.__extends || function() {
  var extendStatics2 = function(d2, b2) {
    extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {
      d3.__proto__ = b3;
    } || function(d3, b3) {
      for (var p5 in b3)
        if (Object.prototype.hasOwnProperty.call(b3, p5))
          d3[p5] = b3[p5];
    };
    return extendStatics2(d2, b2);
  };
  return function(d2, b2) {
    if (typeof b2 !== "function" && b2 !== null)
      throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
    extendStatics2(d2, b2);
    function __() {
      this.constructor = d2;
    }
    d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
  };
}();
var ReprojTile = function(_super) {
  __extends$X(ReprojTile2, _super);
  function ReprojTile2(sourceProj, sourceTileGrid, targetProj, targetTileGrid, tileCoord, wrappedTileCoord, pixelRatio, gutter, getTileFunction, opt_errorThreshold, opt_renderEdges, opt_interpolate) {
    var _this = _super.call(this, tileCoord, TileState.IDLE, { interpolate: !!opt_interpolate }) || this;
    _this.renderEdges_ = opt_renderEdges !== void 0 ? opt_renderEdges : false;
    _this.pixelRatio_ = pixelRatio;
    _this.gutter_ = gutter;
    _this.canvas_ = null;
    _this.sourceTileGrid_ = sourceTileGrid;
    _this.targetTileGrid_ = targetTileGrid;
    _this.wrappedTileCoord_ = wrappedTileCoord ? wrappedTileCoord : tileCoord;
    _this.sourceTiles_ = [];
    _this.sourcesListenerKeys_ = null;
    _this.sourceZ_ = 0;
    var targetExtent = targetTileGrid.getTileCoordExtent(_this.wrappedTileCoord_);
    var maxTargetExtent = _this.targetTileGrid_.getExtent();
    var maxSourceExtent = _this.sourceTileGrid_.getExtent();
    var limitedTargetExtent = maxTargetExtent ? getIntersection(targetExtent, maxTargetExtent) : targetExtent;
    if (getArea(limitedTargetExtent) === 0) {
      _this.state = TileState.EMPTY;
      return _this;
    }
    var sourceProjExtent = sourceProj.getExtent();
    if (sourceProjExtent) {
      if (!maxSourceExtent) {
        maxSourceExtent = sourceProjExtent;
      } else {
        maxSourceExtent = getIntersection(maxSourceExtent, sourceProjExtent);
      }
    }
    var targetResolution = targetTileGrid.getResolution(_this.wrappedTileCoord_[0]);
    var sourceResolution = calculateSourceExtentResolution(sourceProj, targetProj, limitedTargetExtent, targetResolution);
    if (!isFinite(sourceResolution) || sourceResolution <= 0) {
      _this.state = TileState.EMPTY;
      return _this;
    }
    var errorThresholdInPixels = opt_errorThreshold !== void 0 ? opt_errorThreshold : ERROR_THRESHOLD;
    _this.triangulation_ = new Triangulation$1(sourceProj, targetProj, limitedTargetExtent, maxSourceExtent, sourceResolution * errorThresholdInPixels, targetResolution);
    if (_this.triangulation_.getTriangles().length === 0) {
      _this.state = TileState.EMPTY;
      return _this;
    }
    _this.sourceZ_ = sourceTileGrid.getZForResolution(sourceResolution);
    var sourceExtent = _this.triangulation_.calculateSourceExtent();
    if (maxSourceExtent) {
      if (sourceProj.canWrapX()) {
        sourceExtent[1] = clamp(sourceExtent[1], maxSourceExtent[1], maxSourceExtent[3]);
        sourceExtent[3] = clamp(sourceExtent[3], maxSourceExtent[1], maxSourceExtent[3]);
      } else {
        sourceExtent = getIntersection(sourceExtent, maxSourceExtent);
      }
    }
    if (!getArea(sourceExtent)) {
      _this.state = TileState.EMPTY;
    } else {
      var sourceRange = sourceTileGrid.getTileRangeForExtentAndZ(sourceExtent, _this.sourceZ_);
      for (var srcX = sourceRange.minX; srcX <= sourceRange.maxX; srcX++) {
        for (var srcY = sourceRange.minY; srcY <= sourceRange.maxY; srcY++) {
          var tile2 = getTileFunction(_this.sourceZ_, srcX, srcY, pixelRatio);
          if (tile2) {
            _this.sourceTiles_.push(tile2);
          }
        }
      }
      if (_this.sourceTiles_.length === 0) {
        _this.state = TileState.EMPTY;
      }
    }
    return _this;
  }
  ReprojTile2.prototype.getImage = function() {
    return this.canvas_;
  };
  ReprojTile2.prototype.reproject_ = function() {
    var sources = [];
    this.sourceTiles_.forEach(function(tile2, i2, arr) {
      if (tile2 && tile2.getState() == TileState.LOADED) {
        sources.push({
          extent: this.sourceTileGrid_.getTileCoordExtent(tile2.tileCoord),
          image: tile2.getImage()
        });
      }
    }.bind(this));
    this.sourceTiles_.length = 0;
    if (sources.length === 0) {
      this.state = TileState.ERROR;
    } else {
      var z2 = this.wrappedTileCoord_[0];
      var size = this.targetTileGrid_.getTileSize(z2);
      var width = typeof size === "number" ? size : size[0];
      var height = typeof size === "number" ? size : size[1];
      var targetResolution = this.targetTileGrid_.getResolution(z2);
      var sourceResolution = this.sourceTileGrid_.getResolution(this.sourceZ_);
      var targetExtent = this.targetTileGrid_.getTileCoordExtent(this.wrappedTileCoord_);
      this.canvas_ = render(width, height, this.pixelRatio_, sourceResolution, this.sourceTileGrid_.getExtent(), targetResolution, targetExtent, this.triangulation_, sources, this.gutter_, this.renderEdges_, this.interpolate);
      this.state = TileState.LOADED;
    }
    this.changed();
  };
  ReprojTile2.prototype.load = function() {
    if (this.state == TileState.IDLE) {
      this.state = TileState.LOADING;
      this.changed();
      var leftToLoad_1 = 0;
      this.sourcesListenerKeys_ = [];
      this.sourceTiles_.forEach(function(tile2, i2, arr) {
        var state = tile2.getState();
        if (state == TileState.IDLE || state == TileState.LOADING) {
          leftToLoad_1++;
          var sourceListenKey_1 = listen(tile2, EventType.CHANGE, function(e2) {
            var state2 = tile2.getState();
            if (state2 == TileState.LOADED || state2 == TileState.ERROR || state2 == TileState.EMPTY) {
              unlistenByKey(sourceListenKey_1);
              leftToLoad_1--;
              if (leftToLoad_1 === 0) {
                this.unlistenSources_();
                this.reproject_();
              }
            }
          }, this);
          this.sourcesListenerKeys_.push(sourceListenKey_1);
        }
      }.bind(this));
      if (leftToLoad_1 === 0) {
        setTimeout(this.reproject_.bind(this), 0);
      } else {
        this.sourceTiles_.forEach(function(tile2, i2, arr) {
          var state = tile2.getState();
          if (state == TileState.IDLE) {
            tile2.load();
          }
        });
      }
    }
  };
  ReprojTile2.prototype.unlistenSources_ = function() {
    this.sourcesListenerKeys_.forEach(unlistenByKey);
    this.sourcesListenerKeys_ = null;
  };
  return ReprojTile2;
}(Tile$1);
var ReprojTile$1 = ReprojTile;
var TileRange = function() {
  function TileRange2(minX, maxX, minY, maxY) {
    this.minX = minX;
    this.maxX = maxX;
    this.minY = minY;
    this.maxY = maxY;
  }
  TileRange2.prototype.contains = function(tileCoord) {
    return this.containsXY(tileCoord[1], tileCoord[2]);
  };
  TileRange2.prototype.containsTileRange = function(tileRange) {
    return this.minX <= tileRange.minX && tileRange.maxX <= this.maxX && this.minY <= tileRange.minY && tileRange.maxY <= this.maxY;
  };
  TileRange2.prototype.containsXY = function(x2, y2) {
    return this.minX <= x2 && x2 <= this.maxX && this.minY <= y2 && y2 <= this.maxY;
  };
  TileRange2.prototype.equals = function(tileRange) {
    return this.minX == tileRange.minX && this.minY == tileRange.minY && this.maxX == tileRange.maxX && this.maxY == tileRange.maxY;
  };
  TileRange2.prototype.extend = function(tileRange) {
    if (tileRange.minX < this.minX) {
      this.minX = tileRange.minX;
    }
    if (tileRange.maxX > this.maxX) {
      this.maxX = tileRange.maxX;
    }
    if (tileRange.minY < this.minY) {
      this.minY = tileRange.minY;
    }
    if (tileRange.maxY > this.maxY) {
      this.maxY = tileRange.maxY;
    }
  };
  TileRange2.prototype.getHeight = function() {
    return this.maxY - this.minY + 1;
  };
  TileRange2.prototype.getSize = function() {
    return [this.getWidth(), this.getHeight()];
  };
  TileRange2.prototype.getWidth = function() {
    return this.maxX - this.minX + 1;
  };
  TileRange2.prototype.intersects = function(tileRange) {
    return this.minX <= tileRange.maxX && this.maxX >= tileRange.minX && this.minY <= tileRange.maxY && this.maxY >= tileRange.minY;
  };
  return TileRange2;
}();
function createOrUpdate$1(minX, maxX, minY, maxY, tileRange) {
  if (tileRange !== void 0) {
    tileRange.minX = minX;
    tileRange.maxX = maxX;
    tileRange.minY = minY;
    tileRange.maxY = maxY;
    return tileRange;
  } else {
    return new TileRange(minX, maxX, minY, maxY);
  }
}
var TileRange$1 = TileRange;
var __extends$W = globalThis && globalThis.__extends || function() {
  var extendStatics2 = function(d2, b2) {
    extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {
      d3.__proto__ = b3;
    } || function(d3, b3) {
      for (var p5 in b3)
        if (Object.prototype.hasOwnProperty.call(b3, p5))
          d3[p5] = b3[p5];
    };
    return extendStatics2(d2, b2);
  };
  return function(d2, b2) {
    if (typeof b2 !== "function" && b2 !== null)
      throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
    extendStatics2(d2, b2);
    function __() {
      this.constructor = d2;
    }
    d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
  };
}();
var CanvasTileLayerRenderer = function(_super) {
  __extends$W(CanvasTileLayerRenderer2, _super);
  function CanvasTileLayerRenderer2(tileLayer) {
    var _this = _super.call(this, tileLayer) || this;
    _this.extentChanged = true;
    _this.renderedExtent_ = null;
    _this.renderedPixelRatio;
    _this.renderedProjection = null;
    _this.renderedRevision;
    _this.renderedTiles = [];
    _this.newTiles_ = false;
    _this.tmpExtent = createEmpty();
    _this.tmpTileRange_ = new TileRange$1(0, 0, 0, 0);
    return _this;
  }
  CanvasTileLayerRenderer2.prototype.isDrawableTile = function(tile2) {
    var tileLayer = this.getLayer();
    var tileState = tile2.getState();
    var useInterimTilesOnError = tileLayer.getUseInterimTilesOnError();
    return tileState == TileState.LOADED || tileState == TileState.EMPTY || tileState == TileState.ERROR && !useInterimTilesOnError;
  };
  CanvasTileLayerRenderer2.prototype.getTile = function(z2, x2, y2, frameState) {
    var pixelRatio = frameState.pixelRatio;
    var projection = frameState.viewState.projection;
    var tileLayer = this.getLayer();
    var tileSource = tileLayer.getSource();
    var tile2 = tileSource.getTile(z2, x2, y2, pixelRatio, projection);
    if (tile2.getState() == TileState.ERROR) {
      if (!tileLayer.getUseInterimTilesOnError()) {
        tile2.setState(TileState.LOADED);
      } else if (tileLayer.getPreload() > 0) {
        this.newTiles_ = true;
      }
    }
    if (!this.isDrawableTile(tile2)) {
      tile2 = tile2.getInterimTile();
    }
    return tile2;
  };
  CanvasTileLayerRenderer2.prototype.getData = function(pixel) {
    var frameState = this.frameState;
    if (!frameState) {
      return null;
    }
    var layer = this.getLayer();
    var coordinate = apply$5(frameState.pixelToCoordinateTransform, pixel.slice());
    var layerExtent = layer.getExtent();
    if (layerExtent) {
      if (!containsCoordinate(layerExtent, coordinate)) {
        return null;
      }
    }
    var pixelRatio = frameState.pixelRatio;
    var projection = frameState.viewState.projection;
    var viewState = frameState.viewState;
    var source = layer.getRenderSource();
    var tileGrid = source.getTileGridForProjection(viewState.projection);
    var tilePixelRatio = source.getTilePixelRatio(frameState.pixelRatio);
    for (var z2 = tileGrid.getZForResolution(viewState.resolution); z2 >= tileGrid.getMinZoom(); --z2) {
      var tileCoord = tileGrid.getTileCoordForCoordAndZ(coordinate, z2);
      var tile2 = source.getTile(z2, tileCoord[1], tileCoord[2], pixelRatio, projection);
      if (!(tile2 instanceof ImageTile$1 || tile2 instanceof ReprojTile$1)) {
        return null;
      }
      if (tile2.getState() !== TileState.LOADED) {
        continue;
      }
      var tileOrigin = tileGrid.getOrigin(z2);
      var tileSize = toSize(tileGrid.getTileSize(z2));
      var tileResolution = tileGrid.getResolution(z2);
      var col = Math.floor(tilePixelRatio * ((coordinate[0] - tileOrigin[0]) / tileResolution - tileCoord[1] * tileSize[0]));
      var row = Math.floor(tilePixelRatio * ((tileOrigin[1] - coordinate[1]) / tileResolution - tileCoord[2] * tileSize[1]));
      return this.getImageData(tile2.getImage(), col, row);
    }
    return null;
  };
  CanvasTileLayerRenderer2.prototype.loadedTileCallback = function(tiles, zoom, tile2) {
    if (this.isDrawableTile(tile2)) {
      return _super.prototype.loadedTileCallback.call(this, tiles, zoom, tile2);
    }
    return false;
  };
  CanvasTileLayerRenderer2.prototype.prepareFrame = function(frameState) {
    return !!this.getLayer().getSource();
  };
  CanvasTileLayerRenderer2.prototype.renderFrame = function(frameState, target) {
    var layerState = frameState.layerStatesArray[frameState.layerIndex];
    var viewState = frameState.viewState;
    var projection = viewState.projection;
    var viewResolution = viewState.resolution;
    var viewCenter = viewState.center;
    var rotation = viewState.rotation;
    var pixelRatio = frameState.pixelRatio;
    var tileLayer = this.getLayer();
    var tileSource = tileLayer.getSource();
    var sourceRevision = tileSource.getRevision();
    var tileGrid = tileSource.getTileGridForProjection(projection);
    var z2 = tileGrid.getZForResolution(viewResolution, tileSource.zDirection);
    var tileResolution = tileGrid.getResolution(z2);
    var extent2 = frameState.extent;
    var layerExtent = layerState.extent && fromUserExtent(layerState.extent);
    if (layerExtent) {
      extent2 = getIntersection(extent2, fromUserExtent(layerState.extent));
    }
    var tilePixelRatio = tileSource.getTilePixelRatio(pixelRatio);
    var width = Math.round(frameState.size[0] * tilePixelRatio);
    var height = Math.round(frameState.size[1] * tilePixelRatio);
    if (rotation) {
      var size = Math.round(Math.sqrt(width * width + height * height));
      width = size;
      height = size;
    }
    var dx = tileResolution * width / 2 / tilePixelRatio;
    var dy = tileResolution * height / 2 / tilePixelRatio;
    var canvasExtent = [
      viewCenter[0] - dx,
      viewCenter[1] - dy,
      viewCenter[0] + dx,
      viewCenter[1] + dy
    ];
    var tileRange = tileGrid.getTileRangeForExtentAndZ(extent2, z2);
    var tilesToDrawByZ = {};
    tilesToDrawByZ[z2] = {};
    var findLoadedTiles = this.createLoadedTileFinder(tileSource, projection, tilesToDrawByZ);
    var tmpExtent2 = this.tmpExtent;
    var tmpTileRange = this.tmpTileRange_;
    this.newTiles_ = false;
    for (var x2 = tileRange.minX; x2 <= tileRange.maxX; ++x2) {
      for (var y2 = tileRange.minY; y2 <= tileRange.maxY; ++y2) {
        var tile2 = this.getTile(z2, x2, y2, frameState);
        if (this.isDrawableTile(tile2)) {
          var uid2 = getUid(this);
          if (tile2.getState() == TileState.LOADED) {
            tilesToDrawByZ[z2][tile2.tileCoord.toString()] = tile2;
            var inTransition = tile2.inTransition(uid2);
            if (!this.newTiles_ && (inTransition || this.renderedTiles.indexOf(tile2) === -1)) {
              this.newTiles_ = true;
            }
          }
          if (tile2.getAlpha(uid2, frameState.time) === 1) {
            continue;
          }
        }
        var childTileRange = tileGrid.getTileCoordChildTileRange(tile2.tileCoord, tmpTileRange, tmpExtent2);
        var covered = false;
        if (childTileRange) {
          covered = findLoadedTiles(z2 + 1, childTileRange);
        }
        if (!covered) {
          tileGrid.forEachTileCoordParentTileRange(tile2.tileCoord, findLoadedTiles, tmpTileRange, tmpExtent2);
        }
      }
    }
    var canvasScale = tileResolution / viewResolution;
    compose(this.pixelTransform, frameState.size[0] / 2, frameState.size[1] / 2, 1 / tilePixelRatio, 1 / tilePixelRatio, rotation, -width / 2, -height / 2);
    var canvasTransform = toString$d(this.pixelTransform);
    this.useContainer(target, canvasTransform, layerState.opacity, this.getBackground(frameState));
    var context = this.context;
    var canvas = context.canvas;
    makeInverse(this.inversePixelTransform, this.pixelTransform);
    compose(this.tempTransform, width / 2, height / 2, canvasScale, canvasScale, 0, -width / 2, -height / 2);
    if (canvas.width != width || canvas.height != height) {
      canvas.width = width;
      canvas.height = height;
    } else if (!this.containerReused) {
      context.clearRect(0, 0, width, height);
    }
    if (layerExtent) {
      this.clipUnrotated(context, frameState, layerExtent);
    }
    if (!tileSource.getInterpolate()) {
      assign(context, IMAGE_SMOOTHING_DISABLED);
    }
    this.preRender(context, frameState);
    this.renderedTiles.length = 0;
    var zs = Object.keys(tilesToDrawByZ).map(Number);
    zs.sort(numberSafeCompareFunction);
    var clips, clipZs, currentClip;
    if (layerState.opacity === 1 && (!this.containerReused || tileSource.getOpaque(frameState.viewState.projection))) {
      zs = zs.reverse();
    } else {
      clips = [];
      clipZs = [];
    }
    for (var i2 = zs.length - 1; i2 >= 0; --i2) {
      var currentZ = zs[i2];
      var currentTilePixelSize = tileSource.getTilePixelSize(currentZ, pixelRatio, projection);
      var currentResolution = tileGrid.getResolution(currentZ);
      var currentScale = currentResolution / tileResolution;
      var dx_1 = currentTilePixelSize[0] * currentScale * canvasScale;
      var dy_1 = currentTilePixelSize[1] * currentScale * canvasScale;
      var originTileCoord = tileGrid.getTileCoordForCoordAndZ(getTopLeft(canvasExtent), currentZ);
      var originTileExtent = tileGrid.getTileCoordExtent(originTileCoord);
      var origin_1 = apply$5(this.tempTransform, [
        tilePixelRatio * (originTileExtent[0] - canvasExtent[0]) / tileResolution,
        tilePixelRatio * (canvasExtent[3] - originTileExtent[3]) / tileResolution
      ]);
      var tileGutter = tilePixelRatio * tileSource.getGutterForProjection(projection);
      var tilesToDraw = tilesToDrawByZ[currentZ];
      for (var tileCoordKey in tilesToDraw) {
        var tile2 = tilesToDraw[tileCoordKey];
        var tileCoord = tile2.tileCoord;
        var xIndex = originTileCoord[1] - tileCoord[1];
        var nextX = Math.round(origin_1[0] - (xIndex - 1) * dx_1);
        var yIndex = originTileCoord[2] - tileCoord[2];
        var nextY = Math.round(origin_1[1] - (yIndex - 1) * dy_1);
        var x2 = Math.round(origin_1[0] - xIndex * dx_1);
        var y2 = Math.round(origin_1[1] - yIndex * dy_1);
        var w2 = nextX - x2;
        var h2 = nextY - y2;
        var transition = z2 === currentZ;
        var inTransition = transition && tile2.getAlpha(getUid(this), frameState.time) !== 1;
        var contextSaved = false;
        if (!inTransition) {
          if (clips) {
            currentClip = [x2, y2, x2 + w2, y2, x2 + w2, y2 + h2, x2, y2 + h2];
            for (var i_1 = 0, ii = clips.length; i_1 < ii; ++i_1) {
              if (z2 !== currentZ && currentZ < clipZs[i_1]) {
                var clip = clips[i_1];
                if (intersects$1([x2, y2, x2 + w2, y2 + h2], [clip[0], clip[3], clip[4], clip[7]])) {
                  if (!contextSaved) {
                    context.save();
                    contextSaved = true;
                  }
                  context.beginPath();
                  context.moveTo(currentClip[0], currentClip[1]);
                  context.lineTo(currentClip[2], currentClip[3]);
                  context.lineTo(currentClip[4], currentClip[5]);
                  context.lineTo(currentClip[6], currentClip[7]);
                  context.moveTo(clip[6], clip[7]);
                  context.lineTo(clip[4], clip[5]);
                  context.lineTo(clip[2], clip[3]);
                  context.lineTo(clip[0], clip[1]);
                  context.clip();
                }
              }
            }
            clips.push(currentClip);
            clipZs.push(currentZ);
          } else {
            context.clearRect(x2, y2, w2, h2);
          }
        }
        this.drawTileImage(tile2, frameState, x2, y2, w2, h2, tileGutter, transition);
        if (clips && !inTransition) {
          if (contextSaved) {
            context.restore();
          }
          this.renderedTiles.unshift(tile2);
        } else {
          this.renderedTiles.push(tile2);
        }
        this.updateUsedTiles(frameState.usedTiles, tileSource, tile2);
      }
    }
    this.renderedRevision = sourceRevision;
    this.renderedResolution = tileResolution;
    this.extentChanged = !this.renderedExtent_ || !equals$1(this.renderedExtent_, canvasExtent);
    this.renderedExtent_ = canvasExtent;
    this.renderedPixelRatio = pixelRatio;
    this.renderedProjection = projection;
    this.manageTilePyramid(frameState, tileSource, tileGrid, pixelRatio, projection, extent2, z2, tileLayer.getPreload());
    this.scheduleExpireCache(frameState, tileSource);
    this.postRender(context, frameState);
    if (layerState.extent) {
      context.restore();
    }
    assign(context, IMAGE_SMOOTHING_ENABLED);
    if (canvasTransform !== canvas.style.transform) {
      canvas.style.transform = canvasTransform;
    }
    var opacity2 = cssOpacity(layerState.opacity);
    var container = this.container;
    if (opacity2 !== container.style.opacity) {
      container.style.opacity = opacity2;
    }
    return this.container;
  };
  CanvasTileLayerRenderer2.prototype.drawTileImage = function(tile2, frameState, x2, y2, w2, h2, gutter, transition) {
    var image2 = this.getTileImage(tile2);
    if (!image2) {
      return;
    }
    var uid2 = getUid(this);
    var alpha = transition ? tile2.getAlpha(uid2, frameState.time) : 1;
    var alphaChanged = alpha !== this.context.globalAlpha;
    if (alphaChanged) {
      this.context.save();
      this.context.globalAlpha = alpha;
    }
    this.context.drawImage(image2, gutter, gutter, image2.width - 2 * gutter, image2.height - 2 * gutter, x2, y2, w2, h2);
    if (alphaChanged) {
      this.context.restore();
    }
    if (alpha !== 1) {
      frameState.animate = true;
    } else if (transition) {
      tile2.endTransition(uid2);
    }
  };
  CanvasTileLayerRenderer2.prototype.getImage = function() {
    var context = this.context;
    return context ? context.canvas : null;
  };
  CanvasTileLayerRenderer2.prototype.getTileImage = function(tile2) {
    return tile2.getImage();
  };
  CanvasTileLayerRenderer2.prototype.scheduleExpireCache = function(frameState, tileSource) {
    if (tileSource.canExpireCache()) {
      var postRenderFunction = function(tileSource2, map, frameState2) {
        var tileSourceKey = getUid(tileSource2);
        if (tileSourceKey in frameState2.usedTiles) {
          tileSource2.expireCache(frameState2.viewState.projection, frameState2.usedTiles[tileSourceKey]);
        }
      }.bind(null, tileSource);
      frameState.postRenderFunctions.push(postRenderFunction);
    }
  };
  CanvasTileLayerRenderer2.prototype.updateUsedTiles = function(usedTiles, tileSource, tile2) {
    var tileSourceKey = getUid(tileSource);
    if (!(tileSourceKey in usedTiles)) {
      usedTiles[tileSourceKey] = {};
    }
    usedTiles[tileSourceKey][tile2.getKey()] = true;
  };
  CanvasTileLayerRenderer2.prototype.manageTilePyramid = function(frameState, tileSource, tileGrid, pixelRatio, projection, extent2, currentZ, preload, opt_tileCallback) {
    var tileSourceKey = getUid(tileSource);
    if (!(tileSourceKey in frameState.wantedTiles)) {
      frameState.wantedTiles[tileSourceKey] = {};
    }
    var wantedTiles = frameState.wantedTiles[tileSourceKey];
    var tileQueue = frameState.tileQueue;
    var minZoom = tileGrid.getMinZoom();
    var tileCount = 0;
    var tile2, tileRange, tileResolution, x2, y2, z2;
    for (z2 = minZoom; z2 <= currentZ; ++z2) {
      tileRange = tileGrid.getTileRangeForExtentAndZ(extent2, z2, tileRange);
      tileResolution = tileGrid.getResolution(z2);
      for (x2 = tileRange.minX; x2 <= tileRange.maxX; ++x2) {
        for (y2 = tileRange.minY; y2 <= tileRange.maxY; ++y2) {
          if (currentZ - z2 <= preload) {
            ++tileCount;
            tile2 = tileSource.getTile(z2, x2, y2, pixelRatio, projection);
            if (tile2.getState() == TileState.IDLE) {
              wantedTiles[tile2.getKey()] = true;
              if (!tileQueue.isKeyQueued(tile2.getKey())) {
                tileQueue.enqueue([
                  tile2,
                  tileSourceKey,
                  tileGrid.getTileCoordCenter(tile2.tileCoord),
                  tileResolution
                ]);
              }
            }
            if (opt_tileCallback !== void 0) {
              opt_tileCallback(tile2);
            }
          } else {
            tileSource.useTile(z2, x2, y2, projection);
          }
        }
      }
    }
    tileSource.updateCacheSize(tileCount, projection);
  };
  return CanvasTileLayerRenderer2;
}(CanvasLayerRenderer$1);
var CanvasTileLayerRenderer$1 = CanvasTileLayerRenderer;
var __extends$V = globalThis && globalThis.__extends || function() {
  var extendStatics2 = function(d2, b2) {
    extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {
      d3.__proto__ = b3;
    } || function(d3, b3) {
      for (var p5 in b3)
        if (Object.prototype.hasOwnProperty.call(b3, p5))
          d3[p5] = b3[p5];
    };
    return extendStatics2(d2, b2);
  };
  return function(d2, b2) {
    if (typeof b2 !== "function" && b2 !== null)
      throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
    extendStatics2(d2, b2);
    function __() {
      this.constructor = d2;
    }
    d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
  };
}();
var TileLayer$2 = function(_super) {
  __extends$V(TileLayer2, _super);
  function TileLayer2(opt_options) {
    return _super.call(this, opt_options) || this;
  }
  TileLayer2.prototype.createRenderer = function() {
    return new CanvasTileLayerRenderer$1(this);
  };
  return TileLayer2;
}(BaseTileLayer$1);
var ol_layer_Tile = TileLayer$2;
var _sfc_main$10 = {
  props: {
    className: {
      type: String,
      default: "ol-layer"
    },
    opacity: {
      type: Number,
      default: 1
    },
    visible: {
      type: Boolean,
      default: true
    },
    extent: {
      type: Array
    },
    zIndex: {
      type: Number
    },
    minResolution: {
      type: Number
    },
    maxResolution: {
      type: Number
    },
    minZoom: {
      type: Number
    },
    maxZoom: {
      type: Number
    },
    title: {
      type: String
    },
    name: {
      type: String
    },
    preview: {
      type: String
    },
    baseLayer: {
      type: Boolean
    },
    properties: {
      type: Object,
      default: () => {
      }
    }
  }
};
function _sfc_render$10(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div");
}
var BaseLayer = _export_sfc(_sfc_main$10, [["render", _sfc_render$10]]);
var _sfc_main$$ = {
  extends: BaseLayer,
  name: "ol-tile-layer",
  setup(props) {
    const map = inject("map");
    const overViewMap = inject("overviewMap", null);
    const {
      properties
    } = usePropsAsObjectProperties(props);
    const tileLayer = computed(() => new ol_layer_Tile(properties));
    const applyTileLayer = () => {
      if (overViewMap != null) {
        overViewMap.value.getOverviewMap().addLayer(tileLayer.value);
        overViewMap.value.changed();
      } else {
        map.addLayer(tileLayer.value);
      }
    };
    const removeTileLayer = () => {
      if (overViewMap != null) {
        overViewMap.value.getOverviewMap().removeLayer(tileLayer.value);
        overViewMap.value.changed();
      } else {
        map.removeLayer(tileLayer.value);
      }
    };
    if (overViewMap != null) {
      watch(overViewMap, () => {
        removeTileLayer();
        applyTileLayer();
      });
    }
    onMounted(() => {
      applyTileLayer();
    });
    onUnmounted(() => {
      removeTileLayer();
    });
    provide("tileLayer", tileLayer);
    return {
      tileLayer
    };
  },
  props: {
    preload: {
      type: Number,
      default: 1
    }
  }
};
function _sfc_render$$(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", null, [
    renderSlot(_ctx.$slots, "default")
  ]);
}
var TileLayer$1 = _export_sfc(_sfc_main$$, [["render", _sfc_render$$]]);
var LRUCache = function() {
  function LRUCache2(opt_highWaterMark) {
    this.highWaterMark = opt_highWaterMark !== void 0 ? opt_highWaterMark : 2048;
    this.count_ = 0;
    this.entries_ = {};
    this.oldest_ = null;
    this.newest_ = null;
  }
  LRUCache2.prototype.canExpireCache = function() {
    return this.highWaterMark > 0 && this.getCount() > this.highWaterMark;
  };
  LRUCache2.prototype.expireCache = function(keep) {
    while (this.canExpireCache()) {
      this.pop();
    }
  };
  LRUCache2.prototype.clear = function() {
    this.count_ = 0;
    this.entries_ = {};
    this.oldest_ = null;
    this.newest_ = null;
  };
  LRUCache2.prototype.containsKey = function(key) {
    return this.entries_.hasOwnProperty(key);
  };
  LRUCache2.prototype.forEach = function(f2) {
    var entry = this.oldest_;
    while (entry) {
      f2(entry.value_, entry.key_, this);
      entry = entry.newer;
    }
  };
  LRUCache2.prototype.get = function(key, opt_options) {
    var entry = this.entries_[key];
    assert(entry !== void 0, 15);
    if (entry === this.newest_) {
      return entry.value_;
    } else if (entry === this.oldest_) {
      this.oldest_ = this.oldest_.newer;
      this.oldest_.older = null;
    } else {
      entry.newer.older = entry.older;
      entry.older.newer = entry.newer;
    }
    entry.newer = null;
    entry.older = this.newest_;
    this.newest_.newer = entry;
    this.newest_ = entry;
    return entry.value_;
  };
  LRUCache2.prototype.remove = function(key) {
    var entry = this.entries_[key];
    assert(entry !== void 0, 15);
    if (entry === this.newest_) {
      this.newest_ = entry.older;
      if (this.newest_) {
        this.newest_.newer = null;
      }
    } else if (entry === this.oldest_) {
      this.oldest_ = entry.newer;
      if (this.oldest_) {
        this.oldest_.older = null;
      }
    } else {
      entry.newer.older = entry.older;
      entry.older.newer = entry.newer;
    }
    delete this.entries_[key];
    --this.count_;
    return entry.value_;
  };
  LRUCache2.prototype.getCount = function() {
    return this.count_;
  };
  LRUCache2.prototype.getKeys = function() {
    var keys3 = new Array(this.count_);
    var i2 = 0;
    var entry;
    for (entry = this.newest_; entry; entry = entry.older) {
      keys3[i2++] = entry.key_;
    }
    return keys3;
  };
  LRUCache2.prototype.getValues = function() {
    var values2 = new Array(this.count_);
    var i2 = 0;
    var entry;
    for (entry = this.newest_; entry; entry = entry.older) {
      values2[i2++] = entry.value_;
    }
    return values2;
  };
  LRUCache2.prototype.peekLast = function() {
    return this.oldest_.value_;
  };
  LRUCache2.prototype.peekLastKey = function() {
    return this.oldest_.key_;
  };
  LRUCache2.prototype.peekFirstKey = function() {
    return this.newest_.key_;
  };
  LRUCache2.prototype.pop = function() {
    var entry = this.oldest_;
    delete this.entries_[entry.key_];
    if (entry.newer) {
      entry.newer.older = null;
    }
    this.oldest_ = entry.newer;
    if (!this.oldest_) {
      this.newest_ = null;
    }
    --this.count_;
    return entry.value_;
  };
  LRUCache2.prototype.replace = function(key, value) {
    this.get(key);
    this.entries_[key].value_ = value;
  };
  LRUCache2.prototype.set = function(key, value) {
    assert(!(key in this.entries_), 16);
    var entry = {
      key_: key,
      newer: null,
      older: this.newest_,
      value_: value
    };
    if (!this.newest_) {
      this.oldest_ = entry;
    } else {
      this.newest_.newer = entry;
    }
    this.newest_ = entry;
    this.entries_[key] = entry;
    ++this.count_;
  };
  LRUCache2.prototype.setSize = function(size) {
    this.highWaterMark = size;
  };
  return LRUCache2;
}();
var LRUCache$1 = LRUCache;
var __extends$U = globalThis && globalThis.__extends || function() {
  var extendStatics2 = function(d2, b2) {
    extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {
      d3.__proto__ = b3;
    } || function(d3, b3) {
      for (var p5 in b3)
        if (Object.prototype.hasOwnProperty.call(b3, p5))
          d3[p5] = b3[p5];
    };
    return extendStatics2(d2, b2);
  };
  return function(d2, b2) {
    if (typeof b2 !== "function" && b2 !== null)
      throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
    extendStatics2(d2, b2);
    function __() {
      this.constructor = d2;
    }
    d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
  };
}();
var DataTile = function(_super) {
  __extends$U(DataTile2, _super);
  function DataTile2(options) {
    var _this = this;
    var state = TileState.IDLE;
    _this = _super.call(this, options.tileCoord, state, {
      transition: options.transition,
      interpolate: options.interpolate
    }) || this;
    _this.loader_ = options.loader;
    _this.data_ = null;
    _this.error_ = null;
    return _this;
  }
  DataTile2.prototype.getData = function() {
    return this.data_;
  };
  DataTile2.prototype.getError = function() {
    return this.error_;
  };
  DataTile2.prototype.load = function() {
    this.state = TileState.LOADING;
    this.changed();
    var self2 = this;
    this.loader_().then(function(data2) {
      self2.data_ = data2;
      self2.state = TileState.LOADED;
      self2.changed();
    }).catch(function(error) {
      self2.error_ = error;
      self2.state = TileState.ERROR;
      self2.changed();
    });
  };
  return DataTile2;
}(Tile$1);
var DataTile$1 = DataTile;
var ARRAY_BUFFER = 34962;
var ELEMENT_ARRAY_BUFFER = 34963;
var STREAM_DRAW = 35040;
var STATIC_DRAW = 35044;
var DYNAMIC_DRAW = 35048;
var UNSIGNED_BYTE = 5121;
var UNSIGNED_SHORT = 5123;
var UNSIGNED_INT = 5125;
var FLOAT = 5126;
var CONTEXT_IDS = ["experimental-webgl", "webgl", "webkit-3d", "moz-webgl"];
function getContext(canvas, opt_attributes) {
  var attributes = assign({
    preserveDrawingBuffer: true,
    antialias: SAFARI_BUG_237906 ? false : true
  }, opt_attributes);
  var ii = CONTEXT_IDS.length;
  for (var i2 = 0; i2 < ii; ++i2) {
    try {
      var context = canvas.getContext(CONTEXT_IDS[i2], attributes);
      if (context) {
        return context;
      }
    } catch (e2) {
    }
  }
  return null;
}
var BufferUsage = {
  STATIC_DRAW,
  STREAM_DRAW,
  DYNAMIC_DRAW
};
var WebGLArrayBuffer = function() {
  function WebGLArrayBuffer2(type, opt_usage) {
    this.array = null;
    this.type = type;
    assert(type === ARRAY_BUFFER || type === ELEMENT_ARRAY_BUFFER, 62);
    this.usage = opt_usage !== void 0 ? opt_usage : BufferUsage.STATIC_DRAW;
  }
  WebGLArrayBuffer2.prototype.ofSize = function(size) {
    this.array = new (getArrayClassForType(this.type))(size);
  };
  WebGLArrayBuffer2.prototype.fromArray = function(array) {
    var arrayClass = getArrayClassForType(this.type);
    this.array = arrayClass.from ? arrayClass.from(array) : new arrayClass(array);
  };
  WebGLArrayBuffer2.prototype.fromArrayBuffer = function(buffer2) {
    this.array = new (getArrayClassForType(this.type))(buffer2);
  };
  WebGLArrayBuffer2.prototype.getType = function() {
    return this.type;
  };
  WebGLArrayBuffer2.prototype.getArray = function() {
    return this.array;
  };
  WebGLArrayBuffer2.prototype.getUsage = function() {
    return this.usage;
  };
  WebGLArrayBuffer2.prototype.getSize = function() {
    return this.array ? this.array.length : 0;
  };
  return WebGLArrayBuffer2;
}();
function getArrayClassForType(type) {
  switch (type) {
    case ARRAY_BUFFER:
      return Float32Array;
    case ELEMENT_ARRAY_BUFFER:
      return Uint32Array;
    default:
      return Float32Array;
  }
}
var WebGLArrayBuffer$1 = WebGLArrayBuffer;
var __extends$T = globalThis && globalThis.__extends || function() {
  var extendStatics2 = function(d2, b2) {
    extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {
      d3.__proto__ = b3;
    } || function(d3, b3) {
      for (var p5 in b3)
        if (Object.prototype.hasOwnProperty.call(b3, p5))
          d3[p5] = b3[p5];
    };
    return extendStatics2(d2, b2);
  };
  return function(d2, b2) {
    if (typeof b2 !== "function" && b2 !== null)
      throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
    extendStatics2(d2, b2);
    function __() {
      this.constructor = d2;
    }
    d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
  };
}();
function bindAndConfigure(gl, texture, interpolate) {
  var resampleFilter = interpolate ? gl.LINEAR : gl.NEAREST;
  gl.bindTexture(gl.TEXTURE_2D, texture);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, resampleFilter);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, resampleFilter);
}
function uploadImageTexture(gl, texture, image2, interpolate) {
  bindAndConfigure(gl, texture, interpolate);
  gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, image2);
}
function uploadDataTexture(helper, texture, data2, size, bandCount, interpolate) {
  var gl = helper.getGL();
  var textureType;
  var canInterpolate;
  if (data2 instanceof Float32Array) {
    textureType = gl.FLOAT;
    helper.getExtension("OES_texture_float");
    var extension = helper.getExtension("OES_texture_float_linear");
    canInterpolate = extension !== null;
  } else {
    textureType = gl.UNSIGNED_BYTE;
    canInterpolate = true;
  }
  bindAndConfigure(gl, texture, interpolate && canInterpolate);
  var bytesPerRow = data2.byteLength / size[1];
  var unpackAlignment = 1;
  if (bytesPerRow % 8 === 0) {
    unpackAlignment = 8;
  } else if (bytesPerRow % 4 === 0) {
    unpackAlignment = 4;
  } else if (bytesPerRow % 2 === 0) {
    unpackAlignment = 2;
  }
  var format2;
  switch (bandCount) {
    case 1: {
      format2 = gl.LUMINANCE;
      break;
    }
    case 2: {
      format2 = gl.LUMINANCE_ALPHA;
      break;
    }
    case 3: {
      format2 = gl.RGB;
      break;
    }
    case 4: {
      format2 = gl.RGBA;
      break;
    }
    default: {
      throw new Error("Unsupported number of bands: ".concat(bandCount));
    }
  }
  var oldUnpackAlignment = gl.getParameter(gl.UNPACK_ALIGNMENT);
  gl.pixelStorei(gl.UNPACK_ALIGNMENT, unpackAlignment);
  gl.texImage2D(gl.TEXTURE_2D, 0, format2, size[0], size[1], 0, format2, textureType, data2);
  gl.pixelStorei(gl.UNPACK_ALIGNMENT, oldUnpackAlignment);
}
var pixelContext = null;
function createPixelContext() {
  var canvas = document.createElement("canvas");
  canvas.width = 1;
  canvas.height = 1;
  pixelContext = canvas.getContext("2d");
}
var TileTexture = function(_super) {
  __extends$T(TileTexture2, _super);
  function TileTexture2(options) {
    var _this = _super.call(this) || this;
    _this.tile;
    _this.textures = [];
    _this.handleTileChange_ = _this.handleTileChange_.bind(_this);
    _this.size = toSize(options.grid.getTileSize(options.tile.tileCoord[0]));
    _this.tilePixelRatio_ = options.tilePixelRatio || 1;
    _this.gutter_ = options.gutter || 0;
    _this.bandCount = NaN;
    _this.helper_ = options.helper;
    var coords = new WebGLArrayBuffer$1(ARRAY_BUFFER, STATIC_DRAW);
    coords.fromArray([
      0,
      1,
      1,
      1,
      1,
      0,
      0,
      0
    ]);
    _this.helper_.flushBufferData(coords);
    _this.coords = coords;
    _this.setTile(options.tile);
    return _this;
  }
  TileTexture2.prototype.setTile = function(tile2) {
    if (tile2 !== this.tile) {
      if (this.tile) {
        this.tile.removeEventListener(EventType.CHANGE, this.handleTileChange_);
      }
      this.tile = tile2;
      this.textures.length = 0;
      this.loaded = tile2.getState() === TileState.LOADED;
      if (this.loaded) {
        this.uploadTile_();
      } else {
        if (tile2 instanceof ImageTile$1) {
          var image2 = tile2.getImage();
          if (image2 instanceof Image && !image2.crossOrigin) {
            image2.crossOrigin = "anonymous";
          }
        }
        tile2.addEventListener(EventType.CHANGE, this.handleTileChange_);
      }
    }
  };
  TileTexture2.prototype.uploadTile_ = function() {
    var helper = this.helper_;
    var gl = helper.getGL();
    var tile2 = this.tile;
    if (tile2 instanceof ImageTile$1 || tile2 instanceof ReprojTile$1) {
      var image2 = tile2.getImage();
      if (this.gutter_ !== 0) {
        var gutter = this.tilePixelRatio_ * this.gutter_;
        var width = Math.round(image2.width - 2 * gutter);
        var height = Math.round(image2.height - 2 * gutter);
        var context = createCanvasContext2D(width, height);
        if (!tile2.interpolate) {
          assign(context, IMAGE_SMOOTHING_DISABLED);
        }
        context.drawImage(image2, gutter, gutter, width, height, 0, 0, width, height);
        image2 = context.canvas;
      }
      var texture = gl.createTexture();
      this.textures.push(texture);
      this.bandCount = 4;
      uploadImageTexture(gl, texture, image2, tile2.interpolate);
      return;
    }
    var pixelSize = [
      this.size[0] * this.tilePixelRatio_,
      this.size[1] * this.tilePixelRatio_
    ];
    var data2 = tile2.getData();
    var isFloat = data2 instanceof Float32Array;
    var pixelCount = pixelSize[0] * pixelSize[1];
    var DataType = isFloat ? Float32Array : Uint8Array;
    var bytesPerElement = DataType.BYTES_PER_ELEMENT;
    var bytesPerRow = data2.byteLength / pixelSize[1];
    this.bandCount = Math.floor(bytesPerRow / bytesPerElement / pixelSize[0]);
    var textureCount = Math.ceil(this.bandCount / 4);
    if (textureCount === 1) {
      var texture = gl.createTexture();
      this.textures.push(texture);
      uploadDataTexture(helper, texture, data2, pixelSize, this.bandCount, tile2.interpolate);
      return;
    }
    var textureDataArrays = new Array(textureCount);
    for (var textureIndex = 0; textureIndex < textureCount; ++textureIndex) {
      var texture = gl.createTexture();
      this.textures.push(texture);
      var bandCount = textureIndex < textureCount - 1 ? 4 : this.bandCount % 4;
      textureDataArrays[textureIndex] = new DataType(pixelCount * bandCount);
    }
    var dataIndex = 0;
    var rowOffset = 0;
    var colCount = pixelSize[0] * this.bandCount;
    for (var rowIndex = 0; rowIndex < pixelSize[1]; ++rowIndex) {
      for (var colIndex = 0; colIndex < colCount; ++colIndex) {
        var dataValue = data2[rowOffset + colIndex];
        var pixelIndex = Math.floor(dataIndex / this.bandCount);
        var bandIndex = colIndex % this.bandCount;
        var textureIndex = Math.floor(bandIndex / 4);
        var textureData = textureDataArrays[textureIndex];
        var bandCount = textureData.length / pixelCount;
        var textureBandIndex = bandIndex % 4;
        textureData[pixelIndex * bandCount + textureBandIndex] = dataValue;
        ++dataIndex;
      }
      rowOffset += bytesPerRow / bytesPerElement;
    }
    for (var textureIndex = 0; textureIndex < textureCount; ++textureIndex) {
      var texture = this.textures[textureIndex];
      var textureData = textureDataArrays[textureIndex];
      var bandCount = textureData.length / pixelCount;
      uploadDataTexture(helper, texture, textureData, pixelSize, bandCount, tile2.interpolate);
    }
  };
  TileTexture2.prototype.handleTileChange_ = function() {
    if (this.tile.getState() === TileState.LOADED) {
      this.loaded = true;
      this.uploadTile_();
      this.dispatchEvent(EventType.CHANGE);
    }
  };
  TileTexture2.prototype.disposeInternal = function() {
    var gl = this.helper_.getGL();
    this.helper_.deleteBuffer(this.coords);
    for (var i2 = 0; i2 < this.textures.length; ++i2) {
      gl.deleteTexture(this.textures[i2]);
    }
    this.tile.removeEventListener(EventType.CHANGE, this.handleTileChange_);
  };
  TileTexture2.prototype.getPixelData = function(col, row) {
    if (!this.loaded) {
      return null;
    }
    col = Math.floor(this.tilePixelRatio_ * col);
    row = Math.floor(this.tilePixelRatio_ * row);
    if (this.tile instanceof DataTile$1) {
      var data_1 = this.tile.getData();
      var pixelsPerRow = Math.floor(this.tilePixelRatio_ * this.size[0]);
      if (data_1 instanceof DataView) {
        var bytesPerPixel = data_1.byteLength / (this.size[0] * this.size[1]);
        var offset_1 = row * pixelsPerRow * bytesPerPixel + col * bytesPerPixel;
        var buffer2 = data_1.buffer.slice(offset_1, offset_1 + bytesPerPixel);
        return new DataView(buffer2);
      }
      var offset2 = row * pixelsPerRow * this.bandCount + col * this.bandCount;
      return data_1.slice(offset2, offset2 + this.bandCount);
    }
    if (!pixelContext) {
      createPixelContext();
    }
    pixelContext.clearRect(0, 0, 1, 1);
    var data2;
    var image2 = this.tile.getImage();
    try {
      pixelContext.drawImage(image2, col, row, 1, 1, 0, 0, 1, 1);
      data2 = pixelContext.getImageData(0, 0, 1, 1).data;
    } catch (err) {
      return null;
    }
    return data2;
  };
  return TileTexture2;
}(EventTarget);
var TileTexture$1 = TileTexture;
var ContextEventType = {
  LOST: "webglcontextlost",
  RESTORED: "webglcontextrestored"
};
var DEFAULT_VERTEX_SHADER = "\n  precision mediump float;\n  \n  attribute vec2 a_position;\n  varying vec2 v_texCoord;\n  varying vec2 v_screenCoord;\n  \n  uniform vec2 u_screenSize;\n   \n  void main() {\n    v_texCoord = a_position * 0.5 + 0.5;\n    v_screenCoord = v_texCoord * u_screenSize;\n    gl_Position = vec4(a_position, 0.0, 1.0);\n  }\n";
var DEFAULT_FRAGMENT_SHADER = "\n  precision mediump float;\n   \n  uniform sampler2D u_image;\n  uniform float u_opacity;\n   \n  varying vec2 v_texCoord;\n   \n  void main() {\n    gl_FragColor = texture2D(u_image, v_texCoord) * u_opacity;\n  }\n";
var WebGLPostProcessingPass = function() {
  function WebGLPostProcessingPass2(options) {
    this.gl_ = options.webGlContext;
    var gl = this.gl_;
    this.scaleRatio_ = options.scaleRatio || 1;
    this.renderTargetTexture_ = gl.createTexture();
    this.renderTargetTextureSize_ = null;
    this.frameBuffer_ = gl.createFramebuffer();
    var vertexShader = gl.createShader(gl.VERTEX_SHADER);
    gl.shaderSource(vertexShader, options.vertexShader || DEFAULT_VERTEX_SHADER);
    gl.compileShader(vertexShader);
    var fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);
    gl.shaderSource(fragmentShader, options.fragmentShader || DEFAULT_FRAGMENT_SHADER);
    gl.compileShader(fragmentShader);
    this.renderTargetProgram_ = gl.createProgram();
    gl.attachShader(this.renderTargetProgram_, vertexShader);
    gl.attachShader(this.renderTargetProgram_, fragmentShader);
    gl.linkProgram(this.renderTargetProgram_);
    this.renderTargetVerticesBuffer_ = gl.createBuffer();
    var verticesArray = [-1, -1, 1, -1, -1, 1, 1, -1, 1, 1, -1, 1];
    gl.bindBuffer(gl.ARRAY_BUFFER, this.renderTargetVerticesBuffer_);
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(verticesArray), gl.STATIC_DRAW);
    this.renderTargetAttribLocation_ = gl.getAttribLocation(this.renderTargetProgram_, "a_position");
    this.renderTargetUniformLocation_ = gl.getUniformLocation(this.renderTargetProgram_, "u_screenSize");
    this.renderTargetOpacityLocation_ = gl.getUniformLocation(this.renderTargetProgram_, "u_opacity");
    this.renderTargetTextureLocation_ = gl.getUniformLocation(this.renderTargetProgram_, "u_image");
    this.uniforms_ = [];
    options.uniforms && Object.keys(options.uniforms).forEach(function(name) {
      this.uniforms_.push({
        value: options.uniforms[name],
        location: gl.getUniformLocation(this.renderTargetProgram_, name)
      });
    }.bind(this));
  }
  WebGLPostProcessingPass2.prototype.getGL = function() {
    return this.gl_;
  };
  WebGLPostProcessingPass2.prototype.init = function(frameState) {
    var gl = this.getGL();
    var textureSize = [
      gl.drawingBufferWidth * this.scaleRatio_,
      gl.drawingBufferHeight * this.scaleRatio_
    ];
    gl.bindFramebuffer(gl.FRAMEBUFFER, this.getFrameBuffer());
    gl.viewport(0, 0, textureSize[0], textureSize[1]);
    if (!this.renderTargetTextureSize_ || this.renderTargetTextureSize_[0] !== textureSize[0] || this.renderTargetTextureSize_[1] !== textureSize[1]) {
      this.renderTargetTextureSize_ = textureSize;
      var level = 0;
      var internalFormat = gl.RGBA;
      var border = 0;
      var format2 = gl.RGBA;
      var type = gl.UNSIGNED_BYTE;
      var data2 = null;
      gl.bindTexture(gl.TEXTURE_2D, this.renderTargetTexture_);
      gl.texImage2D(gl.TEXTURE_2D, level, internalFormat, textureSize[0], textureSize[1], border, format2, type, data2);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
      gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, this.renderTargetTexture_, 0);
    }
  };
  WebGLPostProcessingPass2.prototype.apply = function(frameState, nextPass, preCompose, postCompose) {
    var gl = this.getGL();
    var size = frameState.size;
    gl.bindFramebuffer(gl.FRAMEBUFFER, nextPass ? nextPass.getFrameBuffer() : null);
    gl.activeTexture(gl.TEXTURE0);
    gl.bindTexture(gl.TEXTURE_2D, this.renderTargetTexture_);
    if (!nextPass) {
      var canvasId = getUid(gl.canvas);
      if (!frameState.renderTargets[canvasId]) {
        var attributes = gl.getContextAttributes();
        if (attributes && attributes.preserveDrawingBuffer) {
          gl.clearColor(0, 0, 0, 0);
          gl.clear(gl.COLOR_BUFFER_BIT);
        }
        frameState.renderTargets[canvasId] = true;
      }
    }
    gl.enable(gl.BLEND);
    gl.blendFunc(gl.ONE, gl.ONE_MINUS_SRC_ALPHA);
    gl.viewport(0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight);
    gl.bindBuffer(gl.ARRAY_BUFFER, this.renderTargetVerticesBuffer_);
    gl.useProgram(this.renderTargetProgram_);
    gl.enableVertexAttribArray(this.renderTargetAttribLocation_);
    gl.vertexAttribPointer(this.renderTargetAttribLocation_, 2, gl.FLOAT, false, 0, 0);
    gl.uniform2f(this.renderTargetUniformLocation_, size[0], size[1]);
    gl.uniform1i(this.renderTargetTextureLocation_, 0);
    var opacity2 = frameState.layerStatesArray[frameState.layerIndex].opacity;
    gl.uniform1f(this.renderTargetOpacityLocation_, opacity2);
    this.applyUniforms(frameState);
    if (preCompose) {
      preCompose(gl, frameState);
    }
    gl.drawArrays(gl.TRIANGLES, 0, 6);
    if (postCompose) {
      postCompose(gl, frameState);
    }
  };
  WebGLPostProcessingPass2.prototype.getFrameBuffer = function() {
    return this.frameBuffer_;
  };
  WebGLPostProcessingPass2.prototype.applyUniforms = function(frameState) {
    var gl = this.getGL();
    var value;
    var textureSlot = 1;
    this.uniforms_.forEach(function(uniform) {
      value = typeof uniform.value === "function" ? uniform.value(frameState) : uniform.value;
      if (value instanceof HTMLCanvasElement || value instanceof ImageData) {
        if (!uniform.texture) {
          uniform.texture = gl.createTexture();
        }
        gl.activeTexture(gl["TEXTURE".concat(textureSlot)]);
        gl.bindTexture(gl.TEXTURE_2D, uniform.texture);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
        if (value instanceof ImageData) {
          gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, value.width, value.height, 0, gl.UNSIGNED_BYTE, new Uint8Array(value.data));
        } else {
          gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, value);
        }
        gl.uniform1i(uniform.location, textureSlot++);
      } else if (Array.isArray(value)) {
        switch (value.length) {
          case 2:
            gl.uniform2f(uniform.location, value[0], value[1]);
            return;
          case 3:
            gl.uniform3f(uniform.location, value[0], value[1], value[2]);
            return;
          case 4:
            gl.uniform4f(uniform.location, value[0], value[1], value[2], value[3]);
            return;
          default:
            return;
        }
      } else if (typeof value === "number") {
        gl.uniform1f(uniform.location, value);
      }
    });
  };
  return WebGLPostProcessingPass2;
}();
var WebGLPostProcessingPass$1 = WebGLPostProcessingPass;
function create$5() {
  return [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
}
function fromTransform(mat4, transform2) {
  mat4[0] = transform2[0];
  mat4[1] = transform2[1];
  mat4[4] = transform2[2];
  mat4[5] = transform2[3];
  mat4[12] = transform2[4];
  mat4[13] = transform2[5];
  return mat4;
}
var __extends$S = globalThis && globalThis.__extends || function() {
  var extendStatics2 = function(d2, b2) {
    extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {
      d3.__proto__ = b3;
    } || function(d3, b3) {
      for (var p5 in b3)
        if (Object.prototype.hasOwnProperty.call(b3, p5))
          d3[p5] = b3[p5];
    };
    return extendStatics2(d2, b2);
  };
  return function(d2, b2) {
    if (typeof b2 !== "function" && b2 !== null)
      throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
    extendStatics2(d2, b2);
    function __() {
      this.constructor = d2;
    }
    d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
  };
}();
var DefaultUniform = {
  PROJECTION_MATRIX: "u_projectionMatrix",
  OFFSET_SCALE_MATRIX: "u_offsetScaleMatrix",
  OFFSET_ROTATION_MATRIX: "u_offsetRotateMatrix",
  TIME: "u_time",
  ZOOM: "u_zoom",
  RESOLUTION: "u_resolution"
};
var AttributeType = {
  UNSIGNED_BYTE,
  UNSIGNED_SHORT,
  UNSIGNED_INT,
  FLOAT
};
var canvasCache = {};
function getSharedCanvasCacheKey(key) {
  return "shared/" + key;
}
var uniqueCanvasCacheKeyCount = 0;
function getUniqueCanvasCacheKey() {
  var key = "unique/" + uniqueCanvasCacheKeyCount;
  uniqueCanvasCacheKeyCount += 1;
  return key;
}
function getCanvas(key) {
  var cacheItem = canvasCache[key];
  if (!cacheItem) {
    var canvas = document.createElement("canvas");
    canvas.style.position = "absolute";
    canvas.style.left = "0";
    cacheItem = { users: 0, canvas };
    canvasCache[key] = cacheItem;
  }
  cacheItem.users += 1;
  return cacheItem.canvas;
}
function releaseCanvas(key) {
  var cacheItem = canvasCache[key];
  if (!cacheItem) {
    return;
  }
  cacheItem.users -= 1;
  if (cacheItem.users > 0) {
    return;
  }
  var canvas = cacheItem.canvas;
  var gl = getContext(canvas);
  var extension = gl.getExtension("WEBGL_lose_context");
  if (extension) {
    extension.loseContext();
  }
  delete canvasCache[key];
}
var WebGLHelper = function(_super) {
  __extends$S(WebGLHelper2, _super);
  function WebGLHelper2(opt_options) {
    var _this = _super.call(this) || this;
    var options = opt_options || {};
    _this.boundHandleWebGLContextLost_ = _this.handleWebGLContextLost.bind(_this);
    _this.boundHandleWebGLContextRestored_ = _this.handleWebGLContextRestored.bind(_this);
    _this.canvasCacheKey_ = options.canvasCacheKey ? getSharedCanvasCacheKey(options.canvasCacheKey) : getUniqueCanvasCacheKey();
    _this.canvas_ = getCanvas(_this.canvasCacheKey_);
    _this.gl_ = getContext(_this.canvas_);
    _this.bufferCache_ = {};
    _this.extensionCache_ = {};
    _this.currentProgram_ = null;
    _this.canvas_.addEventListener(ContextEventType.LOST, _this.boundHandleWebGLContextLost_);
    _this.canvas_.addEventListener(ContextEventType.RESTORED, _this.boundHandleWebGLContextRestored_);
    _this.offsetRotateMatrix_ = create$6();
    _this.offsetScaleMatrix_ = create$6();
    _this.tmpMat4_ = create$5();
    _this.uniformLocations_ = {};
    _this.attribLocations_ = {};
    _this.uniforms_ = [];
    if (options.uniforms) {
      _this.setUniforms(options.uniforms);
    }
    var gl = _this.getGL();
    _this.postProcessPasses_ = options.postProcesses ? options.postProcesses.map(function(options2) {
      return new WebGLPostProcessingPass$1({
        webGlContext: gl,
        scaleRatio: options2.scaleRatio,
        vertexShader: options2.vertexShader,
        fragmentShader: options2.fragmentShader,
        uniforms: options2.uniforms
      });
    }) : [new WebGLPostProcessingPass$1({ webGlContext: gl })];
    _this.shaderCompileErrors_ = null;
    _this.startTime_ = Date.now();
    return _this;
  }
  WebGLHelper2.prototype.setUniforms = function(uniforms) {
    this.uniforms_ = [];
    for (var name_1 in uniforms) {
      this.uniforms_.push({
        name: name_1,
        value: uniforms[name_1]
      });
    }
    this.uniformLocations_ = {};
  };
  WebGLHelper2.prototype.canvasCacheKeyMatches = function(canvasCacheKey) {
    return this.canvasCacheKey_ === getSharedCanvasCacheKey(canvasCacheKey);
  };
  WebGLHelper2.prototype.getExtension = function(name) {
    if (name in this.extensionCache_) {
      return this.extensionCache_[name];
    }
    var extension = this.gl_.getExtension(name);
    this.extensionCache_[name] = extension;
    return extension;
  };
  WebGLHelper2.prototype.bindBuffer = function(buffer2) {
    var gl = this.getGL();
    var bufferKey = getUid(buffer2);
    var bufferCache = this.bufferCache_[bufferKey];
    if (!bufferCache) {
      var webGlBuffer = gl.createBuffer();
      bufferCache = {
        buffer: buffer2,
        webGlBuffer
      };
      this.bufferCache_[bufferKey] = bufferCache;
    }
    gl.bindBuffer(buffer2.getType(), bufferCache.webGlBuffer);
  };
  WebGLHelper2.prototype.flushBufferData = function(buffer2) {
    var gl = this.getGL();
    this.bindBuffer(buffer2);
    gl.bufferData(buffer2.getType(), buffer2.getArray(), buffer2.getUsage());
  };
  WebGLHelper2.prototype.deleteBuffer = function(buf) {
    var gl = this.getGL();
    var bufferKey = getUid(buf);
    var bufferCacheEntry = this.bufferCache_[bufferKey];
    if (bufferCacheEntry && !gl.isContextLost()) {
      gl.deleteBuffer(bufferCacheEntry.webGlBuffer);
    }
    delete this.bufferCache_[bufferKey];
  };
  WebGLHelper2.prototype.disposeInternal = function() {
    this.canvas_.removeEventListener(ContextEventType.LOST, this.boundHandleWebGLContextLost_);
    this.canvas_.removeEventListener(ContextEventType.RESTORED, this.boundHandleWebGLContextRestored_);
    releaseCanvas(this.canvasCacheKey_);
    delete this.gl_;
    delete this.canvas_;
  };
  WebGLHelper2.prototype.prepareDraw = function(frameState, opt_disableAlphaBlend) {
    var gl = this.getGL();
    var canvas = this.getCanvas();
    var size = frameState.size;
    var pixelRatio = frameState.pixelRatio;
    canvas.width = size[0] * pixelRatio;
    canvas.height = size[1] * pixelRatio;
    canvas.style.width = size[0] + "px";
    canvas.style.height = size[1] + "px";
    gl.useProgram(this.currentProgram_);
    for (var i2 = this.postProcessPasses_.length - 1; i2 >= 0; i2--) {
      this.postProcessPasses_[i2].init(frameState);
    }
    gl.bindTexture(gl.TEXTURE_2D, null);
    gl.clearColor(0, 0, 0, 0);
    gl.clear(gl.COLOR_BUFFER_BIT);
    gl.enable(gl.BLEND);
    gl.blendFunc(gl.ONE, opt_disableAlphaBlend ? gl.ZERO : gl.ONE_MINUS_SRC_ALPHA);
    gl.useProgram(this.currentProgram_);
    this.applyFrameState(frameState);
    this.applyUniforms(frameState);
  };
  WebGLHelper2.prototype.prepareDrawToRenderTarget = function(frameState, renderTarget, opt_disableAlphaBlend) {
    var gl = this.getGL();
    var size = renderTarget.getSize();
    gl.bindFramebuffer(gl.FRAMEBUFFER, renderTarget.getFramebuffer());
    gl.viewport(0, 0, size[0], size[1]);
    gl.bindTexture(gl.TEXTURE_2D, renderTarget.getTexture());
    gl.clearColor(0, 0, 0, 0);
    gl.clear(gl.COLOR_BUFFER_BIT);
    gl.enable(gl.BLEND);
    gl.blendFunc(gl.ONE, opt_disableAlphaBlend ? gl.ZERO : gl.ONE_MINUS_SRC_ALPHA);
    gl.useProgram(this.currentProgram_);
    this.applyFrameState(frameState);
    this.applyUniforms(frameState);
  };
  WebGLHelper2.prototype.drawElements = function(start2, end) {
    var gl = this.getGL();
    this.getExtension("OES_element_index_uint");
    var elementType = gl.UNSIGNED_INT;
    var elementSize = 4;
    var numItems = end - start2;
    var offsetInBytes = start2 * elementSize;
    gl.drawElements(gl.TRIANGLES, numItems, elementType, offsetInBytes);
  };
  WebGLHelper2.prototype.finalizeDraw = function(frameState, preCompose, postCompose) {
    for (var i2 = 0, ii = this.postProcessPasses_.length; i2 < ii; i2++) {
      if (i2 === ii - 1) {
        this.postProcessPasses_[i2].apply(frameState, null, preCompose, postCompose);
      } else {
        this.postProcessPasses_[i2].apply(frameState, this.postProcessPasses_[i2 + 1]);
      }
    }
  };
  WebGLHelper2.prototype.getCanvas = function() {
    return this.canvas_;
  };
  WebGLHelper2.prototype.getGL = function() {
    return this.gl_;
  };
  WebGLHelper2.prototype.applyFrameState = function(frameState) {
    var size = frameState.size;
    var rotation = frameState.viewState.rotation;
    var offsetScaleMatrix = reset(this.offsetScaleMatrix_);
    scale$3(offsetScaleMatrix, 2 / size[0], 2 / size[1]);
    var offsetRotateMatrix = reset(this.offsetRotateMatrix_);
    if (rotation !== 0) {
      rotate$2(offsetRotateMatrix, -rotation);
    }
    this.setUniformMatrixValue(DefaultUniform.OFFSET_SCALE_MATRIX, fromTransform(this.tmpMat4_, offsetScaleMatrix));
    this.setUniformMatrixValue(DefaultUniform.OFFSET_ROTATION_MATRIX, fromTransform(this.tmpMat4_, offsetRotateMatrix));
    this.setUniformFloatValue(DefaultUniform.TIME, (Date.now() - this.startTime_) * 1e-3);
    this.setUniformFloatValue(DefaultUniform.ZOOM, frameState.viewState.zoom);
    this.setUniformFloatValue(DefaultUniform.RESOLUTION, frameState.viewState.resolution);
  };
  WebGLHelper2.prototype.applyUniforms = function(frameState) {
    var gl = this.getGL();
    var value;
    var textureSlot = 0;
    this.uniforms_.forEach(function(uniform) {
      value = typeof uniform.value === "function" ? uniform.value(frameState) : uniform.value;
      if (value instanceof HTMLCanvasElement || value instanceof HTMLImageElement || value instanceof ImageData) {
        if (!uniform.texture) {
          uniform.prevValue = void 0;
          uniform.texture = gl.createTexture();
        }
        gl.activeTexture(gl["TEXTURE".concat(textureSlot)]);
        gl.bindTexture(gl.TEXTURE_2D, uniform.texture);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
        var imageReady2 = !(value instanceof HTMLImageElement) || value.complete;
        if (imageReady2 && uniform.prevValue !== value) {
          uniform.prevValue = value;
          gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, value);
        }
        gl.uniform1i(this.getUniformLocation(uniform.name), textureSlot++);
      } else if (Array.isArray(value) && value.length === 6) {
        this.setUniformMatrixValue(uniform.name, fromTransform(this.tmpMat4_, value));
      } else if (Array.isArray(value) && value.length <= 4) {
        switch (value.length) {
          case 2:
            gl.uniform2f(this.getUniformLocation(uniform.name), value[0], value[1]);
            return;
          case 3:
            gl.uniform3f(this.getUniformLocation(uniform.name), value[0], value[1], value[2]);
            return;
          case 4:
            gl.uniform4f(this.getUniformLocation(uniform.name), value[0], value[1], value[2], value[3]);
            return;
          default:
            return;
        }
      } else if (typeof value === "number") {
        gl.uniform1f(this.getUniformLocation(uniform.name), value);
      }
    }.bind(this));
  };
  WebGLHelper2.prototype.useProgram = function(program) {
    if (program == this.currentProgram_) {
      return false;
    } else {
      var gl = this.getGL();
      gl.useProgram(program);
      this.currentProgram_ = program;
      this.uniformLocations_ = {};
      this.attribLocations_ = {};
      return true;
    }
  };
  WebGLHelper2.prototype.compileShader = function(source, type) {
    var gl = this.getGL();
    var shader = gl.createShader(type);
    gl.shaderSource(shader, source);
    gl.compileShader(shader);
    return shader;
  };
  WebGLHelper2.prototype.getProgram = function(fragmentShaderSource, vertexShaderSource) {
    var gl = this.getGL();
    var fragmentShader = this.compileShader(fragmentShaderSource, gl.FRAGMENT_SHADER);
    var vertexShader = this.compileShader(vertexShaderSource, gl.VERTEX_SHADER);
    var program = gl.createProgram();
    gl.attachShader(program, fragmentShader);
    gl.attachShader(program, vertexShader);
    gl.linkProgram(program);
    if (!gl.getShaderParameter(fragmentShader, gl.COMPILE_STATUS)) {
      var message = "Fragment shader compliation failed: ".concat(gl.getShaderInfoLog(fragmentShader));
      throw new Error(message);
    }
    gl.deleteShader(fragmentShader);
    if (!gl.getShaderParameter(vertexShader, gl.COMPILE_STATUS)) {
      var message = "Vertex shader compilation failed: ".concat(gl.getShaderInfoLog(vertexShader));
      throw new Error(message);
    }
    gl.deleteShader(vertexShader);
    if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
      var message = "GL program linking failed: ".concat(gl.getShaderInfoLog(vertexShader));
      throw new Error(message);
    }
    return program;
  };
  WebGLHelper2.prototype.getUniformLocation = function(name) {
    if (this.uniformLocations_[name] === void 0) {
      this.uniformLocations_[name] = this.getGL().getUniformLocation(this.currentProgram_, name);
    }
    return this.uniformLocations_[name];
  };
  WebGLHelper2.prototype.getAttributeLocation = function(name) {
    if (this.attribLocations_[name] === void 0) {
      this.attribLocations_[name] = this.getGL().getAttribLocation(this.currentProgram_, name);
    }
    return this.attribLocations_[name];
  };
  WebGLHelper2.prototype.makeProjectionTransform = function(frameState, transform2) {
    var size = frameState.size;
    var rotation = frameState.viewState.rotation;
    var resolution = frameState.viewState.resolution;
    var center = frameState.viewState.center;
    reset(transform2);
    compose(transform2, 0, 0, 2 / (resolution * size[0]), 2 / (resolution * size[1]), -rotation, -center[0], -center[1]);
    return transform2;
  };
  WebGLHelper2.prototype.setUniformFloatValue = function(uniform, value) {
    this.getGL().uniform1f(this.getUniformLocation(uniform), value);
  };
  WebGLHelper2.prototype.setUniformFloatVec4 = function(uniform, value) {
    this.getGL().uniform4fv(this.getUniformLocation(uniform), value);
  };
  WebGLHelper2.prototype.setUniformMatrixValue = function(uniform, value) {
    this.getGL().uniformMatrix4fv(this.getUniformLocation(uniform), false, value);
  };
  WebGLHelper2.prototype.enableAttributeArray_ = function(attribName, size, type, stride, offset2) {
    var location2 = this.getAttributeLocation(attribName);
    if (location2 < 0) {
      return;
    }
    this.getGL().enableVertexAttribArray(location2);
    this.getGL().vertexAttribPointer(location2, size, type, false, stride, offset2);
  };
  WebGLHelper2.prototype.enableAttributes = function(attributes) {
    var stride = computeAttributesStride(attributes);
    var offset2 = 0;
    for (var i2 = 0; i2 < attributes.length; i2++) {
      var attr = attributes[i2];
      this.enableAttributeArray_(attr.name, attr.size, attr.type || FLOAT, stride, offset2);
      offset2 += attr.size * getByteSizeFromType(attr.type);
    }
  };
  WebGLHelper2.prototype.handleWebGLContextLost = function() {
    clear$1(this.bufferCache_);
    this.currentProgram_ = null;
  };
  WebGLHelper2.prototype.handleWebGLContextRestored = function() {
  };
  WebGLHelper2.prototype.createTexture = function(size, opt_data, opt_texture) {
    var gl = this.getGL();
    var texture = opt_texture || gl.createTexture();
    var level = 0;
    var internalFormat = gl.RGBA;
    var border = 0;
    var format2 = gl.RGBA;
    var type = gl.UNSIGNED_BYTE;
    gl.bindTexture(gl.TEXTURE_2D, texture);
    if (opt_data) {
      gl.texImage2D(gl.TEXTURE_2D, level, internalFormat, format2, type, opt_data);
    } else {
      gl.texImage2D(gl.TEXTURE_2D, level, internalFormat, size[0], size[1], border, format2, type, null);
    }
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
    return texture;
  };
  return WebGLHelper2;
}(Disposable$1);
function computeAttributesStride(attributes) {
  var stride = 0;
  for (var i2 = 0; i2 < attributes.length; i2++) {
    var attr = attributes[i2];
    stride += attr.size * getByteSizeFromType(attr.type);
  }
  return stride;
}
function getByteSizeFromType(type) {
  switch (type) {
    case AttributeType.UNSIGNED_BYTE:
      return Uint8Array.BYTES_PER_ELEMENT;
    case AttributeType.UNSIGNED_SHORT:
      return Uint16Array.BYTES_PER_ELEMENT;
    case AttributeType.UNSIGNED_INT:
      return Uint32Array.BYTES_PER_ELEMENT;
    case AttributeType.FLOAT:
    default:
      return Float32Array.BYTES_PER_ELEMENT;
  }
}
var __extends$R = globalThis && globalThis.__extends || function() {
  var extendStatics2 = function(d2, b2) {
    extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {
      d3.__proto__ = b3;
    } || function(d3, b3) {
      for (var p5 in b3)
        if (Object.prototype.hasOwnProperty.call(b3, p5))
          d3[p5] = b3[p5];
    };
    return extendStatics2(d2, b2);
  };
  return function(d2, b2) {
    if (typeof b2 !== "function" && b2 !== null)
      throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
    extendStatics2(d2, b2);
    function __() {
      this.constructor = d2;
    }
    d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
  };
}();
var WebGLWorkerMessageType = {
  GENERATE_BUFFERS: "GENERATE_BUFFERS"
};
var WebGLLayerRenderer = function(_super) {
  __extends$R(WebGLLayerRenderer2, _super);
  function WebGLLayerRenderer2(layer, opt_options) {
    var _this = _super.call(this, layer) || this;
    var options = opt_options || {};
    _this.inversePixelTransform_ = create$6();
    _this.pixelContext_ = null;
    _this.postProcesses_ = options.postProcesses;
    _this.uniforms_ = options.uniforms;
    _this.helper;
    layer.addChangeListener(LayerProperty.MAP, _this.removeHelper.bind(_this));
    _this.dispatchPreComposeEvent = _this.dispatchPreComposeEvent.bind(_this);
    _this.dispatchPostComposeEvent = _this.dispatchPostComposeEvent.bind(_this);
    return _this;
  }
  WebGLLayerRenderer2.prototype.dispatchPreComposeEvent = function(context, frameState) {
    var layer = this.getLayer();
    if (layer.hasListener(RenderEventType.PRECOMPOSE)) {
      var event_1 = new RenderEvent$1(RenderEventType.PRECOMPOSE, void 0, frameState, context);
      layer.dispatchEvent(event_1);
    }
  };
  WebGLLayerRenderer2.prototype.dispatchPostComposeEvent = function(context, frameState) {
    var layer = this.getLayer();
    if (layer.hasListener(RenderEventType.POSTCOMPOSE)) {
      var event_2 = new RenderEvent$1(RenderEventType.POSTCOMPOSE, void 0, frameState, context);
      layer.dispatchEvent(event_2);
    }
  };
  WebGLLayerRenderer2.prototype.reset = function(options) {
    this.uniforms_ = options.uniforms;
    if (this.helper) {
      this.helper.setUniforms(this.uniforms_);
    }
  };
  WebGLLayerRenderer2.prototype.removeHelper = function() {
    if (this.helper) {
      this.helper.dispose();
      delete this.helper;
    }
  };
  WebGLLayerRenderer2.prototype.prepareFrame = function(frameState) {
    if (this.getLayer().getRenderSource()) {
      var incrementGroup = true;
      var groupNumber = -1;
      var className = void 0;
      for (var i2 = 0, ii = frameState.layerStatesArray.length; i2 < ii; i2++) {
        var layer = frameState.layerStatesArray[i2].layer;
        var renderer = layer.getRenderer();
        if (!(renderer instanceof WebGLLayerRenderer2)) {
          incrementGroup = true;
          continue;
        }
        var layerClassName = layer.getClassName();
        if (incrementGroup || layerClassName !== className) {
          groupNumber += 1;
          incrementGroup = false;
        }
        className = layerClassName;
        if (renderer === this) {
          break;
        }
      }
      var canvasCacheKey = "map/" + frameState.mapId + "/group/" + groupNumber;
      if (!this.helper || !this.helper.canvasCacheKeyMatches(canvasCacheKey)) {
        this.removeHelper();
        this.helper = new WebGLHelper({
          postProcesses: this.postProcesses_,
          uniforms: this.uniforms_,
          canvasCacheKey
        });
        if (className) {
          this.helper.getCanvas().className = className;
        }
        this.afterHelperCreated();
      }
    }
    return this.prepareFrameInternal(frameState);
  };
  WebGLLayerRenderer2.prototype.afterHelperCreated = function() {
  };
  WebGLLayerRenderer2.prototype.prepareFrameInternal = function(frameState) {
    return true;
  };
  WebGLLayerRenderer2.prototype.disposeInternal = function() {
    this.removeHelper();
    _super.prototype.disposeInternal.call(this);
  };
  WebGLLayerRenderer2.prototype.dispatchRenderEvent_ = function(type, context, frameState) {
    var layer = this.getLayer();
    if (layer.hasListener(type)) {
      compose(this.inversePixelTransform_, 0, 0, frameState.pixelRatio, -frameState.pixelRatio, 0, 0, -frameState.size[1]);
      var event_3 = new RenderEvent$1(type, this.inversePixelTransform_, frameState, context);
      layer.dispatchEvent(event_3);
    }
  };
  WebGLLayerRenderer2.prototype.preRender = function(context, frameState) {
    this.dispatchRenderEvent_(RenderEventType.PRERENDER, context, frameState);
  };
  WebGLLayerRenderer2.prototype.postRender = function(context, frameState) {
    this.dispatchRenderEvent_(RenderEventType.POSTRENDER, context, frameState);
  };
  WebGLLayerRenderer2.prototype.getDataAtPixel = function(pixel, frameState, hitTolerance) {
    var renderPixel = apply$5([frameState.pixelRatio, 0, 0, frameState.pixelRatio, 0, 0], pixel.slice());
    var gl = this.helper.getGL();
    if (!gl) {
      return null;
    }
    var layer = this.getLayer();
    var layerExtent = layer.getExtent();
    if (layerExtent) {
      var renderCoordinate = apply$5(frameState.pixelToCoordinateTransform, pixel.slice());
      if (!containsCoordinate(layerExtent, renderCoordinate)) {
        return null;
      }
    }
    var attributes = gl.getContextAttributes();
    if (!attributes || !attributes.preserveDrawingBuffer) {
      return new Uint8Array();
    }
    var x2 = Math.round(renderPixel[0]);
    var y2 = Math.round(renderPixel[1]);
    var pixelContext2 = this.pixelContext_;
    if (!pixelContext2) {
      var pixelCanvas = document.createElement("canvas");
      pixelCanvas.width = 1;
      pixelCanvas.height = 1;
      pixelContext2 = pixelCanvas.getContext("2d");
      this.pixelContext_ = pixelContext2;
    }
    pixelContext2.clearRect(0, 0, 1, 1);
    var data2;
    try {
      pixelContext2.drawImage(gl.canvas, x2, y2, 1, 1, 0, 0, 1, 1);
      data2 = pixelContext2.getImageData(0, 0, 1, 1).data;
    } catch (err) {
      return data2;
    }
    if (data2[3] === 0) {
      return null;
    }
    return data2;
  };
  return WebGLLayerRenderer2;
}(LayerRenderer$1);
function colorEncodeId(id, opt_array) {
  var array = opt_array || [];
  var radix = 256;
  var divide = radix - 1;
  array[0] = Math.floor(id / radix / radix / radix) / divide;
  array[1] = Math.floor(id / radix / radix) % radix / divide;
  array[2] = Math.floor(id / radix) % radix / divide;
  array[3] = id % radix / divide;
  return array;
}
function colorDecodeId(color2) {
  var id = 0;
  var radix = 256;
  var mult = radix - 1;
  id += Math.round(color2[0] * radix * radix * radix * mult);
  id += Math.round(color2[1] * radix * radix * mult);
  id += Math.round(color2[2] * radix * mult);
  id += Math.round(color2[3] * mult);
  return id;
}
var WebGLLayerRenderer$1 = WebGLLayerRenderer;
function createOrUpdate(z2, x2, y2, opt_tileCoord) {
  if (opt_tileCoord !== void 0) {
    opt_tileCoord[0] = z2;
    opt_tileCoord[1] = x2;
    opt_tileCoord[2] = y2;
    return opt_tileCoord;
  } else {
    return [z2, x2, y2];
  }
}
function getKeyZXY(z2, x2, y2) {
  return z2 + "/" + x2 + "/" + y2;
}
function getKey(tileCoord) {
  return getKeyZXY(tileCoord[0], tileCoord[1], tileCoord[2]);
}
function fromKey(key) {
  return key.split("/").map(Number);
}
function hash(tileCoord) {
  return (tileCoord[1] << tileCoord[0]) + tileCoord[2];
}
function withinExtentAndZ(tileCoord, tileGrid) {
  var z2 = tileCoord[0];
  var x2 = tileCoord[1];
  var y2 = tileCoord[2];
  if (tileGrid.getMinZoom() > z2 || z2 > tileGrid.getMaxZoom()) {
    return false;
  }
  var tileRange = tileGrid.getFullTileRange(z2);
  if (!tileRange) {
    return true;
  } else {
    return tileRange.containsXY(x2, y2);
  }
}
var __extends$Q = globalThis && globalThis.__extends || function() {
  var extendStatics2 = function(d2, b2) {
    extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {
      d3.__proto__ = b3;
    } || function(d3, b3) {
      for (var p5 in b3)
        if (Object.prototype.hasOwnProperty.call(b3, p5))
          d3[p5] = b3[p5];
    };
    return extendStatics2(d2, b2);
  };
  return function(d2, b2) {
    if (typeof b2 !== "function" && b2 !== null)
      throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
    extendStatics2(d2, b2);
    function __() {
      this.constructor = d2;
    }
    d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
  };
}();
var Uniforms = {
  TILE_TEXTURE_ARRAY: "u_tileTextures",
  TILE_TRANSFORM: "u_tileTransform",
  TRANSITION_ALPHA: "u_transitionAlpha",
  DEPTH: "u_depth",
  TEXTURE_PIXEL_WIDTH: "u_texturePixelWidth",
  TEXTURE_PIXEL_HEIGHT: "u_texturePixelHeight",
  TEXTURE_RESOLUTION: "u_textureResolution",
  TEXTURE_ORIGIN_X: "u_textureOriginX",
  TEXTURE_ORIGIN_Y: "u_textureOriginY",
  RENDER_EXTENT: "u_renderExtent",
  RESOLUTION: "u_resolution",
  ZOOM: "u_zoom"
};
var Attributes = {
  TEXTURE_COORD: "a_textureCoord"
};
var attributeDescriptions = [
  {
    name: Attributes.TEXTURE_COORD,
    size: 2,
    type: AttributeType.FLOAT
  }
];
var empty$1 = {};
function depthForZ(z2) {
  return 2 * (1 - 1 / (z2 + 1)) - 1;
}
function addTileTextureToLookup(tileTexturesByZ, tileTexture, z2) {
  if (!(z2 in tileTexturesByZ)) {
    tileTexturesByZ[z2] = [];
  }
  tileTexturesByZ[z2].push(tileTexture);
}
function getRenderExtent(frameState, extent2) {
  var layerState = frameState.layerStatesArray[frameState.layerIndex];
  if (layerState.extent) {
    extent2 = getIntersection(extent2, fromUserExtent(layerState.extent, frameState.viewState.projection));
  }
  var source = layerState.layer.getRenderSource();
  if (!source.getWrapX()) {
    var gridExtent = source.getTileGridForProjection(frameState.viewState.projection).getExtent();
    if (gridExtent) {
      extent2 = getIntersection(extent2, gridExtent);
    }
  }
  return extent2;
}
function getCacheKey(source, tileCoord) {
  return "".concat(source.getKey(), ",").concat(getKey(tileCoord));
}
var WebGLTileLayerRenderer = function(_super) {
  __extends$Q(WebGLTileLayerRenderer2, _super);
  function WebGLTileLayerRenderer2(tileLayer, options) {
    var _this = _super.call(this, tileLayer, {
      uniforms: options.uniforms
    }) || this;
    _this.renderComplete = false;
    _this.tileTransform_ = create$6();
    _this.tempMat4_ = create$5();
    _this.tempTileRange_ = new TileRange$1(0, 0, 0, 0);
    _this.tempTileCoord_ = createOrUpdate(0, 0, 0);
    _this.tempSize_ = [0, 0];
    _this.program_;
    _this.vertexShader_ = options.vertexShader;
    _this.fragmentShader_ = options.fragmentShader;
    _this.indices_ = new WebGLArrayBuffer$1(ELEMENT_ARRAY_BUFFER, STATIC_DRAW);
    _this.indices_.fromArray([0, 1, 3, 1, 2, 3]);
    var cacheSize = options.cacheSize !== void 0 ? options.cacheSize : 512;
    _this.tileTextureCache_ = new LRUCache$1(cacheSize);
    _this.paletteTextures_ = options.paletteTextures || [];
    _this.frameState_ = null;
    return _this;
  }
  WebGLTileLayerRenderer2.prototype.reset = function(options) {
    _super.prototype.reset.call(this, {
      uniforms: options.uniforms
    });
    this.vertexShader_ = options.vertexShader;
    this.fragmentShader_ = options.fragmentShader;
    this.paletteTextures_ = options.paletteTextures || [];
    if (this.helper) {
      this.program_ = this.helper.getProgram(this.fragmentShader_, this.vertexShader_);
    }
  };
  WebGLTileLayerRenderer2.prototype.afterHelperCreated = function() {
    this.program_ = this.helper.getProgram(this.fragmentShader_, this.vertexShader_);
    this.helper.flushBufferData(this.indices_);
  };
  WebGLTileLayerRenderer2.prototype.isDrawableTile_ = function(tile2) {
    var tileLayer = this.getLayer();
    var tileState = tile2.getState();
    var useInterimTilesOnError = tileLayer.getUseInterimTilesOnError();
    return tileState == TileState.LOADED || tileState == TileState.EMPTY || tileState == TileState.ERROR && !useInterimTilesOnError;
  };
  WebGLTileLayerRenderer2.prototype.prepareFrameInternal = function(frameState) {
    var layer = this.getLayer();
    var source = layer.getRenderSource();
    if (!source) {
      return false;
    }
    if (isEmpty$1(getRenderExtent(frameState, frameState.extent))) {
      return false;
    }
    return source.getState() === SourceState.READY;
  };
  WebGLTileLayerRenderer2.prototype.enqueueTiles = function(frameState, extent2, initialZ, tileTexturesByZ) {
    var viewState = frameState.viewState;
    var tileLayer = this.getLayer();
    var tileSource = tileLayer.getRenderSource();
    var tileGrid = tileSource.getTileGridForProjection(viewState.projection);
    var tilePixelRatio = tileSource.getTilePixelRatio(frameState.pixelRatio);
    var gutter = tileSource.getGutterForProjection(viewState.projection);
    var tileSourceKey = getUid(tileSource);
    if (!(tileSourceKey in frameState.wantedTiles)) {
      frameState.wantedTiles[tileSourceKey] = {};
    }
    var wantedTiles = frameState.wantedTiles[tileSourceKey];
    var tileTextureCache = this.tileTextureCache_;
    var minZ = Math.max(initialZ - tileLayer.getPreload(), tileGrid.getMinZoom(), tileLayer.getMinZoom());
    for (var z2 = initialZ; z2 >= minZ; --z2) {
      var tileRange = tileGrid.getTileRangeForExtentAndZ(extent2, z2, this.tempTileRange_);
      var tileResolution = tileGrid.getResolution(z2);
      for (var x2 = tileRange.minX; x2 <= tileRange.maxX; ++x2) {
        for (var y2 = tileRange.minY; y2 <= tileRange.maxY; ++y2) {
          var tileCoord = createOrUpdate(z2, x2, y2, this.tempTileCoord_);
          var cacheKey = getCacheKey(tileSource, tileCoord);
          var tileTexture = void 0;
          var tile2 = void 0;
          if (tileTextureCache.containsKey(cacheKey)) {
            tileTexture = tileTextureCache.get(cacheKey);
            tile2 = tileTexture.tile;
          }
          if (!tileTexture || tileTexture.tile.key !== tileSource.getKey()) {
            tile2 = tileSource.getTile(z2, x2, y2, frameState.pixelRatio, viewState.projection);
            if (!tileTexture) {
              tileTexture = new TileTexture$1({
                tile: tile2,
                grid: tileGrid,
                helper: this.helper,
                tilePixelRatio,
                gutter
              });
              tileTextureCache.set(cacheKey, tileTexture);
            } else {
              if (this.isDrawableTile_(tile2)) {
                tileTexture.setTile(tile2);
              } else {
                var interimTile = tile2.getInterimTile();
                tileTexture.setTile(interimTile);
              }
            }
          }
          addTileTextureToLookup(tileTexturesByZ, tileTexture, z2);
          var tileQueueKey = tile2.getKey();
          wantedTiles[tileQueueKey] = true;
          if (tile2.getState() === TileState.IDLE) {
            if (!frameState.tileQueue.isKeyQueued(tileQueueKey)) {
              frameState.tileQueue.enqueue([
                tile2,
                tileSourceKey,
                tileGrid.getTileCoordCenter(tileCoord),
                tileResolution
              ]);
            }
          }
        }
      }
    }
  };
  WebGLTileLayerRenderer2.prototype.renderFrame = function(frameState) {
    this.frameState_ = frameState;
    this.renderComplete = true;
    var gl = this.helper.getGL();
    this.preRender(gl, frameState);
    var viewState = frameState.viewState;
    var tileLayer = this.getLayer();
    var tileSource = tileLayer.getRenderSource();
    var tileGrid = tileSource.getTileGridForProjection(viewState.projection);
    var extent2 = getRenderExtent(frameState, frameState.extent);
    var z2 = tileGrid.getZForResolution(viewState.resolution, tileSource.zDirection);
    var tileTexturesByZ = {};
    if (frameState.nextExtent) {
      var targetZ = tileGrid.getZForResolution(viewState.nextResolution, tileSource.zDirection);
      var nextExtent = getRenderExtent(frameState, frameState.nextExtent);
      this.enqueueTiles(frameState, nextExtent, targetZ, tileTexturesByZ);
    }
    this.enqueueTiles(frameState, extent2, z2, tileTexturesByZ);
    var alphaLookup = {};
    var uid2 = getUid(this);
    var time2 = frameState.time;
    var blend = false;
    var tileTextures = tileTexturesByZ[z2];
    for (var i2 = 0, ii = tileTextures.length; i2 < ii; ++i2) {
      var tileTexture = tileTextures[i2];
      var tile2 = tileTexture.tile;
      var tileCoord = tile2.tileCoord;
      if (tileTexture.loaded) {
        var alpha = tile2.getAlpha(uid2, time2);
        if (alpha === 1) {
          tile2.endTransition(uid2);
          continue;
        }
        blend = true;
        var tileCoordKey = getKey(tileCoord);
        alphaLookup[tileCoordKey] = alpha;
      }
      this.renderComplete = false;
      var coveredByChildren = this.findAltTiles_(tileGrid, tileCoord, z2 + 1, tileTexturesByZ);
      if (coveredByChildren) {
        continue;
      }
      var minZoom = tileGrid.getMinZoom();
      for (var parentZ = z2 - 1; parentZ >= minZoom; --parentZ) {
        var coveredByParent = this.findAltTiles_(tileGrid, tileCoord, parentZ, tileTexturesByZ);
        if (coveredByParent) {
          break;
        }
      }
    }
    this.helper.useProgram(this.program_);
    this.helper.prepareDraw(frameState, !blend);
    var zs = Object.keys(tileTexturesByZ).map(Number).sort(numberSafeCompareFunction);
    var centerX = viewState.center[0];
    var centerY = viewState.center[1];
    for (var j2 = 0, jj = zs.length; j2 < jj; ++j2) {
      var tileZ = zs[j2];
      var tileResolution = tileGrid.getResolution(tileZ);
      var tileSize = toSize(tileGrid.getTileSize(tileZ), this.tempSize_);
      var tileOrigin = tileGrid.getOrigin(tileZ);
      var centerI = (centerX - tileOrigin[0]) / (tileSize[0] * tileResolution);
      var centerJ = (tileOrigin[1] - centerY) / (tileSize[1] * tileResolution);
      var tileScale = viewState.resolution / tileResolution;
      var depth = depthForZ(tileZ);
      var tileTextures_1 = tileTexturesByZ[tileZ];
      for (var i2 = 0, ii = tileTextures_1.length; i2 < ii; ++i2) {
        var tileTexture = tileTextures_1[i2];
        if (!tileTexture.loaded) {
          continue;
        }
        var tile2 = tileTexture.tile;
        var tileCoord = tile2.tileCoord;
        var tileCoordKey = getKey(tileCoord);
        var tileCenterI = tileCoord[1];
        var tileCenterJ = tileCoord[2];
        compose(this.tileTransform_, 0, 0, 2 / (frameState.size[0] * tileScale / tileSize[0]), -2 / (frameState.size[1] * tileScale / tileSize[1]), viewState.rotation, -(centerI - tileCenterI), -(centerJ - tileCenterJ));
        this.helper.setUniformMatrixValue(Uniforms.TILE_TRANSFORM, fromTransform(this.tempMat4_, this.tileTransform_));
        this.helper.bindBuffer(tileTexture.coords);
        this.helper.bindBuffer(this.indices_);
        this.helper.enableAttributes(attributeDescriptions);
        var textureSlot = 0;
        while (textureSlot < tileTexture.textures.length) {
          var textureProperty = "TEXTURE" + textureSlot;
          var uniformName = "".concat(Uniforms.TILE_TEXTURE_ARRAY, "[").concat(textureSlot, "]");
          gl.activeTexture(gl[textureProperty]);
          gl.bindTexture(gl.TEXTURE_2D, tileTexture.textures[textureSlot]);
          gl.uniform1i(this.helper.getUniformLocation(uniformName), textureSlot);
          ++textureSlot;
        }
        for (var paletteIndex = 0; paletteIndex < this.paletteTextures_.length; ++paletteIndex) {
          var paletteTexture = this.paletteTextures_[paletteIndex];
          gl.activeTexture(gl["TEXTURE" + textureSlot]);
          var texture = paletteTexture.getTexture(gl);
          gl.bindTexture(gl.TEXTURE_2D, texture);
          gl.uniform1i(this.helper.getUniformLocation(paletteTexture.name), textureSlot);
          ++textureSlot;
        }
        var alpha = tileCoordKey in alphaLookup ? alphaLookup[tileCoordKey] : 1;
        if (alpha < 1) {
          frameState.animate = true;
        }
        this.helper.setUniformFloatValue(Uniforms.TRANSITION_ALPHA, alpha);
        this.helper.setUniformFloatValue(Uniforms.DEPTH, depth);
        this.helper.setUniformFloatValue(Uniforms.TEXTURE_PIXEL_WIDTH, tileSize[0]);
        this.helper.setUniformFloatValue(Uniforms.TEXTURE_PIXEL_HEIGHT, tileSize[1]);
        this.helper.setUniformFloatValue(Uniforms.TEXTURE_RESOLUTION, tileResolution);
        this.helper.setUniformFloatValue(Uniforms.TEXTURE_ORIGIN_X, tileOrigin[0] + tileCenterI * tileSize[0] * tileResolution);
        this.helper.setUniformFloatValue(Uniforms.TEXTURE_ORIGIN_Y, tileOrigin[1] - tileCenterJ * tileSize[1] * tileResolution);
        this.helper.setUniformFloatVec4(Uniforms.RENDER_EXTENT, extent2);
        this.helper.setUniformFloatValue(Uniforms.RESOLUTION, viewState.resolution);
        this.helper.setUniformFloatValue(Uniforms.ZOOM, viewState.zoom);
        this.helper.drawElements(0, this.indices_.getSize());
      }
    }
    this.helper.finalizeDraw(frameState, this.dispatchPreComposeEvent, this.dispatchPostComposeEvent);
    var canvas = this.helper.getCanvas();
    var tileTextureCache = this.tileTextureCache_;
    while (tileTextureCache.canExpireCache()) {
      var tileTexture = tileTextureCache.pop();
      tileTexture.dispose();
    }
    var postRenderFunction = function(map, frameState2) {
      tileSource.expireCache(frameState2.viewState.projection, empty$1);
    };
    frameState.postRenderFunctions.push(postRenderFunction);
    this.postRender(gl, frameState);
    return canvas;
  };
  WebGLTileLayerRenderer2.prototype.getData = function(pixel) {
    var gl = this.helper.getGL();
    if (!gl) {
      return null;
    }
    var frameState = this.frameState_;
    if (!frameState) {
      return null;
    }
    var layer = this.getLayer();
    var coordinate = apply$5(frameState.pixelToCoordinateTransform, pixel.slice());
    var viewState = frameState.viewState;
    var layerExtent = layer.getExtent();
    if (layerExtent) {
      if (!containsCoordinate(fromUserExtent(layerExtent, viewState.projection), coordinate)) {
        return null;
      }
    }
    var source = layer.getRenderSource();
    var tileGrid = source.getTileGridForProjection(viewState.projection);
    if (!source.getWrapX()) {
      var gridExtent = tileGrid.getExtent();
      if (gridExtent) {
        if (!containsCoordinate(gridExtent, coordinate)) {
          return null;
        }
      }
    }
    var tileTextureCache = this.tileTextureCache_;
    for (var z2 = tileGrid.getZForResolution(viewState.resolution); z2 >= tileGrid.getMinZoom(); --z2) {
      var tileCoord = tileGrid.getTileCoordForCoordAndZ(coordinate, z2);
      var cacheKey = getCacheKey(source, tileCoord);
      if (!tileTextureCache.containsKey(cacheKey)) {
        continue;
      }
      var tileTexture = tileTextureCache.get(cacheKey);
      if (!tileTexture.loaded) {
        continue;
      }
      var tileOrigin = tileGrid.getOrigin(z2);
      var tileSize = toSize(tileGrid.getTileSize(z2));
      var tileResolution = tileGrid.getResolution(z2);
      var col = (coordinate[0] - tileOrigin[0]) / tileResolution - tileCoord[1] * tileSize[0];
      var row = (tileOrigin[1] - coordinate[1]) / tileResolution - tileCoord[2] * tileSize[1];
      return tileTexture.getPixelData(col, row);
    }
    return null;
  };
  WebGLTileLayerRenderer2.prototype.findAltTiles_ = function(tileGrid, tileCoord, altZ, tileTexturesByZ) {
    var tileRange = tileGrid.getTileRangeForTileCoordAndZ(tileCoord, altZ, this.tempTileRange_);
    if (!tileRange) {
      return false;
    }
    var covered = true;
    var tileTextureCache = this.tileTextureCache_;
    var source = this.getLayer().getRenderSource();
    for (var x2 = tileRange.minX; x2 <= tileRange.maxX; ++x2) {
      for (var y2 = tileRange.minY; y2 <= tileRange.maxY; ++y2) {
        var cacheKey = getCacheKey(source, [altZ, x2, y2]);
        var loaded = false;
        if (tileTextureCache.containsKey(cacheKey)) {
          var tileTexture = tileTextureCache.get(cacheKey);
          if (tileTexture.loaded) {
            addTileTextureToLookup(tileTexturesByZ, tileTexture, altZ);
            loaded = true;
          }
        }
        if (!loaded) {
          covered = false;
        }
      }
    }
    return covered;
  };
  WebGLTileLayerRenderer2.prototype.removeHelper = function() {
    if (this.helper) {
      var tileTextureCache = this.tileTextureCache_;
      tileTextureCache.forEach(function(tileTexture) {
        return tileTexture.dispose();
      });
      tileTextureCache.clear();
    }
    _super.prototype.removeHelper.call(this);
  };
  WebGLTileLayerRenderer2.prototype.disposeInternal = function() {
    var helper = this.helper;
    if (helper) {
      var gl = helper.getGL();
      gl.deleteProgram(this.program_);
      delete this.program_;
      helper.deleteBuffer(this.indices_);
    }
    _super.prototype.disposeInternal.call(this);
    delete this.indices_;
    delete this.tileTextureCache_;
    delete this.frameState_;
  };
  return WebGLTileLayerRenderer2;
}(WebGLLayerRenderer$1);
var WebGLTileLayerRenderer$1 = WebGLTileLayerRenderer;
var PaletteTexture = function() {
  function PaletteTexture2(name, data2) {
    this.name = name;
    this.data = data2;
    this.texture_ = null;
  }
  PaletteTexture2.prototype.getTexture = function(gl) {
    if (!this.texture_) {
      var texture = gl.createTexture();
      gl.bindTexture(gl.TEXTURE_2D, texture);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
      gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, this.data.length / 4, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, this.data);
      this.texture_ = texture;
    }
    return this.texture_;
  };
  return PaletteTexture2;
}();
var PaletteTexture$1 = PaletteTexture;
var ValueTypes = {
  NUMBER: 1,
  STRING: 2,
  COLOR: 4,
  BOOLEAN: 8,
  NUMBER_ARRAY: 16,
  ANY: 31,
  NONE: 0
};
var Operators = {};
function getValueType(value) {
  if (typeof value === "number") {
    return ValueTypes.NUMBER;
  }
  if (typeof value === "boolean") {
    return ValueTypes.BOOLEAN;
  }
  if (typeof value === "string") {
    if (isStringColor(value)) {
      return ValueTypes.COLOR | ValueTypes.STRING;
    }
    return ValueTypes.STRING;
  }
  if (!Array.isArray(value)) {
    throw new Error("Unhandled value type: ".concat(JSON.stringify(value)));
  }
  var valueArr = value;
  var onlyNumbers = valueArr.every(function(v2) {
    return typeof v2 === "number";
  });
  if (onlyNumbers) {
    if (valueArr.length === 3 || valueArr.length === 4) {
      return ValueTypes.COLOR | ValueTypes.NUMBER_ARRAY;
    }
    return ValueTypes.NUMBER_ARRAY;
  }
  if (typeof valueArr[0] !== "string") {
    throw new Error("Expected an expression operator but received: ".concat(JSON.stringify(valueArr)));
  }
  var operator = Operators[valueArr[0]];
  if (operator === void 0) {
    throw new Error("Unrecognized expression operator: ".concat(JSON.stringify(valueArr)));
  }
  return operator.getReturnType(valueArr.slice(1));
}
function isTypeUnique(valueType) {
  return log2(valueType) % 1 === 0;
}
function numberToGlsl(v2) {
  var s2 = v2.toString();
  return s2.indexOf(".") === -1 ? s2 + ".0" : s2;
}
function arrayToGlsl(array) {
  if (array.length < 2 || array.length > 4) {
    throw new Error("`formatArray` can only output `vec2`, `vec3` or `vec4` arrays.");
  }
  return "vec".concat(array.length, "(").concat(array.map(numberToGlsl).join(", "), ")");
}
function colorToGlsl(color2) {
  var array = asArray(color2).slice();
  if (array.length < 4) {
    array.push(1);
  }
  return arrayToGlsl(array.map(function(c2, i2) {
    return i2 < 3 ? c2 / 255 : c2;
  }));
}
function getStringNumberEquivalent(context, string) {
  if (context.stringLiteralsMap[string] === void 0) {
    context.stringLiteralsMap[string] = Object.keys(context.stringLiteralsMap).length;
  }
  return context.stringLiteralsMap[string];
}
function stringToGlsl(context, string) {
  return numberToGlsl(getStringNumberEquivalent(context, string));
}
function expressionToGlsl(context, value, typeHint) {
  if (Array.isArray(value) && typeof value[0] === "string") {
    var operator = Operators[value[0]];
    if (operator === void 0) {
      throw new Error("Unrecognized expression operator: ".concat(JSON.stringify(value)));
    }
    return operator.toGlsl(context, value.slice(1), typeHint);
  }
  var valueType = getValueType(value);
  if ((valueType & ValueTypes.NUMBER) > 0) {
    return numberToGlsl(value);
  }
  if ((valueType & ValueTypes.BOOLEAN) > 0) {
    return value.toString();
  }
  if ((valueType & ValueTypes.STRING) > 0 && (typeHint === void 0 || typeHint == ValueTypes.STRING)) {
    return stringToGlsl(context, value.toString());
  }
  if ((valueType & ValueTypes.COLOR) > 0 && (typeHint === void 0 || typeHint == ValueTypes.COLOR)) {
    return colorToGlsl(value);
  }
  if ((valueType & ValueTypes.NUMBER_ARRAY) > 0) {
    return arrayToGlsl(value);
  }
  throw new Error("Unexpected expression ".concat(value, " (expected type ").concat(typeHint, ")"));
}
function assertNumber(value) {
  if (!(getValueType(value) & ValueTypes.NUMBER)) {
    throw new Error("A numeric value was expected, got ".concat(JSON.stringify(value), " instead"));
  }
}
function assertNumbers(values2) {
  for (var i2 = 0; i2 < values2.length; i2++) {
    assertNumber(values2[i2]);
  }
}
function assertString(value) {
  if (!(getValueType(value) & ValueTypes.STRING)) {
    throw new Error("A string value was expected, got ".concat(JSON.stringify(value), " instead"));
  }
}
function assertBoolean(value) {
  if (!(getValueType(value) & ValueTypes.BOOLEAN)) {
    throw new Error("A boolean value was expected, got ".concat(JSON.stringify(value), " instead"));
  }
}
function assertArgsCount(args, count) {
  if (args.length !== count) {
    throw new Error("Exactly ".concat(count, " arguments were expected, got ").concat(args.length, " instead"));
  }
}
function assertArgsMinCount(args, count) {
  if (args.length < count) {
    throw new Error("At least ".concat(count, " arguments were expected, got ").concat(args.length, " instead"));
  }
}
function assertArgsMaxCount(args, count) {
  if (args.length > count) {
    throw new Error("At most ".concat(count, " arguments were expected, got ").concat(args.length, " instead"));
  }
}
function assertArgsEven(args) {
  if (args.length % 2 !== 0) {
    throw new Error("An even amount of arguments was expected, got ".concat(args, " instead"));
  }
}
function assertArgsOdd(args) {
  if (args.length % 2 === 0) {
    throw new Error("An odd amount of arguments was expected, got ".concat(args, " instead"));
  }
}
function assertUniqueInferredType(args, types) {
  if (!isTypeUnique(types)) {
    throw new Error("Could not infer only one type from the following expression: ".concat(JSON.stringify(args)));
  }
}
Operators["get"] = {
  getReturnType: function(args) {
    return ValueTypes.ANY;
  },
  toGlsl: function(context, args) {
    assertArgsCount(args, 1);
    assertString(args[0]);
    var value = args[0].toString();
    if (context.attributes.indexOf(value) === -1) {
      context.attributes.push(value);
    }
    var prefix = context.inFragmentShader ? "v_" : "a_";
    return prefix + value;
  }
};
function uniformNameForVariable(variableName) {
  return "u_var_" + variableName;
}
Operators["var"] = {
  getReturnType: function(args) {
    return ValueTypes.ANY;
  },
  toGlsl: function(context, args) {
    assertArgsCount(args, 1);
    assertString(args[0]);
    var value = args[0].toString();
    if (context.variables.indexOf(value) === -1) {
      context.variables.push(value);
    }
    return uniformNameForVariable(value);
  }
};
var PALETTE_TEXTURE_ARRAY = "u_paletteTextures";
Operators["palette"] = {
  getReturnType: function(args) {
    return ValueTypes.COLOR;
  },
  toGlsl: function(context, args) {
    assertArgsCount(args, 2);
    assertNumber(args[0]);
    var index2 = expressionToGlsl(context, args[0]);
    var colors = args[1];
    if (!Array.isArray(colors)) {
      throw new Error("The second argument of palette must be an array");
    }
    var numColors = colors.length;
    var palette = new Uint8Array(numColors * 4);
    for (var i2 = 0; i2 < numColors; i2++) {
      var candidate = colors[i2];
      var color2 = void 0;
      if (typeof candidate === "string") {
        color2 = fromString(candidate);
      } else {
        if (!Array.isArray(candidate)) {
          throw new Error("The second argument of palette must be an array of strings or colors");
        }
        var length_1 = candidate.length;
        if (length_1 === 4) {
          color2 = candidate;
        } else {
          if (length_1 !== 3) {
            throw new Error("Expected palette color to have 3 or 4 values, got ".concat(length_1));
          }
          color2 = [candidate[0], candidate[1], candidate[2], 1];
        }
      }
      var offset2 = i2 * 4;
      palette[offset2] = color2[0];
      palette[offset2 + 1] = color2[1];
      palette[offset2 + 2] = color2[2];
      palette[offset2 + 3] = color2[3] * 255;
    }
    if (!context.paletteTextures) {
      context.paletteTextures = [];
    }
    var paletteName = "".concat(PALETTE_TEXTURE_ARRAY, "[").concat(context.paletteTextures.length, "]");
    var paletteTexture = new PaletteTexture$1(paletteName, palette);
    context.paletteTextures.push(paletteTexture);
    return "texture2D(".concat(paletteName, ", vec2((").concat(index2, " + 0.5) / ").concat(numColors, ".0, 0.5))");
  }
};
var GET_BAND_VALUE_FUNC = "getBandValue";
Operators["band"] = {
  getReturnType: function(args) {
    return ValueTypes.NUMBER;
  },
  toGlsl: function(context, args) {
    assertArgsMinCount(args, 1);
    assertArgsMaxCount(args, 3);
    var band = args[0];
    if (!(GET_BAND_VALUE_FUNC in context.functions)) {
      var ifBlocks = "";
      var bandCount = context.bandCount || 1;
      for (var i2 = 0; i2 < bandCount; i2++) {
        var colorIndex = Math.floor(i2 / 4);
        var bandIndex = i2 % 4;
        if (bandIndex === bandCount - 1 && bandIndex === 1) {
          bandIndex = 3;
        }
        var textureName = "".concat(Uniforms.TILE_TEXTURE_ARRAY, "[").concat(colorIndex, "]");
        ifBlocks += "\n          if (band == ".concat(i2 + 1, ".0) {\n            return texture2D(").concat(textureName, ", v_textureCoord + vec2(dx, dy))[").concat(bandIndex, "];\n          }\n        ");
      }
      context.functions[GET_BAND_VALUE_FUNC] = "\n        float getBandValue(float band, float xOffset, float yOffset) {\n          float dx = xOffset / ".concat(Uniforms.TEXTURE_PIXEL_WIDTH, ";\n          float dy = yOffset / ").concat(Uniforms.TEXTURE_PIXEL_HEIGHT, ";\n          ").concat(ifBlocks, "\n        }\n      ");
    }
    var bandExpression = expressionToGlsl(context, band);
    var xOffsetExpression = expressionToGlsl(context, args[1] || 0);
    var yOffsetExpression = expressionToGlsl(context, args[2] || 0);
    return "".concat(GET_BAND_VALUE_FUNC, "(").concat(bandExpression, ", ").concat(xOffsetExpression, ", ").concat(yOffsetExpression, ")");
  }
};
Operators["time"] = {
  getReturnType: function(args) {
    return ValueTypes.NUMBER;
  },
  toGlsl: function(context, args) {
    assertArgsCount(args, 0);
    return "u_time";
  }
};
Operators["zoom"] = {
  getReturnType: function(args) {
    return ValueTypes.NUMBER;
  },
  toGlsl: function(context, args) {
    assertArgsCount(args, 0);
    return "u_zoom";
  }
};
Operators["resolution"] = {
  getReturnType: function(args) {
    return ValueTypes.NUMBER;
  },
  toGlsl: function(context, args) {
    assertArgsCount(args, 0);
    return "u_resolution";
  }
};
Operators["*"] = {
  getReturnType: function(args) {
    return ValueTypes.NUMBER;
  },
  toGlsl: function(context, args) {
    assertArgsCount(args, 2);
    assertNumbers(args);
    return "(".concat(expressionToGlsl(context, args[0]), " * ").concat(expressionToGlsl(context, args[1]), ")");
  }
};
Operators["/"] = {
  getReturnType: function(args) {
    return ValueTypes.NUMBER;
  },
  toGlsl: function(context, args) {
    assertArgsCount(args, 2);
    assertNumbers(args);
    return "(".concat(expressionToGlsl(context, args[0]), " / ").concat(expressionToGlsl(context, args[1]), ")");
  }
};
Operators["+"] = {
  getReturnType: function(args) {
    return ValueTypes.NUMBER;
  },
  toGlsl: function(context, args) {
    assertArgsCount(args, 2);
    assertNumbers(args);
    return "(".concat(expressionToGlsl(context, args[0]), " + ").concat(expressionToGlsl(context, args[1]), ")");
  }
};
Operators["-"] = {
  getReturnType: function(args) {
    return ValueTypes.NUMBER;
  },
  toGlsl: function(context, args) {
    assertArgsCount(args, 2);
    assertNumbers(args);
    return "(".concat(expressionToGlsl(context, args[0]), " - ").concat(expressionToGlsl(context, args[1]), ")");
  }
};
Operators["clamp"] = {
  getReturnType: function(args) {
    return ValueTypes.NUMBER;
  },
  toGlsl: function(context, args) {
    assertArgsCount(args, 3);
    assertNumbers(args);
    var min2 = expressionToGlsl(context, args[1]);
    var max2 = expressionToGlsl(context, args[2]);
    return "clamp(".concat(expressionToGlsl(context, args[0]), ", ").concat(min2, ", ").concat(max2, ")");
  }
};
Operators["%"] = {
  getReturnType: function(args) {
    return ValueTypes.NUMBER;
  },
  toGlsl: function(context, args) {
    assertArgsCount(args, 2);
    assertNumbers(args);
    return "mod(".concat(expressionToGlsl(context, args[0]), ", ").concat(expressionToGlsl(context, args[1]), ")");
  }
};
Operators["^"] = {
  getReturnType: function(args) {
    return ValueTypes.NUMBER;
  },
  toGlsl: function(context, args) {
    assertArgsCount(args, 2);
    assertNumbers(args);
    return "pow(".concat(expressionToGlsl(context, args[0]), ", ").concat(expressionToGlsl(context, args[1]), ")");
  }
};
Operators["abs"] = {
  getReturnType: function(args) {
    return ValueTypes.NUMBER;
  },
  toGlsl: function(context, args) {
    assertArgsCount(args, 1);
    assertNumbers(args);
    return "abs(".concat(expressionToGlsl(context, args[0]), ")");
  }
};
Operators["floor"] = {
  getReturnType: function(args) {
    return ValueTypes.NUMBER;
  },
  toGlsl: function(context, args) {
    assertArgsCount(args, 1);
    assertNumbers(args);
    return "floor(".concat(expressionToGlsl(context, args[0]), ")");
  }
};
Operators["round"] = {
  getReturnType: function(args) {
    return ValueTypes.NUMBER;
  },
  toGlsl: function(context, args) {
    assertArgsCount(args, 1);
    assertNumbers(args);
    return "floor(".concat(expressionToGlsl(context, args[0]), " + 0.5)");
  }
};
Operators["ceil"] = {
  getReturnType: function(args) {
    return ValueTypes.NUMBER;
  },
  toGlsl: function(context, args) {
    assertArgsCount(args, 1);
    assertNumbers(args);
    return "ceil(".concat(expressionToGlsl(context, args[0]), ")");
  }
};
Operators["sin"] = {
  getReturnType: function(args) {
    return ValueTypes.NUMBER;
  },
  toGlsl: function(context, args) {
    assertArgsCount(args, 1);
    assertNumbers(args);
    return "sin(".concat(expressionToGlsl(context, args[0]), ")");
  }
};
Operators["cos"] = {
  getReturnType: function(args) {
    return ValueTypes.NUMBER;
  },
  toGlsl: function(context, args) {
    assertArgsCount(args, 1);
    assertNumbers(args);
    return "cos(".concat(expressionToGlsl(context, args[0]), ")");
  }
};
Operators["atan"] = {
  getReturnType: function(args) {
    return ValueTypes.NUMBER;
  },
  toGlsl: function(context, args) {
    assertArgsMinCount(args, 1);
    assertArgsMaxCount(args, 2);
    assertNumbers(args);
    return args.length === 2 ? "atan(".concat(expressionToGlsl(context, args[0]), ", ").concat(expressionToGlsl(context, args[1]), ")") : "atan(".concat(expressionToGlsl(context, args[0]), ")");
  }
};
Operators[">"] = {
  getReturnType: function(args) {
    return ValueTypes.BOOLEAN;
  },
  toGlsl: function(context, args) {
    assertArgsCount(args, 2);
    assertNumbers(args);
    return "(".concat(expressionToGlsl(context, args[0]), " > ").concat(expressionToGlsl(context, args[1]), ")");
  }
};
Operators[">="] = {
  getReturnType: function(args) {
    return ValueTypes.BOOLEAN;
  },
  toGlsl: function(context, args) {
    assertArgsCount(args, 2);
    assertNumbers(args);
    return "(".concat(expressionToGlsl(context, args[0]), " >= ").concat(expressionToGlsl(context, args[1]), ")");
  }
};
Operators["<"] = {
  getReturnType: function(args) {
    return ValueTypes.BOOLEAN;
  },
  toGlsl: function(context, args) {
    assertArgsCount(args, 2);
    assertNumbers(args);
    return "(".concat(expressionToGlsl(context, args[0]), " < ").concat(expressionToGlsl(context, args[1]), ")");
  }
};
Operators["<="] = {
  getReturnType: function(args) {
    return ValueTypes.BOOLEAN;
  },
  toGlsl: function(context, args) {
    assertArgsCount(args, 2);
    assertNumbers(args);
    return "(".concat(expressionToGlsl(context, args[0]), " <= ").concat(expressionToGlsl(context, args[1]), ")");
  }
};
function getEqualOperator(operator) {
  return {
    getReturnType: function(args) {
      return ValueTypes.BOOLEAN;
    },
    toGlsl: function(context, args) {
      assertArgsCount(args, 2);
      var type = ValueTypes.ANY;
      for (var i2 = 0; i2 < args.length; i2++) {
        type &= getValueType(args[i2]);
      }
      if (type === ValueTypes.NONE) {
        throw new Error("All arguments should be of compatible type, got ".concat(JSON.stringify(args), " instead"));
      }
      type &= ~ValueTypes.COLOR;
      return "(".concat(expressionToGlsl(context, args[0], type), " ").concat(operator, " ").concat(expressionToGlsl(context, args[1], type), ")");
    }
  };
}
Operators["=="] = getEqualOperator("==");
Operators["!="] = getEqualOperator("!=");
Operators["!"] = {
  getReturnType: function(args) {
    return ValueTypes.BOOLEAN;
  },
  toGlsl: function(context, args) {
    assertArgsCount(args, 1);
    assertBoolean(args[0]);
    return "(!".concat(expressionToGlsl(context, args[0]), ")");
  }
};
function getDecisionOperator(operator) {
  return {
    getReturnType: function(args) {
      return ValueTypes.BOOLEAN;
    },
    toGlsl: function(context, args) {
      assertArgsMinCount(args, 2);
      for (var i2 = 0; i2 < args.length; i2++) {
        assertBoolean(args[i2]);
      }
      var result = "";
      result = args.map(function(arg) {
        return expressionToGlsl(context, arg);
      }).join(" ".concat(operator, " "));
      result = "(".concat(result, ")");
      return result;
    }
  };
}
Operators["all"] = getDecisionOperator("&&");
Operators["any"] = getDecisionOperator("||");
Operators["between"] = {
  getReturnType: function(args) {
    return ValueTypes.BOOLEAN;
  },
  toGlsl: function(context, args) {
    assertArgsCount(args, 3);
    assertNumbers(args);
    var min2 = expressionToGlsl(context, args[1]);
    var max2 = expressionToGlsl(context, args[2]);
    var value = expressionToGlsl(context, args[0]);
    return "(".concat(value, " >= ").concat(min2, " && ").concat(value, " <= ").concat(max2, ")");
  }
};
Operators["array"] = {
  getReturnType: function(args) {
    return ValueTypes.NUMBER_ARRAY;
  },
  toGlsl: function(context, args) {
    assertArgsMinCount(args, 2);
    assertArgsMaxCount(args, 4);
    assertNumbers(args);
    var parsedArgs = args.map(function(val) {
      return expressionToGlsl(context, val, ValueTypes.NUMBER);
    });
    return "vec".concat(args.length, "(").concat(parsedArgs.join(", "), ")");
  }
};
Operators["color"] = {
  getReturnType: function(args) {
    return ValueTypes.COLOR;
  },
  toGlsl: function(context, args) {
    assertArgsMinCount(args, 3);
    assertArgsMaxCount(args, 4);
    assertNumbers(args);
    var array = args;
    if (args.length === 3) {
      array.push(1);
    }
    var parsedArgs = args.map(function(val, i2) {
      return expressionToGlsl(context, val, ValueTypes.NUMBER) + (i2 < 3 ? " / 255.0" : "");
    });
    return "vec".concat(args.length, "(").concat(parsedArgs.join(", "), ")");
  }
};
Operators["interpolate"] = {
  getReturnType: function(args) {
    var type = ValueTypes.COLOR | ValueTypes.NUMBER;
    for (var i2 = 3; i2 < args.length; i2 += 2) {
      type = type & getValueType(args[i2]);
    }
    return type;
  },
  toGlsl: function(context, args, opt_typeHint) {
    assertArgsEven(args);
    assertArgsMinCount(args, 6);
    var type = args[0];
    var interpolation;
    switch (type[0]) {
      case "linear":
        interpolation = 1;
        break;
      case "exponential":
        interpolation = type[1];
        break;
      default:
        interpolation = null;
    }
    if (!interpolation) {
      throw new Error('Invalid interpolation type for "interpolate" operator, received: '.concat(JSON.stringify(type)));
    }
    var typeHint = opt_typeHint !== void 0 ? opt_typeHint : ValueTypes.ANY;
    var outputType = Operators["interpolate"].getReturnType(args) & typeHint;
    assertUniqueInferredType(args, outputType);
    var input = expressionToGlsl(context, args[1]);
    var exponent = numberToGlsl(interpolation);
    var result = "";
    for (var i2 = 2; i2 < args.length - 2; i2 += 2) {
      var stop1 = expressionToGlsl(context, args[i2]);
      var output1 = result || expressionToGlsl(context, args[i2 + 1], outputType);
      var stop2 = expressionToGlsl(context, args[i2 + 2]);
      var output2 = expressionToGlsl(context, args[i2 + 3], outputType);
      result = "mix(".concat(output1, ", ").concat(output2, ", pow(clamp((").concat(input, " - ").concat(stop1, ") / (").concat(stop2, " - ").concat(stop1, "), 0.0, 1.0), ").concat(exponent, "))");
    }
    return result;
  }
};
Operators["match"] = {
  getReturnType: function(args) {
    var type = ValueTypes.ANY;
    for (var i2 = 2; i2 < args.length; i2 += 2) {
      type = type & getValueType(args[i2]);
    }
    type = type & getValueType(args[args.length - 1]);
    return type;
  },
  toGlsl: function(context, args, opt_typeHint) {
    assertArgsEven(args);
    assertArgsMinCount(args, 4);
    var typeHint = opt_typeHint !== void 0 ? opt_typeHint : ValueTypes.ANY;
    var outputType = Operators["match"].getReturnType(args) & typeHint;
    assertUniqueInferredType(args, outputType);
    var input = expressionToGlsl(context, args[0]);
    var fallback = expressionToGlsl(context, args[args.length - 1], outputType);
    var result = null;
    for (var i2 = args.length - 3; i2 >= 1; i2 -= 2) {
      var match2 = expressionToGlsl(context, args[i2]);
      var output = expressionToGlsl(context, args[i2 + 1], outputType);
      result = "(".concat(input, " == ").concat(match2, " ? ").concat(output, " : ").concat(result || fallback, ")");
    }
    return result;
  }
};
Operators["case"] = {
  getReturnType: function(args) {
    var type = ValueTypes.ANY;
    for (var i2 = 1; i2 < args.length; i2 += 2) {
      type = type & getValueType(args[i2]);
    }
    type = type & getValueType(args[args.length - 1]);
    return type;
  },
  toGlsl: function(context, args, opt_typeHint) {
    assertArgsOdd(args);
    assertArgsMinCount(args, 3);
    var typeHint = opt_typeHint !== void 0 ? opt_typeHint : ValueTypes.ANY;
    var outputType = Operators["case"].getReturnType(args) & typeHint;
    assertUniqueInferredType(args, outputType);
    for (var i2 = 0; i2 < args.length - 1; i2 += 2) {
      assertBoolean(args[i2]);
    }
    var fallback = expressionToGlsl(context, args[args.length - 1], outputType);
    var result = null;
    for (var i2 = args.length - 3; i2 >= 0; i2 -= 2) {
      var condition = expressionToGlsl(context, args[i2]);
      var output = expressionToGlsl(context, args[i2 + 1], outputType);
      result = "(".concat(condition, " ? ").concat(output, " : ").concat(result || fallback, ")");
    }
    return result;
  }
};
var __extends$P = globalThis && globalThis.__extends || function() {
  var extendStatics2 = function(d2, b2) {
    extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {
      d3.__proto__ = b3;
    } || function(d3, b3) {
      for (var p5 in b3)
        if (Object.prototype.hasOwnProperty.call(b3, p5))
          d3[p5] = b3[p5];
    };
    return extendStatics2(d2, b2);
  };
  return function(d2, b2) {
    if (typeof b2 !== "function" && b2 !== null)
      throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
    extendStatics2(d2, b2);
    function __() {
      this.constructor = d2;
    }
    d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
  };
}();
function parseStyle(style2, bandCount) {
  var vertexShader = "\n    attribute vec2 ".concat(Attributes.TEXTURE_COORD, ";\n    uniform mat4 ").concat(Uniforms.TILE_TRANSFORM, ";\n    uniform float ").concat(Uniforms.TEXTURE_PIXEL_WIDTH, ";\n    uniform float ").concat(Uniforms.TEXTURE_PIXEL_HEIGHT, ";\n    uniform float ").concat(Uniforms.TEXTURE_RESOLUTION, ";\n    uniform float ").concat(Uniforms.TEXTURE_ORIGIN_X, ";\n    uniform float ").concat(Uniforms.TEXTURE_ORIGIN_Y, ";\n    uniform float ").concat(Uniforms.DEPTH, ";\n\n    varying vec2 v_textureCoord;\n    varying vec2 v_mapCoord;\n\n    void main() {\n      v_textureCoord = ").concat(Attributes.TEXTURE_COORD, ";\n      v_mapCoord = vec2(\n        ").concat(Uniforms.TEXTURE_ORIGIN_X, " + ").concat(Uniforms.TEXTURE_RESOLUTION, " * ").concat(Uniforms.TEXTURE_PIXEL_WIDTH, " * v_textureCoord[0],\n        ").concat(Uniforms.TEXTURE_ORIGIN_Y, " - ").concat(Uniforms.TEXTURE_RESOLUTION, " * ").concat(Uniforms.TEXTURE_PIXEL_HEIGHT, " * v_textureCoord[1]\n      );\n      gl_Position = ").concat(Uniforms.TILE_TRANSFORM, " * vec4(").concat(Attributes.TEXTURE_COORD, ", ").concat(Uniforms.DEPTH, ", 1.0);\n    }\n  ");
  var context = {
    inFragmentShader: true,
    variables: [],
    attributes: [],
    stringLiteralsMap: {},
    functions: {},
    bandCount
  };
  var pipeline = [];
  if (style2.color !== void 0) {
    var color2 = expressionToGlsl(context, style2.color, ValueTypes.COLOR);
    pipeline.push("color = ".concat(color2, ";"));
  }
  if (style2.contrast !== void 0) {
    var contrast = expressionToGlsl(context, style2.contrast, ValueTypes.NUMBER);
    pipeline.push("color.rgb = clamp((".concat(contrast, " + 1.0) * color.rgb - (").concat(contrast, " / 2.0), vec3(0.0, 0.0, 0.0), vec3(1.0, 1.0, 1.0));"));
  }
  if (style2.exposure !== void 0) {
    var exposure = expressionToGlsl(context, style2.exposure, ValueTypes.NUMBER);
    pipeline.push("color.rgb = clamp((".concat(exposure, " + 1.0) * color.rgb, vec3(0.0, 0.0, 0.0), vec3(1.0, 1.0, 1.0));"));
  }
  if (style2.saturation !== void 0) {
    var saturation = expressionToGlsl(context, style2.saturation, ValueTypes.NUMBER);
    pipeline.push("\n      float saturation = ".concat(saturation, " + 1.0;\n      float sr = (1.0 - saturation) * 0.2126;\n      float sg = (1.0 - saturation) * 0.7152;\n      float sb = (1.0 - saturation) * 0.0722;\n      mat3 saturationMatrix = mat3(\n        sr + saturation, sr, sr,\n        sg, sg + saturation, sg,\n        sb, sb, sb + saturation\n      );\n      color.rgb = clamp(saturationMatrix * color.rgb, vec3(0.0, 0.0, 0.0), vec3(1.0, 1.0, 1.0));\n    "));
  }
  if (style2.gamma !== void 0) {
    var gamma = expressionToGlsl(context, style2.gamma, ValueTypes.NUMBER);
    pipeline.push("color.rgb = pow(color.rgb, vec3(1.0 / ".concat(gamma, "));"));
  }
  if (style2.brightness !== void 0) {
    var brightness = expressionToGlsl(context, style2.brightness, ValueTypes.NUMBER);
    pipeline.push("color.rgb = clamp(color.rgb + ".concat(brightness, ", vec3(0.0, 0.0, 0.0), vec3(1.0, 1.0, 1.0));"));
  }
  var uniforms = {};
  var numVariables = context.variables.length;
  if (numVariables > 1 && !style2.variables) {
    throw new Error("Missing variables in style (expected ".concat(context.variables, ")"));
  }
  var _loop_1 = function(i3) {
    var variableName = context.variables[i3];
    if (!(variableName in style2.variables)) {
      throw new Error("Missing '".concat(variableName, "' in style variables"));
    }
    var uniformName = uniformNameForVariable(variableName);
    uniforms[uniformName] = function() {
      var value = style2.variables[variableName];
      if (typeof value === "string") {
        value = getStringNumberEquivalent(context, value);
      }
      return value !== void 0 ? value : -9999999;
    };
  };
  for (var i2 = 0; i2 < numVariables; ++i2) {
    _loop_1(i2);
  }
  var uniformDeclarations = Object.keys(uniforms).map(function(name) {
    return "uniform float ".concat(name, ";");
  });
  var textureCount = Math.ceil(bandCount / 4);
  uniformDeclarations.push("uniform sampler2D ".concat(Uniforms.TILE_TEXTURE_ARRAY, "[").concat(textureCount, "];"));
  if (context.paletteTextures) {
    uniformDeclarations.push("uniform sampler2D ".concat(PALETTE_TEXTURE_ARRAY, "[").concat(context.paletteTextures.length, "];"));
  }
  var functionDefintions = Object.keys(context.functions).map(function(name) {
    return context.functions[name];
  });
  var fragmentShader = "\n    #ifdef GL_FRAGMENT_PRECISION_HIGH\n    precision highp float;\n    #else\n    precision mediump float;\n    #endif\n\n    varying vec2 v_textureCoord;\n    varying vec2 v_mapCoord;\n    uniform vec4 ".concat(Uniforms.RENDER_EXTENT, ";\n    uniform float ").concat(Uniforms.TRANSITION_ALPHA, ";\n    uniform float ").concat(Uniforms.TEXTURE_PIXEL_WIDTH, ";\n    uniform float ").concat(Uniforms.TEXTURE_PIXEL_HEIGHT, ";\n    uniform float ").concat(Uniforms.RESOLUTION, ";\n    uniform float ").concat(Uniforms.ZOOM, ";\n\n    ").concat(uniformDeclarations.join("\n"), "\n\n    ").concat(functionDefintions.join("\n"), "\n\n    void main() {\n      if (\n        v_mapCoord[0] < ").concat(Uniforms.RENDER_EXTENT, "[0] ||\n        v_mapCoord[1] < ").concat(Uniforms.RENDER_EXTENT, "[1] ||\n        v_mapCoord[0] > ").concat(Uniforms.RENDER_EXTENT, "[2] ||\n        v_mapCoord[1] > ").concat(Uniforms.RENDER_EXTENT, "[3]\n      ) {\n        discard;\n      }\n\n      vec4 color = texture2D(").concat(Uniforms.TILE_TEXTURE_ARRAY, "[0],  v_textureCoord);\n\n      ").concat(pipeline.join("\n"), "\n\n      if (color.a == 0.0) {\n        discard;\n      }\n\n      gl_FragColor = color;\n      gl_FragColor.rgb *= gl_FragColor.a;\n      gl_FragColor *= ").concat(Uniforms.TRANSITION_ALPHA, ";\n    }");
  return {
    vertexShader,
    fragmentShader,
    uniforms,
    paletteTextures: context.paletteTextures
  };
}
var WebGLTileLayer$1 = function(_super) {
  __extends$P(WebGLTileLayer2, _super);
  function WebGLTileLayer2(opt_options) {
    var _this = this;
    var options = opt_options ? assign({}, opt_options) : {};
    var style2 = options.style || {};
    delete options.style;
    var cacheSize = options.cacheSize;
    delete options.cacheSize;
    _this = _super.call(this, options) || this;
    _this.sources_ = options.sources;
    _this.renderedSource_ = null;
    _this.renderedResolution_ = NaN;
    _this.style_ = style2;
    _this.cacheSize_ = cacheSize;
    _this.styleVariables_ = _this.style_.variables || {};
    _this.addChangeListener(LayerProperty.SOURCE, _this.handleSourceUpdate_);
    return _this;
  }
  WebGLTileLayer2.prototype.getSources = function(extent2, resolution) {
    var source = this.getSource();
    return this.sources_ ? typeof this.sources_ === "function" ? this.sources_(extent2, resolution) : this.sources_ : source ? [source] : [];
  };
  WebGLTileLayer2.prototype.getRenderSource = function() {
    return this.renderedSource_ || this.getSource();
  };
  WebGLTileLayer2.prototype.getSourceState = function() {
    var source = this.getRenderSource();
    return source ? source.getState() : SourceState.UNDEFINED;
  };
  WebGLTileLayer2.prototype.handleSourceUpdate_ = function() {
    if (this.getSource()) {
      this.setStyle(this.style_);
    }
  };
  WebGLTileLayer2.prototype.getSourceBandCount_ = function() {
    var source = this.getSource();
    return source && "bandCount" in source ? source.bandCount : 4;
  };
  WebGLTileLayer2.prototype.createRenderer = function() {
    var parsedStyle = parseStyle(this.style_, this.getSourceBandCount_());
    return new WebGLTileLayerRenderer$1(this, {
      vertexShader: parsedStyle.vertexShader,
      fragmentShader: parsedStyle.fragmentShader,
      uniforms: parsedStyle.uniforms,
      cacheSize: this.cacheSize_,
      paletteTextures: parsedStyle.paletteTextures
    });
  };
  WebGLTileLayer2.prototype.renderSources = function(frameState, sources) {
    var layerRenderer = this.getRenderer();
    var canvas;
    for (var i2 = 0, ii = sources.length; i2 < ii; ++i2) {
      this.renderedSource_ = sources[i2];
      if (layerRenderer.prepareFrame(frameState)) {
        canvas = layerRenderer.renderFrame(frameState);
      }
    }
    return canvas;
  };
  WebGLTileLayer2.prototype.render = function(frameState, target) {
    var _this = this;
    this.rendered = true;
    var viewState = frameState.viewState;
    var sources = this.getSources(frameState.extent, viewState.resolution);
    var ready = true;
    var _loop_2 = function(i3, ii2) {
      var source = sources[i3];
      var sourceState = source.getState();
      if (sourceState == SourceState.LOADING) {
        var onChange_1 = function() {
          if (source.getState() == SourceState.READY) {
            source.removeEventListener("change", onChange_1);
            _this.changed();
          }
        };
        source.addEventListener("change", onChange_1);
      }
      ready = ready && sourceState == SourceState.READY;
    };
    for (var i2 = 0, ii = sources.length; i2 < ii; ++i2) {
      _loop_2(i2);
    }
    var canvas = this.renderSources(frameState, sources);
    if (this.getRenderer().renderComplete && ready) {
      this.renderedResolution_ = viewState.resolution;
      return canvas;
    }
    if (this.renderedResolution_ > 0.5 * viewState.resolution) {
      var altSources = this.getSources(frameState.extent, this.renderedResolution_).filter(function(source) {
        return !sources.includes(source);
      });
      if (altSources.length > 0) {
        return this.renderSources(frameState, altSources);
      }
    }
    return canvas;
  };
  WebGLTileLayer2.prototype.setStyle = function(style2) {
    this.styleVariables_ = style2.variables || {};
    this.style_ = style2;
    var parsedStyle = parseStyle(this.style_, this.getSourceBandCount_());
    var renderer = this.getRenderer();
    renderer.reset({
      vertexShader: parsedStyle.vertexShader,
      fragmentShader: parsedStyle.fragmentShader,
      uniforms: parsedStyle.uniforms,
      paletteTextures: parsedStyle.paletteTextures
    });
    this.changed();
  };
  WebGLTileLayer2.prototype.updateStyleVariables = function(variables) {
    assign(this.styleVariables_, variables);
    this.changed();
  };
  return WebGLTileLayer2;
}(BaseTileLayer$1);
WebGLTileLayer$1.prototype.dispose;
var TileLayer = WebGLTileLayer$1;
var _sfc_main$_ = {
  extends: BaseLayer,
  name: "ol-webgl-tile-layer",
  setup(props) {
    const map = inject("map");
    const overViewMap = inject("overviewMap", null);
    const {
      properties
    } = usePropsAsObjectProperties(props);
    const tileLayer = computed(() => new TileLayer(properties));
    const applyTileLayer = () => {
      if (overViewMap != null) {
        overViewMap.value.getOverviewMap().addLayer(tileLayer.value);
        overViewMap.value.changed();
      } else {
        map.addLayer(tileLayer.value);
      }
    };
    const removeTileLayer = () => {
      if (overViewMap != null) {
        overViewMap.value.getOverviewMap().removeLayer(tileLayer.value);
        overViewMap.value.changed();
      } else {
        map.removeLayer(tileLayer.value);
      }
    };
    if (overViewMap != null) {
      watch(overViewMap, () => {
        removeTileLayer();
        applyTileLayer();
      });
    }
    onMounted(() => {
      applyTileLayer();
    });
    onUnmounted(() => {
      removeTileLayer();
    });
    provide("tileLayer", tileLayer);
    return {
      tileLayer
    };
  },
  props: {
    preload: {
      type: Number,
      default: 1
    }
  }
};
function _sfc_render$_(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", null, [
    renderSlot(_ctx.$slots, "default")
  ]);
}
var WebGLTileLayer = _export_sfc(_sfc_main$_, [["render", _sfc_render$_]]);
var __extends$O = globalThis && globalThis.__extends || function() {
  var extendStatics2 = function(d2, b2) {
    extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {
      d3.__proto__ = b3;
    } || function(d3, b3) {
      for (var p5 in b3)
        if (Object.prototype.hasOwnProperty.call(b3, p5))
          d3[p5] = b3[p5];
    };
    return extendStatics2(d2, b2);
  };
  return function(d2, b2) {
    if (typeof b2 !== "function" && b2 !== null)
      throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
    extendStatics2(d2, b2);
    function __() {
      this.constructor = d2;
    }
    d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
  };
}();
var BaseImageLayer = function(_super) {
  __extends$O(BaseImageLayer2, _super);
  function BaseImageLayer2(opt_options) {
    var options = opt_options ? opt_options : {};
    return _super.call(this, options) || this;
  }
  return BaseImageLayer2;
}(ol_layer_Base);
var BaseImageLayer$1 = BaseImageLayer;
var __extends$N = globalThis && globalThis.__extends || function() {
  var extendStatics2 = function(d2, b2) {
    extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {
      d3.__proto__ = b3;
    } || function(d3, b3) {
      for (var p5 in b3)
        if (Object.prototype.hasOwnProperty.call(b3, p5))
          d3[p5] = b3[p5];
    };
    return extendStatics2(d2, b2);
  };
  return function(d2, b2) {
    if (typeof b2 !== "function" && b2 !== null)
      throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
    extendStatics2(d2, b2);
    function __() {
      this.constructor = d2;
    }
    d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
  };
}();
var CanvasImageLayerRenderer = function(_super) {
  __extends$N(CanvasImageLayerRenderer2, _super);
  function CanvasImageLayerRenderer2(imageLayer) {
    var _this = _super.call(this, imageLayer) || this;
    _this.image_ = null;
    return _this;
  }
  CanvasImageLayerRenderer2.prototype.getImage = function() {
    return !this.image_ ? null : this.image_.getImage();
  };
  CanvasImageLayerRenderer2.prototype.prepareFrame = function(frameState) {
    var layerState = frameState.layerStatesArray[frameState.layerIndex];
    var pixelRatio = frameState.pixelRatio;
    var viewState = frameState.viewState;
    var viewResolution = viewState.resolution;
    var imageSource = this.getLayer().getSource();
    var hints = frameState.viewHints;
    var renderedExtent = frameState.extent;
    if (layerState.extent !== void 0) {
      renderedExtent = getIntersection(renderedExtent, fromUserExtent(layerState.extent, viewState.projection));
    }
    if (!hints[ViewHint.ANIMATING] && !hints[ViewHint.INTERACTING] && !isEmpty$1(renderedExtent)) {
      if (imageSource) {
        var projection = viewState.projection;
        if (!ENABLE_RASTER_REPROJECTION) {
          var sourceProjection = imageSource.getProjection();
          if (sourceProjection) {
            projection = sourceProjection;
          }
        }
        var image2 = imageSource.getImage(renderedExtent, viewResolution, pixelRatio, projection);
        if (image2) {
          if (this.loadImage(image2)) {
            this.image_ = image2;
          } else if (image2.getState() === ImageState.EMPTY) {
            this.image_ = null;
          }
        }
      } else {
        this.image_ = null;
      }
    }
    return !!this.image_;
  };
  CanvasImageLayerRenderer2.prototype.getData = function(pixel) {
    var frameState = this.frameState;
    if (!frameState) {
      return null;
    }
    var layer = this.getLayer();
    var coordinate = apply$5(frameState.pixelToCoordinateTransform, pixel.slice());
    var layerExtent = layer.getExtent();
    if (layerExtent) {
      if (!containsCoordinate(layerExtent, coordinate)) {
        return null;
      }
    }
    var imageExtent = this.image_.getExtent();
    var img = this.image_.getImage();
    var imageMapWidth = getWidth(imageExtent);
    var col = Math.floor(img.width * ((coordinate[0] - imageExtent[0]) / imageMapWidth));
    if (col < 0 || col >= img.width) {
      return null;
    }
    var imageMapHeight = getHeight(imageExtent);
    var row = Math.floor(img.height * ((imageExtent[3] - coordinate[1]) / imageMapHeight));
    if (row < 0 || row >= img.height) {
      return null;
    }
    return this.getImageData(img, col, row);
  };
  CanvasImageLayerRenderer2.prototype.renderFrame = function(frameState, target) {
    var image2 = this.image_;
    var imageExtent = image2.getExtent();
    var imageResolution = image2.getResolution();
    var imagePixelRatio = image2.getPixelRatio();
    var layerState = frameState.layerStatesArray[frameState.layerIndex];
    var pixelRatio = frameState.pixelRatio;
    var viewState = frameState.viewState;
    var viewCenter = viewState.center;
    var viewResolution = viewState.resolution;
    var size = frameState.size;
    var scale2 = pixelRatio * imageResolution / (viewResolution * imagePixelRatio);
    var width = Math.round(size[0] * pixelRatio);
    var height = Math.round(size[1] * pixelRatio);
    var rotation = viewState.rotation;
    if (rotation) {
      var size_1 = Math.round(Math.sqrt(width * width + height * height));
      width = size_1;
      height = size_1;
    }
    compose(this.pixelTransform, frameState.size[0] / 2, frameState.size[1] / 2, 1 / pixelRatio, 1 / pixelRatio, rotation, -width / 2, -height / 2);
    makeInverse(this.inversePixelTransform, this.pixelTransform);
    var canvasTransform = toString$d(this.pixelTransform);
    this.useContainer(target, canvasTransform, layerState.opacity, this.getBackground(frameState));
    var context = this.context;
    var canvas = context.canvas;
    if (canvas.width != width || canvas.height != height) {
      canvas.width = width;
      canvas.height = height;
    } else if (!this.containerReused) {
      context.clearRect(0, 0, width, height);
    }
    var clipped = false;
    var render2 = true;
    if (layerState.extent) {
      var layerExtent = fromUserExtent(layerState.extent, viewState.projection);
      render2 = intersects$1(layerExtent, frameState.extent);
      clipped = render2 && !containsExtent(layerExtent, frameState.extent);
      if (clipped) {
        this.clipUnrotated(context, frameState, layerExtent);
      }
    }
    var img = image2.getImage();
    var transform2 = compose(this.tempTransform, width / 2, height / 2, scale2, scale2, 0, imagePixelRatio * (imageExtent[0] - viewCenter[0]) / imageResolution, imagePixelRatio * (viewCenter[1] - imageExtent[3]) / imageResolution);
    this.renderedResolution = imageResolution * pixelRatio / imagePixelRatio;
    var dw = img.width * transform2[0];
    var dh = img.height * transform2[3];
    if (!this.getLayer().getSource().getInterpolate()) {
      assign(context, IMAGE_SMOOTHING_DISABLED);
    }
    this.preRender(context, frameState);
    if (render2 && dw >= 0.5 && dh >= 0.5) {
      var dx = transform2[4];
      var dy = transform2[5];
      var opacity2 = layerState.opacity;
      var previousAlpha = void 0;
      if (opacity2 !== 1) {
        previousAlpha = context.globalAlpha;
        context.globalAlpha = opacity2;
      }
      context.drawImage(img, 0, 0, +img.width, +img.height, Math.round(dx), Math.round(dy), Math.round(dw), Math.round(dh));
      if (opacity2 !== 1) {
        context.globalAlpha = previousAlpha;
      }
    }
    this.postRender(context, frameState);
    if (clipped) {
      context.restore();
    }
    assign(context, IMAGE_SMOOTHING_ENABLED);
    if (canvasTransform !== canvas.style.transform) {
      canvas.style.transform = canvasTransform;
    }
    return this.container;
  };
  return CanvasImageLayerRenderer2;
}(CanvasLayerRenderer$1);
var CanvasImageLayerRenderer$1 = CanvasImageLayerRenderer;
var __extends$M = globalThis && globalThis.__extends || function() {
  var extendStatics2 = function(d2, b2) {
    extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {
      d3.__proto__ = b3;
    } || function(d3, b3) {
      for (var p5 in b3)
        if (Object.prototype.hasOwnProperty.call(b3, p5))
          d3[p5] = b3[p5];
    };
    return extendStatics2(d2, b2);
  };
  return function(d2, b2) {
    if (typeof b2 !== "function" && b2 !== null)
      throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
    extendStatics2(d2, b2);
    function __() {
      this.constructor = d2;
    }
    d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
  };
}();
var ImageLayer$1 = function(_super) {
  __extends$M(ImageLayer2, _super);
  function ImageLayer2(opt_options) {
    return _super.call(this, opt_options) || this;
  }
  ImageLayer2.prototype.createRenderer = function() {
    return new CanvasImageLayerRenderer$1(this);
  };
  ImageLayer2.prototype.getData = function(pixel) {
    return _super.prototype.getData.call(this, pixel);
  };
  return ImageLayer2;
}(BaseImageLayer$1);
var ol_layer_Image = ImageLayer$1;
var _sfc_main$Z = {
  extends: BaseLayer,
  name: "ol-image-layer",
  setup(props) {
    const map = inject("map");
    const {
      properties
    } = usePropsAsObjectProperties(props);
    const imageLayer = new ol_layer_Image(properties);
    watch(properties, () => {
      imageLayer.setProperties(properties);
    });
    onMounted(() => {
      map.addLayer(imageLayer);
    });
    onUnmounted(() => {
      map.removeLayer(imageLayer);
    });
    provide("imageLayer", imageLayer);
    return {
      imageLayer
    };
  }
};
function _sfc_render$Z(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", null, [
    renderSlot(_ctx.$slots, "default")
  ]);
}
var ImageLayer = _export_sfc(_sfc_main$Z, [["render", _sfc_render$Z]]);
var _sfc_main$Y = {
  extends: BaseLayer,
  name: "ol-vector-layer",
  setup(props) {
    const map = inject("map");
    const {
      properties
    } = usePropsAsObjectProperties(props);
    const vectorLayer = computed(() => new ol_layer_Vector(properties));
    watch(properties, () => {
      vectorLayer.value.setProperties(properties);
    });
    onMounted(() => {
      map.addLayer(vectorLayer.value);
    });
    onUnmounted(() => {
      map.removeLayer(vectorLayer.value);
    });
    provide("vectorLayer", vectorLayer);
    provide("stylable", vectorLayer);
    return {
      vectorLayer
    };
  },
  props: {
    renderBuffer: {
      type: Number,
      default: 100
    },
    updateWhileAnimating: {
      type: Boolean,
      default: false
    },
    style: {
      type: Function
    },
    updateWhileInteracting: {
      type: Boolean,
      default: false
    }
  }
};
function _sfc_render$Y(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", null, [
    renderSlot(_ctx.$slots, "default")
  ]);
}
var VectorLayer = _export_sfc(_sfc_main$Y, [["render", _sfc_render$Y]]);
var __extends$L = globalThis && globalThis.__extends || function() {
  var extendStatics2 = function(d2, b2) {
    extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {
      d3.__proto__ = b3;
    } || function(d3, b3) {
      for (var p5 in b3)
        if (Object.prototype.hasOwnProperty.call(b3, p5))
          d3[p5] = b3[p5];
    };
    return extendStatics2(d2, b2);
  };
  return function(d2, b2) {
    if (typeof b2 !== "function" && b2 !== null)
      throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
    extendStatics2(d2, b2);
    function __() {
      this.constructor = d2;
    }
    d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
  };
}();
var TileCache = function(_super) {
  __extends$L(TileCache2, _super);
  function TileCache2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  TileCache2.prototype.expireCache = function(usedTiles) {
    while (this.canExpireCache()) {
      var tile2 = this.peekLast();
      if (tile2.getKey() in usedTiles) {
        break;
      } else {
        this.pop().release();
      }
    }
  };
  TileCache2.prototype.pruneExceptNewestZ = function() {
    if (this.getCount() === 0) {
      return;
    }
    var key = this.peekFirstKey();
    var tileCoord = fromKey(key);
    var z2 = tileCoord[0];
    this.forEach(function(tile2) {
      if (tile2.tileCoord[0] !== z2) {
        this.remove(getKey(tile2.tileCoord));
        tile2.release();
      }
    }.bind(this));
  };
  return TileCache2;
}(LRUCache$1);
var TileCache$1 = TileCache;
var TileEventType = {
  TILELOADSTART: "tileloadstart",
  TILELOADEND: "tileloadend",
  TILELOADERROR: "tileloaderror"
};
var tmpTileCoord = [0, 0, 0];
var DECIMALS$1 = 5;
var TileGrid = function() {
  function TileGrid2(options) {
    this.minZoom = options.minZoom !== void 0 ? options.minZoom : 0;
    this.resolutions_ = options.resolutions;
    assert(isSorted(this.resolutions_, function(a2, b2) {
      return b2 - a2;
    }, true), 17);
    var zoomFactor;
    if (!options.origins) {
      for (var i2 = 0, ii = this.resolutions_.length - 1; i2 < ii; ++i2) {
        if (!zoomFactor) {
          zoomFactor = this.resolutions_[i2] / this.resolutions_[i2 + 1];
        } else {
          if (this.resolutions_[i2] / this.resolutions_[i2 + 1] !== zoomFactor) {
            zoomFactor = void 0;
            break;
          }
        }
      }
    }
    this.zoomFactor_ = zoomFactor;
    this.maxZoom = this.resolutions_.length - 1;
    this.origin_ = options.origin !== void 0 ? options.origin : null;
    this.origins_ = null;
    if (options.origins !== void 0) {
      this.origins_ = options.origins;
      assert(this.origins_.length == this.resolutions_.length, 20);
    }
    var extent2 = options.extent;
    if (extent2 !== void 0 && !this.origin_ && !this.origins_) {
      this.origin_ = getTopLeft(extent2);
    }
    assert(!this.origin_ && this.origins_ || this.origin_ && !this.origins_, 18);
    this.tileSizes_ = null;
    if (options.tileSizes !== void 0) {
      this.tileSizes_ = options.tileSizes;
      assert(this.tileSizes_.length == this.resolutions_.length, 19);
    }
    this.tileSize_ = options.tileSize !== void 0 ? options.tileSize : !this.tileSizes_ ? DEFAULT_TILE_SIZE : null;
    assert(!this.tileSize_ && this.tileSizes_ || this.tileSize_ && !this.tileSizes_, 22);
    this.extent_ = extent2 !== void 0 ? extent2 : null;
    this.fullTileRanges_ = null;
    this.tmpSize_ = [0, 0];
    this.tmpExtent_ = [0, 0, 0, 0];
    if (options.sizes !== void 0) {
      this.fullTileRanges_ = options.sizes.map(function(size, z2) {
        var tileRange = new TileRange$1(Math.min(0, size[0]), Math.max(size[0] - 1, -1), Math.min(0, size[1]), Math.max(size[1] - 1, -1));
        if (extent2) {
          var restrictedTileRange = this.getTileRangeForExtentAndZ(extent2, z2);
          tileRange.minX = Math.max(restrictedTileRange.minX, tileRange.minX);
          tileRange.maxX = Math.min(restrictedTileRange.maxX, tileRange.maxX);
          tileRange.minY = Math.max(restrictedTileRange.minY, tileRange.minY);
          tileRange.maxY = Math.min(restrictedTileRange.maxY, tileRange.maxY);
        }
        return tileRange;
      }, this);
    } else if (extent2) {
      this.calculateTileRanges_(extent2);
    }
  }
  TileGrid2.prototype.forEachTileCoord = function(extent2, zoom, callback) {
    var tileRange = this.getTileRangeForExtentAndZ(extent2, zoom);
    for (var i2 = tileRange.minX, ii = tileRange.maxX; i2 <= ii; ++i2) {
      for (var j2 = tileRange.minY, jj = tileRange.maxY; j2 <= jj; ++j2) {
        callback([zoom, i2, j2]);
      }
    }
  };
  TileGrid2.prototype.forEachTileCoordParentTileRange = function(tileCoord, callback, opt_tileRange, opt_extent) {
    var tileRange, x2, y2;
    var tileCoordExtent = null;
    var z2 = tileCoord[0] - 1;
    if (this.zoomFactor_ === 2) {
      x2 = tileCoord[1];
      y2 = tileCoord[2];
    } else {
      tileCoordExtent = this.getTileCoordExtent(tileCoord, opt_extent);
    }
    while (z2 >= this.minZoom) {
      if (this.zoomFactor_ === 2) {
        x2 = Math.floor(x2 / 2);
        y2 = Math.floor(y2 / 2);
        tileRange = createOrUpdate$1(x2, x2, y2, y2, opt_tileRange);
      } else {
        tileRange = this.getTileRangeForExtentAndZ(tileCoordExtent, z2, opt_tileRange);
      }
      if (callback(z2, tileRange)) {
        return true;
      }
      --z2;
    }
    return false;
  };
  TileGrid2.prototype.getExtent = function() {
    return this.extent_;
  };
  TileGrid2.prototype.getMaxZoom = function() {
    return this.maxZoom;
  };
  TileGrid2.prototype.getMinZoom = function() {
    return this.minZoom;
  };
  TileGrid2.prototype.getOrigin = function(z2) {
    if (this.origin_) {
      return this.origin_;
    } else {
      return this.origins_[z2];
    }
  };
  TileGrid2.prototype.getResolution = function(z2) {
    return this.resolutions_[z2];
  };
  TileGrid2.prototype.getResolutions = function() {
    return this.resolutions_;
  };
  TileGrid2.prototype.getTileCoordChildTileRange = function(tileCoord, opt_tileRange, opt_extent) {
    if (tileCoord[0] < this.maxZoom) {
      if (this.zoomFactor_ === 2) {
        var minX = tileCoord[1] * 2;
        var minY = tileCoord[2] * 2;
        return createOrUpdate$1(minX, minX + 1, minY, minY + 1, opt_tileRange);
      }
      var tileCoordExtent = this.getTileCoordExtent(tileCoord, opt_extent || this.tmpExtent_);
      return this.getTileRangeForExtentAndZ(tileCoordExtent, tileCoord[0] + 1, opt_tileRange);
    }
    return null;
  };
  TileGrid2.prototype.getTileRangeForTileCoordAndZ = function(tileCoord, z2, opt_tileRange) {
    if (z2 > this.maxZoom || z2 < this.minZoom) {
      return null;
    }
    var tileCoordZ = tileCoord[0];
    var tileCoordX = tileCoord[1];
    var tileCoordY = tileCoord[2];
    if (z2 === tileCoordZ) {
      return createOrUpdate$1(tileCoordX, tileCoordY, tileCoordX, tileCoordY, opt_tileRange);
    }
    if (this.zoomFactor_) {
      var factor = Math.pow(this.zoomFactor_, z2 - tileCoordZ);
      var minX = Math.floor(tileCoordX * factor);
      var minY = Math.floor(tileCoordY * factor);
      if (z2 < tileCoordZ) {
        return createOrUpdate$1(minX, minX, minY, minY, opt_tileRange);
      }
      var maxX = Math.floor(factor * (tileCoordX + 1)) - 1;
      var maxY = Math.floor(factor * (tileCoordY + 1)) - 1;
      return createOrUpdate$1(minX, maxX, minY, maxY, opt_tileRange);
    }
    var tileCoordExtent = this.getTileCoordExtent(tileCoord, this.tmpExtent_);
    return this.getTileRangeForExtentAndZ(tileCoordExtent, z2, opt_tileRange);
  };
  TileGrid2.prototype.getTileRangeExtent = function(z2, tileRange, opt_extent) {
    var origin = this.getOrigin(z2);
    var resolution = this.getResolution(z2);
    var tileSize = toSize(this.getTileSize(z2), this.tmpSize_);
    var minX = origin[0] + tileRange.minX * tileSize[0] * resolution;
    var maxX = origin[0] + (tileRange.maxX + 1) * tileSize[0] * resolution;
    var minY = origin[1] + tileRange.minY * tileSize[1] * resolution;
    var maxY = origin[1] + (tileRange.maxY + 1) * tileSize[1] * resolution;
    return createOrUpdate$2(minX, minY, maxX, maxY, opt_extent);
  };
  TileGrid2.prototype.getTileRangeForExtentAndZ = function(extent2, z2, opt_tileRange) {
    var tileCoord = tmpTileCoord;
    this.getTileCoordForXYAndZ_(extent2[0], extent2[3], z2, false, tileCoord);
    var minX = tileCoord[1];
    var minY = tileCoord[2];
    this.getTileCoordForXYAndZ_(extent2[2], extent2[1], z2, true, tileCoord);
    return createOrUpdate$1(minX, tileCoord[1], minY, tileCoord[2], opt_tileRange);
  };
  TileGrid2.prototype.getTileCoordCenter = function(tileCoord) {
    var origin = this.getOrigin(tileCoord[0]);
    var resolution = this.getResolution(tileCoord[0]);
    var tileSize = toSize(this.getTileSize(tileCoord[0]), this.tmpSize_);
    return [
      origin[0] + (tileCoord[1] + 0.5) * tileSize[0] * resolution,
      origin[1] - (tileCoord[2] + 0.5) * tileSize[1] * resolution
    ];
  };
  TileGrid2.prototype.getTileCoordExtent = function(tileCoord, opt_extent) {
    var origin = this.getOrigin(tileCoord[0]);
    var resolution = this.getResolution(tileCoord[0]);
    var tileSize = toSize(this.getTileSize(tileCoord[0]), this.tmpSize_);
    var minX = origin[0] + tileCoord[1] * tileSize[0] * resolution;
    var minY = origin[1] - (tileCoord[2] + 1) * tileSize[1] * resolution;
    var maxX = minX + tileSize[0] * resolution;
    var maxY = minY + tileSize[1] * resolution;
    return createOrUpdate$2(minX, minY, maxX, maxY, opt_extent);
  };
  TileGrid2.prototype.getTileCoordForCoordAndResolution = function(coordinate, resolution, opt_tileCoord) {
    return this.getTileCoordForXYAndResolution_(coordinate[0], coordinate[1], resolution, false, opt_tileCoord);
  };
  TileGrid2.prototype.getTileCoordForXYAndResolution_ = function(x2, y2, resolution, reverseIntersectionPolicy, opt_tileCoord) {
    var z2 = this.getZForResolution(resolution);
    var scale2 = resolution / this.getResolution(z2);
    var origin = this.getOrigin(z2);
    var tileSize = toSize(this.getTileSize(z2), this.tmpSize_);
    var tileCoordX = scale2 * (x2 - origin[0]) / resolution / tileSize[0];
    var tileCoordY = scale2 * (origin[1] - y2) / resolution / tileSize[1];
    if (reverseIntersectionPolicy) {
      tileCoordX = ceil$1(tileCoordX, DECIMALS$1) - 1;
      tileCoordY = ceil$1(tileCoordY, DECIMALS$1) - 1;
    } else {
      tileCoordX = floor$2(tileCoordX, DECIMALS$1);
      tileCoordY = floor$2(tileCoordY, DECIMALS$1);
    }
    return createOrUpdate(z2, tileCoordX, tileCoordY, opt_tileCoord);
  };
  TileGrid2.prototype.getTileCoordForXYAndZ_ = function(x2, y2, z2, reverseIntersectionPolicy, opt_tileCoord) {
    var origin = this.getOrigin(z2);
    var resolution = this.getResolution(z2);
    var tileSize = toSize(this.getTileSize(z2), this.tmpSize_);
    var tileCoordX = (x2 - origin[0]) / resolution / tileSize[0];
    var tileCoordY = (origin[1] - y2) / resolution / tileSize[1];
    if (reverseIntersectionPolicy) {
      tileCoordX = ceil$1(tileCoordX, DECIMALS$1) - 1;
      tileCoordY = ceil$1(tileCoordY, DECIMALS$1) - 1;
    } else {
      tileCoordX = floor$2(tileCoordX, DECIMALS$1);
      tileCoordY = floor$2(tileCoordY, DECIMALS$1);
    }
    return createOrUpdate(z2, tileCoordX, tileCoordY, opt_tileCoord);
  };
  TileGrid2.prototype.getTileCoordForCoordAndZ = function(coordinate, z2, opt_tileCoord) {
    return this.getTileCoordForXYAndZ_(coordinate[0], coordinate[1], z2, false, opt_tileCoord);
  };
  TileGrid2.prototype.getTileCoordResolution = function(tileCoord) {
    return this.resolutions_[tileCoord[0]];
  };
  TileGrid2.prototype.getTileSize = function(z2) {
    if (this.tileSize_) {
      return this.tileSize_;
    } else {
      return this.tileSizes_[z2];
    }
  };
  TileGrid2.prototype.getFullTileRange = function(z2) {
    if (!this.fullTileRanges_) {
      return this.extent_ ? this.getTileRangeForExtentAndZ(this.extent_, z2) : null;
    } else {
      return this.fullTileRanges_[z2];
    }
  };
  TileGrid2.prototype.getZForResolution = function(resolution, opt_direction) {
    var z2 = linearFindNearest(this.resolutions_, resolution, opt_direction || 0);
    return clamp(z2, this.minZoom, this.maxZoom);
  };
  TileGrid2.prototype.calculateTileRanges_ = function(extent2) {
    var length = this.resolutions_.length;
    var fullTileRanges = new Array(length);
    for (var z2 = this.minZoom; z2 < length; ++z2) {
      fullTileRanges[z2] = this.getTileRangeForExtentAndZ(extent2, z2);
    }
    this.fullTileRanges_ = fullTileRanges;
  };
  return TileGrid2;
}();
var TileGrid$1 = TileGrid;
function getForProjection(projection) {
  var tileGrid = projection.getDefaultTileGrid();
  if (!tileGrid) {
    tileGrid = createForProjection(projection);
    projection.setDefaultTileGrid(tileGrid);
  }
  return tileGrid;
}
function wrapX(tileGrid, tileCoord, projection) {
  var z2 = tileCoord[0];
  var center = tileGrid.getTileCoordCenter(tileCoord);
  var projectionExtent = extentFromProjection(projection);
  if (!containsCoordinate(projectionExtent, center)) {
    var worldWidth = getWidth(projectionExtent);
    var worldsAway = Math.ceil((projectionExtent[0] - center[0]) / worldWidth);
    center[0] += worldWidth * worldsAway;
    return tileGrid.getTileCoordForCoordAndZ(center, z2);
  } else {
    return tileCoord;
  }
}
function createForExtent(extent2, opt_maxZoom, opt_tileSize, opt_corner) {
  var corner = opt_corner !== void 0 ? opt_corner : Corner.TOP_LEFT;
  var resolutions = resolutionsFromExtent(extent2, opt_maxZoom, opt_tileSize);
  return new TileGrid$1({
    extent: extent2,
    origin: getCorner(extent2, corner),
    resolutions,
    tileSize: opt_tileSize
  });
}
function createXYZ(opt_options) {
  var xyzOptions = opt_options || {};
  var extent2 = xyzOptions.extent || get$3("EPSG:3857").getExtent();
  var gridOptions = {
    extent: extent2,
    minZoom: xyzOptions.minZoom,
    tileSize: xyzOptions.tileSize,
    resolutions: resolutionsFromExtent(extent2, xyzOptions.maxZoom, xyzOptions.tileSize, xyzOptions.maxResolution)
  };
  return new TileGrid$1(gridOptions);
}
function resolutionsFromExtent(extent2, opt_maxZoom, opt_tileSize, opt_maxResolution) {
  var maxZoom = opt_maxZoom !== void 0 ? opt_maxZoom : DEFAULT_MAX_ZOOM;
  var height = getHeight(extent2);
  var width = getWidth(extent2);
  var tileSize = toSize(opt_tileSize !== void 0 ? opt_tileSize : DEFAULT_TILE_SIZE);
  var maxResolution = opt_maxResolution > 0 ? opt_maxResolution : Math.max(width / tileSize[0], height / tileSize[1]);
  var length = maxZoom + 1;
  var resolutions = new Array(length);
  for (var z2 = 0; z2 < length; ++z2) {
    resolutions[z2] = maxResolution / Math.pow(2, z2);
  }
  return resolutions;
}
function createForProjection(projection, opt_maxZoom, opt_tileSize, opt_corner) {
  var extent2 = extentFromProjection(projection);
  return createForExtent(extent2, opt_maxZoom, opt_tileSize, opt_corner);
}
function extentFromProjection(projection) {
  projection = get$3(projection);
  var extent2 = projection.getExtent();
  if (!extent2) {
    var half = 180 * METERS_PER_UNIT$1[Units$2.DEGREES] / projection.getMetersPerUnit();
    extent2 = createOrUpdate$2(-half, -half, half, half);
  }
  return extent2;
}
var __extends$K = globalThis && globalThis.__extends || function() {
  var extendStatics2 = function(d2, b2) {
    extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {
      d3.__proto__ = b3;
    } || function(d3, b3) {
      for (var p5 in b3)
        if (Object.prototype.hasOwnProperty.call(b3, p5))
          d3[p5] = b3[p5];
    };
    return extendStatics2(d2, b2);
  };
  return function(d2, b2) {
    if (typeof b2 !== "function" && b2 !== null)
      throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
    extendStatics2(d2, b2);
    function __() {
      this.constructor = d2;
    }
    d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
  };
}();
var TileSource = function(_super) {
  __extends$K(TileSource2, _super);
  function TileSource2(options) {
    var _this = _super.call(this, {
      attributions: options.attributions,
      attributionsCollapsible: options.attributionsCollapsible,
      projection: options.projection,
      state: options.state,
      wrapX: options.wrapX,
      interpolate: options.interpolate
    }) || this;
    _this.on;
    _this.once;
    _this.un;
    _this.opaque_ = options.opaque !== void 0 ? options.opaque : false;
    _this.tilePixelRatio_ = options.tilePixelRatio !== void 0 ? options.tilePixelRatio : 1;
    _this.tileGrid = options.tileGrid !== void 0 ? options.tileGrid : null;
    var tileSize = [256, 256];
    if (_this.tileGrid) {
      toSize(_this.tileGrid.getTileSize(_this.tileGrid.getMinZoom()), tileSize);
    }
    _this.tileCache = new TileCache$1(options.cacheSize || 0);
    _this.tmpSize = [0, 0];
    _this.key_ = options.key || "";
    _this.tileOptions = {
      transition: options.transition,
      interpolate: options.interpolate
    };
    _this.zDirection = options.zDirection ? options.zDirection : 0;
    return _this;
  }
  TileSource2.prototype.canExpireCache = function() {
    return this.tileCache.canExpireCache();
  };
  TileSource2.prototype.expireCache = function(projection, usedTiles) {
    var tileCache = this.getTileCacheForProjection(projection);
    if (tileCache) {
      tileCache.expireCache(usedTiles);
    }
  };
  TileSource2.prototype.forEachLoadedTile = function(projection, z2, tileRange, callback) {
    var tileCache = this.getTileCacheForProjection(projection);
    if (!tileCache) {
      return false;
    }
    var covered = true;
    var tile2, tileCoordKey, loaded;
    for (var x2 = tileRange.minX; x2 <= tileRange.maxX; ++x2) {
      for (var y2 = tileRange.minY; y2 <= tileRange.maxY; ++y2) {
        tileCoordKey = getKeyZXY(z2, x2, y2);
        loaded = false;
        if (tileCache.containsKey(tileCoordKey)) {
          tile2 = tileCache.get(tileCoordKey);
          loaded = tile2.getState() === TileState.LOADED;
          if (loaded) {
            loaded = callback(tile2) !== false;
          }
        }
        if (!loaded) {
          covered = false;
        }
      }
    }
    return covered;
  };
  TileSource2.prototype.getGutterForProjection = function(projection) {
    return 0;
  };
  TileSource2.prototype.getKey = function() {
    return this.key_;
  };
  TileSource2.prototype.setKey = function(key) {
    if (this.key_ !== key) {
      this.key_ = key;
      this.changed();
    }
  };
  TileSource2.prototype.getOpaque = function(projection) {
    return this.opaque_;
  };
  TileSource2.prototype.getResolutions = function() {
    if (!this.tileGrid) {
      return null;
    }
    return this.tileGrid.getResolutions();
  };
  TileSource2.prototype.getTile = function(z2, x2, y2, pixelRatio, projection) {
    return abstract();
  };
  TileSource2.prototype.getTileGrid = function() {
    return this.tileGrid;
  };
  TileSource2.prototype.getTileGridForProjection = function(projection) {
    if (!this.tileGrid) {
      return getForProjection(projection);
    } else {
      return this.tileGrid;
    }
  };
  TileSource2.prototype.getTileCacheForProjection = function(projection) {
    assert(equivalent(this.getProjection(), projection), 68);
    return this.tileCache;
  };
  TileSource2.prototype.getTilePixelRatio = function(pixelRatio) {
    return this.tilePixelRatio_;
  };
  TileSource2.prototype.getTilePixelSize = function(z2, pixelRatio, projection) {
    var tileGrid = this.getTileGridForProjection(projection);
    var tilePixelRatio = this.getTilePixelRatio(pixelRatio);
    var tileSize = toSize(tileGrid.getTileSize(z2), this.tmpSize);
    if (tilePixelRatio == 1) {
      return tileSize;
    } else {
      return scale(tileSize, tilePixelRatio, this.tmpSize);
    }
  };
  TileSource2.prototype.getTileCoordForTileUrlFunction = function(tileCoord, opt_projection) {
    var projection = opt_projection !== void 0 ? opt_projection : this.getProjection();
    var tileGrid = this.getTileGridForProjection(projection);
    if (this.getWrapX() && projection.isGlobal()) {
      tileCoord = wrapX(tileGrid, tileCoord, projection);
    }
    return withinExtentAndZ(tileCoord, tileGrid) ? tileCoord : null;
  };
  TileSource2.prototype.clear = function() {
    this.tileCache.clear();
  };
  TileSource2.prototype.refresh = function() {
    this.clear();
    _super.prototype.refresh.call(this);
  };
  TileSource2.prototype.updateCacheSize = function(tileCount, projection) {
    var tileCache = this.getTileCacheForProjection(projection);
    if (tileCount > tileCache.highWaterMark) {
      tileCache.highWaterMark = tileCount;
    }
  };
  TileSource2.prototype.useTile = function(z2, x2, y2, projection) {
  };
  return TileSource2;
}(ol_source_Source);
var TileSourceEvent = function(_super) {
  __extends$K(TileSourceEvent2, _super);
  function TileSourceEvent2(type, tile2) {
    var _this = _super.call(this, type) || this;
    _this.tile = tile2;
    return _this;
  }
  return TileSourceEvent2;
}(Event$1);
var ol_source_Tile = TileSource;
function createFromTemplate(template, tileGrid) {
  var zRegEx = /\{z\}/g;
  var xRegEx = /\{x\}/g;
  var yRegEx = /\{y\}/g;
  var dashYRegEx = /\{-y\}/g;
  return function(tileCoord, pixelRatio, projection) {
    if (!tileCoord) {
      return void 0;
    } else {
      return template.replace(zRegEx, tileCoord[0].toString()).replace(xRegEx, tileCoord[1].toString()).replace(yRegEx, tileCoord[2].toString()).replace(dashYRegEx, function() {
        var z2 = tileCoord[0];
        var range = tileGrid.getFullTileRange(z2);
        assert(range, 55);
        var y2 = range.getHeight() - tileCoord[2] - 1;
        return y2.toString();
      });
    }
  };
}
function createFromTemplates(templates, tileGrid) {
  var len = templates.length;
  var tileUrlFunctions = new Array(len);
  for (var i2 = 0; i2 < len; ++i2) {
    tileUrlFunctions[i2] = createFromTemplate(templates[i2], tileGrid);
  }
  return createFromTileUrlFunctions(tileUrlFunctions);
}
function createFromTileUrlFunctions(tileUrlFunctions) {
  if (tileUrlFunctions.length === 1) {
    return tileUrlFunctions[0];
  }
  return function(tileCoord, pixelRatio, projection) {
    if (!tileCoord) {
      return void 0;
    } else {
      var h2 = hash(tileCoord);
      var index2 = modulo(h2, tileUrlFunctions.length);
      return tileUrlFunctions[index2](tileCoord, pixelRatio, projection);
    }
  };
}
function expandUrl(url) {
  var urls = [];
  var match2 = /\{([a-z])-([a-z])\}/.exec(url);
  if (match2) {
    var startCharCode = match2[1].charCodeAt(0);
    var stopCharCode = match2[2].charCodeAt(0);
    var charCode = void 0;
    for (charCode = startCharCode; charCode <= stopCharCode; ++charCode) {
      urls.push(url.replace(match2[0], String.fromCharCode(charCode)));
    }
    return urls;
  }
  match2 = /\{(\d+)-(\d+)\}/.exec(url);
  if (match2) {
    var stop_1 = parseInt(match2[2], 10);
    for (var i2 = parseInt(match2[1], 10); i2 <= stop_1; i2++) {
      urls.push(url.replace(match2[0], i2.toString()));
    }
    return urls;
  }
  urls.push(url);
  return urls;
}
var __extends$J = globalThis && globalThis.__extends || function() {
  var extendStatics2 = function(d2, b2) {
    extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {
      d3.__proto__ = b3;
    } || function(d3, b3) {
      for (var p5 in b3)
        if (Object.prototype.hasOwnProperty.call(b3, p5))
          d3[p5] = b3[p5];
    };
    return extendStatics2(d2, b2);
  };
  return function(d2, b2) {
    if (typeof b2 !== "function" && b2 !== null)
      throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
    extendStatics2(d2, b2);
    function __() {
      this.constructor = d2;
    }
    d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
  };
}();
var UrlTile = function(_super) {
  __extends$J(UrlTile2, _super);
  function UrlTile2(options) {
    var _this = _super.call(this, {
      attributions: options.attributions,
      cacheSize: options.cacheSize,
      opaque: options.opaque,
      projection: options.projection,
      state: options.state,
      tileGrid: options.tileGrid,
      tilePixelRatio: options.tilePixelRatio,
      wrapX: options.wrapX,
      transition: options.transition,
      interpolate: options.interpolate,
      key: options.key,
      attributionsCollapsible: options.attributionsCollapsible,
      zDirection: options.zDirection
    }) || this;
    _this.generateTileUrlFunction_ = _this.tileUrlFunction === UrlTile2.prototype.tileUrlFunction;
    _this.tileLoadFunction = options.tileLoadFunction;
    if (options.tileUrlFunction) {
      _this.tileUrlFunction = options.tileUrlFunction;
    }
    _this.urls = null;
    if (options.urls) {
      _this.setUrls(options.urls);
    } else if (options.url) {
      _this.setUrl(options.url);
    }
    _this.tileLoadingKeys_ = {};
    return _this;
  }
  UrlTile2.prototype.getTileLoadFunction = function() {
    return this.tileLoadFunction;
  };
  UrlTile2.prototype.getTileUrlFunction = function() {
    return Object.getPrototypeOf(this).tileUrlFunction === this.tileUrlFunction ? this.tileUrlFunction.bind(this) : this.tileUrlFunction;
  };
  UrlTile2.prototype.getUrls = function() {
    return this.urls;
  };
  UrlTile2.prototype.handleTileChange = function(event) {
    var tile2 = event.target;
    var uid2 = getUid(tile2);
    var tileState = tile2.getState();
    var type;
    if (tileState == TileState.LOADING) {
      this.tileLoadingKeys_[uid2] = true;
      type = TileEventType.TILELOADSTART;
    } else if (uid2 in this.tileLoadingKeys_) {
      delete this.tileLoadingKeys_[uid2];
      type = tileState == TileState.ERROR ? TileEventType.TILELOADERROR : tileState == TileState.LOADED ? TileEventType.TILELOADEND : void 0;
    }
    if (type != void 0) {
      this.dispatchEvent(new TileSourceEvent(type, tile2));
    }
  };
  UrlTile2.prototype.setTileLoadFunction = function(tileLoadFunction) {
    this.tileCache.clear();
    this.tileLoadFunction = tileLoadFunction;
    this.changed();
  };
  UrlTile2.prototype.setTileUrlFunction = function(tileUrlFunction, key) {
    this.tileUrlFunction = tileUrlFunction;
    this.tileCache.pruneExceptNewestZ();
    if (typeof key !== "undefined") {
      this.setKey(key);
    } else {
      this.changed();
    }
  };
  UrlTile2.prototype.setUrl = function(url) {
    var urls = expandUrl(url);
    this.urls = urls;
    this.setUrls(urls);
  };
  UrlTile2.prototype.setUrls = function(urls) {
    this.urls = urls;
    var key = urls.join("\n");
    if (this.generateTileUrlFunction_) {
      this.setTileUrlFunction(createFromTemplates(urls, this.tileGrid), key);
    } else {
      this.setKey(key);
    }
  };
  UrlTile2.prototype.tileUrlFunction = function(tileCoord, pixelRatio, projection) {
    return void 0;
  };
  UrlTile2.prototype.useTile = function(z2, x2, y2) {
    var tileCoordKey = getKeyZXY(z2, x2, y2);
    if (this.tileCache.containsKey(tileCoordKey)) {
      this.tileCache.get(tileCoordKey);
    }
  };
  return UrlTile2;
}(ol_source_Tile);
var UrlTile$1 = UrlTile;
var __extends$I = globalThis && globalThis.__extends || function() {
  var extendStatics2 = function(d2, b2) {
    extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {
      d3.__proto__ = b3;
    } || function(d3, b3) {
      for (var p5 in b3)
        if (Object.prototype.hasOwnProperty.call(b3, p5))
          d3[p5] = b3[p5];
    };
    return extendStatics2(d2, b2);
  };
  return function(d2, b2) {
    if (typeof b2 !== "function" && b2 !== null)
      throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
    extendStatics2(d2, b2);
    function __() {
      this.constructor = d2;
    }
    d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
  };
}();
var TileImage = function(_super) {
  __extends$I(TileImage2, _super);
  function TileImage2(options) {
    var _this = this;
    var interpolate = options.imageSmoothing !== void 0 ? options.imageSmoothing : true;
    if (options.interpolate !== void 0) {
      interpolate = options.interpolate;
    }
    _this = _super.call(this, {
      attributions: options.attributions,
      cacheSize: options.cacheSize,
      opaque: options.opaque,
      projection: options.projection,
      state: options.state,
      tileGrid: options.tileGrid,
      tileLoadFunction: options.tileLoadFunction ? options.tileLoadFunction : defaultTileLoadFunction,
      tilePixelRatio: options.tilePixelRatio,
      tileUrlFunction: options.tileUrlFunction,
      url: options.url,
      urls: options.urls,
      wrapX: options.wrapX,
      transition: options.transition,
      interpolate,
      key: options.key,
      attributionsCollapsible: options.attributionsCollapsible,
      zDirection: options.zDirection
    }) || this;
    _this.crossOrigin = options.crossOrigin !== void 0 ? options.crossOrigin : null;
    _this.tileClass = options.tileClass !== void 0 ? options.tileClass : ImageTile$1;
    _this.tileCacheForProjection = {};
    _this.tileGridForProjection = {};
    _this.reprojectionErrorThreshold_ = options.reprojectionErrorThreshold;
    _this.renderReprojectionEdges_ = false;
    return _this;
  }
  TileImage2.prototype.canExpireCache = function() {
    if (!ENABLE_RASTER_REPROJECTION) {
      return _super.prototype.canExpireCache.call(this);
    }
    if (this.tileCache.canExpireCache()) {
      return true;
    } else {
      for (var key in this.tileCacheForProjection) {
        if (this.tileCacheForProjection[key].canExpireCache()) {
          return true;
        }
      }
    }
    return false;
  };
  TileImage2.prototype.expireCache = function(projection, usedTiles) {
    if (!ENABLE_RASTER_REPROJECTION) {
      _super.prototype.expireCache.call(this, projection, usedTiles);
      return;
    }
    var usedTileCache = this.getTileCacheForProjection(projection);
    this.tileCache.expireCache(this.tileCache == usedTileCache ? usedTiles : {});
    for (var id in this.tileCacheForProjection) {
      var tileCache = this.tileCacheForProjection[id];
      tileCache.expireCache(tileCache == usedTileCache ? usedTiles : {});
    }
  };
  TileImage2.prototype.getGutterForProjection = function(projection) {
    if (ENABLE_RASTER_REPROJECTION && this.getProjection() && projection && !equivalent(this.getProjection(), projection)) {
      return 0;
    } else {
      return this.getGutter();
    }
  };
  TileImage2.prototype.getGutter = function() {
    return 0;
  };
  TileImage2.prototype.getKey = function() {
    var key = _super.prototype.getKey.call(this);
    if (!this.getInterpolate()) {
      key += ":disable-interpolation";
    }
    return key;
  };
  TileImage2.prototype.getOpaque = function(projection) {
    if (ENABLE_RASTER_REPROJECTION && this.getProjection() && projection && !equivalent(this.getProjection(), projection)) {
      return false;
    } else {
      return _super.prototype.getOpaque.call(this, projection);
    }
  };
  TileImage2.prototype.getTileGridForProjection = function(projection) {
    if (!ENABLE_RASTER_REPROJECTION) {
      return _super.prototype.getTileGridForProjection.call(this, projection);
    }
    var thisProj = this.getProjection();
    if (this.tileGrid && (!thisProj || equivalent(thisProj, projection))) {
      return this.tileGrid;
    } else {
      var projKey = getUid(projection);
      if (!(projKey in this.tileGridForProjection)) {
        this.tileGridForProjection[projKey] = getForProjection(projection);
      }
      return this.tileGridForProjection[projKey];
    }
  };
  TileImage2.prototype.getTileCacheForProjection = function(projection) {
    if (!ENABLE_RASTER_REPROJECTION) {
      return _super.prototype.getTileCacheForProjection.call(this, projection);
    }
    var thisProj = this.getProjection();
    if (!thisProj || equivalent(thisProj, projection)) {
      return this.tileCache;
    } else {
      var projKey = getUid(projection);
      if (!(projKey in this.tileCacheForProjection)) {
        this.tileCacheForProjection[projKey] = new TileCache$1(this.tileCache.highWaterMark);
      }
      return this.tileCacheForProjection[projKey];
    }
  };
  TileImage2.prototype.createTile_ = function(z2, x2, y2, pixelRatio, projection, key) {
    var tileCoord = [z2, x2, y2];
    var urlTileCoord = this.getTileCoordForTileUrlFunction(tileCoord, projection);
    var tileUrl = urlTileCoord ? this.tileUrlFunction(urlTileCoord, pixelRatio, projection) : void 0;
    var tile2 = new this.tileClass(tileCoord, tileUrl !== void 0 ? TileState.IDLE : TileState.EMPTY, tileUrl !== void 0 ? tileUrl : "", this.crossOrigin, this.tileLoadFunction, this.tileOptions);
    tile2.key = key;
    tile2.addEventListener(EventType.CHANGE, this.handleTileChange.bind(this));
    return tile2;
  };
  TileImage2.prototype.getTile = function(z2, x2, y2, pixelRatio, projection) {
    var sourceProjection = this.getProjection();
    if (!ENABLE_RASTER_REPROJECTION || !sourceProjection || !projection || equivalent(sourceProjection, projection)) {
      return this.getTileInternal(z2, x2, y2, pixelRatio, sourceProjection || projection);
    } else {
      var cache2 = this.getTileCacheForProjection(projection);
      var tileCoord = [z2, x2, y2];
      var tile2 = void 0;
      var tileCoordKey = getKey(tileCoord);
      if (cache2.containsKey(tileCoordKey)) {
        tile2 = cache2.get(tileCoordKey);
      }
      var key = this.getKey();
      if (tile2 && tile2.key == key) {
        return tile2;
      } else {
        var sourceTileGrid = this.getTileGridForProjection(sourceProjection);
        var targetTileGrid = this.getTileGridForProjection(projection);
        var wrappedTileCoord = this.getTileCoordForTileUrlFunction(tileCoord, projection);
        var newTile = new ReprojTile$1(sourceProjection, sourceTileGrid, projection, targetTileGrid, tileCoord, wrappedTileCoord, this.getTilePixelRatio(pixelRatio), this.getGutter(), function(z3, x3, y3, pixelRatio2) {
          return this.getTileInternal(z3, x3, y3, pixelRatio2, sourceProjection);
        }.bind(this), this.reprojectionErrorThreshold_, this.renderReprojectionEdges_, this.getInterpolate());
        newTile.key = key;
        if (tile2) {
          newTile.interimTile = tile2;
          newTile.refreshInterimChain();
          cache2.replace(tileCoordKey, newTile);
        } else {
          cache2.set(tileCoordKey, newTile);
        }
        return newTile;
      }
    }
  };
  TileImage2.prototype.getTileInternal = function(z2, x2, y2, pixelRatio, projection) {
    var tile2 = null;
    var tileCoordKey = getKeyZXY(z2, x2, y2);
    var key = this.getKey();
    if (!this.tileCache.containsKey(tileCoordKey)) {
      tile2 = this.createTile_(z2, x2, y2, pixelRatio, projection, key);
      this.tileCache.set(tileCoordKey, tile2);
    } else {
      tile2 = this.tileCache.get(tileCoordKey);
      if (tile2.key != key) {
        var interimTile = tile2;
        tile2 = this.createTile_(z2, x2, y2, pixelRatio, projection, key);
        if (interimTile.getState() == TileState.IDLE) {
          tile2.interimTile = interimTile.interimTile;
        } else {
          tile2.interimTile = interimTile;
        }
        tile2.refreshInterimChain();
        this.tileCache.replace(tileCoordKey, tile2);
      }
    }
    return tile2;
  };
  TileImage2.prototype.setRenderReprojectionEdges = function(render2) {
    if (!ENABLE_RASTER_REPROJECTION || this.renderReprojectionEdges_ == render2) {
      return;
    }
    this.renderReprojectionEdges_ = render2;
    for (var id in this.tileCacheForProjection) {
      this.tileCacheForProjection[id].clear();
    }
    this.changed();
  };
  TileImage2.prototype.setTileGridForProjection = function(projection, tilegrid) {
    if (ENABLE_RASTER_REPROJECTION) {
      var proj = get$3(projection);
      if (proj) {
        var projKey = getUid(proj);
        if (!(projKey in this.tileGridForProjection)) {
          this.tileGridForProjection[projKey] = tilegrid;
        }
      }
    }
  };
  return TileImage2;
}(UrlTile$1);
function defaultTileLoadFunction(imageTile, src) {
  imageTile.getImage().src = src;
}
var TileImage$1 = TileImage;
var __extends$H = globalThis && globalThis.__extends || function() {
  var extendStatics2 = function(d2, b2) {
    extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {
      d3.__proto__ = b3;
    } || function(d3, b3) {
      for (var p5 in b3)
        if (Object.prototype.hasOwnProperty.call(b3, p5))
          d3[p5] = b3[p5];
    };
    return extendStatics2(d2, b2);
  };
  return function(d2, b2) {
    if (typeof b2 !== "function" && b2 !== null)
      throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
    extendStatics2(d2, b2);
    function __() {
      this.constructor = d2;
    }
    d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
  };
}();
function jsonp(url, callback, opt_errback, opt_callbackParam) {
  var script = document.createElement("script");
  var key = "olc_" + getUid(callback);
  function cleanup() {
    delete window[key];
    script.parentNode.removeChild(script);
  }
  script.async = true;
  script.src = url + (url.indexOf("?") == -1 ? "?" : "&") + (opt_callbackParam || "callback") + "=" + key;
  var timer = setTimeout(function() {
    cleanup();
    if (opt_errback) {
      opt_errback();
    }
  }, 1e4);
  window[key] = function(data2) {
    clearTimeout(timer);
    cleanup();
    callback(data2);
  };
  document.getElementsByTagName("head")[0].appendChild(script);
}
(function(_super) {
  __extends$H(ResponseError, _super);
  function ResponseError(response) {
    var _this = this;
    var message = "Unexpected response status: " + response.status;
    _this = _super.call(this, message) || this;
    _this.name = "ResponseError";
    _this.response = response;
    return _this;
  }
  return ResponseError;
})(Error);
(function(_super) {
  __extends$H(ClientError, _super);
  function ClientError(client) {
    var _this = _super.call(this, "Failed to issue request") || this;
    _this.name = "ClientError";
    _this.client = client;
    return _this;
  }
  return ClientError;
})(Error);
var __extends$G = globalThis && globalThis.__extends || function() {
  var extendStatics2 = function(d2, b2) {
    extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {
      d3.__proto__ = b3;
    } || function(d3, b3) {
      for (var p5 in b3)
        if (Object.prototype.hasOwnProperty.call(b3, p5))
          d3[p5] = b3[p5];
    };
    return extendStatics2(d2, b2);
  };
  return function(d2, b2) {
    if (typeof b2 !== "function" && b2 !== null)
      throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
    extendStatics2(d2, b2);
    function __() {
      this.constructor = d2;
    }
    d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
  };
}();
function quadKey(tileCoord) {
  var z2 = tileCoord[0];
  var digits = new Array(z2);
  var mask = 1 << z2 - 1;
  var i2, charCode;
  for (i2 = 0; i2 < z2; ++i2) {
    charCode = 48;
    if (tileCoord[1] & mask) {
      charCode += 1;
    }
    if (tileCoord[2] & mask) {
      charCode += 2;
    }
    digits[i2] = String.fromCharCode(charCode);
    mask >>= 1;
  }
  return digits.join("");
}
var TOS_ATTRIBUTION = '<a class="ol-attribution-bing-tos" href="https://www.microsoft.com/maps/product/terms.html" target="_blank">Terms of Use</a>';
var BingMaps = function(_super) {
  __extends$G(BingMaps2, _super);
  function BingMaps2(options) {
    var _this = this;
    var hidpi = options.hidpi !== void 0 ? options.hidpi : false;
    var interpolate = options.imageSmoothing !== void 0 ? options.imageSmoothing : true;
    if (options.interpolate !== void 0) {
      interpolate = options.interpolate;
    }
    _this = _super.call(this, {
      cacheSize: options.cacheSize,
      crossOrigin: "anonymous",
      interpolate,
      opaque: true,
      projection: get$3("EPSG:3857"),
      reprojectionErrorThreshold: options.reprojectionErrorThreshold,
      state: SourceState.LOADING,
      tileLoadFunction: options.tileLoadFunction,
      tilePixelRatio: hidpi ? 2 : 1,
      wrapX: options.wrapX !== void 0 ? options.wrapX : true,
      transition: options.transition,
      zDirection: options.zDirection
    }) || this;
    _this.hidpi_ = hidpi;
    _this.culture_ = options.culture !== void 0 ? options.culture : "en-us";
    _this.maxZoom_ = options.maxZoom !== void 0 ? options.maxZoom : -1;
    _this.apiKey_ = options.key;
    _this.imagerySet_ = options.imagerySet;
    var url = "https://dev.virtualearth.net/REST/v1/Imagery/Metadata/" + _this.imagerySet_ + "?uriScheme=https&include=ImageryProviders&key=" + _this.apiKey_ + "&c=" + _this.culture_;
    jsonp(url, _this.handleImageryMetadataResponse.bind(_this), void 0, "jsonp");
    return _this;
  }
  BingMaps2.prototype.getApiKey = function() {
    return this.apiKey_;
  };
  BingMaps2.prototype.getImagerySet = function() {
    return this.imagerySet_;
  };
  BingMaps2.prototype.handleImageryMetadataResponse = function(response) {
    if (response.statusCode != 200 || response.statusDescription != "OK" || response.authenticationResultCode != "ValidCredentials" || response.resourceSets.length != 1 || response.resourceSets[0].resources.length != 1) {
      this.setState(SourceState.ERROR);
      return;
    }
    var resource = response.resourceSets[0].resources[0];
    var maxZoom = this.maxZoom_ == -1 ? resource.zoomMax : this.maxZoom_;
    var sourceProjection = this.getProjection();
    var extent2 = extentFromProjection(sourceProjection);
    var scale2 = this.hidpi_ ? 2 : 1;
    var tileSize = resource.imageWidth == resource.imageHeight ? resource.imageWidth / scale2 : [resource.imageWidth / scale2, resource.imageHeight / scale2];
    var tileGrid = createXYZ({
      extent: extent2,
      minZoom: resource.zoomMin,
      maxZoom,
      tileSize
    });
    this.tileGrid = tileGrid;
    var culture = this.culture_;
    var hidpi = this.hidpi_;
    this.tileUrlFunction = createFromTileUrlFunctions(resource.imageUrlSubdomains.map(function(subdomain) {
      var quadKeyTileCoord = [0, 0, 0];
      var imageUrl = resource.imageUrl.replace("{subdomain}", subdomain).replace("{culture}", culture);
      return function(tileCoord, pixelRatio, projection) {
        if (!tileCoord) {
          return void 0;
        } else {
          createOrUpdate(tileCoord[0], tileCoord[1], tileCoord[2], quadKeyTileCoord);
          var url = imageUrl;
          if (hidpi) {
            url += "&dpi=d1&device=mobile";
          }
          return url.replace("{quadkey}", quadKey(quadKeyTileCoord));
        }
      };
    }));
    if (resource.imageryProviders) {
      var transform_1 = getTransformFromProjections(get$3("EPSG:4326"), this.getProjection());
      this.setAttributions(function(frameState) {
        var attributions = [];
        var viewState = frameState.viewState;
        var tileGrid2 = this.getTileGrid();
        var z2 = tileGrid2.getZForResolution(viewState.resolution, this.zDirection);
        var tileCoord = tileGrid2.getTileCoordForCoordAndZ(viewState.center, z2);
        var zoom = tileCoord[0];
        resource.imageryProviders.map(function(imageryProvider) {
          var intersecting = false;
          var coverageAreas = imageryProvider.coverageAreas;
          for (var i2 = 0, ii = coverageAreas.length; i2 < ii; ++i2) {
            var coverageArea = coverageAreas[i2];
            if (zoom >= coverageArea.zoomMin && zoom <= coverageArea.zoomMax) {
              var bbox2 = coverageArea.bbox;
              var epsg4326Extent = [bbox2[1], bbox2[0], bbox2[3], bbox2[2]];
              var extent_1 = applyTransform(epsg4326Extent, transform_1);
              if (intersects$1(extent_1, frameState.extent)) {
                intersecting = true;
                break;
              }
            }
          }
          if (intersecting) {
            attributions.push(imageryProvider.attribution);
          }
        });
        attributions.push(TOS_ATTRIBUTION);
        return attributions;
      }.bind(this));
    }
    this.setState(SourceState.READY);
  };
  return BingMaps2;
}(TileImage$1);
var BingMaps$1 = BingMaps;
var __extends$F = globalThis && globalThis.__extends || function() {
  var extendStatics2 = function(d2, b2) {
    extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {
      d3.__proto__ = b3;
    } || function(d3, b3) {
      for (var p5 in b3)
        if (Object.prototype.hasOwnProperty.call(b3, p5))
          d3[p5] = b3[p5];
    };
    return extendStatics2(d2, b2);
  };
  return function(d2, b2) {
    if (typeof b2 !== "function" && b2 !== null)
      throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
    extendStatics2(d2, b2);
    function __() {
      this.constructor = d2;
    }
    d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
  };
}();
var XYZ = function(_super) {
  __extends$F(XYZ2, _super);
  function XYZ2(opt_options) {
    var options = opt_options || {};
    var interpolate = options.imageSmoothing !== void 0 ? options.imageSmoothing : true;
    if (options.interpolate !== void 0) {
      interpolate = options.interpolate;
    }
    var projection = options.projection !== void 0 ? options.projection : "EPSG:3857";
    var tileGrid = options.tileGrid !== void 0 ? options.tileGrid : createXYZ({
      extent: extentFromProjection(projection),
      maxResolution: options.maxResolution,
      maxZoom: options.maxZoom,
      minZoom: options.minZoom,
      tileSize: options.tileSize
    });
    return _super.call(this, {
      attributions: options.attributions,
      cacheSize: options.cacheSize,
      crossOrigin: options.crossOrigin,
      interpolate,
      opaque: options.opaque,
      projection,
      reprojectionErrorThreshold: options.reprojectionErrorThreshold,
      tileGrid,
      tileLoadFunction: options.tileLoadFunction,
      tilePixelRatio: options.tilePixelRatio,
      tileUrlFunction: options.tileUrlFunction,
      url: options.url,
      urls: options.urls,
      wrapX: options.wrapX !== void 0 ? options.wrapX : true,
      transition: options.transition,
      attributionsCollapsible: options.attributionsCollapsible,
      zDirection: options.zDirection
    }) || this;
  }
  return XYZ2;
}(TileImage$1);
var XYZ$1 = XYZ;
var __extends$E = globalThis && globalThis.__extends || function() {
  var extendStatics2 = function(d2, b2) {
    extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {
      d3.__proto__ = b3;
    } || function(d3, b3) {
      for (var p5 in b3)
        if (Object.prototype.hasOwnProperty.call(b3, p5))
          d3[p5] = b3[p5];
    };
    return extendStatics2(d2, b2);
  };
  return function(d2, b2) {
    if (typeof b2 !== "function" && b2 !== null)
      throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
    extendStatics2(d2, b2);
    function __() {
      this.constructor = d2;
    }
    d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
  };
}();
var Cluster = function(_super) {
  __extends$E(Cluster2, _super);
  function Cluster2(options) {
    var _this = _super.call(this, {
      attributions: options.attributions,
      wrapX: options.wrapX
    }) || this;
    _this.resolution = void 0;
    _this.distance = options.distance !== void 0 ? options.distance : 20;
    _this.minDistance = options.minDistance || 0;
    _this.interpolationRatio = 0;
    _this.features = [];
    _this.geometryFunction = options.geometryFunction || function(feature2) {
      var geometry = feature2.getGeometry();
      assert(geometry.getType() == GeometryType.POINT, 10);
      return geometry;
    };
    _this.createCustomCluster_ = options.createCluster;
    _this.source = null;
    _this.boundRefresh_ = _this.refresh.bind(_this);
    _this.updateDistance(_this.distance, _this.minDistance);
    _this.setSource(options.source || null);
    return _this;
  }
  Cluster2.prototype.clear = function(opt_fast) {
    this.features.length = 0;
    _super.prototype.clear.call(this, opt_fast);
  };
  Cluster2.prototype.getDistance = function() {
    return this.distance;
  };
  Cluster2.prototype.getSource = function() {
    return this.source;
  };
  Cluster2.prototype.loadFeatures = function(extent2, resolution, projection) {
    this.source.loadFeatures(extent2, resolution, projection);
    if (resolution !== this.resolution) {
      this.resolution = resolution;
      this.refresh();
    }
  };
  Cluster2.prototype.setDistance = function(distance2) {
    this.updateDistance(distance2, this.minDistance);
  };
  Cluster2.prototype.setMinDistance = function(minDistance) {
    this.updateDistance(this.distance, minDistance);
  };
  Cluster2.prototype.getMinDistance = function() {
    return this.minDistance;
  };
  Cluster2.prototype.setSource = function(source) {
    if (this.source) {
      this.source.removeEventListener(EventType.CHANGE, this.boundRefresh_);
    }
    this.source = source;
    if (source) {
      source.addEventListener(EventType.CHANGE, this.boundRefresh_);
    }
    this.refresh();
  };
  Cluster2.prototype.refresh = function() {
    this.clear();
    this.cluster();
    this.addFeatures(this.features);
  };
  Cluster2.prototype.updateDistance = function(distance2, minDistance) {
    var ratio = distance2 === 0 ? 0 : Math.min(minDistance, distance2) / distance2;
    var changed = distance2 !== this.distance || this.interpolationRatio !== ratio;
    this.distance = distance2;
    this.minDistance = minDistance;
    this.interpolationRatio = ratio;
    if (changed) {
      this.refresh();
    }
  };
  Cluster2.prototype.cluster = function() {
    if (this.resolution === void 0 || !this.source) {
      return;
    }
    var extent2 = createEmpty();
    var mapDistance = this.distance * this.resolution;
    var features = this.source.getFeatures();
    var clustered = {};
    for (var i2 = 0, ii = features.length; i2 < ii; i2++) {
      var feature2 = features[i2];
      if (!(getUid(feature2) in clustered)) {
        var geometry = this.geometryFunction(feature2);
        if (geometry) {
          var coordinates2 = geometry.getCoordinates();
          createOrUpdateFromCoordinate(coordinates2, extent2);
          buffer$1(extent2, mapDistance, extent2);
          var neighbors = this.source.getFeaturesInExtent(extent2).filter(function(neighbor) {
            var uid2 = getUid(neighbor);
            if (uid2 in clustered) {
              return false;
            }
            clustered[uid2] = true;
            return true;
          });
          this.features.push(this.createCluster(neighbors, extent2));
        }
      }
    }
  };
  Cluster2.prototype.createCluster = function(features, extent2) {
    var centroid2 = [0, 0];
    for (var i2 = features.length - 1; i2 >= 0; --i2) {
      var geometry_1 = this.geometryFunction(features[i2]);
      if (geometry_1) {
        add$3(centroid2, geometry_1.getCoordinates());
      } else {
        features.splice(i2, 1);
      }
    }
    scale$2(centroid2, 1 / features.length);
    var searchCenter = getCenter(extent2);
    var ratio = this.interpolationRatio;
    var geometry = new Point$4([
      centroid2[0] * (1 - ratio) + searchCenter[0] * ratio,
      centroid2[1] * (1 - ratio) + searchCenter[1] * ratio
    ]);
    if (this.createCustomCluster_) {
      return this.createCustomCluster_(geometry, features);
    } else {
      return new feature({
        geometry,
        features
      });
    }
  };
  return Cluster2;
}(ol_source_Vector);
var Cluster$1 = Cluster;
var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
function getAugmentedNamespace(n2) {
  if (n2.__esModule)
    return n2;
  var a2 = Object.defineProperty({}, "__esModule", { value: true });
  Object.keys(n2).forEach(function(k2) {
    var d2 = Object.getOwnPropertyDescriptor(n2, k2);
    Object.defineProperty(a2, k2, d2.get ? d2 : {
      enumerable: true,
      get: function() {
        return n2[k2];
      }
    });
  });
  return a2;
}
var __spreadArray$1 = globalThis && globalThis.__spreadArray || function(to, from, pack2) {
  if (pack2 || arguments.length === 2)
    for (var i2 = 0, l2 = from.length, ar; i2 < l2; i2++) {
      if (ar || !(i2 in from)) {
        if (!ar)
          ar = Array.prototype.slice.call(from, 0, i2);
        ar[i2] = from[i2];
      }
    }
  return to.concat(ar || Array.prototype.slice.call(from));
};
var Versions = {
  VERSION1: "version1",
  VERSION2: "version2",
  VERSION3: "version3"
};
var IIIF_PROFILE_VALUES = {};
IIIF_PROFILE_VALUES[Versions.VERSION1] = {
  "level0": {
    supports: [],
    formats: [],
    qualities: ["native"]
  },
  "level1": {
    supports: ["regionByPx", "sizeByW", "sizeByH", "sizeByPct"],
    formats: ["jpg"],
    qualities: ["native"]
  },
  "level2": {
    supports: [
      "regionByPx",
      "regionByPct",
      "sizeByW",
      "sizeByH",
      "sizeByPct",
      "sizeByConfinedWh",
      "sizeByWh"
    ],
    formats: ["jpg", "png"],
    qualities: ["native", "color", "grey", "bitonal"]
  }
};
IIIF_PROFILE_VALUES[Versions.VERSION2] = {
  "level0": {
    supports: [],
    formats: ["jpg"],
    qualities: ["default"]
  },
  "level1": {
    supports: ["regionByPx", "sizeByW", "sizeByH", "sizeByPct"],
    formats: ["jpg"],
    qualities: ["default"]
  },
  "level2": {
    supports: [
      "regionByPx",
      "regionByPct",
      "sizeByW",
      "sizeByH",
      "sizeByPct",
      "sizeByConfinedWh",
      "sizeByDistortedWh",
      "sizeByWh"
    ],
    formats: ["jpg", "png"],
    qualities: ["default", "bitonal"]
  }
};
IIIF_PROFILE_VALUES[Versions.VERSION3] = {
  "level0": {
    supports: [],
    formats: ["jpg"],
    qualities: ["default"]
  },
  "level1": {
    supports: ["regionByPx", "regionSquare", "sizeByW", "sizeByH", "sizeByWh"],
    formats: ["jpg"],
    qualities: ["default"]
  },
  "level2": {
    supports: [
      "regionByPx",
      "regionSquare",
      "regionByPct",
      "sizeByW",
      "sizeByH",
      "sizeByPct",
      "sizeByConfinedWh",
      "sizeByWh"
    ],
    formats: ["jpg", "png"],
    qualities: ["default"]
  }
};
IIIF_PROFILE_VALUES["none"] = {
  "none": {
    supports: [],
    formats: [],
    qualities: []
  }
};
var COMPLIANCE_VERSION1 = /^https?:\/\/library\.stanford\.edu\/iiif\/image-api\/(?:1\.1\/)?compliance\.html#level[0-2]$/;
var COMPLIANCE_VERSION2 = /^https?:\/\/iiif\.io\/api\/image\/2\/level[0-2](?:\.json)?$/;
var COMPLIANCE_VERSION3 = /(^https?:\/\/iiif\.io\/api\/image\/3\/level[0-2](?:\.json)?$)|(^level[0-2]$)/;
function generateVersion1Options(iiifInfo) {
  var levelProfile = iiifInfo.getComplianceLevelSupportedFeatures();
  if (levelProfile === void 0) {
    levelProfile = IIIF_PROFILE_VALUES[Versions.VERSION1]["level0"];
  }
  return {
    url: iiifInfo.imageInfo["@id"] === void 0 ? void 0 : iiifInfo.imageInfo["@id"].replace(/\/?(?:info\.json)?$/g, ""),
    supports: levelProfile.supports,
    formats: __spreadArray$1(__spreadArray$1([], levelProfile.formats, true), [
      iiifInfo.imageInfo.formats === void 0 ? [] : iiifInfo.imageInfo.formats
    ], false),
    qualities: __spreadArray$1(__spreadArray$1([], levelProfile.qualities, true), [
      iiifInfo.imageInfo.qualities === void 0 ? [] : iiifInfo.imageInfo.qualities
    ], false),
    resolutions: iiifInfo.imageInfo.scale_factors,
    tileSize: iiifInfo.imageInfo.tile_width !== void 0 ? iiifInfo.imageInfo.tile_height !== void 0 ? [iiifInfo.imageInfo.tile_width, iiifInfo.imageInfo.tile_height] : [iiifInfo.imageInfo.tile_width, iiifInfo.imageInfo.tile_width] : iiifInfo.imageInfo.tile_height != void 0 ? [iiifInfo.imageInfo.tile_height, iiifInfo.imageInfo.tile_height] : void 0
  };
}
function generateVersion2Options(iiifInfo) {
  var levelProfile = iiifInfo.getComplianceLevelSupportedFeatures(), additionalProfile = Array.isArray(iiifInfo.imageInfo.profile) && iiifInfo.imageInfo.profile.length > 1, profileSupports = additionalProfile && iiifInfo.imageInfo.profile[1].supports ? iiifInfo.imageInfo.profile[1].supports : [], profileFormats = additionalProfile && iiifInfo.imageInfo.profile[1].formats ? iiifInfo.imageInfo.profile[1].formats : [], profileQualities = additionalProfile && iiifInfo.imageInfo.profile[1].qualities ? iiifInfo.imageInfo.profile[1].qualities : [];
  return {
    url: iiifInfo.imageInfo["@id"].replace(/\/?(?:info\.json)?$/g, ""),
    sizes: iiifInfo.imageInfo.sizes === void 0 ? void 0 : iiifInfo.imageInfo.sizes.map(function(size) {
      return [size.width, size.height];
    }),
    tileSize: iiifInfo.imageInfo.tiles === void 0 ? void 0 : [
      iiifInfo.imageInfo.tiles.map(function(tile2) {
        return tile2.width;
      })[0],
      iiifInfo.imageInfo.tiles.map(function(tile2) {
        return tile2.height === void 0 ? tile2.width : tile2.height;
      })[0]
    ],
    resolutions: iiifInfo.imageInfo.tiles === void 0 ? void 0 : iiifInfo.imageInfo.tiles.map(function(tile2) {
      return tile2.scaleFactors;
    })[0],
    supports: __spreadArray$1(__spreadArray$1([], levelProfile.supports, true), profileSupports, true),
    formats: __spreadArray$1(__spreadArray$1([], levelProfile.formats, true), profileFormats, true),
    qualities: __spreadArray$1(__spreadArray$1([], levelProfile.qualities, true), profileQualities, true)
  };
}
function generateVersion3Options(iiifInfo) {
  var levelProfile = iiifInfo.getComplianceLevelSupportedFeatures(), formats = iiifInfo.imageInfo.extraFormats === void 0 ? levelProfile.formats : __spreadArray$1(__spreadArray$1([], levelProfile.formats, true), iiifInfo.imageInfo.extraFormats, true), preferredFormat = iiifInfo.imageInfo.preferredFormats !== void 0 && Array.isArray(iiifInfo.imageInfo.preferredFormats) && iiifInfo.imageInfo.preferredFormats.length > 0 ? iiifInfo.imageInfo.preferredFormats.filter(function(format2) {
    return includes(["jpg", "png", "gif"], format2);
  }).reduce(function(acc, format2) {
    return acc === void 0 && includes(formats, format2) ? format2 : acc;
  }, void 0) : void 0;
  return {
    url: iiifInfo.imageInfo["id"],
    sizes: iiifInfo.imageInfo.sizes === void 0 ? void 0 : iiifInfo.imageInfo.sizes.map(function(size) {
      return [size.width, size.height];
    }),
    tileSize: iiifInfo.imageInfo.tiles === void 0 ? void 0 : [
      iiifInfo.imageInfo.tiles.map(function(tile2) {
        return tile2.width;
      })[0],
      iiifInfo.imageInfo.tiles.map(function(tile2) {
        return tile2.height;
      })[0]
    ],
    resolutions: iiifInfo.imageInfo.tiles === void 0 ? void 0 : iiifInfo.imageInfo.tiles.map(function(tile2) {
      return tile2.scaleFactors;
    })[0],
    supports: iiifInfo.imageInfo.extraFeatures === void 0 ? levelProfile.supports : __spreadArray$1(__spreadArray$1([], levelProfile.supports, true), iiifInfo.imageInfo.extraFeatures, true),
    formats,
    qualities: iiifInfo.imageInfo.extraQualities === void 0 ? levelProfile.qualities : __spreadArray$1(__spreadArray$1([], levelProfile.qualities, true), iiifInfo.imageInfo.extraQualities, true),
    preferredFormat
  };
}
var versionFunctions = {};
versionFunctions[Versions.VERSION1] = generateVersion1Options;
versionFunctions[Versions.VERSION2] = generateVersion2Options;
versionFunctions[Versions.VERSION3] = generateVersion3Options;
var IIIFInfo = function() {
  function IIIFInfo2(imageInfo) {
    this.setImageInfo(imageInfo);
  }
  IIIFInfo2.prototype.setImageInfo = function(imageInfo) {
    if (typeof imageInfo == "string") {
      this.imageInfo = JSON.parse(imageInfo);
    } else {
      this.imageInfo = imageInfo;
    }
  };
  IIIFInfo2.prototype.getImageApiVersion = function() {
    if (this.imageInfo === void 0) {
      return;
    }
    var context = this.imageInfo["@context"] || "ol-no-context";
    if (typeof context == "string") {
      context = [context];
    }
    for (var i2 = 0; i2 < context.length; i2++) {
      switch (context[i2]) {
        case "http://library.stanford.edu/iiif/image-api/1.1/context.json":
        case "http://iiif.io/api/image/1/context.json":
          return Versions.VERSION1;
        case "http://iiif.io/api/image/2/context.json":
          return Versions.VERSION2;
        case "http://iiif.io/api/image/3/context.json":
          return Versions.VERSION3;
        case "ol-no-context":
          if (this.getComplianceLevelEntryFromProfile(Versions.VERSION1) && this.imageInfo.identifier) {
            return Versions.VERSION1;
          }
          break;
      }
    }
    assert(false, 61);
  };
  IIIFInfo2.prototype.getComplianceLevelEntryFromProfile = function(version2) {
    if (this.imageInfo === void 0 || this.imageInfo.profile === void 0) {
      return;
    }
    if (version2 === void 0) {
      version2 = this.getImageApiVersion();
    }
    switch (version2) {
      case Versions.VERSION1:
        if (COMPLIANCE_VERSION1.test(this.imageInfo.profile)) {
          return this.imageInfo.profile;
        }
        break;
      case Versions.VERSION3:
        if (COMPLIANCE_VERSION3.test(this.imageInfo.profile)) {
          return this.imageInfo.profile;
        }
        break;
      case Versions.VERSION2:
        if (typeof this.imageInfo.profile === "string" && COMPLIANCE_VERSION2.test(this.imageInfo.profile)) {
          return this.imageInfo.profile;
        }
        if (Array.isArray(this.imageInfo.profile) && this.imageInfo.profile.length > 0 && typeof this.imageInfo.profile[0] === "string" && COMPLIANCE_VERSION2.test(this.imageInfo.profile[0])) {
          return this.imageInfo.profile[0];
        }
        break;
    }
  };
  IIIFInfo2.prototype.getComplianceLevelFromProfile = function(version2) {
    var complianceLevel = this.getComplianceLevelEntryFromProfile(version2);
    if (complianceLevel === void 0) {
      return void 0;
    }
    var level = complianceLevel.match(/level[0-2](?:\.json)?$/g);
    return Array.isArray(level) ? level[0].replace(".json", "") : void 0;
  };
  IIIFInfo2.prototype.getComplianceLevelSupportedFeatures = function() {
    if (this.imageInfo === void 0) {
      return;
    }
    var version2 = this.getImageApiVersion();
    var level = this.getComplianceLevelFromProfile(version2);
    if (level === void 0) {
      return IIIF_PROFILE_VALUES["none"]["none"];
    }
    return IIIF_PROFILE_VALUES[version2][level];
  };
  IIIFInfo2.prototype.getTileSourceOptions = function(opt_preferredOptions) {
    var options = opt_preferredOptions || {}, version2 = this.getImageApiVersion();
    if (version2 === void 0) {
      return;
    }
    var imageOptions = version2 === void 0 ? void 0 : versionFunctions[version2](this);
    if (imageOptions === void 0) {
      return;
    }
    return {
      url: imageOptions.url,
      version: version2,
      size: [this.imageInfo.width, this.imageInfo.height],
      sizes: imageOptions.sizes,
      format: options.format !== void 0 && includes(imageOptions.formats, options.format) ? options.format : imageOptions.preferredFormat !== void 0 ? imageOptions.preferredFormat : "jpg",
      supports: imageOptions.supports,
      quality: options.quality && includes(imageOptions.qualities, options.quality) ? options.quality : includes(imageOptions.qualities, "native") ? "native" : "default",
      resolutions: Array.isArray(imageOptions.resolutions) ? imageOptions.resolutions.sort(function(a2, b2) {
        return b2 - a2;
      }) : void 0,
      tileSize: imageOptions.tileSize
    };
  };
  return IIIFInfo2;
}();
var IIIFInfo$1 = IIIFInfo;
var __extends$D = globalThis && globalThis.__extends || function() {
  var extendStatics2 = function(d2, b2) {
    extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {
      d3.__proto__ = b3;
    } || function(d3, b3) {
      for (var p5 in b3)
        if (Object.prototype.hasOwnProperty.call(b3, p5))
          d3[p5] = b3[p5];
    };
    return extendStatics2(d2, b2);
  };
  return function(d2, b2) {
    if (typeof b2 !== "function" && b2 !== null)
      throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
    extendStatics2(d2, b2);
    function __() {
      this.constructor = d2;
    }
    d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
  };
}();
var ReprojImage = function(_super) {
  __extends$D(ReprojImage2, _super);
  function ReprojImage2(sourceProj, targetProj, targetExtent, targetResolution, pixelRatio, getImageFunction, interpolate) {
    var _this = this;
    var maxSourceExtent = sourceProj.getExtent();
    var maxTargetExtent = targetProj.getExtent();
    var limitedTargetExtent = maxTargetExtent ? getIntersection(targetExtent, maxTargetExtent) : targetExtent;
    var targetCenter = getCenter(limitedTargetExtent);
    var sourceResolution = calculateSourceResolution(sourceProj, targetProj, targetCenter, targetResolution);
    var errorThresholdInPixels = ERROR_THRESHOLD;
    var triangulation = new Triangulation$1(sourceProj, targetProj, limitedTargetExtent, maxSourceExtent, sourceResolution * errorThresholdInPixels, targetResolution);
    var sourceExtent = triangulation.calculateSourceExtent();
    var sourceImage = getImageFunction(sourceExtent, sourceResolution, pixelRatio);
    var state = sourceImage ? ImageState.IDLE : ImageState.EMPTY;
    var sourcePixelRatio = sourceImage ? sourceImage.getPixelRatio() : 1;
    _this = _super.call(this, targetExtent, targetResolution, sourcePixelRatio, state) || this;
    _this.targetProj_ = targetProj;
    _this.maxSourceExtent_ = maxSourceExtent;
    _this.triangulation_ = triangulation;
    _this.targetResolution_ = targetResolution;
    _this.targetExtent_ = targetExtent;
    _this.sourceImage_ = sourceImage;
    _this.sourcePixelRatio_ = sourcePixelRatio;
    _this.interpolate_ = interpolate;
    _this.canvas_ = null;
    _this.sourceListenerKey_ = null;
    return _this;
  }
  ReprojImage2.prototype.disposeInternal = function() {
    if (this.state == ImageState.LOADING) {
      this.unlistenSource_();
    }
    _super.prototype.disposeInternal.call(this);
  };
  ReprojImage2.prototype.getImage = function() {
    return this.canvas_;
  };
  ReprojImage2.prototype.getProjection = function() {
    return this.targetProj_;
  };
  ReprojImage2.prototype.reproject_ = function() {
    var sourceState = this.sourceImage_.getState();
    if (sourceState == ImageState.LOADED) {
      var width = getWidth(this.targetExtent_) / this.targetResolution_;
      var height = getHeight(this.targetExtent_) / this.targetResolution_;
      this.canvas_ = render(width, height, this.sourcePixelRatio_, this.sourceImage_.getResolution(), this.maxSourceExtent_, this.targetResolution_, this.targetExtent_, this.triangulation_, [
        {
          extent: this.sourceImage_.getExtent(),
          image: this.sourceImage_.getImage()
        }
      ], 0, void 0, this.interpolate_);
    }
    this.state = sourceState;
    this.changed();
  };
  ReprojImage2.prototype.load = function() {
    if (this.state == ImageState.IDLE) {
      this.state = ImageState.LOADING;
      this.changed();
      var sourceState = this.sourceImage_.getState();
      if (sourceState == ImageState.LOADED || sourceState == ImageState.ERROR) {
        this.reproject_();
      } else {
        this.sourceListenerKey_ = listen(this.sourceImage_, EventType.CHANGE, function(e2) {
          var sourceState2 = this.sourceImage_.getState();
          if (sourceState2 == ImageState.LOADED || sourceState2 == ImageState.ERROR) {
            this.unlistenSource_();
            this.reproject_();
          }
        }, this);
        this.sourceImage_.load();
      }
    }
  };
  ReprojImage2.prototype.unlistenSource_ = function() {
    unlistenByKey(this.sourceListenerKey_);
    this.sourceListenerKey_ = null;
  };
  return ReprojImage2;
}(ImageBase$1);
var ReprojImage$1 = ReprojImage;
var __extends$C = globalThis && globalThis.__extends || function() {
  var extendStatics2 = function(d2, b2) {
    extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {
      d3.__proto__ = b3;
    } || function(d3, b3) {
      for (var p5 in b3)
        if (Object.prototype.hasOwnProperty.call(b3, p5))
          d3[p5] = b3[p5];
    };
    return extendStatics2(d2, b2);
  };
  return function(d2, b2) {
    if (typeof b2 !== "function" && b2 !== null)
      throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
    extendStatics2(d2, b2);
    function __() {
      this.constructor = d2;
    }
    d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
  };
}();
var ImageSourceEventType = {
  IMAGELOADSTART: "imageloadstart",
  IMAGELOADEND: "imageloadend",
  IMAGELOADERROR: "imageloaderror"
};
var ImageSourceEvent = function(_super) {
  __extends$C(ImageSourceEvent2, _super);
  function ImageSourceEvent2(type, image2) {
    var _this = _super.call(this, type) || this;
    _this.image = image2;
    return _this;
  }
  return ImageSourceEvent2;
}(Event$1);
var ImageSource = function(_super) {
  __extends$C(ImageSource2, _super);
  function ImageSource2(options) {
    var _this = this;
    var interpolate = options.imageSmoothing !== void 0 ? options.imageSmoothing : true;
    if (options.interpolate !== void 0) {
      interpolate = options.interpolate;
    }
    _this = _super.call(this, {
      attributions: options.attributions,
      projection: options.projection,
      state: options.state,
      interpolate
    }) || this;
    _this.on;
    _this.once;
    _this.un;
    _this.resolutions_ = options.resolutions !== void 0 ? options.resolutions : null;
    _this.reprojectedImage_ = null;
    _this.reprojectedRevision_ = 0;
    return _this;
  }
  ImageSource2.prototype.getResolutions = function() {
    return this.resolutions_;
  };
  ImageSource2.prototype.findNearestResolution = function(resolution) {
    if (this.resolutions_) {
      var idx = linearFindNearest(this.resolutions_, resolution, 0);
      resolution = this.resolutions_[idx];
    }
    return resolution;
  };
  ImageSource2.prototype.getImage = function(extent2, resolution, pixelRatio, projection) {
    var sourceProjection = this.getProjection();
    if (!sourceProjection || !projection || equivalent(sourceProjection, projection)) {
      if (sourceProjection) {
        projection = sourceProjection;
      }
      return this.getImageInternal(extent2, resolution, pixelRatio, projection);
    } else {
      if (this.reprojectedImage_) {
        if (this.reprojectedRevision_ == this.getRevision() && equivalent(this.reprojectedImage_.getProjection(), projection) && this.reprojectedImage_.getResolution() == resolution && equals$1(this.reprojectedImage_.getExtent(), extent2)) {
          return this.reprojectedImage_;
        }
        this.reprojectedImage_.dispose();
        this.reprojectedImage_ = null;
      }
      this.reprojectedImage_ = new ReprojImage$1(sourceProjection, projection, extent2, resolution, pixelRatio, function(extent3, resolution2, pixelRatio2) {
        return this.getImageInternal(extent3, resolution2, pixelRatio2, sourceProjection);
      }.bind(this), this.getInterpolate());
      this.reprojectedRevision_ = this.getRevision();
      return this.reprojectedImage_;
    }
  };
  ImageSource2.prototype.getImageInternal = function(extent2, resolution, pixelRatio, projection) {
    return abstract();
  };
  ImageSource2.prototype.handleImageChange = function(event) {
    var image2 = event.target;
    var type;
    switch (image2.getState()) {
      case ImageState.LOADING:
        this.loading = true;
        type = ImageSourceEventType.IMAGELOADSTART;
        break;
      case ImageState.LOADED:
        this.loading = false;
        type = ImageSourceEventType.IMAGELOADEND;
        break;
      case ImageState.ERROR:
        this.loading = false;
        type = ImageSourceEventType.IMAGELOADERROR;
        break;
      default:
        return;
    }
    if (this.hasListener(type)) {
      this.dispatchEvent(new ImageSourceEvent(type, image2));
    }
  };
  return ImageSource2;
}(ol_source_Source);
function defaultImageLoadFunction(image2, src) {
  image2.getImage().src = src;
}
var ImageSource$1 = ImageSource;
function appendParams(uri, params2) {
  var keyParams = [];
  Object.keys(params2).forEach(function(k2) {
    if (params2[k2] !== null && params2[k2] !== void 0) {
      keyParams.push(k2 + "=" + encodeURIComponent(params2[k2]));
    }
  });
  var qs = keyParams.join("&");
  uri = uri.replace(/[?&]$/, "");
  uri = uri.indexOf("?") === -1 ? uri + "?" : uri + "&";
  return uri + qs;
}
var __extends$B = globalThis && globalThis.__extends || function() {
  var extendStatics2 = function(d2, b2) {
    extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {
      d3.__proto__ = b3;
    } || function(d3, b3) {
      for (var p5 in b3)
        if (Object.prototype.hasOwnProperty.call(b3, p5))
          d3[p5] = b3[p5];
    };
    return extendStatics2(d2, b2);
  };
  return function(d2, b2) {
    if (typeof b2 !== "function" && b2 !== null)
      throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
    extendStatics2(d2, b2);
    function __() {
      this.constructor = d2;
    }
    d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
  };
}();
var Static = function(_super) {
  __extends$B(Static2, _super);
  function Static2(options) {
    var _this = this;
    var crossOrigin = options.crossOrigin !== void 0 ? options.crossOrigin : null;
    var imageLoadFunction = options.imageLoadFunction !== void 0 ? options.imageLoadFunction : defaultImageLoadFunction;
    var interpolate = options.imageSmoothing !== void 0 ? options.imageSmoothing : true;
    if (options.interpolate !== void 0) {
      interpolate = options.interpolate;
    }
    _this = _super.call(this, {
      attributions: options.attributions,
      interpolate,
      projection: get$3(options.projection)
    }) || this;
    _this.url_ = options.url;
    _this.imageExtent_ = options.imageExtent;
    _this.image_ = new ImageWrapper$1(_this.imageExtent_, void 0, 1, _this.url_, crossOrigin, imageLoadFunction);
    _this.imageSize_ = options.imageSize ? options.imageSize : null;
    _this.image_.addEventListener(EventType.CHANGE, _this.handleImageChange.bind(_this));
    return _this;
  }
  Static2.prototype.getImageExtent = function() {
    return this.imageExtent_;
  };
  Static2.prototype.getImageInternal = function(extent2, resolution, pixelRatio, projection) {
    if (intersects$1(extent2, this.image_.getExtent())) {
      return this.image_;
    }
    return null;
  };
  Static2.prototype.getUrl = function() {
    return this.url_;
  };
  Static2.prototype.handleImageChange = function(evt) {
    if (this.image_.getState() == ImageState.LOADED) {
      var imageExtent = this.image_.getExtent();
      var image2 = this.image_.getImage();
      var imageWidth = void 0, imageHeight = void 0;
      if (this.imageSize_) {
        imageWidth = this.imageSize_[0];
        imageHeight = this.imageSize_[1];
      } else {
        imageWidth = image2.width;
        imageHeight = image2.height;
      }
      var extentWidth = getWidth(imageExtent);
      var extentHeight = getHeight(imageExtent);
      var xResolution = extentWidth / imageWidth;
      var yResolution = extentHeight / imageHeight;
      var targetWidth = imageWidth;
      var targetHeight = imageHeight;
      if (xResolution > yResolution) {
        targetWidth = Math.round(extentWidth / yResolution);
      } else {
        targetHeight = Math.round(extentHeight / xResolution);
      }
      if (targetWidth !== imageWidth || targetHeight !== imageHeight) {
        var context = createCanvasContext2D(targetWidth, targetHeight);
        if (!this.getInterpolate()) {
          assign(context, IMAGE_SMOOTHING_DISABLED);
        }
        var canvas = context.canvas;
        context.drawImage(image2, 0, 0, imageWidth, imageHeight, 0, 0, canvas.width, canvas.height);
        this.image_.setImage(canvas);
      }
    }
    _super.prototype.handleImageChange.call(this, evt);
  };
  return Static2;
}(ImageSource$1);
var Static$1 = Static;
var DEFAULT_WMS_VERSION = "1.3.0";
var WMSServerType = {
  CARMENTA_SERVER: "carmentaserver",
  GEOSERVER: "geoserver",
  MAPSERVER: "mapserver",
  QGIS: "qgis"
};
var __extends$A = globalThis && globalThis.__extends || function() {
  var extendStatics2 = function(d2, b2) {
    extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {
      d3.__proto__ = b3;
    } || function(d3, b3) {
      for (var p5 in b3)
        if (Object.prototype.hasOwnProperty.call(b3, p5))
          d3[p5] = b3[p5];
    };
    return extendStatics2(d2, b2);
  };
  return function(d2, b2) {
    if (typeof b2 !== "function" && b2 !== null)
      throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
    extendStatics2(d2, b2);
    function __() {
      this.constructor = d2;
    }
    d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
  };
}();
var DECIMALS = 4;
var GETFEATUREINFO_IMAGE_SIZE = [101, 101];
var ImageWMS = function(_super) {
  __extends$A(ImageWMS2, _super);
  function ImageWMS2(opt_options) {
    var _this = this;
    var options = opt_options ? opt_options : {};
    var interpolate = options.imageSmoothing !== void 0 ? options.imageSmoothing : true;
    if (options.interpolate !== void 0) {
      interpolate = options.interpolate;
    }
    _this = _super.call(this, {
      attributions: options.attributions,
      interpolate,
      projection: options.projection,
      resolutions: options.resolutions
    }) || this;
    _this.crossOrigin_ = options.crossOrigin !== void 0 ? options.crossOrigin : null;
    _this.url_ = options.url;
    _this.imageLoadFunction_ = options.imageLoadFunction !== void 0 ? options.imageLoadFunction : defaultImageLoadFunction;
    _this.params_ = options.params || {};
    _this.v13_ = true;
    _this.updateV13_();
    _this.serverType_ = options.serverType;
    _this.hidpi_ = options.hidpi !== void 0 ? options.hidpi : true;
    _this.image_ = null;
    _this.imageSize_ = [0, 0];
    _this.renderedRevision_ = 0;
    _this.ratio_ = options.ratio !== void 0 ? options.ratio : 1.5;
    return _this;
  }
  ImageWMS2.prototype.getFeatureInfoUrl = function(coordinate, resolution, projection, params2) {
    if (this.url_ === void 0) {
      return void 0;
    }
    var projectionObj = get$3(projection);
    var sourceProjectionObj = this.getProjection();
    if (sourceProjectionObj && sourceProjectionObj !== projectionObj) {
      resolution = calculateSourceResolution(sourceProjectionObj, projectionObj, coordinate, resolution);
      coordinate = transform$3(coordinate, projectionObj, sourceProjectionObj);
    }
    var extent2 = getForViewAndSize(coordinate, resolution, 0, GETFEATUREINFO_IMAGE_SIZE);
    var baseParams = {
      "SERVICE": "WMS",
      "VERSION": DEFAULT_WMS_VERSION,
      "REQUEST": "GetFeatureInfo",
      "FORMAT": "image/png",
      "TRANSPARENT": true,
      "QUERY_LAYERS": this.params_["LAYERS"]
    };
    assign(baseParams, this.params_, params2);
    var x2 = floor$2((coordinate[0] - extent2[0]) / resolution, DECIMALS);
    var y2 = floor$2((extent2[3] - coordinate[1]) / resolution, DECIMALS);
    baseParams[this.v13_ ? "I" : "X"] = x2;
    baseParams[this.v13_ ? "J" : "Y"] = y2;
    return this.getRequestUrl_(extent2, GETFEATUREINFO_IMAGE_SIZE, 1, sourceProjectionObj || projectionObj, baseParams);
  };
  ImageWMS2.prototype.getLegendUrl = function(resolution, params2) {
    if (this.url_ === void 0) {
      return void 0;
    }
    var baseParams = {
      "SERVICE": "WMS",
      "VERSION": DEFAULT_WMS_VERSION,
      "REQUEST": "GetLegendGraphic",
      "FORMAT": "image/png"
    };
    if (params2 === void 0 || params2["LAYER"] === void 0) {
      var layers = this.params_.LAYERS;
      var isSingleLayer = !Array.isArray(layers) || layers.length === 1;
      if (!isSingleLayer) {
        return void 0;
      }
      baseParams["LAYER"] = layers;
    }
    if (resolution !== void 0) {
      var mpu = this.getProjection() ? this.getProjection().getMetersPerUnit() : 1;
      var pixelSize = 28e-5;
      baseParams["SCALE"] = resolution * mpu / pixelSize;
    }
    assign(baseParams, params2);
    return appendParams(this.url_, baseParams);
  };
  ImageWMS2.prototype.getParams = function() {
    return this.params_;
  };
  ImageWMS2.prototype.getImageInternal = function(extent2, resolution, pixelRatio, projection) {
    if (this.url_ === void 0) {
      return null;
    }
    resolution = this.findNearestResolution(resolution);
    if (pixelRatio != 1 && (!this.hidpi_ || this.serverType_ === void 0)) {
      pixelRatio = 1;
    }
    var imageResolution = resolution / pixelRatio;
    var center = getCenter(extent2);
    var viewWidth = ceil$1(getWidth(extent2) / imageResolution, DECIMALS);
    var viewHeight = ceil$1(getHeight(extent2) / imageResolution, DECIMALS);
    var viewExtent = getForViewAndSize(center, imageResolution, 0, [
      viewWidth,
      viewHeight
    ]);
    var requestWidth = ceil$1(this.ratio_ * getWidth(extent2) / imageResolution, DECIMALS);
    var requestHeight = ceil$1(this.ratio_ * getHeight(extent2) / imageResolution, DECIMALS);
    var requestExtent = getForViewAndSize(center, imageResolution, 0, [
      requestWidth,
      requestHeight
    ]);
    var image2 = this.image_;
    if (image2 && this.renderedRevision_ == this.getRevision() && image2.getResolution() == resolution && image2.getPixelRatio() == pixelRatio && containsExtent(image2.getExtent(), viewExtent)) {
      return image2;
    }
    var params2 = {
      "SERVICE": "WMS",
      "VERSION": DEFAULT_WMS_VERSION,
      "REQUEST": "GetMap",
      "FORMAT": "image/png",
      "TRANSPARENT": true
    };
    assign(params2, this.params_);
    this.imageSize_[0] = round(getWidth(requestExtent) / imageResolution, DECIMALS);
    this.imageSize_[1] = round(getHeight(requestExtent) / imageResolution, DECIMALS);
    var url = this.getRequestUrl_(requestExtent, this.imageSize_, pixelRatio, projection, params2);
    this.image_ = new ImageWrapper$1(requestExtent, resolution, pixelRatio, url, this.crossOrigin_, this.imageLoadFunction_);
    this.renderedRevision_ = this.getRevision();
    this.image_.addEventListener(EventType.CHANGE, this.handleImageChange.bind(this));
    return this.image_;
  };
  ImageWMS2.prototype.getImageLoadFunction = function() {
    return this.imageLoadFunction_;
  };
  ImageWMS2.prototype.getRequestUrl_ = function(extent2, size, pixelRatio, projection, params2) {
    assert(this.url_ !== void 0, 9);
    params2[this.v13_ ? "CRS" : "SRS"] = projection.getCode();
    if (!("STYLES" in this.params_)) {
      params2["STYLES"] = "";
    }
    if (pixelRatio != 1) {
      switch (this.serverType_) {
        case WMSServerType.GEOSERVER:
          var dpi = 90 * pixelRatio + 0.5 | 0;
          if ("FORMAT_OPTIONS" in params2) {
            params2["FORMAT_OPTIONS"] += ";dpi:" + dpi;
          } else {
            params2["FORMAT_OPTIONS"] = "dpi:" + dpi;
          }
          break;
        case WMSServerType.MAPSERVER:
          params2["MAP_RESOLUTION"] = 90 * pixelRatio;
          break;
        case WMSServerType.CARMENTA_SERVER:
        case WMSServerType.QGIS:
          params2["DPI"] = 90 * pixelRatio;
          break;
        default:
          assert(false, 8);
          break;
      }
    }
    params2["WIDTH"] = size[0];
    params2["HEIGHT"] = size[1];
    var axisOrientation = projection.getAxisOrientation();
    var bbox2;
    if (this.v13_ && axisOrientation.substr(0, 2) == "ne") {
      bbox2 = [extent2[1], extent2[0], extent2[3], extent2[2]];
    } else {
      bbox2 = extent2;
    }
    params2["BBOX"] = bbox2.join(",");
    return appendParams(this.url_, params2);
  };
  ImageWMS2.prototype.getUrl = function() {
    return this.url_;
  };
  ImageWMS2.prototype.setImageLoadFunction = function(imageLoadFunction) {
    this.image_ = null;
    this.imageLoadFunction_ = imageLoadFunction;
    this.changed();
  };
  ImageWMS2.prototype.setUrl = function(url) {
    if (url != this.url_) {
      this.url_ = url;
      this.image_ = null;
      this.changed();
    }
  };
  ImageWMS2.prototype.updateParams = function(params2) {
    assign(this.params_, params2);
    this.updateV13_();
    this.image_ = null;
    this.changed();
  };
  ImageWMS2.prototype.updateV13_ = function() {
    var version2 = this.params_["VERSION"] || DEFAULT_WMS_VERSION;
    this.v13_ = compareVersions(version2, "1.3") >= 0;
  };
  return ImageWMS2;
}(ImageSource$1);
var ImageWMS$1 = ImageWMS;
var __extends$z = globalThis && globalThis.__extends || function() {
  var extendStatics2 = function(d2, b2) {
    extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {
      d3.__proto__ = b3;
    } || function(d3, b3) {
      for (var p5 in b3)
        if (Object.prototype.hasOwnProperty.call(b3, p5))
          d3[p5] = b3[p5];
    };
    return extendStatics2(d2, b2);
  };
  return function(d2, b2) {
    if (typeof b2 !== "function" && b2 !== null)
      throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
    extendStatics2(d2, b2);
    function __() {
      this.constructor = d2;
    }
    d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
  };
}();
var ATTRIBUTION = '&#169; <a href="https://www.openstreetmap.org/copyright" target="_blank">OpenStreetMap</a> contributors.';
var OSM = function(_super) {
  __extends$z(OSM2, _super);
  function OSM2(opt_options) {
    var options = opt_options || {};
    var interpolate = options.imageSmoothing !== void 0 ? options.imageSmoothing : true;
    if (options.interpolate !== void 0) {
      interpolate = options.interpolate;
    }
    var attributions;
    if (options.attributions !== void 0) {
      attributions = options.attributions;
    } else {
      attributions = [ATTRIBUTION];
    }
    var crossOrigin = options.crossOrigin !== void 0 ? options.crossOrigin : "anonymous";
    var url = options.url !== void 0 ? options.url : "https://{a-c}.tile.openstreetmap.org/{z}/{x}/{y}.png";
    return _super.call(this, {
      attributions,
      attributionsCollapsible: false,
      cacheSize: options.cacheSize,
      crossOrigin,
      interpolate,
      maxZoom: options.maxZoom !== void 0 ? options.maxZoom : 19,
      opaque: options.opaque !== void 0 ? options.opaque : true,
      reprojectionErrorThreshold: options.reprojectionErrorThreshold,
      tileLoadFunction: options.tileLoadFunction,
      transition: options.transition,
      url,
      wrapX: options.wrapX,
      zDirection: options.zDirection
    }) || this;
  }
  return OSM2;
}(XYZ$1);
var OSM$1 = OSM;
var __extends$y = globalThis && globalThis.__extends || function() {
  var extendStatics2 = function(d2, b2) {
    extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {
      d3.__proto__ = b3;
    } || function(d3, b3) {
      for (var p5 in b3)
        if (Object.prototype.hasOwnProperty.call(b3, p5))
          d3[p5] = b3[p5];
    };
    return extendStatics2(d2, b2);
  };
  return function(d2, b2) {
    if (typeof b2 !== "function" && b2 !== null)
      throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
    extendStatics2(d2, b2);
    function __() {
      this.constructor = d2;
    }
    d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
  };
}();
var TileWMS = function(_super) {
  __extends$y(TileWMS2, _super);
  function TileWMS2(opt_options) {
    var _this = this;
    var options = opt_options ? opt_options : {};
    var interpolate = options.imageSmoothing !== void 0 ? options.imageSmoothing : true;
    if (options.interpolate !== void 0) {
      interpolate = options.interpolate;
    }
    var params2 = options.params || {};
    var transparent = "TRANSPARENT" in params2 ? params2["TRANSPARENT"] : true;
    _this = _super.call(this, {
      attributions: options.attributions,
      attributionsCollapsible: options.attributionsCollapsible,
      cacheSize: options.cacheSize,
      crossOrigin: options.crossOrigin,
      interpolate,
      opaque: !transparent,
      projection: options.projection,
      reprojectionErrorThreshold: options.reprojectionErrorThreshold,
      tileClass: options.tileClass,
      tileGrid: options.tileGrid,
      tileLoadFunction: options.tileLoadFunction,
      url: options.url,
      urls: options.urls,
      wrapX: options.wrapX !== void 0 ? options.wrapX : true,
      transition: options.transition,
      zDirection: options.zDirection
    }) || this;
    _this.gutter_ = options.gutter !== void 0 ? options.gutter : 0;
    _this.params_ = params2;
    _this.v13_ = true;
    _this.serverType_ = options.serverType;
    _this.hidpi_ = options.hidpi !== void 0 ? options.hidpi : true;
    _this.tmpExtent_ = createEmpty();
    _this.updateV13_();
    _this.setKey(_this.getKeyForParams_());
    return _this;
  }
  TileWMS2.prototype.getFeatureInfoUrl = function(coordinate, resolution, projection, params2) {
    var projectionObj = get$3(projection);
    var sourceProjectionObj = this.getProjection();
    var tileGrid = this.getTileGrid();
    if (!tileGrid) {
      tileGrid = this.getTileGridForProjection(projectionObj);
    }
    var z2 = tileGrid.getZForResolution(resolution, this.zDirection);
    var tileCoord = tileGrid.getTileCoordForCoordAndZ(coordinate, z2);
    if (tileGrid.getResolutions().length <= tileCoord[0]) {
      return void 0;
    }
    var tileResolution = tileGrid.getResolution(tileCoord[0]);
    var tileExtent = tileGrid.getTileCoordExtent(tileCoord, this.tmpExtent_);
    var tileSize = toSize(tileGrid.getTileSize(tileCoord[0]), this.tmpSize);
    var gutter = this.gutter_;
    if (gutter !== 0) {
      tileSize = buffer(tileSize, gutter, this.tmpSize);
      tileExtent = buffer$1(tileExtent, tileResolution * gutter, tileExtent);
    }
    if (sourceProjectionObj && sourceProjectionObj !== projectionObj) {
      tileResolution = calculateSourceResolution(sourceProjectionObj, projectionObj, coordinate, tileResolution);
      tileExtent = transformExtent(tileExtent, projectionObj, sourceProjectionObj);
      coordinate = transform$3(coordinate, projectionObj, sourceProjectionObj);
    }
    var baseParams = {
      "SERVICE": "WMS",
      "VERSION": DEFAULT_WMS_VERSION,
      "REQUEST": "GetFeatureInfo",
      "FORMAT": "image/png",
      "TRANSPARENT": true,
      "QUERY_LAYERS": this.params_["LAYERS"]
    };
    assign(baseParams, this.params_, params2);
    var x2 = Math.floor((coordinate[0] - tileExtent[0]) / tileResolution);
    var y2 = Math.floor((tileExtent[3] - coordinate[1]) / tileResolution);
    baseParams[this.v13_ ? "I" : "X"] = x2;
    baseParams[this.v13_ ? "J" : "Y"] = y2;
    return this.getRequestUrl_(tileCoord, tileSize, tileExtent, 1, sourceProjectionObj || projectionObj, baseParams);
  };
  TileWMS2.prototype.getLegendUrl = function(resolution, params2) {
    if (this.urls[0] === void 0) {
      return void 0;
    }
    var baseParams = {
      "SERVICE": "WMS",
      "VERSION": DEFAULT_WMS_VERSION,
      "REQUEST": "GetLegendGraphic",
      "FORMAT": "image/png"
    };
    if (params2 === void 0 || params2["LAYER"] === void 0) {
      var layers = this.params_.LAYERS;
      var isSingleLayer = !Array.isArray(layers) || layers.length === 1;
      if (!isSingleLayer) {
        return void 0;
      }
      baseParams["LAYER"] = layers;
    }
    if (resolution !== void 0) {
      var mpu = this.getProjection() ? this.getProjection().getMetersPerUnit() : 1;
      var pixelSize = 28e-5;
      baseParams["SCALE"] = resolution * mpu / pixelSize;
    }
    assign(baseParams, params2);
    return appendParams(this.urls[0], baseParams);
  };
  TileWMS2.prototype.getGutter = function() {
    return this.gutter_;
  };
  TileWMS2.prototype.getParams = function() {
    return this.params_;
  };
  TileWMS2.prototype.getRequestUrl_ = function(tileCoord, tileSize, tileExtent, pixelRatio, projection, params2) {
    var urls = this.urls;
    if (!urls) {
      return void 0;
    }
    params2["WIDTH"] = tileSize[0];
    params2["HEIGHT"] = tileSize[1];
    params2[this.v13_ ? "CRS" : "SRS"] = projection.getCode();
    if (!("STYLES" in this.params_)) {
      params2["STYLES"] = "";
    }
    if (pixelRatio != 1) {
      switch (this.serverType_) {
        case WMSServerType.GEOSERVER:
          var dpi = 90 * pixelRatio + 0.5 | 0;
          if ("FORMAT_OPTIONS" in params2) {
            params2["FORMAT_OPTIONS"] += ";dpi:" + dpi;
          } else {
            params2["FORMAT_OPTIONS"] = "dpi:" + dpi;
          }
          break;
        case WMSServerType.MAPSERVER:
          params2["MAP_RESOLUTION"] = 90 * pixelRatio;
          break;
        case WMSServerType.CARMENTA_SERVER:
        case WMSServerType.QGIS:
          params2["DPI"] = 90 * pixelRatio;
          break;
        default:
          assert(false, 52);
          break;
      }
    }
    var axisOrientation = projection.getAxisOrientation();
    var bbox2 = tileExtent;
    if (this.v13_ && axisOrientation.substr(0, 2) == "ne") {
      var tmp = void 0;
      tmp = tileExtent[0];
      bbox2[0] = tileExtent[1];
      bbox2[1] = tmp;
      tmp = tileExtent[2];
      bbox2[2] = tileExtent[3];
      bbox2[3] = tmp;
    }
    params2["BBOX"] = bbox2.join(",");
    var url;
    if (urls.length == 1) {
      url = urls[0];
    } else {
      var index2 = modulo(hash(tileCoord), urls.length);
      url = urls[index2];
    }
    return appendParams(url, params2);
  };
  TileWMS2.prototype.getTilePixelRatio = function(pixelRatio) {
    return !this.hidpi_ || this.serverType_ === void 0 ? 1 : pixelRatio;
  };
  TileWMS2.prototype.getKeyForParams_ = function() {
    var i2 = 0;
    var res = [];
    for (var key in this.params_) {
      res[i2++] = key + "-" + this.params_[key];
    }
    return res.join("/");
  };
  TileWMS2.prototype.updateParams = function(params2) {
    assign(this.params_, params2);
    this.updateV13_();
    this.setKey(this.getKeyForParams_());
  };
  TileWMS2.prototype.updateV13_ = function() {
    var version2 = this.params_["VERSION"] || DEFAULT_WMS_VERSION;
    this.v13_ = compareVersions(version2, "1.3") >= 0;
  };
  TileWMS2.prototype.tileUrlFunction = function(tileCoord, pixelRatio, projection) {
    var tileGrid = this.getTileGrid();
    if (!tileGrid) {
      tileGrid = this.getTileGridForProjection(projection);
    }
    if (tileGrid.getResolutions().length <= tileCoord[0]) {
      return void 0;
    }
    if (pixelRatio != 1 && (!this.hidpi_ || this.serverType_ === void 0)) {
      pixelRatio = 1;
    }
    var tileResolution = tileGrid.getResolution(tileCoord[0]);
    var tileExtent = tileGrid.getTileCoordExtent(tileCoord, this.tmpExtent_);
    var tileSize = toSize(tileGrid.getTileSize(tileCoord[0]), this.tmpSize);
    var gutter = this.gutter_;
    if (gutter !== 0) {
      tileSize = buffer(tileSize, gutter, this.tmpSize);
      tileExtent = buffer$1(tileExtent, tileResolution * gutter, tileExtent);
    }
    if (pixelRatio != 1) {
      tileSize = scale(tileSize, pixelRatio, this.tmpSize);
    }
    var baseParams = {
      "SERVICE": "WMS",
      "VERSION": DEFAULT_WMS_VERSION,
      "REQUEST": "GetMap",
      "FORMAT": "image/png",
      "TRANSPARENT": true
    };
    assign(baseParams, this.params_);
    return this.getRequestUrl_(tileCoord, tileSize, tileExtent, pixelRatio, projection, baseParams);
  };
  return TileWMS2;
}(TileImage$1);
var ol_source_TileWMS = TileWMS;
var WMTSRequestEncoding = {
  KVP: "KVP",
  REST: "REST"
};
var __extends$x = globalThis && globalThis.__extends || function() {
  var extendStatics2 = function(d2, b2) {
    extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {
      d3.__proto__ = b3;
    } || function(d3, b3) {
      for (var p5 in b3)
        if (Object.prototype.hasOwnProperty.call(b3, p5))
          d3[p5] = b3[p5];
    };
    return extendStatics2(d2, b2);
  };
  return function(d2, b2) {
    if (typeof b2 !== "function" && b2 !== null)
      throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
    extendStatics2(d2, b2);
    function __() {
      this.constructor = d2;
    }
    d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
  };
}();
var WMTSTileGrid = function(_super) {
  __extends$x(WMTSTileGrid2, _super);
  function WMTSTileGrid2(options) {
    var _this = _super.call(this, {
      extent: options.extent,
      origin: options.origin,
      origins: options.origins,
      resolutions: options.resolutions,
      tileSize: options.tileSize,
      tileSizes: options.tileSizes,
      sizes: options.sizes
    }) || this;
    _this.matrixIds_ = options.matrixIds;
    return _this;
  }
  WMTSTileGrid2.prototype.getMatrixId = function(z2) {
    return this.matrixIds_[z2];
  };
  WMTSTileGrid2.prototype.getMatrixIds = function() {
    return this.matrixIds_;
  };
  return WMTSTileGrid2;
}(TileGrid$1);
var TileGridWMTS = WMTSTileGrid;
var __extends$w = globalThis && globalThis.__extends || function() {
  var extendStatics2 = function(d2, b2) {
    extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {
      d3.__proto__ = b3;
    } || function(d3, b3) {
      for (var p5 in b3)
        if (Object.prototype.hasOwnProperty.call(b3, p5))
          d3[p5] = b3[p5];
    };
    return extendStatics2(d2, b2);
  };
  return function(d2, b2) {
    if (typeof b2 !== "function" && b2 !== null)
      throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
    extendStatics2(d2, b2);
    function __() {
      this.constructor = d2;
    }
    d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
  };
}();
var WMTS = function(_super) {
  __extends$w(WMTS2, _super);
  function WMTS2(options) {
    var _this = this;
    var interpolate = options.imageSmoothing !== void 0 ? options.imageSmoothing : true;
    if (options.interpolate !== void 0) {
      interpolate = options.interpolate;
    }
    var requestEncoding = options.requestEncoding !== void 0 ? options.requestEncoding : WMTSRequestEncoding.KVP;
    var tileGrid = options.tileGrid;
    var urls = options.urls;
    if (urls === void 0 && options.url !== void 0) {
      urls = expandUrl(options.url);
    }
    _this = _super.call(this, {
      attributions: options.attributions,
      attributionsCollapsible: options.attributionsCollapsible,
      cacheSize: options.cacheSize,
      crossOrigin: options.crossOrigin,
      interpolate,
      projection: options.projection,
      reprojectionErrorThreshold: options.reprojectionErrorThreshold,
      tileClass: options.tileClass,
      tileGrid,
      tileLoadFunction: options.tileLoadFunction,
      tilePixelRatio: options.tilePixelRatio,
      urls,
      wrapX: options.wrapX !== void 0 ? options.wrapX : false,
      transition: options.transition,
      zDirection: options.zDirection
    }) || this;
    _this.version_ = options.version !== void 0 ? options.version : "1.0.0";
    _this.format_ = options.format !== void 0 ? options.format : "image/jpeg";
    _this.dimensions_ = options.dimensions !== void 0 ? options.dimensions : {};
    _this.layer_ = options.layer;
    _this.matrixSet_ = options.matrixSet;
    _this.style_ = options.style;
    _this.requestEncoding_ = requestEncoding;
    _this.setKey(_this.getKeyForDimensions_());
    if (urls && urls.length > 0) {
      _this.tileUrlFunction = createFromTileUrlFunctions(urls.map(_this.createFromWMTSTemplate.bind(_this)));
    }
    return _this;
  }
  WMTS2.prototype.setUrls = function(urls) {
    this.urls = urls;
    var key = urls.join("\n");
    this.setTileUrlFunction(createFromTileUrlFunctions(urls.map(this.createFromWMTSTemplate.bind(this))), key);
  };
  WMTS2.prototype.getDimensions = function() {
    return this.dimensions_;
  };
  WMTS2.prototype.getFormat = function() {
    return this.format_;
  };
  WMTS2.prototype.getLayer = function() {
    return this.layer_;
  };
  WMTS2.prototype.getMatrixSet = function() {
    return this.matrixSet_;
  };
  WMTS2.prototype.getRequestEncoding = function() {
    return this.requestEncoding_;
  };
  WMTS2.prototype.getStyle = function() {
    return this.style_;
  };
  WMTS2.prototype.getVersion = function() {
    return this.version_;
  };
  WMTS2.prototype.getKeyForDimensions_ = function() {
    var i2 = 0;
    var res = [];
    for (var key in this.dimensions_) {
      res[i2++] = key + "-" + this.dimensions_[key];
    }
    return res.join("/");
  };
  WMTS2.prototype.updateDimensions = function(dimensions) {
    assign(this.dimensions_, dimensions);
    this.setKey(this.getKeyForDimensions_());
  };
  WMTS2.prototype.createFromWMTSTemplate = function(template) {
    var requestEncoding = this.requestEncoding_;
    var context = {
      "layer": this.layer_,
      "style": this.style_,
      "tilematrixset": this.matrixSet_
    };
    if (requestEncoding == WMTSRequestEncoding.KVP) {
      assign(context, {
        "Service": "WMTS",
        "Request": "GetTile",
        "Version": this.version_,
        "Format": this.format_
      });
    }
    template = requestEncoding == WMTSRequestEncoding.KVP ? appendParams(template, context) : template.replace(/\{(\w+?)\}/g, function(m2, p5) {
      return p5.toLowerCase() in context ? context[p5.toLowerCase()] : m2;
    });
    var tileGrid = this.tileGrid;
    var dimensions = this.dimensions_;
    return function(tileCoord, pixelRatio, projection) {
      if (!tileCoord) {
        return void 0;
      } else {
        var localContext_1 = {
          "TileMatrix": tileGrid.getMatrixId(tileCoord[0]),
          "TileCol": tileCoord[1],
          "TileRow": tileCoord[2]
        };
        assign(localContext_1, dimensions);
        var url = template;
        if (requestEncoding == WMTSRequestEncoding.KVP) {
          url = appendParams(url, localContext_1);
        } else {
          url = url.replace(/\{(\w+?)\}/g, function(m2, p5) {
            return localContext_1[p5];
          });
        }
        return url;
      }
    };
  };
  return WMTS2;
}(TileImage$1);
var WMTSSource = WMTS;
if (window.ol && !ol.ext) {
  ol.ext = {};
}
var ol_ext_inherits = function(child, parent) {
  child.prototype = Object.create(parent.prototype);
  child.prototype.constructor = child;
};
if (window.ol) {
  if (!ol.inherits)
    ol.inherits = ol_ext_inherits;
}
if (window.NodeList && !NodeList.prototype.forEach) {
  NodeList.prototype.forEach = Array.prototype.forEach;
}
if (window.Element && !Element.prototype.remove) {
  Element.prototype.remove = function() {
    if (this.parentNode)
      this.parentNode.removeChild(this);
  };
}
function getVectorContext(event) {
  const frameState = event.frameState;
  const transform2 = multiply(event.inversePixelTransform.slice(), frameState.coordinateToPixelTransform);
  return new CanvasImmediateRenderer$1(event.context, frameState.pixelRatio, frameState.extent, transform2, frameState.viewState.rotation);
}
if (window.ol) {
  if (!ol.util) {
    ol.util = {
      VERSION: ol.VERSION || "5.3.0"
    };
  } else if (!ol.util.VERSION) {
    ol.util.VERSION = ol.VERSION || "6.1.0";
  }
}
var ol_ext_olVersion = VERSION.split(".");
ol_ext_olVersion = parseInt(ol_ext_olVersion[0]) * 100 + parseInt(ol_ext_olVersion[1]);
var ol_ext_getVectorContextStyle = function(e2, s2) {
  var ratio = e2.frameState.pixelRatio;
  if (ol_ext_olVersion > 605 && ratio !== 1 && s2.getImage() instanceof Icon$2) {
    s2 = s2.clone();
    var img = s2.getImage();
    img.setScale(img.getScale() * ratio);
    var anchor = img.getAnchor();
    if (img.setDisplacement) {
      var disp = img.getDisplacement();
      if (disp) {
        disp[0] -= anchor[0] / ratio;
        disp[1] += anchor[1] / ratio;
        img.setAnchor([0, 0]);
      }
    } else {
      if (anchor) {
        anchor[0] /= ratio;
        anchor[1] /= ratio;
      }
    }
  }
  return s2;
};
var ol_layer_AnimatedCluster = function(opt_options) {
  var options = opt_options || {};
  ol_layer_Vector.call(this, options);
  this.oldcluster = new ol_source_Vector();
  this.clusters = [];
  this.animation = { start: false };
  this.set("animationDuration", typeof options.animationDuration == "number" ? options.animationDuration : 700);
  this.set("animationMethod", options.animationMethod || easeOut);
  this.getSource().on("change", this.saveCluster.bind(this));
  this.on(["precompose", "prerender"], this.animate.bind(this));
  this.on(["postcompose", "postrender"], this.postanimate.bind(this));
};
ol_ext_inherits(ol_layer_AnimatedCluster, ol_layer_Vector);
ol_layer_AnimatedCluster.prototype.saveCluster = function() {
  if (this.oldcluster) {
    this.oldcluster.clear();
    if (!this.get("animationDuration"))
      return;
    var features = this.getSource().getFeatures();
    if (features.length && features[0].get("features")) {
      this.oldcluster.addFeatures(this.clusters);
      this.clusters = features.slice(0);
      this.sourceChanged = true;
    }
  }
};
ol_layer_AnimatedCluster.prototype.getClusterForFeature = function(f2, cluster) {
  for (var j2 = 0, c2; c2 = cluster[j2]; j2++) {
    var features = c2.get("features");
    if (features && features.length) {
      for (var k2 = 0, f22; f22 = features[k2]; k2++) {
        if (f2 === f22) {
          return c2;
        }
      }
    }
  }
  return false;
};
ol_layer_AnimatedCluster.prototype.stopAnimation = function() {
  this.animation.start = false;
  this.animation.cA = [];
  this.animation.cB = [];
};
ol_layer_AnimatedCluster.prototype.animate = function(e2) {
  var duration2 = this.get("animationDuration");
  if (!duration2)
    return;
  var resolution = e2.frameState.viewState.resolution;
  var i2, c0, a2 = this.animation;
  var time2 = e2.frameState.time;
  if (a2.resolution != resolution && this.sourceChanged) {
    var extent2 = e2.frameState.extent;
    if (a2.resolution < resolution) {
      extent2 = buffer$1(extent2, 100 * resolution);
      a2.cA = this.oldcluster.getFeaturesInExtent(extent2);
      a2.cB = this.getSource().getFeaturesInExtent(extent2);
      a2.revers = false;
    } else {
      extent2 = buffer$1(extent2, 100 * resolution);
      a2.cA = this.getSource().getFeaturesInExtent(extent2);
      a2.cB = this.oldcluster.getFeaturesInExtent(extent2);
      a2.revers = true;
    }
    a2.clusters = [];
    for (i2 = 0, c0; c0 = a2.cA[i2]; i2++) {
      var f2 = c0.get("features");
      if (f2 && f2.length) {
        var c2 = this.getClusterForFeature(f2[0], a2.cB);
        if (c2)
          a2.clusters.push({ f: c0, pt: c2.getGeometry().getCoordinates() });
      }
    }
    a2.resolution = resolution;
    this.sourceChanged = false;
    if (!a2.clusters.length || a2.clusters.length > 1e3) {
      this.stopAnimation();
      return;
    }
    time2 = a2.start = new Date().getTime();
  }
  if (a2.start) {
    var vectorContext = e2.vectorContext || getVectorContext(e2);
    var d2 = (time2 - a2.start) / duration2;
    if (d2 > 1) {
      this.stopAnimation();
      d2 = 1;
    }
    d2 = this.get("animationMethod")(d2);
    var style2 = this.getStyle();
    var stylefn = typeof style2 == "function" ? style2 : style2.length ? function() {
      return style2;
    } : function() {
      return [style2];
    };
    e2.context.save();
    e2.context.globalAlpha = this.getOpacity();
    for (i2 = 0, c2; c2 = a2.clusters[i2]; i2++) {
      var pt2 = c2.f.getGeometry().getCoordinates();
      var dx = pt2[0] - c2.pt[0];
      var dy = pt2[1] - c2.pt[1];
      if (a2.revers) {
        pt2[0] = c2.pt[0] + d2 * dx;
        pt2[1] = c2.pt[1] + d2 * dy;
      } else {
        pt2[0] = pt2[0] - d2 * dx;
        pt2[1] = pt2[1] - d2 * dy;
      }
      var st2 = stylefn(c2.f, resolution, true);
      if (!st2.length)
        st2 = [st2];
      if (c2.f.get("features").length === 1 && !dx && !dy) {
        f2 = c2.f.get("features")[0];
      } else {
        var geo = new Point$4(pt2);
        f2 = new feature(geo);
      }
      for (var k2 = 0, s2; s2 = st2[k2]; k2++) {
        if (s2.getText() && /\n/.test(s2.getText().getText())) {
          var offsetX = s2.getText().getOffsetX();
          var offsetY = s2.getText().getOffsetY();
          var rot = s2.getText().getRotation() || 0;
          var fontSize2 = Number((s2.getText().getFont() || "10px").match(/\d+/)) * 1.2;
          var str = s2.getText().getText().split("\n");
          var dl, nb = str.length - 1;
          var s22 = s2.clone();
          str.forEach(function(t3, i3) {
            if (i3 == 1) {
              s22.setImage();
              s22.setFill();
              s22.setStroke();
            }
            switch (s2.getText().getTextBaseline()) {
              case "alphabetic":
              case "ideographic":
              case "bottom": {
                dl = nb;
                break;
              }
              case "hanging":
              case "top": {
                dl = 0;
                break;
              }
              default: {
                dl = nb / 2;
                break;
              }
            }
            s22.getText().setOffsetX(offsetX - Math.sin(rot) * fontSize2 * (i3 - dl));
            s22.getText().setOffsetY(offsetY + Math.cos(rot) * fontSize2 * (i3 - dl));
            s22.getText().setText(t3);
            vectorContext.drawFeature(f2, ol_ext_getVectorContextStyle(e2, s22));
          });
        } else {
          vectorContext.drawFeature(f2, ol_ext_getVectorContextStyle(e2, s2));
        }
      }
    }
    e2.context.restore();
    e2.frameState.animate = true;
    e2.context.save();
    e2.context.beginPath();
    e2.context.rect(0, 0, 0, 0);
    e2.context.clip();
    this.clip_ = true;
  }
  return;
};
ol_layer_AnimatedCluster.prototype.postanimate = function(e2) {
  if (this.clip_) {
    e2.context.restore();
    this.clip_ = false;
  }
};
var _sfc_main$X = {
  extends: BaseLayer,
  name: "ol-animated-clusterlayer",
  setup(props) {
    const map = inject("map");
    const {
      properties
    } = usePropsAsObjectProperties(props);
    const vectorLayer = computed(() => {
      let ac = new ol_layer_AnimatedCluster(__spreadProps(__spreadValues({}, properties), {
        source: new Cluster$1({
          distance: properties.distance,
          geometryFunction: (feature2) => feature2.getGeometry()
        })
      }));
      return ac;
    });
    const source = computed(() => vectorLayer.value.getSource());
    watch(properties, () => {
      vectorLayer.value.setProperties(properties);
      vectorLayer.value.changed();
    });
    onMounted(() => {
      map.addLayer(vectorLayer.value);
      vectorLayer.value.changed();
      map.changed();
    });
    onUnmounted(() => {
      map.removeLayer(vectorLayer.value);
    });
    provide("vectorLayer", source);
    provide("stylable", vectorLayer);
    return {
      vectorLayer,
      map
    };
  },
  props: {
    animationDuration: {
      type: Number,
      default: 700
    },
    distance: {
      type: Number,
      default: 20
    },
    animationMethod: {
      type: Function,
      default: easeOut
    },
    updateWhileAnimating: {
      type: Boolean,
      default: false
    },
    updateWhileInteracting: {
      type: Boolean,
      default: false
    }
  }
};
function _sfc_render$X(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", null, [
    renderSlot(_ctx.$slots, "default")
  ]);
}
var AnimatedClusterLayer = _export_sfc(_sfc_main$X, [["render", _sfc_render$X]]);
var tmpArray4 = new Uint8Array(4);
var WebGLRenderTarget = function() {
  function WebGLRenderTarget2(helper, opt_size) {
    this.helper_ = helper;
    var gl = helper.getGL();
    this.texture_ = gl.createTexture();
    this.framebuffer_ = gl.createFramebuffer();
    this.size_ = opt_size || [1, 1];
    this.data_ = new Uint8Array(0);
    this.dataCacheDirty_ = true;
    this.updateSize_();
  }
  WebGLRenderTarget2.prototype.setSize = function(size) {
    if (equals$2(size, this.size_)) {
      return;
    }
    this.size_[0] = size[0];
    this.size_[1] = size[1];
    this.updateSize_();
  };
  WebGLRenderTarget2.prototype.getSize = function() {
    return this.size_;
  };
  WebGLRenderTarget2.prototype.clearCachedData = function() {
    this.dataCacheDirty_ = true;
  };
  WebGLRenderTarget2.prototype.readAll = function() {
    if (this.dataCacheDirty_) {
      var size = this.size_;
      var gl = this.helper_.getGL();
      gl.bindFramebuffer(gl.FRAMEBUFFER, this.framebuffer_);
      gl.readPixels(0, 0, size[0], size[1], gl.RGBA, gl.UNSIGNED_BYTE, this.data_);
      this.dataCacheDirty_ = false;
    }
    return this.data_;
  };
  WebGLRenderTarget2.prototype.readPixel = function(x2, y2) {
    if (x2 < 0 || y2 < 0 || x2 > this.size_[0] || y2 >= this.size_[1]) {
      tmpArray4[0] = 0;
      tmpArray4[1] = 0;
      tmpArray4[2] = 0;
      tmpArray4[3] = 0;
      return tmpArray4;
    }
    this.readAll();
    var index2 = Math.floor(x2) + (this.size_[1] - Math.floor(y2) - 1) * this.size_[0];
    tmpArray4[0] = this.data_[index2 * 4];
    tmpArray4[1] = this.data_[index2 * 4 + 1];
    tmpArray4[2] = this.data_[index2 * 4 + 2];
    tmpArray4[3] = this.data_[index2 * 4 + 3];
    return tmpArray4;
  };
  WebGLRenderTarget2.prototype.getTexture = function() {
    return this.texture_;
  };
  WebGLRenderTarget2.prototype.getFramebuffer = function() {
    return this.framebuffer_;
  };
  WebGLRenderTarget2.prototype.updateSize_ = function() {
    var size = this.size_;
    var gl = this.helper_.getGL();
    this.texture_ = this.helper_.createTexture(size, null, this.texture_);
    gl.bindFramebuffer(gl.FRAMEBUFFER, this.framebuffer_);
    gl.viewport(0, 0, size[0], size[1]);
    gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, this.texture_, 0);
    this.data_ = new Uint8Array(size[0] * size[1] * 4);
  };
  return WebGLRenderTarget2;
}();
var WebGLRenderTarget$1 = WebGLRenderTarget;
function create$4() {
  var source = 'var e="function"==typeof Object.assign?Object.assign:function(e,n){if(null==e)throw new TypeError("Cannot convert undefined or null to object");for(var t=Object(e),r=1,o=arguments.length;r<o;++r){var i=arguments[r];if(null!=i)for(var f in i)i.hasOwnProperty(f)&&(t[f]=i[f])}return t},n="GENERATE_BUFFERS",t=[],r={vertexPosition:0,indexPosition:0};function o(e,n,t,r,o){e[n+0]=t,e[n+1]=r,e[n+2]=o}function i(e,n,i,f,s,a){var u=3+s,l=e[n+0],v=e[n+1],c=t;c.length=s;for(var g=0;g<c.length;g++)c[g]=e[n+2+g];var b=a?a.vertexPosition:0,h=a?a.indexPosition:0,d=b/u;return o(i,b,l,v,0),c.length&&i.set(c,b+3),o(i,b+=u,l,v,1),c.length&&i.set(c,b+3),o(i,b+=u,l,v,2),c.length&&i.set(c,b+3),o(i,b+=u,l,v,3),c.length&&i.set(c,b+3),b+=u,f[h++]=d,f[h++]=d+1,f[h++]=d+3,f[h++]=d+1,f[h++]=d+2,f[h++]=d+3,r.vertexPosition=b,r.indexPosition=h,r}var f=self;f.onmessage=function(t){var r=t.data;if(r.type===n){for(var o,s=r.customAttributesCount,a=2+s,u=new Float32Array(r.renderInstructions),l=u.length/a,v=4*l*(s+3),c=new Uint32Array(6*l),g=new Float32Array(v),b=0;b<u.length;b+=a)o=i(u,b,g,c,s,o);var h=e({vertexBuffer:g.buffer,indexBuffer:c.buffer,renderInstructions:u.buffer},r);f.postMessage(h,[g.buffer,c.buffer,u.buffer])}};';
  return new Worker(typeof Blob === "undefined" ? "data:application/javascript;base64," + Buffer.from(source, "binary").toString("base64") : URL.createObjectURL(new Blob([source], { type: "application/javascript" })));
}
var __extends$v = globalThis && globalThis.__extends || function() {
  var extendStatics2 = function(d2, b2) {
    extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {
      d3.__proto__ = b3;
    } || function(d3, b3) {
      for (var p5 in b3)
        if (Object.prototype.hasOwnProperty.call(b3, p5))
          d3[p5] = b3[p5];
    };
    return extendStatics2(d2, b2);
  };
  return function(d2, b2) {
    if (typeof b2 !== "function" && b2 !== null)
      throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
    extendStatics2(d2, b2);
    function __() {
      this.constructor = d2;
    }
    d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
  };
}();
var WebGLPointsLayerRenderer = function(_super) {
  __extends$v(WebGLPointsLayerRenderer2, _super);
  function WebGLPointsLayerRenderer2(layer, options) {
    var _this = this;
    var uniforms = options.uniforms || {};
    var projectionMatrixTransform = create$6();
    uniforms[DefaultUniform.PROJECTION_MATRIX] = projectionMatrixTransform;
    _this = _super.call(this, layer, {
      uniforms,
      postProcesses: options.postProcesses
    }) || this;
    _this.ready = false;
    _this.sourceRevision_ = -1;
    _this.verticesBuffer_ = new WebGLArrayBuffer$1(ARRAY_BUFFER, DYNAMIC_DRAW);
    _this.hitVerticesBuffer_ = new WebGLArrayBuffer$1(ARRAY_BUFFER, DYNAMIC_DRAW);
    _this.indicesBuffer_ = new WebGLArrayBuffer$1(ELEMENT_ARRAY_BUFFER, DYNAMIC_DRAW);
    _this.vertexShader_ = options.vertexShader;
    _this.fragmentShader_ = options.fragmentShader;
    _this.program_;
    _this.hitDetectionEnabled_ = options.hitFragmentShader && options.hitVertexShader ? true : false;
    _this.hitVertexShader_ = options.hitVertexShader;
    _this.hitFragmentShader_ = options.hitFragmentShader;
    _this.hitProgram_;
    var customAttributes = options.attributes ? options.attributes.map(function(attribute) {
      return {
        name: "a_" + attribute.name,
        size: 1,
        type: AttributeType.FLOAT
      };
    }) : [];
    _this.attributes = [
      {
        name: "a_position",
        size: 2,
        type: AttributeType.FLOAT
      },
      {
        name: "a_index",
        size: 1,
        type: AttributeType.FLOAT
      }
    ].concat(customAttributes);
    _this.hitDetectionAttributes = [
      {
        name: "a_position",
        size: 2,
        type: AttributeType.FLOAT
      },
      {
        name: "a_index",
        size: 1,
        type: AttributeType.FLOAT
      },
      {
        name: "a_hitColor",
        size: 4,
        type: AttributeType.FLOAT
      },
      {
        name: "a_featureUid",
        size: 1,
        type: AttributeType.FLOAT
      }
    ].concat(customAttributes);
    _this.customAttributes = options.attributes ? options.attributes : [];
    _this.previousExtent_ = createEmpty();
    _this.currentTransform_ = projectionMatrixTransform;
    _this.renderTransform_ = create$6();
    _this.invertRenderTransform_ = create$6();
    _this.renderInstructions_ = new Float32Array(0);
    _this.hitRenderInstructions_ = new Float32Array(0);
    _this.hitRenderTarget_;
    _this.generateBuffersRun_ = 0;
    _this.worker_ = create$4();
    _this.worker_.addEventListener("message", function(event) {
      var received = event.data;
      if (received.type === WebGLWorkerMessageType.GENERATE_BUFFERS) {
        var projectionTransform = received.projectionTransform;
        if (received.hitDetection) {
          this.hitVerticesBuffer_.fromArrayBuffer(received.vertexBuffer);
          this.helper.flushBufferData(this.hitVerticesBuffer_);
        } else {
          this.verticesBuffer_.fromArrayBuffer(received.vertexBuffer);
          this.helper.flushBufferData(this.verticesBuffer_);
        }
        this.indicesBuffer_.fromArrayBuffer(received.indexBuffer);
        this.helper.flushBufferData(this.indicesBuffer_);
        this.renderTransform_ = projectionTransform;
        makeInverse(this.invertRenderTransform_, this.renderTransform_);
        if (received.hitDetection) {
          this.hitRenderInstructions_ = new Float32Array(event.data.renderInstructions);
        } else {
          this.renderInstructions_ = new Float32Array(event.data.renderInstructions);
          if (received.generateBuffersRun === this.generateBuffersRun_) {
            this.ready = true;
          }
        }
        this.getLayer().changed();
      }
    }.bind(_this));
    _this.featureCache_ = {};
    _this.featureCount_ = 0;
    var source = _this.getLayer().getSource();
    _this.sourceListenKeys_ = [
      listen(source, VectorEventType.ADDFEATURE, _this.handleSourceFeatureAdded_, _this),
      listen(source, VectorEventType.CHANGEFEATURE, _this.handleSourceFeatureChanged_, _this),
      listen(source, VectorEventType.REMOVEFEATURE, _this.handleSourceFeatureDelete_, _this),
      listen(source, VectorEventType.CLEAR, _this.handleSourceFeatureClear_, _this)
    ];
    source.forEachFeature(function(feature2) {
      this.featureCache_[getUid(feature2)] = {
        feature: feature2,
        properties: feature2.getProperties(),
        geometry: feature2.getGeometry()
      };
      this.featureCount_++;
    }.bind(_this));
    return _this;
  }
  WebGLPointsLayerRenderer2.prototype.afterHelperCreated = function() {
    this.program_ = this.helper.getProgram(this.fragmentShader_, this.vertexShader_);
    if (this.hitDetectionEnabled_) {
      this.hitProgram_ = this.helper.getProgram(this.hitFragmentShader_, this.hitVertexShader_);
      this.hitRenderTarget_ = new WebGLRenderTarget$1(this.helper);
    }
  };
  WebGLPointsLayerRenderer2.prototype.handleSourceFeatureAdded_ = function(event) {
    var feature2 = event.feature;
    this.featureCache_[getUid(feature2)] = {
      feature: feature2,
      properties: feature2.getProperties(),
      geometry: feature2.getGeometry()
    };
    this.featureCount_++;
  };
  WebGLPointsLayerRenderer2.prototype.handleSourceFeatureChanged_ = function(event) {
    var feature2 = event.feature;
    this.featureCache_[getUid(feature2)] = {
      feature: feature2,
      properties: feature2.getProperties(),
      geometry: feature2.getGeometry()
    };
  };
  WebGLPointsLayerRenderer2.prototype.handleSourceFeatureDelete_ = function(event) {
    var feature2 = event.feature;
    delete this.featureCache_[getUid(feature2)];
    this.featureCount_--;
  };
  WebGLPointsLayerRenderer2.prototype.handleSourceFeatureClear_ = function() {
    this.featureCache_ = {};
    this.featureCount_ = 0;
  };
  WebGLPointsLayerRenderer2.prototype.renderFrame = function(frameState) {
    var gl = this.helper.getGL();
    this.preRender(gl, frameState);
    var renderCount = this.indicesBuffer_.getSize();
    this.helper.drawElements(0, renderCount);
    this.helper.finalizeDraw(frameState, this.dispatchPreComposeEvent, this.dispatchPostComposeEvent);
    var canvas = this.helper.getCanvas();
    if (this.hitDetectionEnabled_) {
      this.renderHitDetection(frameState);
      this.hitRenderTarget_.clearCachedData();
    }
    this.postRender(gl, frameState);
    return canvas;
  };
  WebGLPointsLayerRenderer2.prototype.prepareFrameInternal = function(frameState) {
    var layer = this.getLayer();
    var vectorSource = layer.getSource();
    var viewState = frameState.viewState;
    var viewNotMoving = !frameState.viewHints[ViewHint.ANIMATING] && !frameState.viewHints[ViewHint.INTERACTING];
    var extentChanged = !equals$1(this.previousExtent_, frameState.extent);
    var sourceChanged = this.sourceRevision_ < vectorSource.getRevision();
    if (sourceChanged) {
      this.sourceRevision_ = vectorSource.getRevision();
    }
    if (viewNotMoving && (extentChanged || sourceChanged)) {
      var projection = viewState.projection;
      var resolution = viewState.resolution;
      var renderBuffer = layer instanceof BaseVectorLayer$1 ? layer.getRenderBuffer() : 0;
      var extent2 = buffer$1(frameState.extent, renderBuffer * resolution);
      vectorSource.loadFeatures(extent2, resolution, projection);
      this.rebuildBuffers_(frameState);
      this.previousExtent_ = frameState.extent.slice();
    }
    this.helper.makeProjectionTransform(frameState, this.currentTransform_);
    multiply(this.currentTransform_, this.invertRenderTransform_);
    this.helper.useProgram(this.program_);
    this.helper.prepareDraw(frameState);
    this.helper.bindBuffer(this.verticesBuffer_);
    this.helper.bindBuffer(this.indicesBuffer_);
    this.helper.enableAttributes(this.attributes);
    return true;
  };
  WebGLPointsLayerRenderer2.prototype.rebuildBuffers_ = function(frameState) {
    var projectionTransform = create$6();
    this.helper.makeProjectionTransform(frameState, projectionTransform);
    var totalInstructionsCount = (2 + this.customAttributes.length) * this.featureCount_;
    if (!this.renderInstructions_ || this.renderInstructions_.length !== totalInstructionsCount) {
      this.renderInstructions_ = new Float32Array(totalInstructionsCount);
    }
    if (this.hitDetectionEnabled_) {
      var totalHitInstructionsCount = (7 + this.customAttributes.length) * this.featureCount_;
      if (!this.hitRenderInstructions_ || this.hitRenderInstructions_.length !== totalHitInstructionsCount) {
        this.hitRenderInstructions_ = new Float32Array(totalHitInstructionsCount);
      }
    }
    var featureCache, geometry;
    var tmpCoords = [];
    var tmpColor = [];
    var renderIndex = 0;
    var hitIndex = 0;
    var hitColor;
    for (var featureUid in this.featureCache_) {
      featureCache = this.featureCache_[featureUid];
      geometry = featureCache.geometry;
      if (!geometry || geometry.getType() !== GeometryType.POINT) {
        continue;
      }
      tmpCoords[0] = geometry.getFlatCoordinates()[0];
      tmpCoords[1] = geometry.getFlatCoordinates()[1];
      apply$5(projectionTransform, tmpCoords);
      hitColor = colorEncodeId(hitIndex + 6, tmpColor);
      this.renderInstructions_[renderIndex++] = tmpCoords[0];
      this.renderInstructions_[renderIndex++] = tmpCoords[1];
      if (this.hitDetectionEnabled_) {
        this.hitRenderInstructions_[hitIndex++] = tmpCoords[0];
        this.hitRenderInstructions_[hitIndex++] = tmpCoords[1];
        this.hitRenderInstructions_[hitIndex++] = hitColor[0];
        this.hitRenderInstructions_[hitIndex++] = hitColor[1];
        this.hitRenderInstructions_[hitIndex++] = hitColor[2];
        this.hitRenderInstructions_[hitIndex++] = hitColor[3];
        this.hitRenderInstructions_[hitIndex++] = Number(featureUid);
      }
      var value = void 0;
      for (var j2 = 0; j2 < this.customAttributes.length; j2++) {
        value = this.customAttributes[j2].callback(featureCache.feature, featureCache.properties);
        this.renderInstructions_[renderIndex++] = value;
        if (this.hitDetectionEnabled_) {
          this.hitRenderInstructions_[hitIndex++] = value;
        }
      }
    }
    var message = {
      type: WebGLWorkerMessageType.GENERATE_BUFFERS,
      renderInstructions: this.renderInstructions_.buffer,
      customAttributesCount: this.customAttributes.length
    };
    message["projectionTransform"] = projectionTransform;
    message["generateBuffersRun"] = ++this.generateBuffersRun_;
    this.ready = false;
    this.worker_.postMessage(message, [this.renderInstructions_.buffer]);
    this.renderInstructions_ = null;
    if (this.hitDetectionEnabled_) {
      var hitMessage = {
        type: WebGLWorkerMessageType.GENERATE_BUFFERS,
        renderInstructions: this.hitRenderInstructions_.buffer,
        customAttributesCount: 5 + this.customAttributes.length
      };
      hitMessage["projectionTransform"] = projectionTransform;
      hitMessage["hitDetection"] = true;
      this.worker_.postMessage(hitMessage, [
        this.hitRenderInstructions_.buffer
      ]);
      this.hitRenderInstructions_ = null;
    }
  };
  WebGLPointsLayerRenderer2.prototype.forEachFeatureAtCoordinate = function(coordinate, frameState, hitTolerance, callback, matches) {
    assert(this.hitDetectionEnabled_, 66);
    if (!this.hitRenderInstructions_) {
      return void 0;
    }
    var pixel = apply$5(frameState.coordinateToPixelTransform, coordinate.slice());
    var data2 = this.hitRenderTarget_.readPixel(pixel[0] / 2, pixel[1] / 2);
    var color2 = [data2[0] / 255, data2[1] / 255, data2[2] / 255, data2[3] / 255];
    var index2 = colorDecodeId(color2);
    var opacity2 = this.hitRenderInstructions_[index2];
    var uid2 = Math.floor(opacity2).toString();
    var source = this.getLayer().getSource();
    var feature2 = source.getFeatureByUid(uid2);
    if (feature2) {
      return callback(feature2, this.getLayer(), null);
    }
    return void 0;
  };
  WebGLPointsLayerRenderer2.prototype.renderHitDetection = function(frameState) {
    if (!this.hitVerticesBuffer_.getSize()) {
      return;
    }
    this.hitRenderTarget_.setSize([
      Math.floor(frameState.size[0] / 2),
      Math.floor(frameState.size[1] / 2)
    ]);
    this.helper.useProgram(this.hitProgram_);
    this.helper.prepareDrawToRenderTarget(frameState, this.hitRenderTarget_, true);
    this.helper.bindBuffer(this.hitVerticesBuffer_);
    this.helper.bindBuffer(this.indicesBuffer_);
    this.helper.enableAttributes(this.hitDetectionAttributes);
    var renderCount = this.indicesBuffer_.getSize();
    this.helper.drawElements(0, renderCount);
  };
  WebGLPointsLayerRenderer2.prototype.disposeInternal = function() {
    this.worker_.terminate();
    this.layer_ = null;
    this.sourceListenKeys_.forEach(function(key) {
      unlistenByKey(key);
    });
    this.sourceListenKeys_ = null;
    _super.prototype.disposeInternal.call(this);
  };
  return WebGLPointsLayerRenderer2;
}(WebGLLayerRenderer$1);
var WebGLPointsLayerRenderer$1 = WebGLPointsLayerRenderer;
var ShaderBuilder = function() {
  function ShaderBuilder2() {
    this.uniforms = [];
    this.attributes = [];
    this.varyings = [];
    this.sizeExpression = "vec2(1.0)";
    this.rotationExpression = "0.0";
    this.offsetExpression = "vec2(0.0)";
    this.colorExpression = "vec4(1.0)";
    this.texCoordExpression = "vec4(0.0, 0.0, 1.0, 1.0)";
    this.discardExpression = "false";
    this.rotateWithView = false;
  }
  ShaderBuilder2.prototype.addUniform = function(name) {
    this.uniforms.push(name);
    return this;
  };
  ShaderBuilder2.prototype.addAttribute = function(name) {
    this.attributes.push(name);
    return this;
  };
  ShaderBuilder2.prototype.addVarying = function(name, type, expression) {
    this.varyings.push({
      name,
      type,
      expression
    });
    return this;
  };
  ShaderBuilder2.prototype.setSizeExpression = function(expression) {
    this.sizeExpression = expression;
    return this;
  };
  ShaderBuilder2.prototype.setRotationExpression = function(expression) {
    this.rotationExpression = expression;
    return this;
  };
  ShaderBuilder2.prototype.setSymbolOffsetExpression = function(expression) {
    this.offsetExpression = expression;
    return this;
  };
  ShaderBuilder2.prototype.setColorExpression = function(expression) {
    this.colorExpression = expression;
    return this;
  };
  ShaderBuilder2.prototype.setTextureCoordinateExpression = function(expression) {
    this.texCoordExpression = expression;
    return this;
  };
  ShaderBuilder2.prototype.setFragmentDiscardExpression = function(expression) {
    this.discardExpression = expression;
    return this;
  };
  ShaderBuilder2.prototype.setSymbolRotateWithView = function(rotateWithView) {
    this.rotateWithView = rotateWithView;
    return this;
  };
  ShaderBuilder2.prototype.getSizeExpression = function() {
    return this.sizeExpression;
  };
  ShaderBuilder2.prototype.getOffsetExpression = function() {
    return this.offsetExpression;
  };
  ShaderBuilder2.prototype.getColorExpression = function() {
    return this.colorExpression;
  };
  ShaderBuilder2.prototype.getTextureCoordinateExpression = function() {
    return this.texCoordExpression;
  };
  ShaderBuilder2.prototype.getFragmentDiscardExpression = function() {
    return this.discardExpression;
  };
  ShaderBuilder2.prototype.getSymbolVertexShader = function(forHitDetection) {
    var offsetMatrix = this.rotateWithView ? "u_offsetScaleMatrix * u_offsetRotateMatrix" : "u_offsetScaleMatrix";
    var attributes = this.attributes;
    var varyings = this.varyings;
    if (forHitDetection) {
      attributes = attributes.concat("vec4 a_hitColor");
      varyings = varyings.concat({
        name: "v_hitColor",
        type: "vec4",
        expression: "a_hitColor"
      });
    }
    return "precision mediump float;\nuniform mat4 u_projectionMatrix;\nuniform mat4 u_offsetScaleMatrix;\nuniform mat4 u_offsetRotateMatrix;\nuniform float u_time;\nuniform float u_zoom;\nuniform float u_resolution;\n".concat(this.uniforms.map(function(uniform) {
      return "uniform " + uniform + ";";
    }).join("\n"), "\nattribute vec2 a_position;\nattribute float a_index;\n").concat(attributes.map(function(attribute) {
      return "attribute " + attribute + ";";
    }).join("\n"), "\nvarying vec2 v_texCoord;\nvarying vec2 v_quadCoord;\n").concat(varyings.map(function(varying) {
      return "varying " + varying.type + " " + varying.name + ";";
    }).join("\n"), "\nvoid main(void) {\n  mat4 offsetMatrix = ").concat(offsetMatrix, ";\n  vec2 halfSize = ").concat(this.sizeExpression, " * 0.5;\n  vec2 offset = ").concat(this.offsetExpression, ";\n  float angle = ").concat(this.rotationExpression, ";\n  float offsetX;\n  float offsetY;\n  if (a_index == 0.0) {\n    offsetX = (offset.x - halfSize.x) * cos(angle) + (offset.y - halfSize.y) * sin(angle);\n    offsetY = (offset.y - halfSize.y) * cos(angle) - (offset.x - halfSize.x) * sin(angle);\n  } else if (a_index == 1.0) {\n    offsetX = (offset.x + halfSize.x) * cos(angle) + (offset.y - halfSize.y) * sin(angle);\n    offsetY = (offset.y - halfSize.y) * cos(angle) - (offset.x + halfSize.x) * sin(angle);\n  } else if (a_index == 2.0) {\n    offsetX = (offset.x + halfSize.x) * cos(angle) + (offset.y + halfSize.y) * sin(angle);\n    offsetY = (offset.y + halfSize.y) * cos(angle) - (offset.x + halfSize.x) * sin(angle);\n  } else {\n    offsetX = (offset.x - halfSize.x) * cos(angle) + (offset.y + halfSize.y) * sin(angle);\n    offsetY = (offset.y + halfSize.y) * cos(angle) - (offset.x - halfSize.x) * sin(angle);\n  }\n  vec4 offsets = offsetMatrix * vec4(offsetX, offsetY, 0.0, 0.0);\n  gl_Position = u_projectionMatrix * vec4(a_position, 0.0, 1.0) + offsets;\n  vec4 texCoord = ").concat(this.texCoordExpression, ";\n  float u = a_index == 0.0 || a_index == 3.0 ? texCoord.s : texCoord.p;\n  float v = a_index == 2.0 || a_index == 3.0 ? texCoord.t : texCoord.q;\n  v_texCoord = vec2(u, v);\n  u = a_index == 0.0 || a_index == 3.0 ? 0.0 : 1.0;\n  v = a_index == 2.0 || a_index == 3.0 ? 0.0 : 1.0;\n  v_quadCoord = vec2(u, v);\n").concat(varyings.map(function(varying) {
      return "  " + varying.name + " = " + varying.expression + ";";
    }).join("\n"), "\n}");
  };
  ShaderBuilder2.prototype.getSymbolFragmentShader = function(forHitDetection) {
    var hitDetectionBypass = forHitDetection ? "  if (gl_FragColor.a < 0.1) { discard; } gl_FragColor = v_hitColor;" : "";
    var varyings = this.varyings;
    if (forHitDetection) {
      varyings = varyings.concat({
        name: "v_hitColor",
        type: "vec4",
        expression: "a_hitColor"
      });
    }
    return "precision mediump float;\nuniform float u_time;\nuniform float u_zoom;\nuniform float u_resolution;\n".concat(this.uniforms.map(function(uniform) {
      return "uniform " + uniform + ";";
    }).join("\n"), "\nvarying vec2 v_texCoord;\nvarying vec2 v_quadCoord;\n").concat(varyings.map(function(varying) {
      return "varying " + varying.type + " " + varying.name + ";";
    }).join("\n"), "\nvoid main(void) {\n  if (").concat(this.discardExpression, ") { discard; }\n  gl_FragColor = ").concat(this.colorExpression, ";\n  gl_FragColor.rgb *= gl_FragColor.a;\n").concat(hitDetectionBypass, "\n}");
  };
  return ShaderBuilder2;
}();
function parseLiteralStyle(style2) {
  var symbStyle = style2.symbol;
  var size = symbStyle.size !== void 0 ? symbStyle.size : 1;
  var color2 = symbStyle.color || "white";
  var texCoord = symbStyle.textureCoord || [0, 0, 1, 1];
  var offset2 = symbStyle.offset || [0, 0];
  var opacity2 = symbStyle.opacity !== void 0 ? symbStyle.opacity : 1;
  var rotation = symbStyle.rotation !== void 0 ? symbStyle.rotation : 0;
  var vertContext = {
    inFragmentShader: false,
    variables: [],
    attributes: [],
    stringLiteralsMap: {},
    functions: {}
  };
  var parsedSize = expressionToGlsl(vertContext, size, ValueTypes.NUMBER_ARRAY | ValueTypes.NUMBER);
  var parsedOffset = expressionToGlsl(vertContext, offset2, ValueTypes.NUMBER_ARRAY);
  var parsedTexCoord = expressionToGlsl(vertContext, texCoord, ValueTypes.NUMBER_ARRAY);
  var parsedRotation = expressionToGlsl(vertContext, rotation, ValueTypes.NUMBER);
  var fragContext = {
    inFragmentShader: true,
    variables: vertContext.variables,
    attributes: [],
    stringLiteralsMap: vertContext.stringLiteralsMap,
    functions: {}
  };
  var parsedColor = expressionToGlsl(fragContext, color2, ValueTypes.COLOR);
  var parsedOpacity = expressionToGlsl(fragContext, opacity2, ValueTypes.NUMBER);
  var opacityFilter = "1.0";
  var visibleSize = "vec2(".concat(expressionToGlsl(fragContext, size, ValueTypes.NUMBER_ARRAY | ValueTypes.NUMBER), ").x");
  switch (symbStyle.symbolType) {
    case "square":
      break;
    case "image":
      break;
    case "circle":
      opacityFilter = "(1.0-smoothstep(1.-4./".concat(visibleSize, ",1.,dot(v_quadCoord-.5,v_quadCoord-.5)*4.))");
      break;
    case "triangle":
      var st2 = "(v_quadCoord*2.-1.)";
      var a2 = "(atan(".concat(st2, ".x,").concat(st2, ".y))");
      opacityFilter = "(1.0-smoothstep(.5-3./".concat(visibleSize, ",.5,cos(floor(.5+").concat(a2, "/2.094395102)*2.094395102-").concat(a2, ")*length(").concat(st2, ")))");
      break;
    default:
      throw new Error("Unexpected symbol type: " + symbStyle.symbolType);
  }
  var builder = new ShaderBuilder().setSizeExpression("vec2(".concat(parsedSize, ")")).setRotationExpression(parsedRotation).setSymbolOffsetExpression(parsedOffset).setTextureCoordinateExpression(parsedTexCoord).setSymbolRotateWithView(!!symbStyle.rotateWithView).setColorExpression("vec4(".concat(parsedColor, ".rgb, ").concat(parsedColor, ".a * ").concat(parsedOpacity, " * ").concat(opacityFilter, ")"));
  if (style2.filter) {
    var parsedFilter = expressionToGlsl(fragContext, style2.filter, ValueTypes.BOOLEAN);
    builder.setFragmentDiscardExpression("!".concat(parsedFilter));
  }
  var uniforms = {};
  fragContext.variables.forEach(function(varName) {
    var uniformName = uniformNameForVariable(varName);
    builder.addUniform("float ".concat(uniformName));
    uniforms[uniformName] = function() {
      if (!style2.variables || style2.variables[varName] === void 0) {
        throw new Error("The following variable is missing from the style: ".concat(varName));
      }
      var value = style2.variables[varName];
      if (typeof value === "string") {
        value = getStringNumberEquivalent(vertContext, value);
      }
      return value !== void 0 ? value : -9999999;
    };
  });
  if (symbStyle.symbolType === "image" && symbStyle.src) {
    var texture = new Image();
    texture.crossOrigin = symbStyle.crossOrigin === void 0 ? "anonymous" : symbStyle.crossOrigin;
    texture.src = symbStyle.src;
    builder.addUniform("sampler2D u_texture").setColorExpression(builder.getColorExpression() + " * texture2D(u_texture, v_texCoord)");
    uniforms["u_texture"] = texture;
  }
  fragContext.attributes.forEach(function(attrName) {
    if (vertContext.attributes.indexOf(attrName) === -1) {
      vertContext.attributes.push(attrName);
    }
    builder.addVarying("v_".concat(attrName), "float", "a_".concat(attrName));
  });
  vertContext.attributes.forEach(function(attrName) {
    builder.addAttribute("float a_".concat(attrName));
  });
  return {
    builder,
    attributes: vertContext.attributes.map(function(attributeName) {
      return {
        name: attributeName,
        callback: function(feature2, props) {
          var value = props[attributeName];
          if (typeof value === "string") {
            value = getStringNumberEquivalent(vertContext, value);
          }
          return value !== void 0 ? value : -9999999;
        }
      };
    }),
    uniforms
  };
}
var __extends$u = globalThis && globalThis.__extends || function() {
  var extendStatics2 = function(d2, b2) {
    extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {
      d3.__proto__ = b3;
    } || function(d3, b3) {
      for (var p5 in b3)
        if (Object.prototype.hasOwnProperty.call(b3, p5))
          d3[p5] = b3[p5];
    };
    return extendStatics2(d2, b2);
  };
  return function(d2, b2) {
    if (typeof b2 !== "function" && b2 !== null)
      throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
    extendStatics2(d2, b2);
    function __() {
      this.constructor = d2;
    }
    d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
  };
}();
var WebGLPointsLayer = function(_super) {
  __extends$u(WebGLPointsLayer2, _super);
  function WebGLPointsLayer2(options) {
    var _this = this;
    var baseOptions = assign({}, options);
    _this = _super.call(this, baseOptions) || this;
    _this.parseResult_ = parseLiteralStyle(options.style);
    _this.styleVariables_ = options.style.variables || {};
    _this.hitDetectionDisabled_ = !!options.disableHitDetection;
    return _this;
  }
  WebGLPointsLayer2.prototype.createRenderer = function() {
    return new WebGLPointsLayerRenderer$1(this, {
      vertexShader: this.parseResult_.builder.getSymbolVertexShader(),
      fragmentShader: this.parseResult_.builder.getSymbolFragmentShader(),
      hitVertexShader: !this.hitDetectionDisabled_ && this.parseResult_.builder.getSymbolVertexShader(true),
      hitFragmentShader: !this.hitDetectionDisabled_ && this.parseResult_.builder.getSymbolFragmentShader(true),
      uniforms: this.parseResult_.uniforms,
      attributes: this.parseResult_.attributes
    });
  };
  WebGLPointsLayer2.prototype.updateStyleVariables = function(variables) {
    assign(this.styleVariables_, variables);
    this.changed();
  };
  return WebGLPointsLayer2;
}(ol_layer_Base);
var WebGLPointsLayer$1 = WebGLPointsLayer;
var _sfc_main$W = {
  extends: BaseLayer,
  name: "ol-webglpoints-layer",
  setup(props) {
    const map = inject("map");
    const {
      properties
    } = usePropsAsObjectProperties(props);
    const webglPointsLayer = computed(() => new WebGLPointsLayer$1(properties));
    watch(properties, () => {
      webglPointsLayer.value.setProperties(properties);
    });
    onMounted(() => {
      map.addLayer(webglPointsLayer.value);
    });
    onUnmounted(() => {
      map.removeLayer(webglPointsLayer.value);
    });
    provide("webglPointsLayer", webglPointsLayer);
    return {
      webglPointsLayer
    };
  },
  props: {
    disableHitDetection: {
      type: Boolean,
      default: false
    },
    style: {
      type: Object,
      default: () => ({
        symbol: {
          symbolType: "circle",
          size: 8,
          color: "#33AAFF",
          opacity: 0.9
        }
      })
    }
  }
};
function _sfc_render$W(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", null, [
    renderSlot(_ctx.$slots, "default")
  ]);
}
var WebglPointsLayer = _export_sfc(_sfc_main$W, [["render", _sfc_render$W]]);
var __extends$t = globalThis && globalThis.__extends || function() {
  var extendStatics2 = function(d2, b2) {
    extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {
      d3.__proto__ = b3;
    } || function(d3, b3) {
      for (var p5 in b3)
        if (Object.prototype.hasOwnProperty.call(b3, p5))
          d3[p5] = b3[p5];
    };
    return extendStatics2(d2, b2);
  };
  return function(d2, b2) {
    if (typeof b2 !== "function" && b2 !== null)
      throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
    extendStatics2(d2, b2);
    function __() {
      this.constructor = d2;
    }
    d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
  };
}();
var Property$1 = {
  BLUR: "blur",
  GRADIENT: "gradient",
  RADIUS: "radius"
};
var DEFAULT_GRADIENT = ["#00f", "#0ff", "#0f0", "#ff0", "#f00"];
var Heatmap = function(_super) {
  __extends$t(Heatmap2, _super);
  function Heatmap2(opt_options) {
    var _this = this;
    var options = opt_options ? opt_options : {};
    var baseOptions = assign({}, options);
    delete baseOptions.gradient;
    delete baseOptions.radius;
    delete baseOptions.blur;
    delete baseOptions.weight;
    _this = _super.call(this, baseOptions) || this;
    _this.gradient_ = null;
    _this.addChangeListener(Property$1.GRADIENT, _this.handleGradientChanged_);
    _this.setGradient(options.gradient ? options.gradient : DEFAULT_GRADIENT);
    _this.setBlur(options.blur !== void 0 ? options.blur : 15);
    _this.setRadius(options.radius !== void 0 ? options.radius : 8);
    var weight = options.weight ? options.weight : "weight";
    if (typeof weight === "string") {
      _this.weightFunction_ = function(feature2) {
        return feature2.get(weight);
      };
    } else {
      _this.weightFunction_ = weight;
    }
    _this.setRenderOrder(null);
    return _this;
  }
  Heatmap2.prototype.getBlur = function() {
    return this.get(Property$1.BLUR);
  };
  Heatmap2.prototype.getGradient = function() {
    return this.get(Property$1.GRADIENT);
  };
  Heatmap2.prototype.getRadius = function() {
    return this.get(Property$1.RADIUS);
  };
  Heatmap2.prototype.handleGradientChanged_ = function() {
    this.gradient_ = createGradient(this.getGradient());
  };
  Heatmap2.prototype.setBlur = function(blur) {
    this.set(Property$1.BLUR, blur);
  };
  Heatmap2.prototype.setGradient = function(colors) {
    this.set(Property$1.GRADIENT, colors);
  };
  Heatmap2.prototype.setRadius = function(radius) {
    this.set(Property$1.RADIUS, radius);
  };
  Heatmap2.prototype.createRenderer = function() {
    return new WebGLPointsLayerRenderer$1(this, {
      className: this.getClassName(),
      attributes: [
        {
          name: "weight",
          callback: function(feature2) {
            var weight = this.weightFunction_(feature2);
            return weight !== void 0 ? clamp(weight, 0, 1) : 1;
          }.bind(this)
        }
      ],
      vertexShader: "\n        precision mediump float;\n        uniform mat4 u_projectionMatrix;\n        uniform mat4 u_offsetScaleMatrix;\n        uniform float u_size;\n        attribute vec2 a_position;\n        attribute float a_index;\n        attribute float a_weight;\n\n        varying vec2 v_texCoord;\n        varying float v_weight;\n\n        void main(void) {\n          mat4 offsetMatrix = u_offsetScaleMatrix;\n          float offsetX = a_index == 0.0 || a_index == 3.0 ? -u_size / 2.0 : u_size / 2.0;\n          float offsetY = a_index == 0.0 || a_index == 1.0 ? -u_size / 2.0 : u_size / 2.0;\n          vec4 offsets = offsetMatrix * vec4(offsetX, offsetY, 0.0, 0.0);\n          gl_Position = u_projectionMatrix * vec4(a_position, 0.0, 1.0) + offsets;\n          float u = a_index == 0.0 || a_index == 3.0 ? 0.0 : 1.0;\n          float v = a_index == 0.0 || a_index == 1.0 ? 0.0 : 1.0;\n          v_texCoord = vec2(u, v);\n          v_weight = a_weight;\n        }",
      fragmentShader: "\n        precision mediump float;\n        uniform float u_blurSlope;\n\n        varying vec2 v_texCoord;\n        varying float v_weight;\n\n        void main(void) {\n          vec2 texCoord = v_texCoord * 2.0 - vec2(1.0, 1.0);\n          float sqRadius = texCoord.x * texCoord.x + texCoord.y * texCoord.y;\n          float value = (1.0 - sqrt(sqRadius)) * u_blurSlope;\n          float alpha = smoothstep(0.0, 1.0, value) * v_weight;\n          gl_FragColor = vec4(alpha, alpha, alpha, alpha);\n        }",
      hitVertexShader: "\n        precision mediump float;\n        uniform mat4 u_projectionMatrix;\n        uniform mat4 u_offsetScaleMatrix;\n        uniform float u_size;\n        attribute vec2 a_position;\n        attribute float a_index;\n        attribute float a_weight;\n        attribute vec4 a_hitColor;\n\n        varying vec2 v_texCoord;\n        varying float v_weight;\n        varying vec4 v_hitColor;\n\n        void main(void) {\n          mat4 offsetMatrix = u_offsetScaleMatrix;\n          float offsetX = a_index == 0.0 || a_index == 3.0 ? -u_size / 2.0 : u_size / 2.0;\n          float offsetY = a_index == 0.0 || a_index == 1.0 ? -u_size / 2.0 : u_size / 2.0;\n          vec4 offsets = offsetMatrix * vec4(offsetX, offsetY, 0.0, 0.0);\n          gl_Position = u_projectionMatrix * vec4(a_position, 0.0, 1.0) + offsets;\n          float u = a_index == 0.0 || a_index == 3.0 ? 0.0 : 1.0;\n          float v = a_index == 0.0 || a_index == 1.0 ? 0.0 : 1.0;\n          v_texCoord = vec2(u, v);\n          v_hitColor = a_hitColor;\n          v_weight = a_weight;\n        }",
      hitFragmentShader: "\n        precision mediump float;\n        uniform float u_blurSlope;\n\n        varying vec2 v_texCoord;\n        varying float v_weight;\n        varying vec4 v_hitColor;\n\n        void main(void) {\n          vec2 texCoord = v_texCoord * 2.0 - vec2(1.0, 1.0);\n          float sqRadius = texCoord.x * texCoord.x + texCoord.y * texCoord.y;\n          float value = (1.0 - sqrt(sqRadius)) * u_blurSlope;\n          float alpha = smoothstep(0.0, 1.0, value) * v_weight;\n          if (alpha < 0.05) {\n            discard;\n          }\n\n          gl_FragColor = v_hitColor;\n        }",
      uniforms: {
        u_size: function() {
          return (this.get(Property$1.RADIUS) + this.get(Property$1.BLUR)) * 2;
        }.bind(this),
        u_blurSlope: function() {
          return this.get(Property$1.RADIUS) / Math.max(1, this.get(Property$1.BLUR));
        }.bind(this)
      },
      postProcesses: [
        {
          fragmentShader: "\n            precision mediump float;\n\n            uniform sampler2D u_image;\n            uniform sampler2D u_gradientTexture;\n            uniform float u_opacity;\n\n            varying vec2 v_texCoord;\n\n            void main() {\n              vec4 color = texture2D(u_image, v_texCoord);\n              gl_FragColor.a = color.a * u_opacity;\n              gl_FragColor.rgb = texture2D(u_gradientTexture, vec2(0.5, color.a)).rgb;\n              gl_FragColor.rgb *= gl_FragColor.a;\n            }",
          uniforms: {
            u_gradientTexture: function() {
              return this.gradient_;
            }.bind(this),
            u_opacity: function() {
              return this.getOpacity();
            }.bind(this)
          }
        }
      ]
    });
  };
  Heatmap2.prototype.renderDeclutter = function() {
  };
  return Heatmap2;
}(BaseVectorLayer$1);
function createGradient(colors) {
  var width = 1;
  var height = 256;
  var context = createCanvasContext2D(width, height);
  var gradient = context.createLinearGradient(0, 0, width, height);
  var step = 1 / (colors.length - 1);
  for (var i2 = 0, ii = colors.length; i2 < ii; ++i2) {
    gradient.addColorStop(i2 * step, colors[i2]);
  }
  context.fillStyle = gradient;
  context.fillRect(0, 0, width, height);
  return context.canvas;
}
var ol_layer_Heatmap = Heatmap;
var _sfc_main$V = {
  extends: BaseLayer,
  name: "ol-heatmap-layer",
  setup(props) {
    const map = inject("map");
    const {
      properties
    } = usePropsAsObjectProperties(props);
    const heatmapLayer = computed(() => new ol_layer_Heatmap(properties));
    watch(properties, () => {
      heatmapLayer.value.setProperties(properties);
    });
    onMounted(() => {
      map.addLayer(heatmapLayer.value);
    });
    onUnmounted(() => {
      map.removeLayer(heatmapLayer.value);
    });
    provide("heatmapLayer", heatmapLayer);
    provide("stylable", heatmapLayer);
    return {
      heatmapLayer
    };
  },
  props: {
    weight: {
      type: Function
    },
    extent: {
      type: Array
    },
    blur: {
      type: Number
    },
    radius: {
      type: Number
    }
  }
};
function _sfc_render$V(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", null, [
    renderSlot(_ctx.$slots, "default")
  ]);
}
var HeatmapLayer = _export_sfc(_sfc_main$V, [["render", _sfc_render$V]]);
function install$7(app) {
  if (install$7.installed) {
    return;
  }
  install$7.installed = true;
  app.component(TileLayer$1.name, TileLayer$1);
  app.component(WebGLTileLayer.name, WebGLTileLayer);
  app.component(ImageLayer.name, ImageLayer);
  app.component(VectorLayer.name, VectorLayer);
  app.component(AnimatedClusterLayer.name, AnimatedClusterLayer);
  app.component(WebglPointsLayer.name, WebglPointsLayer);
  app.component(HeatmapLayer.name, HeatmapLayer);
}
var Layers = Object.freeze(Object.defineProperty({
  __proto__: null,
  "default": install$7,
  install: install$7,
  TileLayer: TileLayer$1,
  WebGLTileLayer,
  ImageLayer,
  VectorLayer,
  AnimatedClusterLayer,
  WebglPointsLayer,
  HeatmapLayer
}, Symbol.toStringTag, { value: "Module" }));
var _sfc_main$U = {
  name: "ol-source-xyz",
  setup(props) {
    const layer = inject("tileLayer");
    const {
      properties
    } = usePropsAsObjectProperties(props);
    let source = computed(() => new XYZ$1(properties));
    watch(source, () => {
      layer.value.setSource(source.value);
    });
    watch(layer, () => {
      layer.value.setSource(source.value);
    });
    onMounted(() => {
      layer.value.setSource(source.value);
    });
    onUnmounted(() => {
      layer.value.setSource(null);
    });
    return {
      layer,
      source
    };
  },
  props: {
    attributions: {
      type: [String, Array]
    },
    url: {
      type: String
    },
    cacheSize: {
      type: Number,
      default: 2048
    },
    crossOrigin: {
      type: String
    },
    maxZoom: {
      type: Number,
      default: 28
    },
    minZoom: {
      type: Number,
      default: 0
    },
    opaque: {
      type: Boolean
    },
    projection: {
      type: String,
      default: "EPSG:3857"
    },
    reprojectionErrorThreshold: {
      type: Number,
      default: 0.5
    },
    tileSize: {
      type: Array,
      default: () => [256, 256]
    },
    tilePixelRatio: {
      type: Number,
      default: 1
    },
    tileKey: {
      type: String
    },
    transition: {
      type: Number
    },
    tileGrid: {
      type: Object
    }
  }
};
function _sfc_render$U(_ctx, _cache, $props, $setup, $data, $options) {
  return createCommentVNode("", true);
}
var SourceXYZ = _export_sfc(_sfc_main$U, [["render", _sfc_render$U]]);
var _sfc_main$T = {
  name: "ol-source-osm",
  setup(props) {
    const layer = inject("tileLayer");
    const {
      properties
    } = usePropsAsObjectProperties(props);
    let source = computed(() => new OSM$1(properties));
    watch(source, () => {
      layer.value.setSource(source.value);
    });
    watch(layer, () => {
      layer.value.setSource(source.value);
    });
    onMounted(() => {
      layer.value.setSource(source.value);
    });
    onUnmounted(() => {
      layer.value.setSource(null);
    });
    return {
      layer,
      source
    };
  },
  props: {
    attributions: {
      type: String
    },
    cacheSize: {
      type: Number,
      default: 2048
    },
    crossOrigin: {
      type: String,
      default: "anonymous"
    },
    imageSmoothing: {
      type: Boolean,
      default: true
    },
    minZoom: {
      type: Number,
      default: 0
    },
    maxZoom: {
      type: Number,
      default: 19
    },
    opaque: {
      type: Boolean,
      default: true
    },
    reprojectionErrorThreshold: {
      type: Number,
      default: 0.5
    },
    transition: {
      type: Number,
      default: 250
    },
    url: {
      type: String,
      default: "https://{a-c}.tile.openstreetmap.org/{z}/{x}/{y}.png"
    },
    wrapX: {
      type: Boolean,
      default: true
    }
  }
};
function _sfc_render$T(_ctx, _cache, $props, $setup, $data, $options) {
  return createCommentVNode("", true);
}
var SourceOSM = _export_sfc(_sfc_main$T, [["render", _sfc_render$T]]);
var _sfc_main$S = {
  name: "ol-source-image-static",
  setup(props) {
    const layer = inject("imageLayer");
    const {
      properties
    } = usePropsAsObjectProperties(props);
    const createSource = () => {
      return new Static$1(__spreadProps(__spreadValues({}, properties), {
        projection: typeof properties.projection == "string" ? properties.projection : new Projection$3(__spreadValues({}, properties.projection))
      }));
    };
    let source = createSource();
    watch(properties, () => {
      layer.setSource(null);
      source = createSource();
      layer.setSource(source);
    });
    onMounted(() => {
      layer.setSource(source);
    });
    onUnmounted(() => {
      layer.setSource(null);
    });
    return {
      layer,
      source
    };
  },
  props: {
    attributions: {
      type: String
    },
    crossOrigin: {
      type: String
    },
    imageExtent: {
      type: Array
    },
    projection: {
      type: [String, Object]
    },
    imageSmoothing: {
      type: Boolean,
      default: true
    },
    imageSize: {
      type: Array
    },
    url: {
      type: String
    }
  }
};
function _sfc_render$S(_ctx, _cache, $props, $setup, $data, $options) {
  return createCommentVNode("", true);
}
var SourceImageStatic = _export_sfc(_sfc_main$S, [["render", _sfc_render$S]]);
var _sfc_main$R = {
  name: "ol-source-wmts",
  setup(props) {
    const tileLayer = inject("tileLayer");
    const {
      properties
    } = usePropsAsObjectProperties(props);
    const extent2 = computed(() => get$3(properties.projection).getExtent());
    const origin = computed(() => getTopLeft(extent2.value));
    const size = computed(() => getWidth(extent2.value) / 256);
    const getTileGrid = computed(() => {
      const resolutions = new Array(properties.tileZoomLevel);
      const matrixIds = new Array(properties.tileZoomLevel);
      for (var z2 = 0; z2 < properties.tileZoomLevel; ++z2) {
        resolutions[z2] = size.value / Math.pow(2, z2);
        matrixIds[z2] = z2;
      }
      return new TileGridWMTS({
        origin: origin.value,
        resolutions,
        matrixIds
      });
    });
    const source = computed(() => new WMTSSource(__spreadProps(__spreadValues({}, properties), {
      projection: typeof properties.projection == "string" ? properties.projection : new Projection$3(__spreadValues({}, properties.projection)),
      tileGrid: getTileGrid.value
    })));
    watch(source, () => {
      tileLayer.value.setSource(source.value);
    });
    watch(tileLayer, () => {
      tileLayer.value.setSource(source.value);
    });
    onMounted(() => {
      tileLayer.value.setSource(source.value);
    });
    onUnmounted(() => {
      tileLayer.value.setSource(null);
    });
    return {
      tileLayer,
      source
    };
  },
  props: {
    tileZoomLevel: {
      type: Number,
      default: 30
    },
    attributions: {
      type: String
    },
    cacheSize: {
      type: Number
    },
    crossOrigin: {
      type: String
    },
    imageSmoothing: {
      type: Boolean,
      default: true
    },
    projection: {
      type: [String, Object],
      default: "EPSG:3857"
    },
    reprojectionErrorThreshold: {
      type: Number,
      default: 0.5
    },
    tilePixelRatio: {
      type: Number,
      default: 1
    },
    format: {
      type: String,
      default: "image/jpeg"
    },
    version: {
      type: String,
      default: "1.0.0"
    },
    matrixSet: {
      type: String
    },
    dimensions: {
      type: Object
    },
    requestEncoding: {
      type: String,
      default: "KVP"
    },
    url: {
      type: String
    },
    urls: {
      type: Array
    },
    wrapX: {
      type: Boolean,
      default: false
    },
    transition: {
      type: Number
    },
    layer: {
      type: String
    },
    style: {
      type: String
    }
  }
};
function _sfc_render$R(_ctx, _cache, $props, $setup, $data, $options) {
  return createCommentVNode("", true);
}
var SourceWMTS = _export_sfc(_sfc_main$R, [["render", _sfc_render$R]]);
var _sfc_main$Q = {
  name: "ol-source-vector",
  setup(props) {
    const layer = inject("vectorLayer") || inject("heatmapLayer");
    const {
      properties
    } = usePropsAsObjectProperties(props);
    let source = computed(() => new ol_source_Vector(properties));
    const applySource = () => {
      layer.value.setSource(null);
      layer.value.setSource(source.value);
      layer.value.changed();
    };
    watch(properties, () => {
      applySource();
    });
    watch(layer, () => {
      applySource();
    });
    onMounted(() => {
      layer.value.setSource(source.value);
    });
    onUnmounted(() => {
      layer.value.setSource(null);
    });
    provide("vectorSource", source);
    return {
      layer,
      source
    };
  },
  props: {
    attributions: {
      type: [String, Array]
    },
    features: {
      type: Array,
      default: () => []
    },
    format: {
      type: Object
    },
    loader: {
      type: Function
    },
    overlaps: {
      type: Boolean,
      default: true
    },
    projection: {
      type: String,
      default: "EPSG:3857"
    },
    strategy: {
      type: Function
    },
    url: {
      type: [String, Function]
    },
    useSpatialIndex: {
      type: Boolean,
      default: true
    },
    wrapX: {
      type: Boolean,
      default: true
    }
  }
};
function _sfc_render$Q(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", null, [
    renderSlot(_ctx.$slots, "default")
  ]);
}
var SourceVector = _export_sfc(_sfc_main$Q, [["render", _sfc_render$Q]]);
var _sfc_main$P = {
  name: "ol-source-cluster",
  setup(props) {
    const layer = inject("vectorLayer");
    const {
      properties
    } = usePropsAsObjectProperties(props);
    let source = computed(() => {
      let c2 = new Cluster$1(properties);
      return c2;
    });
    const applySource = () => {
      layer.value.setSource(null);
      layer.value.setSource(source.value);
      layer.value.changed();
    };
    watch(properties, () => {
      applySource();
    });
    watch(layer, () => {
      applySource();
    });
    onMounted(() => {
      layer.value.setSource(source.value);
      layer.value.changed();
    });
    onUnmounted(() => {
      layer.value.setSource(null);
    });
    provide("vectorLayer", source);
    return {
      layer,
      source
    };
  },
  props: {
    attributions: {
      type: [String, Array]
    },
    distance: {
      type: Number,
      default: 20
    },
    geometryFunction: {
      type: Function,
      default: (feature2) => feature2.getGeometry()
    },
    wrapX: {
      type: Boolean,
      default: true
    }
  }
};
function _sfc_render$P(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", null, [
    renderSlot(_ctx.$slots, "default")
  ]);
}
var SourceCluster = _export_sfc(_sfc_main$P, [["render", _sfc_render$P]]);
var _sfc_main$O = {
  name: "ol-source-bingmaps",
  setup(props) {
    const layer = inject("tileLayer");
    const {
      properties
    } = usePropsAsObjectProperties(props);
    let source = computed(() => new BingMaps$1(__spreadProps(__spreadValues({}, properties), {
      key: properties.apiKey
    })));
    watch(source, () => {
      layer.value.setSource(source.value);
    });
    watch(layer, () => {
      layer.value.setSource(source.value);
    });
    onMounted(() => {
      layer.value.setSource(source.value);
    });
    onUnmounted(() => {
      layer.value.setSource(null);
    });
    return {
      layer,
      source
    };
  },
  props: {
    cacheSize: {
      type: Number
    },
    hidpi: {
      type: Boolean,
      default: false
    },
    culture: {
      type: String,
      default: "en-us"
    },
    apiKey: {
      type: String
    },
    imagerySet: {
      type: String
    },
    imageSmoothing: {
      type: Boolean,
      default: true
    },
    maxZoom: {
      type: Number,
      default: 21
    },
    reprojectionErrorThreshold: {
      type: Number,
      default: 0.5
    },
    tileLoadFunction: {
      type: Function,
      default: (imageTile, src) => imageTile.getImage().src = src
    },
    wrapX: {
      type: Boolean,
      default: true
    },
    transition: {
      type: Number
    }
  }
};
function _sfc_render$O(_ctx, _cache, $props, $setup, $data, $options) {
  return createCommentVNode("", true);
}
var SourceBingMaps = _export_sfc(_sfc_main$O, [["render", _sfc_render$O]]);
var Tianditu = class extends WMTSSource {
  constructor(opt_options) {
    Tianditu.layerLabelMap = {
      vec: "cva",
      ter: "cta",
      img: "cia"
    };
    Tianditu.layerZoomMap = {
      vec: 18,
      ter: 14,
      img: 18
    };
    let options = opt_options || {};
    options.layerType = options.layerType || "vec";
    options.layerType = options.isLabel ? Tianditu.layerLabelMap[options.layerType] : options.layerType;
    options.matrixSet = options.projection === "EPSG:4326" || options.projection === "EPSG:4490" ? "c" : "w";
    if (!options.url && !options.urls) {
      options.url = "https://t{0-7}.tianditu.gov.cn/{layer}_{proj}/wmts?";
    }
    if (options.tk) {
      options.url = `${options.url}tk=${options.tk}`;
    }
    options.url = options.url.replace("{layer}", options.layerType).replace("{proj}", options.matrixSet);
    let tileGrid = options.tileGrid || Tianditu.getTileGrid(options.projection || "EPSG:3857");
    let crossOrigin = options.crossOrigin !== void 0 ? options.crossOrigin : "anonymous";
    let superOptions = {
      version: options.version || "1.0.0",
      format: options.format || "tiles",
      dimensions: options.dimensions || {},
      layer: options.layerType,
      matrixSet: options.matrixSet,
      tileGrid,
      style: options.style || "default",
      cacheSize: options.cacheSize,
      crossOrigin,
      opaque: options.opaque === void 0 ? true : options.opaque,
      maxZoom: Tianditu.layerZoomMap[options.layerType],
      reprojectionErrorThreshold: options.reprojectionErrorThreshold,
      url: options.url,
      urls: options.urls,
      projection: options.projection || "EPSG:3857",
      wrapX: options.wrapX
    };
    if (options.tileProxy) {
      superOptions.tileLoadFunction = tileLoadFunction;
    }
    super(superOptions);
    if (options.tileProxy) {
      this.tileProxy = options.tileProxy;
    }
    let me2 = this;
    function tileLoadFunction(imageTile, src) {
      imageTile.getImage().src = me2.tileProxy + encodeURIComponent(src);
    }
  }
  static getTileGrid(projection) {
    if (projection === "EPSG:4326" || projection === "EPSG:4490") {
      return Tianditu.default4326TileGrid();
    }
    return Tianditu.default3857TileGrid();
  }
  static default4326TileGrid() {
    let tdt_WGS84_resolutions = [];
    let matrixIds = [];
    for (let i2 = 1; i2 < 19; i2++) {
      tdt_WGS84_resolutions.push(0.703125 * 2 / Math.pow(2, i2));
      matrixIds.push(i2);
    }
    let tileGird = new TileGridWMTS({
      extent: [-180, -90, 180, 90],
      resolutions: tdt_WGS84_resolutions,
      origin: [-180, 90],
      matrixIds,
      minZoom: 1
    });
    return tileGird;
  }
  static default3857TileGrid() {
    let tdt_Mercator_resolutions = [];
    let matrixIds = [];
    for (let i2 = 1; i2 < 19; i2++) {
      tdt_Mercator_resolutions.push(78271.51696402031 * 2 / Math.pow(2, i2));
      matrixIds.push(i2);
    }
    let tileGird = new TileGridWMTS({
      extent: [
        -200375083427892e-7,
        -200375083427892e-7,
        200375083427892e-7,
        200375083427892e-7
      ],
      resolutions: tdt_Mercator_resolutions,
      matrixIds,
      origin: [-200375083427892e-7, 200375083427892e-7],
      minZoom: 1
    });
    return tileGird;
  }
};
var _sfc_main$N = {
  name: "ol-source-tianditu",
  setup(props) {
    const layer = inject("tileLayer");
    const { properties } = usePropsAsObjectProperties(props);
    let source = computed(() => {
      return new Tianditu(properties);
    });
    watch(source, () => {
      layer.value.setSource(source.value);
    });
    watch(layer, () => {
      layer.value.setSource(source.value);
    });
    onMounted(() => {
      layer.value.setSource(source.value);
    });
    onUnmounted(() => {
      layer.value.setSource(null);
    });
    return {
      layer,
      source
    };
  },
  props: {
    layerType: {
      type: String,
      default: "img"
    },
    tk: {
      type: String
    },
    isLabel: {
      type: Boolean,
      default: false
    },
    cacheSize: {
      type: Number
    },
    crossOrigin: {
      type: String
    },
    projection: {
      Type: String,
      default: "EPSG:3857"
    },
    hidpi: {
      type: Boolean,
      default: false
    },
    requestEncoding: {
      type: String,
      default: "KVP"
    },
    format: {
      type: String
    },
    version: {
      type: String,
      default: "1.0.0"
    },
    culture: {
      type: String,
      default: "en-us"
    },
    matrixSet: {
      type: String
    },
    dimensions: {
      type: Object,
      default: () => {
      }
    },
    imageSmoothing: {
      type: Boolean,
      default: true
    },
    maxZoom: {
      type: Number,
      default: 21
    },
    reprojectionErrorThreshold: {
      type: Number
    },
    tileLoadFunction: {
      type: Function,
      default: (imageTile, src) => imageTile.getImage().src = src
    },
    wrapX: {
      type: Boolean,
      default: true
    },
    transition: {
      type: Number
    }
  }
};
function _sfc_render$N(_ctx, _cache, $props, $setup, $data, $options) {
  return createCommentVNode("", true);
}
var SourceTianDiTu = _export_sfc(_sfc_main$N, [["render", _sfc_render$N]]);
var _sfc_main$M = {
  name: "ol-source-image-wms",
  setup(props) {
    const layer = inject("imageLayer");
    const {
      properties
    } = usePropsAsObjectProperties(props);
    const createSource = () => {
      return new ImageWMS$1(__spreadProps(__spreadValues({}, properties), {
        params: {
          "LAYERS": props.layers,
          "STYLES": props.styles,
          "TIME": props.time
        },
        projection: typeof properties.projection == "string" ? properties.projection : new Projection$3(__spreadValues({}, properties.projection))
      }));
    };
    let source = createSource();
    watch(properties, () => {
      layer.setSource(null);
      source = createSource();
      layer.setSource(source);
    });
    onMounted(() => {
      layer.setSource(source);
    });
    onUnmounted(() => {
      layer.setSource(null);
    });
    return {
      layer,
      source
    };
  },
  props: {
    attributions: {
      type: String
    },
    crossOrigin: {
      type: String
    },
    imageExtent: {
      type: Array
    },
    projection: {
      type: [String, Object],
      default: "EPSG:3857"
    },
    reprojectionErrorThreshold: {
      type: Number,
      default: 0.5
    },
    format: {
      type: String,
      default: "image/png"
    },
    version: {
      type: String,
      default: "1.3.0"
    },
    matrixSet: {
      type: String
    },
    serverType: {
      type: String,
      default: "mapserver"
    },
    imageSmoothing: {
      type: Boolean,
      default: true
    },
    layers: {
      type: [String, Array],
      required: true
    },
    styles: {
      type: [String, Array],
      default: ""
    },
    time: {
      type: String
    },
    ratio: {
      type: Number,
      default: 1
    },
    imageSize: {
      type: Array
    },
    url: {
      type: String
    },
    params: {
      type: Object
    },
    imageLoadFunction: {
      type: Function
    }
  }
};
function _sfc_render$M(_ctx, _cache, $props, $setup, $data, $options) {
  return createCommentVNode("", true);
}
var SourceImageWMS = _export_sfc(_sfc_main$M, [["render", _sfc_render$M]]);
var _sfc_main$L = {
  name: "ol-source-webglpoints",
  setup(props) {
    const layer = inject("webglPointsLayer");
    const {
      properties
    } = usePropsAsObjectProperties(props);
    let source = computed(() => new ol_source_Vector(properties));
    const applySource = () => {
      layer.value.setSource(null);
      layer.value.setSource(source.value);
      layer.value.changed();
    };
    watch(properties, () => {
      applySource();
    });
    watch(layer, () => {
      applySource();
    });
    onMounted(() => {
      layer.value.setSource(source.value);
    });
    onUnmounted(() => {
      layer.value.setSource(null);
    });
    provide("vectorSource", source);
    return {
      layer,
      source
    };
  },
  props: {
    attributions: {
      type: [String, Array]
    },
    features: {
      type: Array,
      default: () => []
    },
    format: {
      type: Object
    },
    loader: {
      type: Function
    },
    overlaps: {
      type: Boolean,
      default: true
    },
    projection: {
      type: String,
      default: "EPSG:3857"
    },
    strategy: {
      type: Function
    },
    url: {
      type: [String, Function]
    },
    useSpatialIndex: {
      type: Boolean,
      default: true
    },
    wrapX: {
      type: Boolean,
      default: true
    }
  }
};
function _sfc_render$L(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", null, [
    renderSlot(_ctx.$slots, "default")
  ]);
}
var SourceWebglPoints = _export_sfc(_sfc_main$L, [["render", _sfc_render$L]]);
function install$6(app) {
  if (install$6.installed) {
    return;
  }
  install$6.installed = true;
  app.component(SourceXYZ.name, SourceXYZ);
  app.component(SourceOSM.name, SourceOSM);
  app.component(SourceImageStatic.name, SourceImageStatic);
  app.component(SourceWMTS.name, SourceWMTS);
  app.component(SourceVector.name, SourceVector);
  app.component(SourceCluster.name, SourceCluster);
  app.component(SourceBingMaps.name, SourceBingMaps);
  app.component(SourceTianDiTu.name, SourceTianDiTu);
  app.component(SourceImageWMS.name, SourceImageWMS);
  app.component(SourceWebglPoints.name, SourceWebglPoints);
}
var Sources = Object.freeze(Object.defineProperty({
  __proto__: null,
  "default": install$6,
  install: install$6,
  SourceXYZ,
  SourceOSM,
  SourceImageStatic,
  SourceWMTS,
  SourceVector,
  SourceCluster,
  SourceTianDiTu,
  SourceImageWMS,
  SourceWebglPoints,
  SourceBingMaps
}, Symbol.toStringTag, { value: "Module" }));
function useControl(ControlType, props, context) {
  const map = inject("map");
  const controlBar = inject("controlBar", null);
  const parent = controlBar != null ? controlBar.value : map;
  const {
    properties
  } = usePropsAsObjectProperties(props);
  let control = computed(() => new ControlType(__spreadValues({}, properties)));
  control.value.set("order", context.attrs.order == void 0 ? 0 : context.attrs.order);
  watch(control, (newVal, oldVal) => {
    if (parent.removeControl) {
      parent.removeControl(oldVal);
      parent.addControl(newVal);
      map.changed();
    }
  });
  onMounted(() => {
    parent.addControl(control.value);
    if (parent.controls_ != void 0) {
      let sortedControls = [...parent.controls_];
      sortedControls.sort((a2, b2) => a2.get("order") - b2.get("order"));
      parent.controls_ = [];
      sortedControls.forEach((c2) => {
        parent.addControl(c2);
      });
      parent.changed();
    }
    map.changed();
  });
  onUnmounted(() => {
    if (parent.removeControl) {
      parent.removeControl(control.value);
    } else {
      let index2 = parent.controls_.findIndex((a2) => a2 == control.value);
      parent.controls_.splice(index2, 1);
      control.value.dispose();
    }
    map.changed();
  });
  return {
    map,
    control
  };
}
var _sfc_main$K = {
  name: "ol-fullscreen-control",
  setup(props, context) {
    const {
      control
    } = useControl(FullScreen$1, props, context);
    return {
      control
    };
  },
  props: {
    className: {
      type: String,
      default: "ol-full-screen"
    },
    label: {
      type: String,
      default: "\u2922"
    },
    labelActive: {
      type: String,
      default: "\xD7"
    },
    activeClassName: {
      type: String,
      default: "ol-full-screen-true"
    },
    inactiveClassName: {
      type: String,
      default: "ol-full-screen-false"
    },
    tipLabel: {
      type: String,
      default: "Toggle full-screen"
    },
    keys: {
      type: Boolean,
      default: false
    },
    target: {
      type: Object,
      default: void 0
    },
    source: {
      type: Object,
      default: void 0
    }
  }
};
function _sfc_render$K(_ctx, _cache, $props, $setup, $data, $options) {
  return createCommentVNode("", true);
}
var FullScreenControl = _export_sfc(_sfc_main$K, [["render", _sfc_render$K]]);
var _sfc_main$J = {
  name: "ol-mouseposition-control",
  setup(props, context) {
    const {
      control
    } = useControl(MousePosition$1, props, context);
    return {
      control
    };
  },
  props: {
    className: {
      type: String,
      default: "ol-mouse-position"
    },
    coordinateFormat: {
      type: [String, Function]
    },
    projection: {
      type: String
    },
    render: {
      type: Function
    },
    target: {
      type: HTMLElement
    },
    undefinedHTML: {
      type: String,
      default: "&#160;"
    }
  }
};
function _sfc_render$J(_ctx, _cache, $props, $setup, $data, $options) {
  return createCommentVNode("", true);
}
var MousePositionControl = _export_sfc(_sfc_main$J, [["render", _sfc_render$J]]);
var _sfc_main$I = {
  name: "ol-attribution-control",
  setup(props, context) {
    const {
      control
    } = useControl(Attribution$1, props, context);
    return {
      control
    };
  },
  props: {
    className: {
      type: String,
      default: "ol-attribution"
    },
    target: {
      type: HTMLElement
    },
    collapsible: {
      type: Boolean
    },
    collapsed: {
      type: Boolean,
      default: true
    },
    tipLabel: {
      type: String,
      default: "Attributions"
    },
    label: {
      type: String,
      default: "i"
    },
    expandClassName: {
      type: String,
      default: "ol-attribution-expand"
    },
    collapseLabel: {
      type: String,
      default: "\xBB"
    },
    collapseClassName: {
      type: String,
      default: "ol-attribution-collapse"
    },
    render: {
      type: Function
    }
  }
};
function _sfc_render$I(_ctx, _cache, $props, $setup, $data, $options) {
  return createCommentVNode("", true);
}
var AttributionControl = _export_sfc(_sfc_main$I, [["render", _sfc_render$I]]);
var _sfc_main$H = {
  name: "ol-overviewmap-control",
  setup(props, context) {
    const map = inject("map");
    const {
      control
    } = useControl(OverviewMap$1, props, context);
    onMounted(() => {
      control.value.setMap(map);
    });
    onUnmounted(() => {
      control.value.setMap(null);
    });
    provide("overviewMap", control);
    return {
      control
    };
  },
  props: {
    className: {
      type: String,
      default: "ol-overviewmap"
    },
    collapsed: {
      type: Boolean,
      default: true
    },
    collapseLabel: {
      type: String,
      default: "\xAB"
    },
    collapsible: {
      type: Boolean,
      default: true
    },
    label: {
      type: String,
      default: "\xBB"
    },
    render: {
      type: Function
    },
    rotateWithView: {
      type: Boolean,
      default: false
    },
    target: {
      type: HTMLElement
    },
    tipLabel: {
      type: String,
      default: "Overview map"
    }
  }
};
function _sfc_render$H(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", null, [
    renderSlot(_ctx.$slots, "default")
  ]);
}
var OverviewMapControl = _export_sfc(_sfc_main$H, [["render", _sfc_render$H]]);
var _sfc_main$G = {
  name: "ol-scaleline-control",
  setup(props, context) {
    const {
      control
    } = useControl(ScaleLine$1, props, context);
    return {
      control
    };
  },
  props: {
    className: {
      type: String,
      default: "ol-scale-line"
    },
    minWidth: {
      type: Number,
      default: 64
    },
    render: {
      type: Function
    },
    target: {
      type: HTMLElement
    },
    units: {
      type: String,
      default: "metric"
    },
    bar: {
      type: Boolean,
      default: false
    },
    steps: {
      type: Number,
      default: 4
    },
    text: {
      type: Boolean,
      default: false
    },
    dpi: {
      type: Number,
      default: void 0
    }
  }
};
function _sfc_render$G(_ctx, _cache, $props, $setup, $data, $options) {
  return createCommentVNode("", true);
}
var ScaleLineControl = _export_sfc(_sfc_main$G, [["render", _sfc_render$G]]);
var _sfc_main$F = {
  name: "ol-zoom-control",
  setup(props, context) {
    const {
      control
    } = useControl(Zoom$1, props, context);
    return {
      control
    };
  },
  props: {
    duration: {
      type: Number,
      default: 250
    },
    className: {
      type: String,
      default: "ol-zoom"
    },
    zoomInClassName: {
      type: String,
      default: "ol-zoom-in"
    },
    zoomOutClassName: {
      type: String,
      default: "ol-zoom-out"
    },
    zoomInLabel: {
      type: String,
      default: "+"
    },
    zoomOutLabel: {
      type: String,
      default: "-"
    },
    zoomInTipLabel: {
      type: String,
      default: "Zoom in"
    },
    zoomOutTipLabel: {
      type: String,
      default: "Zoom Out"
    },
    delta: {
      type: Number,
      default: 1
    },
    target: {
      type: HTMLElement
    }
  }
};
function _sfc_render$F(_ctx, _cache, $props, $setup, $data, $options) {
  return createCommentVNode("", true);
}
var ZoomControl = _export_sfc(_sfc_main$F, [["render", _sfc_render$F]]);
var _sfc_main$E = {
  name: "ol-zoomslider-control",
  setup(props, context) {
    const {
      control
    } = useControl(ZoomSlider$1, props, context);
    return {
      control
    };
  },
  props: {
    duration: {
      type: Number,
      default: 200
    },
    className: {
      type: String,
      default: "ol-zoomslider"
    },
    render: {
      type: Function
    }
  }
};
function _sfc_render$E(_ctx, _cache, $props, $setup, $data, $options) {
  return createCommentVNode("", true);
}
var ZoomSliderControl = _export_sfc(_sfc_main$E, [["render", _sfc_render$E]]);
var _sfc_main$D = {
  name: "ol-zoomtoextent-control",
  setup(props, context) {
    const {
      control
    } = useControl(ZoomToExtent$1, props, context);
    return {
      control
    };
  },
  props: {
    className: {
      type: String,
      default: "ol-zoom-extent"
    },
    target: {
      type: HTMLElement
    },
    label: {
      type: String,
      default: "E"
    },
    tipLabel: {
      type: String,
      default: "Fit to extent"
    },
    extent: {
      type: Array
    }
  }
};
function _sfc_render$D(_ctx, _cache, $props, $setup, $data, $options) {
  return createCommentVNode("", true);
}
var ZoomToExtentControl = _export_sfc(_sfc_main$D, [["render", _sfc_render$D]]);
var _sfc_main$C = {
  name: "ol-rotate-control",
  setup(props, context) {
    const {
      control
    } = useControl(Rotate$2, props, context);
    return {
      control
    };
  },
  props: {
    className: {
      type: String,
      default: "ol-rotate"
    },
    label: {
      type: String,
      default: "\u21E7"
    },
    tipLabel: {
      type: String,
      default: "Reset rotation"
    },
    compassClassName: {
      type: String,
      default: "ol-compass"
    },
    duration: {
      type: Number,
      default: 250
    },
    autoHide: {
      type: Boolean,
      default: false
    },
    render: {
      type: Function
    },
    resetNorth: {
      type: Function
    },
    target: {
      type: HTMLElement
    }
  }
};
function _sfc_render$C(_ctx, _cache, $props, $setup, $data, $options) {
  return createCommentVNode("", true);
}
var RotateControl = _export_sfc(_sfc_main$C, [["render", _sfc_render$C]]);
var olContextmenu$1 = { exports: {} };
var require$$0 = getAugmentedNamespace(Control$2);
(function(module, exports2) {
  !function(t3, e2) {
    module.exports = e2(require$$0);
  }(commonjsGlobal, function(t3) {
    function e2(t4) {
      return t4 && typeof t4 == "object" && "default" in t4 ? t4 : { default: t4 };
    }
    var n2 = e2(t3), i2 = "ol-ctx-menu", o2 = { namespace: i2, container: i2 + "-container", separator: i2 + "-separator", submenu: i2 + "-submenu", hidden: i2 + "-hidden", icon: i2 + "-icon", zoomIn: i2 + "-zoom-in", zoomOut: i2 + "-zoom-out", unselectable: "ol-unselectable" }, s2 = o2, a2 = "beforeopen", r2 = "open", l2 = "close", c2 = "contextmenu", h2 = { width: 150, scrollAt: 4, eventType: c2, defaultItems: true }, p5 = [{ text: "Zoom In", classname: o2.zoomIn + " " + o2.icon, callback: function(t4, e3) {
      var n3 = e3.getView();
      n3.animate({ zoom: +n3.getZoom() + 1, duration: 700, center: t4.coordinate });
    } }, { text: "Zoom Out", classname: o2.zoomOut + " " + o2.icon, callback: function(t4, e3) {
      var n3 = e3.getView();
      n3.animate({ zoom: +n3.getZoom() - 1, duration: 700, center: t4.coordinate });
    } }];
    function u2(t4, e3) {
      if (e3 === void 0 && (e3 = "Assertion failed"), !t4) {
        if (typeof Error != "undefined")
          throw new Error(e3);
        throw e3;
      }
    }
    function d2(t4) {
      return /^\d+$/.test(t4);
    }
    function m2(t4, e3) {
      return t4.classList ? t4.classList.contains(e3) : g2(e3).test(t4.className);
    }
    function f2(t4, e3, n3) {
      e3 === void 0 && (e3 = window.document);
      var i3 = Array.prototype.slice, o3 = [];
      if (/^(#?[\w-]+|\.[\w-.]+)$/.test(t4))
        switch (t4[0]) {
          case "#":
            o3 = [y2(t4.substr(1))];
            break;
          case ".":
            o3 = i3.call(e3.getElementsByClassName(t4.substr(1).replace(/\./g, " ")));
            break;
          default:
            o3 = i3.call(e3.getElementsByTagName(t4));
        }
      else
        o3 = i3.call(e3.querySelectorAll(t4));
      return n3 ? o3 : o3[0];
    }
    function y2(t4) {
      return t4 = t4[0] === "#" ? t4.substr(1, t4.length) : t4, document.getElementById(t4);
    }
    function v2(t4) {
      var e3 = document.createDocumentFragment(), n3 = document.createElement("div");
      for (n3.innerHTML = t4; n3.firstChild; )
        e3.appendChild(n3.firstChild);
      return e3;
    }
    function g2(t4) {
      return new RegExp("(^|\\s+) " + t4 + " (\\s+|$)");
    }
    function b2(t4, e3, n3) {
      t4.classList ? t4.classList.add(e3) : t4.className = (t4.className + " " + e3).trim(), n3 && d2(n3) && window.setTimeout(function() {
        return C2(t4, e3);
      }, n3);
    }
    function C2(t4, e3, n3) {
      t4.classList ? t4.classList.remove(e3) : t4.className = t4.className.replace(g2(e3), " ").trim(), n3 && d2(n3) && window.setTimeout(function() {
        return b2(t4, e3);
      }, n3);
    }
    var E2 = function(t4) {
      return this.Base = t4, this.map = void 0, this.viewport = void 0, this.coordinateClicked = void 0, this.pixelClicked = void 0, this.lineHeight = 0, this.items = {}, this.opened = false, this.submenu = { left: t4.options.width - 15 + "px", lastLeft: "" }, this.eventHandler = this.handleEvent.bind(this), this.eventMapMoveHandler = this.handleMapMoveEvent.bind(this), this;
    };
    E2.prototype.init = function(t4) {
      this.map = t4, this.viewport = t4.getViewport(), this.setListeners(), this.Base.Html.createMenu(), this.lineHeight = this.getItemsLength() > 0 ? this.Base.container.offsetHeight / this.getItemsLength() : this.Base.Html.cloneAndGetLineHeight();
    }, E2.prototype.getItemsLength = function() {
      var t4 = this, e3 = 0;
      return Object.keys(this.items).forEach(function(n3) {
        t4.items[n3].submenu || t4.items[n3].separator || e3++;
      }), e3;
    }, E2.prototype.getPixelClicked = function() {
      return this.pixelClicked;
    }, E2.prototype.getCoordinateClicked = function() {
      return this.coordinateClicked;
    }, E2.prototype.positionContainer = function(t4) {
      var e3 = this, n3 = this.Base.container, i3 = this.map.getSize(), o3 = i3[1] - t4[1], a3 = i3[0] - t4[0], r3 = n3.offsetWidth, l3 = Math.round(this.lineHeight * this.getItemsLength()), c3 = f2("li." + s2.submenu + ">div", n3, true);
      a3 >= r3 ? (n3.style.right = "auto", n3.style.left = t4[0] + 5 + "px") : (n3.style.left = "auto", n3.style.right = "15px"), o3 >= l3 ? (n3.style.bottom = "auto", n3.style.top = t4[1] - 10 + "px") : (n3.style.top = "auto", n3.style.bottom = 0), function t5(e4, n4, i4) {
        if (Array.isArray(e4))
          e4.forEach(function(e5) {
            return t5(e5, n4, i4);
          });
        else
          for (var o4 = Array.isArray(n4) ? n4 : n4.split(/\s+/), s3 = o4.length; s3--; )
            m2(e4, o4[s3]) && C2(e4, o4[s3], i4);
      }(n3, s2.hidden), c3.length && (this.submenu.lastLeft = a3 < 2 * r3 ? "-" + r3 + "px" : this.submenu.left, c3.forEach(function(t5) {
        var n4, i4, s3, a4 = { w: window.innerWidth || document.documentElement.clientWidth, h: window.innerHeight || document.documentElement.clientHeight }, r4 = (i4 = (n4 = t5).getBoundingClientRect(), s3 = document.documentElement, { left: i4.left + window.pageXOffset - s3.clientLeft, top: i4.top + window.pageYOffset - s3.clientTop, width: n4.offsetWidth, height: n4.offsetHeight }), l4 = r4.height, c4 = o3 - l4;
        c4 < 0 && (c4 = l4 - (a4.h - r4.top), t5.style.top = "-" + c4 + "px"), t5.style.left = e3.submenu.lastLeft;
      }));
    }, E2.prototype.openMenu = function(t4, e3) {
      this.Base.dispatchEvent({ type: r2, pixel: t4, coordinate: e3 }), this.opened = true, this.positionContainer(t4);
    }, E2.prototype.closeMenu = function() {
      this.opened = false, function t4(e3, n3, i3) {
        if (Array.isArray(e3))
          e3.forEach(function(e4) {
            return t4(e4, n3);
          });
        else
          for (var o3 = Array.isArray(n3) ? n3 : n3.split(/\s+/), s3 = o3.length; s3--; )
            m2(e3, o3[s3]) || b2(e3, o3[s3], i3);
      }(this.Base.container, s2.hidden), this.Base.dispatchEvent({ type: l2 });
    }, E2.prototype.setListeners = function() {
      this.viewport.addEventListener(this.Base.options.eventType, this.eventHandler, false), this.map.on("movestart", this.eventMapMoveHandler);
    }, E2.prototype.removeListeners = function() {
      this.viewport.removeEventListener(this.Base.options.eventType, this.eventHandler, false), this.map.un("movestart", this.eventMapMoveHandler);
    }, E2.prototype.handleEvent = function(t4) {
      var e3 = this;
      this.coordinateClicked = this.map.getEventCoordinate(t4), this.pixelClicked = this.map.getEventPixel(t4), this.Base.dispatchEvent({ type: a2, pixel: this.pixelClicked, coordinate: this.coordinateClicked }), this.Base.disabled || (this.Base.options.eventType === c2 && (t4.stopPropagation(), t4.preventDefault()), this.openMenu(this.pixelClicked, this.coordinateClicked), t4.target.addEventListener("pointerdown", { handleEvent: function(n3) {
        e3.opened && (e3.closeMenu(), n3.stopPropagation(), t4.target.removeEventListener(n3.type, this, false));
      } }, false));
    }, E2.prototype.handleMapMoveEvent = function(t4) {
      this.closeMenu();
    }, E2.prototype.setItemListener = function(t4, e3) {
      var n3, i3 = this;
      t4 && typeof this.items[e3].callback == "function" && (n3 = this.items[e3].callback, t4.addEventListener("click", function(t5) {
        t5.preventDefault();
        var o3 = { coordinate: i3.getCoordinateClicked(), data: i3.items[e3].data || null };
        i3.closeMenu(), n3(o3, i3.map);
      }, false));
    };
    var w2 = function(t4) {
      return this.Base = t4, this.Base.container = this.container = this.createContainer(true), this;
    };
    return w2.prototype.createContainer = function(t4) {
      var e3 = document.createElement("div"), n3 = document.createElement("ul"), i3 = [s2.container, s2.unselectable];
      return t4 && i3.push(s2.hidden), e3.className = i3.join(" "), e3.style.width = parseInt(this.Base.options.width, 10) + "px", e3.appendChild(n3), e3;
    }, w2.prototype.createMenu = function() {
      var t4 = [];
      if ("items" in this.Base.options ? t4 = this.Base.options.defaultItems ? this.Base.options.items.concat(p5) : this.Base.options.items : this.Base.options.defaultItems && (t4 = p5), t4.length === 0)
        return false;
      t4.forEach(this.addMenuEntry, this);
    }, w2.prototype.addMenuEntry = function(t4) {
      var e3, n3 = this;
      if (t4.items && Array.isArray(t4.items)) {
        t4.classname = t4.classname || "", e3 = s2.submenu, ~t4.classname.indexOf(e3) || (t4.classname = t4.classname.length ? " " + s2.submenu : s2.submenu);
        var i3 = this.generateHtmlAndPublish(this.container, t4), o3 = this.createContainer();
        o3.style.left = this.Base.Internal.submenu.lastLeft || this.Base.Internal.submenu.left, i3.appendChild(o3), t4.items.forEach(function(t5) {
          n3.generateHtmlAndPublish(o3, t5, true);
        });
      } else
        this.generateHtmlAndPublish(this.container, t4);
    }, w2.prototype.generateHtmlAndPublish = function(t4, e3, n3) {
      var i3, o3, a3 = "_" + Math.random().toString(36).substr(2, 9), r3 = false;
      return typeof e3 == "string" && e3.trim() === "-" ? (i3 = v2('<li id="' + a3 + '" class="' + s2.separator + '"><hr></li>'), o3 = [].slice.call(i3.childNodes, 0)[0], t4.firstChild.appendChild(i3), r3 = true) : (e3.classname = e3.classname || "", i3 = v2("<span>" + e3.text + "</span>"), o3 = document.createElement("li"), e3.icon && (e3.classname === "" ? e3.classname = s2.icon : e3.classname.indexOf(s2.icon) === -1 && (e3.classname += " " + s2.icon), o3.setAttribute("style", "background-image:url(" + e3.icon + ")")), o3.id = a3, o3.className = e3.classname, o3.appendChild(i3), t4.firstChild.appendChild(o3)), this.Base.Internal.items[a3] = { id: a3, submenu: n3 || 0, separator: r3, callback: e3.callback, data: e3.data || null }, this.Base.Internal.setItemListener(o3, a3), o3;
    }, w2.prototype.removeMenuEntry = function(t4) {
      var e3 = f2("#" + t4, this.container.firstChild);
      e3 && this.container.firstChild.removeChild(e3), delete this.Base.Internal.items[t4];
    }, w2.prototype.cloneAndGetLineHeight = function() {
      var t4 = this.container.cloneNode(), e3 = v2("<span>Foo</span>"), n3 = v2("<span>Foo</span>"), i3 = document.createElement("li"), o3 = document.createElement("li");
      i3.appendChild(e3), o3.appendChild(n3), t4.appendChild(i3), t4.appendChild(o3), this.container.parentNode.appendChild(t4);
      var s3 = t4.offsetHeight / 2;
      return this.container.parentNode.removeChild(t4), s3;
    }, function(t4) {
      function e3(e4) {
        e4 === void 0 && (e4 = {}), u2(typeof e4 == "object", "@param `opt_options` should be object type!"), this.options = function(t5, e5) {
          var n3 = {};
          for (var i3 in t5)
            n3[i3] = t5[i3];
          for (var o3 in e5)
            n3[o3] = e5[o3];
          return n3;
        }(h2, e4), this.disabled = false, this.Internal = new E2(this), this.Html = new w2(this), t4.call(this, { element: this.container });
      }
      return t4 && (e3.__proto__ = t4), e3.prototype = Object.create(t4 && t4.prototype), e3.prototype.constructor = e3, e3.prototype.clear = function() {
        Object.keys(this.Internal.items).forEach(this.Html.removeMenuEntry, this.Html);
      }, e3.prototype.close = function() {
        this.Internal.closeMenu();
      }, e3.prototype.enable = function() {
        this.disabled = false;
      }, e3.prototype.disable = function() {
        this.disabled = true;
      }, e3.prototype.getDefaultItems = function() {
        return p5;
      }, e3.prototype.countItems = function() {
        return Object.keys(this.Internal.items).length;
      }, e3.prototype.extend = function(t5) {
        u2(Array.isArray(t5), "@param `arr` should be an Array."), t5.forEach(this.push, this);
      }, e3.prototype.isOpen = function() {
        return this.Internal.opened;
      }, e3.prototype.updatePosition = function(t5) {
        u2(Array.isArray(t5), "@param `pixel` should be an Array."), this.isOpen() && this.Internal.positionContainer(t5);
      }, e3.prototype.pop = function() {
        var t5 = Object.keys(this.Internal.items);
        this.Html.removeMenuEntry(t5[t5.length - 1]);
      }, e3.prototype.push = function(t5) {
        u2(t5 != null, "@param `item` must be informed."), this.Html.addMenuEntry(t5);
      }, e3.prototype.shift = function() {
        this.Html.removeMenuEntry(Object.keys(this.Internal.items)[0]);
      }, e3.prototype.setMap = function(e4) {
        t4.prototype.setMap.call(this, e4), e4 ? this.Internal.init(e4, this) : this.Internal.removeListeners();
      }, e3;
    }(n2.default);
  });
})(olContextmenu$1);
var ContextMenu = olContextmenu$1.exports;
var _sfc_main$B = {
  name: "ol-context-menu",
  setup(props, context) {
    const {
      control
    } = useControl(ContextMenu, props, context);
    return {
      control
    };
  },
  props: {
    eventType: {
      type: String,
      default: "contextmenu"
    },
    defaultItems: {
      type: Boolean,
      default: true
    },
    width: {
      type: Number,
      default: 150
    },
    items: {
      type: Array,
      default: () => []
    }
  }
};
function _sfc_render$B(_ctx, _cache, $props, $setup, $data, $options) {
  return createCommentVNode("", true);
}
var ContextMenuControl = _export_sfc(_sfc_main$B, [["render", _sfc_render$B]]);
var ol_control_Swipe = function(options) {
  options = options || {};
  var button = document.createElement("button");
  var element = document.createElement("div");
  element.className = (options.className || "ol-swipe") + " ol-unselectable ol-control";
  element.appendChild(button);
  element.addEventListener("mousedown", this.move.bind(this));
  element.addEventListener("touchstart", this.move.bind(this));
  ol_control_Control.call(this, {
    element
  });
  this.precomposeRight_ = this.precomposeRight.bind(this);
  this.precomposeLeft_ = this.precomposeLeft.bind(this);
  this.postcompose_ = this.postcompose.bind(this);
  this.layers = [];
  if (options.layers)
    this.addLayer(options.layers, false);
  if (options.rightLayers)
    this.addLayer(options.rightLayers, true);
  this.on("propertychange", function(e2) {
    if (this.getMap()) {
      try {
        this.getMap().renderSync();
      } catch (e3) {
      }
    }
    if (this.get("orientation") === "horizontal") {
      this.element.style.top = this.get("position") * 100 + "%";
      this.element.style.left = "";
    } else {
      if (this.get("orientation") !== "vertical")
        this.set("orientation", "vertical");
      this.element.style.left = this.get("position") * 100 + "%";
      this.element.style.top = "";
    }
    if (e2.key === "orientation") {
      this.element.classList.remove("horizontal", "vertical");
      this.element.classList.add(this.get("orientation"));
    }
    if (!this.isMoving) {
      this.layers.forEach(function(l2) {
        if (l2.layer.getImageRatio)
          l2.layer.changed();
      });
    }
  }.bind(this));
  this.set("position", options.position || 0.5);
  this.set("orientation", options.orientation || "vertical");
};
ol_ext_inherits(ol_control_Swipe, ol_control_Control);
ol_control_Swipe.prototype.setMap = function(map) {
  var i2;
  var l2;
  if (this.getMap()) {
    for (i2 = 0; i2 < this.layers.length; i2++) {
      l2 = this.layers[i2];
      if (l2.right)
        l2.layer.un(["precompose", "prerender"], this.precomposeRight_);
      else
        l2.layer.un(["precompose", "prerender"], this.precomposeLeft_);
      l2.layer.un(["postcompose", "postrender"], this.postcompose_);
    }
    try {
      this.getMap().renderSync();
    } catch (e2) {
    }
  }
  ol_control_Control.prototype.setMap.call(this, map);
  if (map) {
    this._listener = [];
    for (i2 = 0; i2 < this.layers.length; i2++) {
      l2 = this.layers[i2];
      if (l2.right)
        l2.layer.on(["precompose", "prerender"], this.precomposeRight_);
      else
        l2.layer.on(["precompose", "prerender"], this.precomposeLeft_);
      l2.layer.on(["postcompose", "postrender"], this.postcompose_);
    }
    try {
      map.renderSync();
    } catch (e2) {
    }
  }
};
ol_control_Swipe.prototype.isLayer_ = function(layer) {
  for (var k2 = 0; k2 < this.layers.length; k2++) {
    if (this.layers[k2].layer === layer)
      return k2;
  }
  return -1;
};
ol_control_Swipe.prototype.addLayer = function(layers, right) {
  if (!(layers instanceof Array))
    layers = [layers];
  for (var i2 = 0; i2 < layers.length; i2++) {
    var l2 = layers[i2];
    if (this.isLayer_(l2) < 0) {
      this.layers.push({ layer: l2, right });
      if (this.getMap()) {
        if (right)
          l2.on(["precompose", "prerender"], this.precomposeRight_);
        else
          l2.on(["precompose", "prerender"], this.precomposeLeft_);
        l2.on(["postcompose", "postrender"], this.postcompose_);
        try {
          this.getMap().renderSync();
        } catch (e2) {
        }
      }
    }
  }
};
ol_control_Swipe.prototype.removeLayers = function() {
  var layers = [];
  this.layers.forEach(function(l2) {
    layers.push(l2.layer);
  });
  this.removeLayer(layers);
};
ol_control_Swipe.prototype.removeLayer = function(layers) {
  if (!(layers instanceof Array))
    layers = [layers];
  for (var i2 = 0; i2 < layers.length; i2++) {
    var k2 = this.isLayer_(layers[i2]);
    if (k2 >= 0 && this.getMap()) {
      if (this.layers[k2].right)
        layers[i2].un(["precompose", "prerender"], this.precomposeRight_);
      else
        layers[i2].un(["precompose", "prerender"], this.precomposeLeft_);
      layers[i2].un(["postcompose", "postrender"], this.postcompose_);
      this.layers.splice(k2, 1);
    }
  }
  if (this.getMap()) {
    try {
      this.getMap().renderSync();
    } catch (e2) {
    }
  }
};
ol_control_Swipe.prototype.getRectangle = function() {
  var s2;
  if (this.get("orientation") === "vertical") {
    s2 = this.getMap().getSize();
    return [0, 0, s2[0] * this.get("position"), s2[1]];
  } else {
    s2 = this.getMap().getSize();
    return [0, 0, s2[0], s2[1] * this.get("position")];
  }
};
ol_control_Swipe.prototype.move = function(e2) {
  var self2 = this;
  var l2;
  if (!this._movefn)
    this._movefn = this.move.bind(this);
  switch (e2.type) {
    case "touchcancel":
    case "touchend":
    case "mouseup": {
      self2.isMoving = false;
      ["mouseup", "mousemove", "touchend", "touchcancel", "touchmove"].forEach(function(eventName) {
        document.removeEventListener(eventName, self2._movefn);
      });
      this.layers.forEach(function(l3) {
        if (l3.layer.getImageRatio)
          l3.layer.changed();
      });
      break;
    }
    case "mousedown":
    case "touchstart": {
      self2.isMoving = true;
      ["mouseup", "mousemove", "touchend", "touchcancel", "touchmove"].forEach(function(eventName) {
        document.addEventListener(eventName, self2._movefn);
      });
    }
    case "mousemove":
    case "touchmove": {
      if (self2.isMoving) {
        if (self2.get("orientation") === "vertical") {
          var pageX = e2.pageX || e2.touches && e2.touches.length && e2.touches[0].pageX || e2.changedTouches && e2.changedTouches.length && e2.changedTouches[0].pageX;
          if (!pageX)
            break;
          pageX -= self2.getMap().getTargetElement().getBoundingClientRect().left + window.pageXOffset - document.documentElement.clientLeft;
          l2 = self2.getMap().getSize()[0];
          var w2 = l2 - Math.min(Math.max(0, l2 - pageX), l2);
          l2 = w2 / l2;
          self2.set("position", l2);
          self2.dispatchEvent({ type: "moving", size: [w2, self2.getMap().getSize()[1]], position: [l2, 0] });
        } else {
          var pageY = e2.pageY || e2.touches && e2.touches.length && e2.touches[0].pageY || e2.changedTouches && e2.changedTouches.length && e2.changedTouches[0].pageY;
          if (!pageY)
            break;
          pageY -= self2.getMap().getTargetElement().getBoundingClientRect().top + window.pageYOffset - document.documentElement.clientTop;
          l2 = self2.getMap().getSize()[1];
          var h2 = l2 - Math.min(Math.max(0, l2 - pageY), l2);
          l2 = h2 / l2;
          self2.set("position", l2);
          self2.dispatchEvent({ type: "moving", size: [self2.getMap().getSize()[0], h2], position: [0, l2] });
        }
      }
      break;
    }
  }
};
ol_control_Swipe.prototype._transformPt = function(e2, pt2) {
  var tr = e2.inversePixelTransform;
  var x2 = pt2[0];
  var y2 = pt2[1];
  pt2[0] = tr[0] * x2 + tr[2] * y2 + tr[4];
  pt2[1] = tr[1] * x2 + tr[3] * y2 + tr[5];
  return pt2;
};
ol_control_Swipe.prototype._drawRect = function(e2, pts) {
  var tr = e2.inversePixelTransform;
  if (tr) {
    var r2 = [
      [pts[0][0], pts[0][1]],
      [pts[0][0], pts[1][1]],
      [pts[1][0], pts[1][1]],
      [pts[1][0], pts[0][1]],
      [pts[0][0], pts[0][1]]
    ];
    e2.context.save();
    if (e2.target.getImageRatio) {
      var rot = -Math.atan2(e2.frameState.pixelToCoordinateTransform[1], e2.frameState.pixelToCoordinateTransform[0]);
      e2.context.translate(e2.frameState.size[0] / 2, e2.frameState.size[1] / 2);
      e2.context.rotate(rot);
      e2.context.translate(-e2.frameState.size[0] / 2, -e2.frameState.size[1] / 2);
    }
    r2.forEach(function(pt2, i2) {
      pt2 = [
        pt2[0] * tr[0] - pt2[1] * tr[1] + tr[4],
        -pt2[0] * tr[2] + pt2[1] * tr[3] + tr[5]
      ];
      if (!i2) {
        e2.context.moveTo(pt2[0], pt2[1]);
      } else {
        e2.context.lineTo(pt2[0], pt2[1]);
      }
    });
    e2.context.restore();
  } else {
    var ratio = e2.frameState.pixelRatio;
    e2.context.rect(pts[0][0] * ratio, pts[0][1] * ratio, pts[1][0] * ratio, pts[1][1] * ratio);
  }
};
ol_control_Swipe.prototype.precomposeLeft = function(e2) {
  var ctx = e2.context;
  if (ctx instanceof WebGLRenderingContext) {
    if (e2.type === "prerender") {
      ctx.clearColor(0, 0, 0, 0);
      ctx.clear(ctx.COLOR_BUFFER_BIT);
      ctx.enable(ctx.SCISSOR_TEST);
      var mapSize = this.getMap().getSize();
      var bottomLeft = this._transformPt(e2, [0, mapSize[1]]);
      var topRight = this._transformPt(e2, [mapSize[0], 0]);
      var width = topRight[0] - bottomLeft[0];
      var height = topRight[1] - bottomLeft[1];
      if (this.get("orientation") === "vertical") {
        width = Math.round(width * this.get("position"));
      } else {
        height = Math.round(height * this.get("position"));
        bottomLeft[1] += mapSize[1] - height;
      }
      ctx.scissor(bottomLeft[0], bottomLeft[1], width, height);
    }
  } else {
    var size = e2.frameState.size;
    ctx.save();
    ctx.beginPath();
    var pts = [[0, 0], [size[0], size[1]]];
    if (this.get("orientation") === "vertical") {
      pts[1] = [
        size[0] * 0.5 + this.getMap().getSize()[0] * (this.get("position") - 0.5),
        size[1]
      ];
    } else {
      pts[1] = [
        size[0],
        size[1] * 0.5 + this.getMap().getSize()[1] * (this.get("position") - 0.5)
      ];
    }
    this._drawRect(e2, pts);
    ctx.clip();
  }
};
ol_control_Swipe.prototype.precomposeRight = function(e2) {
  var ctx = e2.context;
  if (ctx instanceof WebGLRenderingContext) {
    if (e2.type === "prerender") {
      ctx.clearColor(0, 0, 0, 0);
      ctx.clear(ctx.COLOR_BUFFER_BIT);
      ctx.enable(ctx.SCISSOR_TEST);
      var mapSize = this.getMap().getSize();
      var bottomLeft = this._transformPt(e2, [0, mapSize[1]]);
      var topRight = this._transformPt(e2, [mapSize[0], 0]);
      var width = topRight[0] - bottomLeft[0];
      var height = topRight[1] - bottomLeft[1];
      if (this.get("orientation") === "vertical") {
        width = Math.round(width * (1 - this.get("position")));
        bottomLeft[0] += mapSize[0] - width;
      } else {
        height = Math.round(height * (1 - this.get("position")));
      }
      ctx.scissor(bottomLeft[0], bottomLeft[1], width, height);
    }
  } else {
    var size = e2.frameState.size;
    ctx.save();
    ctx.beginPath();
    var pts = [[0, 0], [size[0], size[1]]];
    if (this.get("orientation") === "vertical") {
      pts[0] = [
        size[0] * 0.5 + this.getMap().getSize()[0] * (this.get("position") - 0.5),
        0
      ];
    } else {
      pts[0] = [
        0,
        size[1] * 0.5 + this.getMap().getSize()[1] * (this.get("position") - 0.5)
      ];
    }
    this._drawRect(e2, pts);
    ctx.clip();
  }
};
ol_control_Swipe.prototype.postcompose = function(e2) {
  if (e2.context instanceof WebGLRenderingContext) {
    if (e2.type === "postrender") {
      var gl = e2.context;
      gl.disable(gl.SCISSOR_TEST);
    }
  } else {
    if (e2.target.getClassName && e2.target.getClassName() !== "ol-layer" && e2.target.get("declutter")) {
      setTimeout(function() {
        e2.context.restore();
      }, 0);
    } else {
      e2.context.restore();
    }
  }
};
var _sfc_main$A = {
  name: "ol-swipe-control",
  setup(props, context) {
    const {
      control
    } = useControl(ol_control_Swipe, props, context);
    const {
      layerList
    } = toRefs(props);
    layerList.value.forEach((layer, index2) => {
      control.value.addLayer(layer, index2 == 1 ? true : false);
    });
    return {
      control
    };
  },
  props: {
    layerList: {
      type: Array
    },
    className: {
      type: String,
      default: "ol-swipe"
    },
    position: {
      type: Number,
      default: 0.5
    },
    orientation: {
      type: String,
      default: "vertical"
    }
  }
};
function _sfc_render$A(_ctx, _cache, $props, $setup, $data, $options) {
  return createCommentVNode("", true);
}
var SwipeControl = _export_sfc(_sfc_main$A, [["render", _sfc_render$A]]);
var ol_control_Bar = function(options) {
  if (!options)
    options = {};
  var element = document.createElement("div");
  element.classList.add("ol-unselectable", "ol-control", "ol-bar");
  if (options.className) {
    var classes = options.className.split(" ").filter(function(className) {
      return className.length > 0;
    });
    element.classList.add.apply(element.classList, classes);
  }
  if (options.group)
    element.classList.add("ol-group");
  ol_control_Control.call(this, {
    element,
    target: options.target
  });
  this.set("toggleOne", options.toggleOne);
  this.set("autoDeactivate", options.autoDeactivate);
  this.controls_ = [];
  if (options.controls instanceof Array) {
    for (var i2 = 0; i2 < options.controls.length; i2++) {
      this.addControl(options.controls[i2]);
    }
  }
};
ol_ext_inherits(ol_control_Bar, ol_control_Control);
ol_control_Bar.prototype.setVisible = function(val) {
  if (val)
    this.element.style.display = "";
  else
    this.element.style.display = "none";
};
ol_control_Bar.prototype.getVisible = function() {
  return this.element.style.display != "none";
};
ol_control_Bar.prototype.setMap = function(map) {
  ol_control_Control.prototype.setMap.call(this, map);
  for (var i2 = 0; i2 < this.controls_.length; i2++) {
    var c2 = this.controls_[i2];
    c2.setMap(map);
  }
};
ol_control_Bar.prototype.getControls = function() {
  return this.controls_;
};
ol_control_Bar.prototype.setPosition = function(pos) {
  this.element.classList.remove("ol-left", "ol-top", "ol-bottom", "ol-right");
  pos = pos.split("-");
  for (var i2 = 0; i2 < pos.length; i2++) {
    switch (pos[i2]) {
      case "top":
      case "left":
      case "bottom":
      case "right":
        this.element.classList.add("ol-" + pos[i2]);
        break;
    }
  }
};
ol_control_Bar.prototype.addControl = function(c2) {
  this.controls_.push(c2);
  c2.setTarget(this.element);
  if (this.getMap()) {
    this.getMap().addControl(c2);
  }
  c2.on("change:active", function(e2) {
    this.onActivateControl_(e2, c2);
  }.bind(this));
  if (c2.getActive) {
    this.onActivateControl_({ target: c2, active: c2.getActive() }, c2);
  }
};
ol_control_Bar.prototype.deactivateControls = function(except) {
  for (var i2 = 0; i2 < this.controls_.length; i2++) {
    if (this.controls_[i2] !== except && this.controls_[i2].setActive) {
      this.controls_[i2].setActive(false);
    }
  }
};
ol_control_Bar.prototype.getActiveControls = function() {
  var active = [];
  for (var i2 = 0, c2; c2 = this.controls_[i2]; i2++) {
    if (c2.getActive && c2.getActive())
      active.push(c2);
  }
  return active;
};
ol_control_Bar.prototype.setActive = function(b2) {
  if (!b2 && this.get("autoDeactivate")) {
    this.deactivateControls();
  }
  if (b2) {
    var ctrls = this.getControls();
    for (var i2 = 0, sb; sb = ctrls[i2]; i2++) {
      if (sb.get("autoActivate"))
        sb.setActive(true);
    }
  }
};
ol_control_Bar.prototype.onActivateControl_ = function(e2, ctrl) {
  if (this.get("toggleOne")) {
    if (e2.active) {
      var n2;
      for (n2 = 0; n2 < this.controls_.length; n2++) {
        if (this.controls_[n2] === ctrl)
          break;
      }
      if (n2 == this.controls_.length)
        return;
      this.deactivateControls(this.controls_[n2]);
    } else {
      if (!this.getActiveControls().length) {
        for (var i2 = 0, c2; c2 = this.controls_[i2]; i2++) {
          if (c2.get("autoActivate")) {
            c2.setActive(true);
            break;
          }
        }
      }
    }
  }
};
ol_control_Bar.prototype.getControlsByName = function(name) {
  var controls = this.getControls();
  return controls.filter(function(control) {
    return control.get("name") === name;
  });
};
var _sfc_main$z = {
  name: "ol-control-bar",
  setup(props, context) {
    const {
      control
    } = useControl(ol_control_Bar, props, context);
    provide("controlBar", control);
    return {
      control
    };
  },
  props: {
    toggleOne: {
      type: Boolean,
      default: true
    },
    group: {
      type: Boolean,
      default: true
    }
  }
};
function _sfc_render$z(_ctx, _cache, $props, $setup, $data, $options) {
  return renderSlot(_ctx.$slots, "default");
}
var ControlBar = _export_sfc(_sfc_main$z, [["render", _sfc_render$z]]);
if (window.ol) {
  ol.ext.input = {};
}
var ol_ext_input_Base = function(options) {
  options = options || {};
  ol_Object.call(this);
  var input = this.input = options.input;
  if (!input) {
    input = this.input = document.createElement("INPUT");
    if (options.type)
      input.setAttribute("type", options.type);
    if (options.min !== void 0)
      input.setAttribute("min", options.min);
    if (options.max !== void 0)
      input.setAttribute("max", options.max);
    if (options.step !== void 0)
      input.setAttribute("step", options.step);
    if (options.parent)
      options.parent.appendChild(input);
  }
  if (options.disabled)
    input.disabled = true;
  if (options.checked !== void 0)
    input.checked = !!options.checked;
  if (options.val !== void 0)
    input.value = options.val;
  if (options.hidden)
    input.style.display = "none";
  input.addEventListener("focus", function() {
    if (this.element)
      this.element.classList.add("ol-focus");
  }.bind(this));
  var tout;
  input.addEventListener("focusout", function() {
    if (this.element) {
      if (tout)
        clearTimeout(tout);
      tout = setTimeout(function() {
        this.element.classList.remove("ol-focus");
      }.bind(this), 0);
    }
  }.bind(this));
};
ol_ext_inherits(ol_ext_input_Base, ol_Object);
ol_ext_input_Base.prototype._listenDrag = function(elt, cback) {
  var handle = function(e2) {
    this.moving = true;
    var listen2 = function(e3) {
      if (e3.type === "pointerup") {
        document.removeEventListener("pointermove", listen2);
        document.removeEventListener("pointerup", listen2);
        document.removeEventListener("pointercancel", listen2);
        setTimeout(function() {
          this.moving = false;
        }.bind(this));
      }
      if (e3.target === elt)
        cback(e3);
      e3.stopPropagation();
      e3.preventDefault();
    }.bind(this);
    document.addEventListener("pointermove", listen2, false);
    document.addEventListener("pointerup", listen2, false);
    document.addEventListener("pointercancel", listen2, false);
    e2.stopPropagation();
    e2.preventDefault();
  }.bind(this);
  elt.addEventListener("mousedown", handle, false);
  elt.addEventListener("touchstart", handle, false);
};
ol_ext_input_Base.prototype.setValue = function(v2) {
  if (v2 !== void 0)
    this.input.value = v2;
  this.input.dispatchEvent(new Event("change"));
};
ol_ext_input_Base.prototype.getValue = function() {
  return this.input.value;
};
ol_ext_input_Base.prototype.getInputElement = function() {
  return this.input;
};
var ol_ext_input_Checkbox = function(options) {
  options = options || {};
  ol_ext_input_Base.call(this, options);
  var label = this.element = document.createElement("LABEL");
  if (options.html instanceof Element)
    label.appendChild(options.html);
  else if (options.html !== void 0)
    label.innerHTML = options.html;
  label.className = ("ol-ext-check ol-ext-checkbox " + (options.className || "")).trim();
  if (this.input.parentNode)
    this.input.parentNode.insertBefore(label, this.input);
  label.appendChild(this.input);
  label.appendChild(document.createElement("SPAN"));
  if (options.after) {
    label.appendChild(document.createTextNode(options.after));
  }
  this.input.addEventListener("change", function() {
    this.dispatchEvent({ type: "check", checked: this.input.checked, value: this.input.value });
  }.bind(this));
};
ol_ext_inherits(ol_ext_input_Checkbox, ol_ext_input_Base);
ol_ext_input_Checkbox.prototype.isChecked = function() {
  return this.input.checked;
};
var ol_ext_input_Switch = function(options) {
  options = options || {};
  ol_ext_input_Checkbox.call(this, options);
  this.element.className = ("ol-ext-toggle-switch " + (options.className || "")).trim();
};
ol_ext_inherits(ol_ext_input_Switch, ol_ext_input_Checkbox);
var ol_ext_input_Radio = function(options) {
  options = options || {};
  ol_ext_input_Checkbox.call(this, options);
  this.element.className = ("ol-ext-check ol-ext-radio " + (options.className || "")).trim();
};
ol_ext_inherits(ol_ext_input_Radio, ol_ext_input_Checkbox);
var ol_ext_element = {};
ol_ext_element.create = function(tagName, options) {
  options = options || {};
  var elt;
  if (tagName === "TEXT") {
    elt = document.createTextNode(options.html || "");
    if (options.parent)
      options.parent.appendChild(elt);
  } else {
    elt = document.createElement(tagName);
    if (/button/i.test(tagName))
      elt.setAttribute("type", "button");
    for (var attr in options) {
      switch (attr) {
        case "className": {
          if (options.className && options.className.trim)
            elt.setAttribute("class", options.className.trim());
          break;
        }
        case "text": {
          elt.innerText = options.text;
          break;
        }
        case "html": {
          if (options.html instanceof Element)
            elt.appendChild(options.html);
          else if (options.html !== void 0)
            elt.innerHTML = options.html;
          break;
        }
        case "parent": {
          if (options.parent)
            options.parent.appendChild(elt);
          break;
        }
        case "options": {
          if (/select/i.test(tagName)) {
            for (var i2 in options.options) {
              ol_ext_element.create("OPTION", {
                html: i2,
                value: options.options[i2],
                parent: elt
              });
            }
          }
          break;
        }
        case "style": {
          this.setStyle(elt, options.style);
          break;
        }
        case "change":
        case "click": {
          ol_ext_element.addListener(elt, attr, options[attr]);
          break;
        }
        case "on": {
          for (var e2 in options.on) {
            ol_ext_element.addListener(elt, e2, options.on[e2]);
          }
          break;
        }
        case "checked": {
          elt.checked = !!options.checked;
          break;
        }
        default: {
          elt.setAttribute(attr, options[attr]);
          break;
        }
      }
    }
  }
  return elt;
};
ol_ext_element.createSwitch = function(options) {
  var input = ol_ext_element.create("INPUT", {
    type: "checkbox",
    on: options.on,
    click: options.click,
    change: options.change,
    parent: options.parent
  });
  var opt = Object.assign({ input }, options || {});
  new ol_ext_input_Switch(opt);
  return input;
};
ol_ext_element.createCheck = function(options) {
  var input = ol_ext_element.create("INPUT", {
    name: options.name,
    type: options.type === "radio" ? "radio" : "checkbox",
    on: options.on,
    parent: options.parent
  });
  console.log(input);
  var opt = Object.assign({ input }, options || {});
  if (options.type === "radio") {
    new ol_ext_input_Radio(opt);
  } else {
    new ol_ext_input_Checkbox(opt);
  }
  return input;
};
ol_ext_element.setHTML = function(element, html2) {
  if (html2 instanceof Element)
    element.appendChild(html2);
  else if (html2 !== void 0)
    element.innerHTML = html2;
};
ol_ext_element.appendText = function(element, text2) {
  element.appendChild(document.createTextNode(text2 || ""));
};
ol_ext_element.addListener = function(element, eventType, fn, useCapture) {
  if (typeof eventType === "string")
    eventType = eventType.split(" ");
  eventType.forEach(function(e2) {
    element.addEventListener(e2, fn, useCapture);
  });
};
ol_ext_element.removeListener = function(element, eventType, fn) {
  if (typeof eventType === "string")
    eventType = eventType.split(" ");
  eventType.forEach(function(e2) {
    element.removeEventListener(e2, fn);
  });
};
ol_ext_element.show = function(element) {
  element.style.display = "";
};
ol_ext_element.hide = function(element) {
  element.style.display = "none";
};
ol_ext_element.hidden = function(element) {
  return ol_ext_element.getStyle(element, "display") === "none";
};
ol_ext_element.toggle = function(element) {
  element.style.display = element.style.display === "none" ? "" : "none";
};
ol_ext_element.setStyle = function(el, st2) {
  for (var s2 in st2) {
    switch (s2) {
      case "top":
      case "left":
      case "bottom":
      case "right":
      case "minWidth":
      case "maxWidth":
      case "width":
      case "height": {
        if (typeof st2[s2] === "number") {
          el.style[s2] = st2[s2] + "px";
        } else {
          el.style[s2] = st2[s2];
        }
        break;
      }
      default: {
        el.style[s2] = st2[s2];
      }
    }
  }
};
ol_ext_element.getStyle = function(el, styleProp) {
  var value, defaultView = (el.ownerDocument || document).defaultView;
  if (defaultView && defaultView.getComputedStyle) {
    styleProp = styleProp.replace(/([A-Z])/g, "-$1").toLowerCase();
    value = defaultView.getComputedStyle(el, null).getPropertyValue(styleProp);
  } else if (el.currentStyle) {
    styleProp = styleProp.replace(/-(\w)/g, function(str, letter) {
      return letter.toUpperCase();
    });
    value = el.currentStyle[styleProp];
    if (/^\d+(em|pt|%|ex)?$/i.test(value)) {
      return function(value2) {
        var oldLeft = el.style.left, oldRsLeft = el.runtimeStyle.left;
        el.runtimeStyle.left = el.currentStyle.left;
        el.style.left = value2 || 0;
        value2 = el.style.pixelLeft + "px";
        el.style.left = oldLeft;
        el.runtimeStyle.left = oldRsLeft;
        return value2;
      }(value);
    }
  }
  if (/px$/.test(value))
    return parseInt(value);
  return value;
};
ol_ext_element.outerHeight = function(elt) {
  return elt.offsetHeight + ol_ext_element.getStyle(elt, "marginBottom");
};
ol_ext_element.outerWidth = function(elt) {
  return elt.offsetWidth + ol_ext_element.getStyle(elt, "marginLeft");
};
ol_ext_element.offsetRect = function(elt) {
  var rect = elt.getBoundingClientRect();
  return {
    top: rect.top + (window.pageYOffset || document.documentElement.scrollTop || document.body.scrollTop || 0),
    left: rect.left + (window.pageXOffset || document.documentElement.scrollLeft || document.body.scrollLeft || 0),
    height: rect.height || rect.bottom - rect.top,
    width: rect.width || rect.right - rect.left
  };
};
ol_ext_element.getFixedOffset = function(elt) {
  var offset2 = {
    left: 0,
    top: 0
  };
  var getOffset = function(parent) {
    if (!parent)
      return offset2;
    if (ol_ext_element.getStyle(parent, "position") === "absolute" && ol_ext_element.getStyle(parent, "transform") !== "none") {
      var r2 = parent.getBoundingClientRect();
      offset2.left += r2.left;
      offset2.top += r2.top;
      return offset2;
    }
    return getOffset(parent.offsetParent);
  };
  return getOffset(elt.offsetParent);
};
ol_ext_element.positionRect = function(elt, fixed) {
  var gleft = 0;
  var gtop = 0;
  var getRect = function(parent) {
    if (parent) {
      gleft += parent.offsetLeft;
      gtop += parent.offsetTop;
      return getRect(parent.offsetParent);
    } else {
      var r2 = {
        top: elt.offsetTop + gtop,
        left: elt.offsetLeft + gleft
      };
      if (fixed) {
        r2.top -= window.pageYOffset || document.documentElement.scrollTop || document.body.scrollTop || 0;
        r2.left -= window.pageXOffset || document.documentElement.scrollLeft || document.body.scrollLeft || 0;
      }
      r2.bottom = r2.top + elt.offsetHeight;
      r2.right = r2.top + elt.offsetWidth;
      return r2;
    }
  };
  return getRect(elt.offsetParent);
};
ol_ext_element.scrollDiv = function(elt, options) {
  options = options || {};
  var pos = false;
  var speed = 0;
  var d2, dt2 = 0;
  var onmove = typeof options.onmove === "function" ? options.onmove : function() {
  };
  var page = options.vertical ? "screenY" : "screenX";
  var scroll = options.vertical ? "scrollTop" : "scrollLeft";
  var moving = false;
  var scale2, isbar;
  var updateCounter = 0;
  var updateMinibar = function() {
    if (scrollbar) {
      updateCounter++;
      setTimeout(updateMinibarDelay);
    }
  };
  var updateMinibarDelay = function() {
    if (scrollbar) {
      updateCounter--;
      if (updateCounter)
        return;
      var pheight = elt.clientHeight;
      var height = elt.scrollHeight;
      scale2 = pheight / height;
      scrollbar.style.height = scale2 * 100 + "%";
      scrollbar.style.top = elt.scrollTop / height * 100 + "%";
      scrollContainer.style.height = pheight + "px";
      if (pheight > height - 0.5)
        scrollContainer.classList.add("ol-100pc");
      else
        scrollContainer.classList.remove("ol-100pc");
    }
  };
  var onPointerDown = function(e2) {
    if (e2.target.classList.contains("ol-noscroll"))
      return;
    moving = false;
    pos = e2[page];
    dt2 = new Date();
    elt.classList.add("ol-move");
    e2.preventDefault();
    window.addEventListener("pointermove", onPointerMove);
    ol_ext_element.addListener(window, ["pointerup", "pointercancel"], onPointerUp);
  };
  var onPointerMove = function(e2) {
    moving = true;
    if (pos !== false) {
      var delta = (isbar ? -1 / scale2 : 1) * (pos - e2[page]);
      elt[scroll] += delta;
      d2 = new Date();
      if (d2 - dt2) {
        speed = (speed + delta / (d2 - dt2)) / 2;
      }
      pos = e2[page];
      dt2 = d2;
      if (delta)
        onmove(true);
    }
  };
  var animate = function(to) {
    var step = to > 0 ? Math.min(100, to / 2) : Math.max(-100, to / 2);
    to -= step;
    elt[scroll] += step;
    if (-1 < to && to < 1) {
      if (moving)
        setTimeout(function() {
          elt.classList.remove("ol-move");
        });
      else
        elt.classList.remove("ol-move");
      moving = false;
      onmove(false);
    } else {
      setTimeout(function() {
        animate(to);
      }, 40);
    }
  };
  var scrollContainer, scrollbar;
  if (options.vertical && options.minibar) {
    var init2 = function(b2) {
      elt.removeEventListener("pointermove", init2);
      elt.parentNode.classList.add("ol-miniscroll");
      scrollbar = ol_ext_element.create("DIV");
      scrollContainer = ol_ext_element.create("DIV", {
        className: "ol-scroll",
        html: scrollbar
      });
      elt.parentNode.insertBefore(scrollContainer, elt);
      scrollbar.addEventListener("pointerdown", function(e2) {
        isbar = true;
        onPointerDown(e2);
      });
      if (options.mousewheel) {
        ol_ext_element.addListener(scrollContainer, ["mousewheel", "DOMMouseScroll", "onmousewheel"], function(e2) {
          onMouseWheel(e2);
        });
        ol_ext_element.addListener(scrollbar, ["mousewheel", "DOMMouseScroll", "onmousewheel"], function(e2) {
          onMouseWheel(e2);
        });
      }
      elt.parentNode.addEventListener("pointerenter", updateMinibar);
      window.addEventListener("resize", updateMinibar);
      if (b2 !== false)
        updateMinibar();
    };
    if (elt.parentNode)
      init2(false);
    else
      elt.addEventListener("pointermove", init2);
    elt.addEventListener("scroll", function() {
      updateMinibar();
    });
  }
  elt.style["touch-action"] = "none";
  elt.style["overflow"] = "hidden";
  elt.classList.add("ol-scrolldiv");
  ol_ext_element.addListener(elt, ["pointerdown"], function(e2) {
    isbar = false;
    onPointerDown(e2);
  });
  elt.addEventListener("click", function(e2) {
    if (elt.classList.contains("ol-move")) {
      e2.preventDefault();
      e2.stopPropagation();
    }
  }, true);
  var onPointerUp = function(e2) {
    dt2 = new Date() - dt2;
    if (dt2 > 100 || isbar) {
      speed = 0;
    } else if (dt2 > 0) {
      speed = ((speed || 0) + (pos - e2[page]) / dt2) / 2;
    }
    animate(options.animate === false ? 0 : speed * 200);
    pos = false;
    speed = 0;
    dt2 = 0;
    if (!elt.classList.contains("ol-move")) {
      elt.classList.add("ol-hasClick");
      setTimeout(function() {
        elt.classList.remove("ol-hasClick");
      }, 500);
    } else {
      elt.classList.remove("ol-hasClick");
    }
    isbar = false;
    window.removeEventListener("pointermove", onPointerMove);
    ol_ext_element.removeListener(window, ["pointerup", "pointercancel"], onPointerUp);
  };
  var onMouseWheel = function(e2) {
    var delta = Math.max(-1, Math.min(1, e2.wheelDelta || -e2.detail));
    elt.classList.add("ol-move");
    elt[scroll] -= delta * 30;
    elt.classList.remove("ol-move");
    return false;
  };
  if (options.mousewheel) {
    ol_ext_element.addListener(elt, ["mousewheel", "DOMMouseScroll", "onmousewheel"], onMouseWheel);
  }
  return {
    refresh: updateMinibar
  };
};
ol_ext_element.dispatchEvent = function(eventName, element) {
  var event;
  try {
    event = new CustomEvent(eventName);
  } catch (e2) {
    event = document.createEvent("CustomEvent");
    event.initCustomEvent(eventName, true, true, {});
  }
  element.dispatchEvent(event);
};
var ol_control_Button = function(options) {
  options = options || {};
  var element = document.createElement("div");
  element.className = (options.className || "") + " ol-button ol-unselectable ol-control";
  var self2 = this;
  var bt2 = this.button_ = document.createElement(/ol-text-button/.test(options.className) ? "div" : "button");
  bt2.type = "button";
  if (options.title)
    bt2.title = options.title;
  if (options.name)
    bt2.name = options.name;
  if (options.html instanceof Element)
    bt2.appendChild(options.html);
  else
    bt2.innerHTML = options.html || "";
  var evtFunction = function(e2) {
    if (e2 && e2.preventDefault) {
      e2.preventDefault();
      e2.stopPropagation();
    }
    if (options.handleClick) {
      options.handleClick.call(self2, e2);
    }
  };
  bt2.addEventListener("click", evtFunction);
  element.appendChild(bt2);
  if (!options.title && bt2.firstElementChild) {
    bt2.title = bt2.firstElementChild.title;
  }
  ol_control_Control.call(this, {
    element,
    target: options.target
  });
  if (options.title) {
    this.set("title", options.title);
  }
  if (options.title)
    this.set("title", options.title);
  if (options.name)
    this.set("name", options.name);
};
ol_ext_inherits(ol_control_Button, ol_control_Control);
ol_control_Button.prototype.setVisible = function(val) {
  if (val)
    ol_ext_element.show(this.element);
  else
    ol_ext_element.hide(this.element);
};
ol_control_Button.prototype.setTitle = function(title) {
  this.button_.setAttribute("title", title);
};
ol_control_Button.prototype.setHtml = function(html2) {
  ol_ext_element.setHTML(this.button_, html2);
};
ol_control_Button.prototype.getButtonElement = function() {
  return this.button_;
};
var ol_control_Toggle = function(options) {
  options = options || {};
  var self2 = this;
  this.interaction_ = options.interaction;
  if (this.interaction_) {
    this.interaction_.setActive(options.active);
    this.interaction_.on("change:active", function() {
      self2.setActive(self2.interaction_.getActive());
    });
  }
  if (options.toggleFn)
    options.onToggle = options.toggleFn;
  options.handleClick = function() {
    self2.toggle();
    if (options.onToggle)
      options.onToggle.call(self2, self2.getActive());
  };
  options.className = (options.className || "") + " ol-toggle";
  ol_control_Button.call(this, options);
  this.set("title", options.title);
  this.set("autoActivate", options.autoActivate);
  if (options.bar)
    this.setSubBar(options.bar);
  this.setActive(options.active);
  this.setDisable(options.disable);
};
ol_ext_inherits(ol_control_Toggle, ol_control_Button);
ol_control_Toggle.prototype.setMap = function(map) {
  if (!map && this.getMap()) {
    if (this.interaction_) {
      this.getMap().removeInteraction(this.interaction_);
    }
    if (this.subbar_)
      this.getMap().removeControl(this.subbar_);
  }
  ol_control_Button.prototype.setMap.call(this, map);
  if (map) {
    if (this.interaction_)
      map.addInteraction(this.interaction_);
    if (this.subbar_)
      map.addControl(this.subbar_);
  }
};
ol_control_Toggle.prototype.getSubBar = function() {
  return this.subbar_;
};
ol_control_Toggle.prototype.setSubBar = function(bar) {
  var map = this.getMap();
  if (map && this.subbar_)
    map.removeControl(this.subbar_);
  this.subbar_ = bar;
  if (bar) {
    this.subbar_.setTarget(this.element);
    this.subbar_.element.classList.add("ol-option-bar");
    if (map)
      map.addControl(this.subbar_);
  }
};
ol_control_Toggle.prototype.getDisable = function() {
  var button = this.element.querySelector("button");
  return button && button.disabled;
};
ol_control_Toggle.prototype.setDisable = function(b2) {
  if (this.getDisable() == b2)
    return;
  this.element.querySelector("button").disabled = b2;
  if (b2 && this.getActive())
    this.setActive(false);
  this.dispatchEvent({ type: "change:disable", key: "disable", oldValue: !b2, disable: b2 });
};
ol_control_Toggle.prototype.getActive = function() {
  return this.element.classList.contains("ol-active");
};
ol_control_Toggle.prototype.toggle = function() {
  if (this.getActive())
    this.setActive(false);
  else
    this.setActive(true);
};
ol_control_Toggle.prototype.setActive = function(b2) {
  if (this.interaction_)
    this.interaction_.setActive(b2);
  if (this.subbar_)
    this.subbar_.setActive(b2);
  if (this.getActive() === b2)
    return;
  if (b2)
    this.element.classList.add("ol-active");
  else
    this.element.classList.remove("ol-active");
  this.dispatchEvent({ type: "change:active", key: "active", oldValue: !b2, active: b2 });
};
ol_control_Toggle.prototype.setInteraction = function(i2) {
  this.interaction_ = i2;
};
ol_control_Toggle.prototype.getInteraction = function() {
  return this.interaction_;
};
var _sfc_main$y = {
  name: "ol-control-toggle",
  setup(props, context) {
    const {
      control
    } = useControl(ol_control_Toggle, props, context);
    return {
      control
    };
  },
  props: {
    html: {
      type: String
    },
    interaction: {
      type: Object
    },
    className: {
      type: String
    },
    title: {
      type: String
    },
    onToggle: {
      type: Function
    }
  }
};
function _sfc_render$y(_ctx, _cache, $props, $setup, $data, $options) {
  return createCommentVNode("", true);
}
var ToggleControl = _export_sfc(_sfc_main$y, [["render", _sfc_render$y]]);
var _sfc_main$x = {
  name: "ol-control-button",
  setup(props, context) {
    const {
      control
    } = useControl(ol_control_Button, props, context);
    return {
      control
    };
  },
  props: {
    html: {
      type: String
    },
    name: {
      type: String
    },
    className: {
      type: String
    },
    title: {
      type: String
    },
    handleClick: {
      type: Function
    }
  }
};
function _sfc_render$x(_ctx, _cache, $props, $setup, $data, $options) {
  return createCommentVNode("", true);
}
var ButtonControl = _export_sfc(_sfc_main$x, [["render", _sfc_render$x]]);
var ol_control_Dialog = function(options) {
  options = options || {};
  if (options.fullscreen)
    options.target = document.body;
  var element = ol_ext_element.create("DIV", {
    className: ((options.className || "") + (options.zoom ? " ol-zoom" : "") + " ol-ext-dialog").trim(),
    click: function(e2) {
      if (this.get("hideOnBack") && e2.target === element)
        this.close();
      if (this.get("hideOnClick"))
        this.close();
    }.bind(this)
  });
  var form = ol_ext_element.create("FORM", {
    on: {
      submit: this._onButton("submit")
    },
    parent: element
  });
  ol_ext_element.create("H2", {
    parent: form
  });
  ol_ext_element.create("DIV", {
    className: "ol-closebox",
    click: this._onButton("cancel"),
    parent: form
  });
  ol_ext_element.create("DIV", {
    className: "ol-content",
    parent: form
  });
  this._progress = ol_ext_element.create("DIV", {
    style: { display: "none" },
    parent: form
  });
  var bar = ol_ext_element.create("DIV", {
    className: "ol-progress-bar",
    parent: this._progress
  });
  this._progressbar = ol_ext_element.create("DIV", {
    parent: bar
  });
  this._progressMessage = ol_ext_element.create("DIV", {
    className: "ol-progress-message",
    parent: this._progress
  });
  ol_ext_element.create("DIV", {
    className: "ol-buttons",
    parent: form
  });
  ol_control_Control.call(this, {
    element,
    target: options.target
  });
  this.set("closeBox", options.closeBox !== false);
  this.set("zoom", !!options.zoom);
  this.set("hideOnClick", !!options.hideOnClick);
  this.set("hideOnBack", !!options.hideOnBack);
  this.set("className", element.className);
  this.set("closeOnSubmit", options.closeOnSubmit);
  this.set("buttons", options.buttons);
  this.setContent(options);
};
ol_ext_inherits(ol_control_Dialog, ol_control_Control);
ol_control_Dialog.prototype.show = function(options) {
  if (options) {
    if (options instanceof Element || typeof options === "string") {
      options = { content: options };
    }
    this.setContent(options);
  }
  this.element.classList.add("ol-visible");
  var input = this.element.querySelector('input[type="text"],input[type="search"],input[type="number"]');
  if (input)
    input.focus();
  this.dispatchEvent({ type: "show" });
  if (options) {
    if (options.autoclose) {
      var listener2 = setTimeout(function() {
        this.hide();
      }.bind(this), options.autoclose);
      this.once("hide", function() {
        clearTimeout(listener2);
      });
    }
    if (options.hideOnBack) {
      var value = this.get("hideOnBack");
      this.set("hideOnBack", true);
      this.once("hide", function() {
        this.set("hideOnBack", value);
      }.bind(this));
    }
  }
};
ol_control_Dialog.prototype.open = function() {
  this.show();
};
ol_control_Dialog.prototype.setContentMessage = function(content2) {
  if (content2 !== void 0) {
    var elt = this.getContentElement();
    if (content2 instanceof Element)
      ol_ext_element.setHTML(elt, "");
    ol_ext_element.setHTML(elt, content2 || "");
  }
};
ol_control_Dialog.prototype.setTitle = function(title) {
  var form = this.element.querySelector("form");
  form.querySelector("h2").innerText = title || "";
  if (title) {
    form.classList.add("ol-title");
  } else {
    form.classList.remove("ol-title");
  }
};
ol_control_Dialog.prototype.setContent = function(options) {
  if (!options)
    return;
  this.element.className = this.get("className");
  if (typeof options === "string")
    options = { content: options };
  options = options || {};
  this.setProgress(false);
  if (options.max)
    this.setProgress(0, options.max);
  if (options.progress !== void 0)
    this.setProgress(options.progress);
  if (this.get("zoom"))
    this.element.classList.add("ol-zoom");
  else
    this.element.classList.remove("ol-zoom");
  if (options.className) {
    options.className.split(" ").forEach(function(c2) {
      this.element.classList.add(c2);
    }.bind(this));
  }
  var form = this.element.querySelector("form");
  if (options.content !== void 0) {
    if (options.content instanceof Element)
      ol_ext_element.setHTML(form.querySelector(".ol-content"), "");
    ol_ext_element.setHTML(form.querySelector(".ol-content"), options.content || "");
  }
  this.setTitle(options.title);
  if (options.closeBox || this.get("closeBox") && options.closeBox !== false) {
    form.classList.add("ol-closebox");
  } else {
    form.classList.remove("ol-closebox");
  }
  var buttons = this.element.querySelector(".ol-buttons");
  buttons.innerHTML = "";
  var btn = options.buttons || this.get("buttons");
  if (btn) {
    form.classList.add("ol-button");
    for (var i2 in btn) {
      ol_ext_element.create("INPUT", {
        type: i2 === "submit" ? "submit" : "button",
        value: btn[i2],
        click: this._onButton(i2, options.onButton),
        parent: buttons
      });
    }
  } else {
    form.classList.remove("ol-button");
  }
};
ol_control_Dialog.prototype.getContentElement = function() {
  return this.element.querySelector("form .ol-content");
};
ol_control_Dialog.prototype.setProgress = function(val, max2, message) {
  if (val === false) {
    ol_ext_element.setStyle(this._progress, { display: "none" });
    return;
  }
  if (max2 > 0) {
    this.set("max", Number(max2));
  } else {
    max2 = this.get("max");
  }
  if (!max2) {
    ol_ext_element.setStyle(this._progress, { display: "none" });
  } else {
    var p5 = Math.round(val / max2 * 100);
    ol_ext_element.setStyle(this._progress, { display: "" });
    this._progressbar.className = p5 ? "" : "notransition";
    ol_ext_element.setStyle(this._progressbar, { width: p5 + "%" });
  }
  this._progressMessage.innerHTML = "";
  ol_ext_element.setHTML(this._progressMessage, message || "");
};
ol_control_Dialog.prototype._onButton = function(button, callback) {
  var fn = function(e2) {
    e2.preventDefault();
    if (button !== "submit" || this.get("closeOnSubmit") !== false)
      this.hide();
    var inputs = this.getInputs();
    this.dispatchEvent({ type: "button", button, inputs });
    if (typeof callback === "function")
      callback(button, inputs);
  }.bind(this);
  return fn;
};
ol_control_Dialog.prototype.getInputs = function() {
  var inputs = {};
  ["input", "textarea", "select"].forEach(function(type) {
    this.element.querySelectorAll("form " + type).forEach(function(input) {
      if (input.className) {
        input.className.split(" ").forEach(function(n2) {
          inputs[n2] = input;
        });
      }
    });
  }.bind(this));
  return inputs;
};
ol_control_Dialog.prototype.hide = function() {
  this.element.classList.remove("ol-visible");
  this.dispatchEvent({ type: "hide" });
};
ol_control_Dialog.prototype.close = ol_control_Dialog.prototype.hide;
ol_control_Dialog.prototype.isOpen = function() {
  return this.element.classList.contains("ol-visible");
};
var ol_ext_getMapCanvas = function(map) {
  if (!map)
    return null;
  var canvas = map.getViewport().getElementsByClassName("ol-fixedoverlay")[0];
  if (!canvas) {
    if (map.getViewport().querySelector(".ol-layers")) {
      canvas = document.createElement("canvas");
      canvas.className = "ol-fixedoverlay";
      map.getViewport().querySelector(".ol-layers").after(canvas);
      map.on("precompose", function(e2) {
        canvas.width = map.getSize()[0] * e2.frameState.pixelRatio;
        canvas.height = map.getSize()[1] * e2.frameState.pixelRatio;
      });
    } else {
      canvas = map.getViewport().querySelector("canvas");
    }
  }
  return canvas;
};
var ol_control_CanvasBase = function(options) {
  if (!options)
    options = {};
  this.setStyle(options.style);
  ol_control_Control.call(this, options);
};
ol_ext_inherits(ol_control_CanvasBase, ol_control_Control);
ol_control_CanvasBase.prototype.setMap = function(map) {
  this.getCanvas(map);
  var oldmap = this.getMap();
  if (this._listener) {
    unByKey(this._listener);
    this._listener = null;
  }
  ol_control_Control.prototype.setMap.call(this, map);
  if (oldmap) {
    try {
      oldmap.renderSync();
    } catch (e2) {
    }
  }
  if (map) {
    this._listener = map.on("postcompose", this._draw.bind(this));
  }
};
ol_control_CanvasBase.prototype.getCanvas = function(map) {
  return ol_ext_getMapCanvas(map);
};
ol_control_CanvasBase.prototype.getContext = function(e2) {
  var ctx = e2.context;
  if (!ctx && this.getMap()) {
    var c2 = this.getMap().getViewport().getElementsByClassName("ol-fixedoverlay")[0];
    ctx = c2 ? c2.getContext("2d") : null;
  }
  return ctx;
};
ol_control_CanvasBase.prototype.setStyle = function(style2) {
  this._style = style2 || new Style$2({});
};
ol_control_CanvasBase.prototype.getStyle = function() {
  return this._style;
};
ol_control_CanvasBase.prototype.getStroke = function() {
  var t3 = this._style.getStroke();
  if (!t3)
    this._style.setStroke(new Stroke$2({ color: "#000", width: 1.25 }));
  return this._style.getStroke();
};
ol_control_CanvasBase.prototype.getFill = function() {
  var t3 = this._style.getFill();
  if (!t3)
    this._style.setFill(new Fill$2({ color: "#fff" }));
  return this._style.getFill();
};
ol_control_CanvasBase.prototype.getTextStroke = function() {
  var t3 = this._style.getText();
  if (!t3)
    t3 = new Text$2({});
  if (!t3.getStroke())
    t3.setStroke(new Stroke$2({ color: "#fff", width: 3 }));
  return t3.getStroke();
};
ol_control_CanvasBase.prototype.getTextFill = function() {
  var t3 = this._style.getText();
  if (!t3)
    t3 = new Text$2({});
  if (!t3.getFill())
    t3.setFill(new Fill$2({ color: "#fff" }));
  return t3.getFill();
};
ol_control_CanvasBase.prototype.getTextFont = function() {
  var t3 = this._style.getText();
  if (!t3)
    t3 = new Text$2({});
  if (!t3.getFont())
    t3.setFont("12px sans-serif");
  return t3.getFont();
};
ol_control_CanvasBase.prototype._draw = function() {
  console.warn("[CanvasBase] draw function not implemented.");
};
function toContext(context, opt_options) {
  var canvas = context.canvas;
  var options = opt_options ? opt_options : {};
  var pixelRatio = options.pixelRatio || DEVICE_PIXEL_RATIO;
  var size = options.size;
  if (size) {
    canvas.width = size[0] * pixelRatio;
    canvas.height = size[1] * pixelRatio;
    canvas.style.width = size[0] + "px";
    canvas.style.height = size[1] + "px";
  }
  var extent2 = [0, 0, canvas.width, canvas.height];
  var transform2 = scale$3(create$6(), pixelRatio, pixelRatio);
  return new CanvasImmediateRenderer$1(context, pixelRatio, extent2, transform2, 0);
}
var ol_legend_Item = function(options) {
  options = options || {};
  ol_Object.call(this, options);
  if (options.feature)
    this.set("feature", options.feature.clone());
};
ol_ext_inherits(ol_legend_Item, ol_Object);
ol_legend_Item.prototype.setTitle = function(title) {
  this.set("title", title || "");
  this.changed();
};
ol_legend_Item.prototype.getElement = function(size, onclick) {
  var element = ol_ext_element.create("LI", {
    className: this.get("className"),
    click: function(e2) {
      onclick(false);
      e2.stopPropagation();
    },
    style: { height: size[1] + "px" },
    "aria-label": this.get("title")
  });
  ol_ext_element.create("DIV", {
    click: function(e2) {
      onclick(true);
      e2.stopPropagation();
    },
    style: {
      width: size[0] + "px",
      height: size[1] + "px"
    },
    parent: element
  });
  return element;
};
if (window.ol && !ol.legend) {
  ol.legend = {};
}
var ol_legend_Legend = function(options) {
  options = options || {};
  ol_Object.call(this);
  this._items = new ol_Collection();
  var listeners = [];
  var tout;
  this._items.on("add", function(e2) {
    listeners.push({
      item: e2.element,
      on: e2.element.on("change", function() {
        this.refresh();
      }.bind(this))
    });
    if (tout) {
      clearTimeout(tout);
      tout = null;
    }
    tout = setTimeout(function() {
      this.refresh();
    }.bind(this), 0);
  }.bind(this));
  this._items.on("remove", function(e2) {
    for (var i2 = 0; i2 < listeners; i2++) {
      if (e2.element === listeners[i2].item) {
        unByKey(listeners[i2].on);
        listeners.splice(i2, 1);
        break;
      }
    }
    if (tout) {
      clearTimeout(tout);
      tout = null;
    }
    tout = setTimeout(function() {
      this.refresh();
    }.bind(this), 0);
  }.bind(this));
  this._listElement = ol_ext_element.create("UL", {
    className: "ol-legend"
  });
  this._canvas = document.createElement("canvas");
  this.set("size", options.size || [40, 25], true);
  this.set("margin", options.margin === 0 ? 0 : options.margin || 10, true);
  this._textStyle = options.textStyle || new Text$2({
    font: "16px sans-serif",
    fill: new Fill$2({
      color: "#333"
    }),
    backgroundFill: new Fill$2({
      color: "rgba(255,255,255,.8)"
    })
  });
  this._title = new ol_legend_Item({ title: options.title || "", className: "ol-title" });
  if (options.titleStyle) {
    this._titleStyle = options.titleStyle;
  } else {
    this._titleStyle = this._textStyle.clone();
    this._titleStyle.setFont("bold " + this._titleStyle.getFont());
  }
  this.setStyle(options.style);
  if (options.items instanceof Array) {
    options.items.forEach(function(item) {
      this.addItem(item);
    }.bind(this));
  }
  this.refresh();
};
ol_ext_inherits(ol_legend_Legend, ol_Object);
ol_legend_Legend.prototype.setTitle = function(title) {
  this._title.setTitle(title);
  this.refresh();
};
ol_legend_Legend.prototype.getTitle = function() {
  return this._title.get("title");
};
ol_legend_Legend.prototype.getTextStyle = function() {
  return this._textStyle;
};
ol_legend_Legend.prototype.set = function(key, value, opt_silent) {
  ol_Object.prototype.set.call(this, key, value, opt_silent);
  if (!opt_silent)
    this.refresh();
};
ol_legend_Legend.prototype.getListElement = function() {
  return this._listElement;
};
ol_legend_Legend.prototype.getCanvas = function() {
  return this._canvas;
};
ol_legend_Legend.prototype.setStyle = function(style2) {
  this._style = style2;
  this.refresh();
};
ol_legend_Legend.prototype.addItem = function(item) {
  if (item instanceof ol_legend_Item) {
    this._items.push(item);
  } else {
    this._items.push(new ol_legend_Item(item));
  }
};
ol_legend_Legend.prototype.getItems = function() {
  return this._items;
};
ol_legend_Legend.prototype._drawText = function(ctx, text2, x2, y2) {
  ctx.save();
  ctx.scale(DEVICE_PIXEL_RATIO, DEVICE_PIXEL_RATIO);
  text2 = text2 || "";
  var txt = text2.split("\n");
  if (txt.length === 1) {
    ctx.fillText(text2, x2, y2);
  } else {
    ctx.textBaseline = "bottom";
    ctx.fillText(txt[0], x2, y2);
    ctx.textBaseline = "top";
    ctx.fillText(txt[1], x2, y2);
  }
  ctx.restore();
};
ol_legend_Legend.prototype._measureText = function(ctx, text2) {
  var txt = (text2 || "").split("\n");
  if (txt.length === 1) {
    return ctx.measureText(text2);
  } else {
    var m1 = ctx.measureText(txt[0]);
    var m2 = ctx.measureText(txt[1]);
    return { width: Math.max(m1.width, m2.width), height: m1.height + m2.height };
  }
};
ol_legend_Legend.prototype.refresh = function() {
  var table = this._listElement;
  table.innerHTML = "";
  var margin = this.get("margin");
  var width = this.get("size")[0] + 2 * margin;
  var height = this.get("lineHeight") || this.get("size")[1] + 2 * margin;
  var canvas = this.getCanvas();
  var ctx = canvas.getContext("2d");
  ctx.textAlign = "left";
  ctx.textBaseline = "middle";
  var ratio = DEVICE_PIXEL_RATIO;
  ctx.font = this._titleStyle.getFont();
  var textWidth = this._measureText(ctx, this.getTitle("title")).width;
  this._items.forEach(function(r2) {
    if (r2.get("feature") || r2.get("typeGeom")) {
      ctx.font = r2.get("textStyle") ? r2.get("textStyle").getFont() : this._textStyle.getFont();
      textWidth = Math.max(textWidth, this._measureText(ctx, r2.get("title")).width + width);
    } else {
      ctx.font = r2.get("textStyle") ? r2.get("textStyle").getFont() : this._titleStyle.getFont();
      textWidth = Math.max(textWidth, this._measureText(ctx, r2.get("title")).width);
    }
  }.bind(this));
  canvas.width = (textWidth + 2 * margin) * ratio;
  canvas.height = (this._items.getLength() + 1) * height * ratio;
  canvas.style.height = (this._items.getLength() + 1) * height + "px";
  ctx.textBaseline = "middle";
  ctx.fillStyle = asString$1(this._textStyle.getFill().getColor());
  if (this.getTitle()) {
    table.appendChild(this._title.getElement([width, height], function(b2) {
      this.dispatchEvent({
        type: "select",
        index: -1,
        symbol: b2,
        item: this._title
      });
    }.bind(this)));
    ctx.font = this._titleStyle.getFont();
    ctx.textAlign = "center";
    this._drawText(ctx, this.getTitle(), canvas.width / ratio / 2, height / 2);
  }
  this._items.forEach(function(r2, i2) {
    var index2 = i2 + (this.getTitle() ? 1 : 0);
    table.appendChild(r2.getElement([width, height], function(b2) {
      this.dispatchEvent({
        type: "select",
        index: i2,
        symbol: b2,
        item: r2
      });
    }.bind(this)));
    var item = r2.getProperties();
    ctx.textAlign = "left";
    if (item.feature || item.typeGeom) {
      canvas = this.getLegendImage(item, canvas, index2);
      ctx.font = r2.get("textStyle") ? r2.get("textStyle").getFont() : this._textStyle.getFont();
      this._drawText(ctx, r2.get("title"), width + margin, (i2 + 1.5) * height);
    } else {
      ctx.font = r2.get("textStyle") ? r2.get("textStyle").getFont() : this._titleStyle.getFont();
      if (/\bcenter\b/.test(item.className)) {
        ctx.textAlign = "center";
        this._drawText(ctx, r2.get("title"), canvas.width / ratio / 2, (i2 + 1.5) * height);
      } else {
        this._drawText(ctx, r2.get("title"), margin, (i2 + 1.5) * height);
      }
    }
  }.bind(this));
  this.dispatchEvent({
    type: "refresh",
    width,
    height: (this._items.length + 1) * height
  });
};
ol_legend_Legend.prototype.getLegendImage = function(options, canvas, row) {
  options = options || {};
  return ol_legend_Legend.getLegendImage({
    className: options.className,
    feature: options.feature,
    typeGeom: options.typeGeom,
    style: options.style || this._style,
    properties: options.properties,
    margin: options.margin || this.get("margin"),
    size: options.size || this.get("size"),
    lineHeight: options.lineHeight || this.get("lineHeight"),
    onload: function() {
      this.refresh();
    }.bind(this)
  }, canvas, row);
};
ol_legend_Legend.getLegendImage = function(item, canvas, row) {
  item = item || {};
  if (typeof item.margin === "undefined")
    item.margin = 10;
  var size = item.size || [40, 25];
  item.onload = item.onload || function() {
    setTimeout(function() {
      ol_legend_Legend.getLegendImage(item, canvas, row);
    }, 100);
  };
  var width = size[0] + 2 * item.margin;
  var height = item.lineHeight || size[1] + 2 * item.margin;
  var ratio = DEVICE_PIXEL_RATIO;
  if (!canvas) {
    row = 0;
    canvas = document.createElement("canvas");
    canvas.width = width * ratio;
    canvas.height = height * ratio;
  }
  var ctx = canvas.getContext("2d");
  ctx.save();
  var vectorContext = toContext(ctx, { pixelRatio: ratio });
  var typeGeom = item.typeGeom;
  var style2;
  var feature$1 = item.feature;
  if (!feature$1 && typeGeom) {
    if (/Point/.test(typeGeom))
      feature$1 = new feature(new Point$4([0, 0]));
    else if (/LineString/.test(typeGeom))
      feature$1 = new feature(new LineString$2([0, 0]));
    else
      feature$1 = new feature(new Polygon$2([[0, 0]]));
    if (item.properties)
      feature$1.setProperties(item.properties);
  }
  if (feature$1) {
    style2 = feature$1.getStyle();
    if (typeof style2 === "function")
      style2 = style2(feature$1);
    if (!style2) {
      style2 = typeof item.style === "function" ? item.style(feature$1) : item.style || [];
    }
    typeGeom = feature$1.getGeometry().getType();
  } else {
    style2 = [];
  }
  if (!(style2 instanceof Array))
    style2 = [style2];
  var cx = width / 2;
  var cy = height / 2;
  var sx = size[0] / 2;
  var sy = size[1] / 2;
  var i2, s2;
  if (typeGeom === "Point") {
    var extent2 = null;
    for (i2 = 0; s2 = style2[i2]; i2++) {
      var img = s2.getImage();
      if (img) {
        var imgElt = img.getImage();
        if (imgElt && imgElt.complete && !imgElt.naturalWidth) {
          if (typeof item.onload === "function") {
            imgElt.addEventListener("load", function() {
              setTimeout(function() {
                item.onload();
              }, 100);
            });
          }
          img.load();
        }
        if (img.getAnchor) {
          var anchor = img.getAnchor();
          if (anchor) {
            var si = img.getSize();
            var dx = anchor[0] - si[0];
            var dy = anchor[1] - si[1];
            if (!extent2) {
              extent2 = [dx, dy, dx + si[0], dy + si[1]];
            } else {
              extend$2(extent2, [dx, dy, dx + si[0], dy + si[1]]);
            }
          }
        }
      }
    }
    if (extent2) {
      cx = cx + (extent2[2] + extent2[0]) / 2;
      cy = cy + (extent2[3] + extent2[1]) / 2;
    }
  }
  cy += row * height || 0;
  for (i2 = 0; s2 = style2[i2]; i2++) {
    vectorContext.setStyle(s2);
    switch (typeGeom) {
      case Point$4:
      case "Point":
      case "MultiPoint":
        vectorContext.drawGeometry(new Point$4([cx, cy]));
        break;
      case LineString$2:
      case "LineString":
      case "MultiLineString":
        ctx.save();
        ctx.rect(item.margin * ratio, 0, size[0] * ratio, canvas.height);
        ctx.clip();
        vectorContext.drawGeometry(new LineString$2([[cx - sx, cy], [cx + sx, cy]]));
        ctx.restore();
        break;
      case Polygon$2:
      case "Polygon":
      case "MultiPolygon":
        vectorContext.drawGeometry(new Polygon$2([[[cx - sx, cy - sy], [cx + sx, cy - sy], [cx + sx, cy + sy], [cx - sx, cy + sy], [cx - sx, cy - sy]]]));
        break;
    }
  }
  ctx.restore();
  return canvas;
};
var ol_control_Legend = function(options) {
  options = options || {};
  var element = document.createElement("div");
  if (options.target) {
    element.className = options.className || "ol-legend";
  } else {
    element.className = (options.className || "ol-legend") + " ol-unselectable ol-control" + (options.collapsible === false ? " ol-uncollapsible" : " ol-collapsed");
    var button = document.createElement("button");
    button.setAttribute("type", "button");
    button.addEventListener("click", function() {
      this.toggle();
    }.bind(this));
    element.appendChild(button);
    button = document.createElement("button");
    button.setAttribute("type", "button");
    button.className = "ol-closebox";
    button.addEventListener("click", function() {
      this.toggle();
    }.bind(this));
    element.appendChild(button);
  }
  ol_control_CanvasBase.call(this, {
    element,
    target: options.target
  });
  this._legend = options.legend;
  this._legend.getCanvas().className = "ol-legendImg";
  element.appendChild(this._legend.getCanvas());
  element.appendChild(this._legend.getListElement());
  if (options.collapsible !== false && options.collapsed === false)
    this.show();
  this._legend.on("select", function(e2) {
    this.dispatchEvent(e2);
  }.bind(this));
  this._legend.on("refresh", function() {
    if (this._onCanvas && this.getMap()) {
      try {
        this.getMap().renderSync();
      } catch (e2) {
      }
    }
  }.bind(this));
};
ol_ext_inherits(ol_control_Legend, ol_control_CanvasBase);
ol_control_Legend.prototype.getLegend = function() {
  return this._legend;
};
ol_control_Legend.prototype.setCanvas = function(b2) {
  this._onCanvas = b2;
  this.element.style.visibility = b2 ? "hidden" : "visible";
  if (this.getMap()) {
    try {
      this.getMap().renderSync();
    } catch (e2) {
    }
  }
};
ol_control_Legend.prototype.onCanvas = function() {
  return !!this._onCanvas;
};
ol_control_Legend.prototype._draw = function(e2) {
  if (this._onCanvas && !this.element.classList.contains("ol-collapsed")) {
    var canvas = this._legend.getCanvas();
    var ctx = this.getContext(e2);
    var h2 = ctx.canvas.height - canvas.height;
    ctx.save();
    ctx.rect(0, h2, canvas.width, canvas.height);
    var col = "#fff";
    if (this._legend.getTextStyle().getBackgroundFill()) {
      col = asString$1(this._legend.getTextStyle().getBackgroundFill().getColor());
    }
    ctx.fillStyle = ctx.strokeStyle = col;
    ctx.lineWidth = 10;
    ctx.lineJoin = "round";
    ctx.stroke();
    ctx.clearRect(0, h2, canvas.width, canvas.height);
    ctx.fill();
    ctx.drawImage(canvas, 0, h2);
    ctx.restore();
  }
};
ol_control_Legend.prototype.show = function() {
  if (this.element.classList.contains("ol-collapsed")) {
    this.element.classList.remove("ol-collapsed");
    this.dispatchEvent({ type: "change:collapse", collapsed: false });
    if (this.getMap()) {
      try {
        this.getMap().renderSync();
      } catch (e2) {
      }
    }
  }
};
ol_control_Legend.prototype.hide = function() {
  if (!this.element.classList.contains("ol-collapsed")) {
    this.element.classList.add("ol-collapsed");
    this.dispatchEvent({ type: "change:collapse", collapsed: true });
    if (this.getMap()) {
      try {
        this.getMap().renderSync();
      } catch (e2) {
      }
    }
  }
};
ol_control_Legend.prototype.collapse = function(b2) {
  if (b2 === false)
    this.show();
  else
    this.hide();
};
ol_control_Legend.prototype.isCollapsed = function() {
  return this.element.classList.contains("ol-collapsed");
};
ol_control_Legend.prototype.toggle = function() {
  this.element.classList.toggle("ol-collapsed");
  this.dispatchEvent({ type: "change:collapse", collapsed: this.element.classList.contains("ol-collapsed") });
  if (this.getMap()) {
    try {
      this.getMap().renderSync();
    } catch (e2) {
    }
  }
};
var ol_control_Print = function(options) {
  if (!options)
    options = {};
  var element = ol_ext_element.create("DIV", {
    className: options.className || "ol-print"
  });
  if (!options.target) {
    element.classList.add("ol-unselectable", "ol-control");
    ol_ext_element.create("BUTTON", {
      type: "button",
      title: options.title || "Print",
      click: function() {
        this.print();
      }.bind(this),
      parent: element
    });
  }
  ol_control_Control.call(this, {
    element,
    target: options.target
  });
  this.set("immediate", options.immediate);
  this.set("imageType", options.imageType || "image/jpeg");
  this.set("quality", options.quality || 0.8);
  this.set("orientation", options.orientation);
};
ol_ext_inherits(ol_control_Print, ol_control_Control);
ol_control_Print.prototype.toClipboard = function(e2, callback) {
  try {
    e2.canvas.toBlob(function(blob) {
      try {
        navigator.clipboard.write([
          new window.ClipboardItem(Object.defineProperty({}, blob.type, {
            value: blob,
            enumerable: true
          }))
        ]);
        if (typeof callback === "function")
          callback(true);
      } catch (err) {
        if (typeof callback === "function")
          callback(false);
      }
    });
  } catch (err) {
    if (typeof callback === "function")
      callback(false);
  }
};
ol_control_Print.prototype.copyMap = function(options, callback) {
  this.once("print", function(e2) {
    this.toClipboard(e2, callback);
  }.bind(this));
  this.print(options);
};
ol_control_Print.prototype._getCanvas = function(event, imageType, canvas) {
  var ctx;
  if (event.context) {
    canvas = event.context.canvas;
  } else {
    if (!canvas) {
      canvas = document.createElement("canvas");
      var size = this.getMap().getSize();
      canvas.width = size[0];
      canvas.height = size[1];
      ctx = canvas.getContext("2d");
      if (/jp.*g$/.test(imageType)) {
        ctx.fillStyle = this.get("bgColor") || "white";
        ctx.fillRect(0, 0, canvas.width, canvas.height);
      }
    } else {
      ctx = canvas.getContext("2d");
    }
    this.getMap().getViewport().querySelectorAll(".ol-layers canvas, canvas.ol-fixedoverlay").forEach(function(c2) {
      if (c2.width) {
        ctx.save();
        if (c2.parentNode.style.opacity === "0")
          return;
        ctx.globalAlpha = parseFloat(c2.parentNode.style.opacity) || 1;
        if (ol_ext_element.getStyle(c2.parentNode, "mix-blend-mode") === "multiply") {
          ctx.globalCompositeOperation = "multiply";
        }
        var tr = ol_ext_element.getStyle(c2, "transform") || ol_ext_element.getStyle(c2, "-webkit-transform");
        if (/^matrix/.test(tr)) {
          tr = tr.replace(/^matrix\(|\)$/g, "").split(",");
          tr.forEach(function(t3, i2) {
            tr[i2] = parseFloat(t3);
          });
          ctx.transform(tr[0], tr[1], tr[2], tr[3], tr[4], tr[5]);
          ctx.drawImage(c2, 0, 0);
        } else {
          ctx.drawImage(c2, 0, 0, ol_ext_element.getStyle(c2, "width"), ol_ext_element.getStyle(c2, "height"));
        }
        ctx.restore();
      }
    }.bind(this));
  }
  return canvas;
};
ol_control_Print.prototype.fastPrint = function(options, callback) {
  options = options || {};
  if (this._ol6) {
    requestAnimationFrame(function() {
      callback(this._getCanvas({}, options.imageType, options.canvas));
    }.bind(this));
  } else {
    this.getMap().once("postcompose", function(event) {
      if (!event.context)
        this._ol6 = true;
      callback(this._getCanvas(event, options.imageType, options.canvas));
    }.bind(this));
    this.getMap().render();
  }
};
ol_control_Print.prototype.print = function(options) {
  options = options || {};
  var imageType = options.imageType || this.get("imageType");
  var quality = options.quality || this.get("quality");
  if (this.getMap()) {
    if (options.immediate !== "silent") {
      this.dispatchEvent(Object.assign({
        type: "printing"
      }, options));
    }
    if (!options.immediate) {
      setTimeout(function() {
        options = Object.assign({}, options);
        options.immediate = "silent";
        this.print(options);
      }.bind(this), 200);
      return;
    }
    this.getMap().once(this.get("immediate") ? "postcompose" : "rendercomplete", function(event) {
      var canvas = this._getCanvas(event, imageType);
      var size = options.size || [210, 297];
      var format2 = options.format || "a4";
      var w2, h2, position2;
      var orient = options.orient || this.get("orientation");
      var margin = typeof options.margin === "number" ? options.margin : 10;
      if (canvas) {
        if (orient !== "landscape" && orient !== "portrait") {
          orient = canvas.width > canvas.height ? "landscape" : "portrait";
        }
        if (orient === "landscape")
          size = [size[1], size[0]];
        var sc = Math.min((size[0] - 2 * margin) / canvas.width, (size[1] - 2 * margin) / canvas.height);
        w2 = sc * canvas.width;
        h2 = sc * canvas.height;
        position2 = [(size[0] - w2) / 2, (size[1] - h2) / 2];
      }
      var image2;
      try {
        image2 = canvas ? canvas.toDataURL(imageType, quality) : null;
      } catch (e3) {
        this.dispatchEvent({
          type: "error",
          canvas
        });
        return;
      }
      var e2 = Object.assign({
        type: "print",
        print: {
          format: format2,
          orientation: orient,
          unit: "mm",
          size,
          position: position2,
          imageWidth: w2,
          imageHeight: h2
        },
        image: image2,
        imageType,
        quality,
        canvas
      }, options);
      this.dispatchEvent(e2);
    }.bind(this));
    this.getMap().render();
  }
};
var ol_control_CanvasTitle = function(options) {
  if (!options)
    options = {};
  var elt = ol_ext_element.create("DIV", {
    className: (options.className || "") + " ol-control-title ol-unselectable",
    style: {
      display: "block",
      visibility: "hidden"
    }
  });
  ol_control_CanvasBase.call(this, {
    element: elt,
    style: options.style
  });
  this.setTitle(options.title || "");
  this.setVisible(options.visible);
  this.element.style.font = this.getTextFont();
};
ol_ext_inherits(ol_control_CanvasTitle, ol_control_CanvasBase);
ol_control_CanvasTitle.prototype.setStyle = function(style2) {
  ol_control_CanvasBase.prototype.setStyle.call(this, style2);
  if (this.element) {
    this.element.style.font = this.getTextFont();
  }
  if (this.getMap())
    this.getMap().render();
};
ol_control_CanvasTitle.prototype.setTitle = function(title) {
  this.element.textContent = title;
  this.set("title", title);
  if (this.getMap()) {
    try {
      this.getMap().renderSync();
    } catch (e2) {
    }
  }
};
ol_control_CanvasTitle.prototype.getTitle = function() {
  return this.get("title");
};
ol_control_CanvasTitle.prototype.setVisible = function(b2) {
  this.element.style.display = b2 ? "block" : "none";
  if (this.getMap()) {
    try {
      this.getMap().renderSync();
    } catch (e2) {
    }
  }
};
ol_control_CanvasTitle.prototype.getVisible = function() {
  return this.element.style.display !== "none";
};
ol_control_CanvasTitle.prototype._draw = function(e2) {
  if (!this.getVisible())
    return;
  var ctx = this.getContext(e2);
  if (!ctx)
    return;
  var ratio = e2.frameState.pixelRatio;
  ctx.save();
  ctx.scale(ratio, ratio);
  var eltRect = this.element.getBoundingClientRect();
  var mapRect = this.getMap().getViewport().getBoundingClientRect();
  var sc = this.getMap().getSize()[0] / mapRect.width;
  ctx.translate(Math.round((eltRect.left - mapRect.left) * sc), Math.round((eltRect.top - mapRect.top) * sc));
  var h2 = this.element.clientHeight;
  var w2 = this.element.clientWidth;
  var left = w2 / 2;
  ctx.beginPath();
  ctx.fillStyle = asString$1(this.getFill().getColor());
  ctx.rect(0, 0, w2, h2);
  ctx.fill();
  ctx.closePath();
  ctx.beginPath();
  ctx.fillStyle = asString$1(this.getTextFill().getColor());
  ctx.strokeStyle = asString$1(this.getTextStroke().getColor());
  ctx.lineWidth = this.getTextStroke().getWidth();
  ctx.textAlign = "center";
  ctx.textBaseline = "middle";
  ctx.font = this.getTextFont();
  if (ctx.lineWidth)
    ctx.strokeText(this.getTitle(), left, h2 / 2);
  ctx.fillText(this.getTitle(), left, h2 / 2);
  ctx.closePath();
  ctx.restore();
};
var ol_sphere_getMapScale = function(map, dpi) {
  var view = map.getView();
  var proj = view.getProjection();
  var center = view.getCenter();
  var px = map.getPixelFromCoordinate(center);
  px[1] += 1;
  var coord = map.getCoordinateFromPixel(px);
  var d2 = getDistance(transform$3(center, proj, "EPSG:4326"), transform$3(coord, proj, "EPSG:4326"));
  d2 *= (dpi || 96) / 0.0254;
  return d2;
};
var ol_sphere_setMapScale = function(map, scale2, dpi) {
  if (map && scale2) {
    var fac = scale2;
    if (typeof scale2 === "string") {
      fac = scale2.split("/")[1];
      if (!fac)
        fac = scale2;
      fac = fac.replace(/[^\d]/g, "");
      fac = parseInt(fac);
    }
    if (!fac)
      return;
    var view = map.getView();
    var proj = view.getProjection();
    var center = view.getCenter();
    var px = map.getPixelFromCoordinate(center);
    px[1] += 1;
    var coord = map.getCoordinateFromPixel(px);
    var d2 = getDistance(transform$3(center, proj, "EPSG:4326"), transform$3(coord, proj, "EPSG:4326"));
    d2 *= (dpi || 96) / 0.0254;
    view.setResolution(view.getResolution() * fac / d2);
    return fac;
  }
};
var ol_control_Compass = function(options) {
  if (!options)
    options = {};
  var elt = document.createElement("div");
  elt.className = "ol-control ol-compassctrl ol-unselectable ol-hidden" + (options.className ? " " + options.className : "");
  elt.style.position = "absolute";
  elt.style.visibility = "hidden";
  var style2 = options.style instanceof Stroke$2 ? new Style$2({ stroke: options.style }) : options.style;
  if (!options.style) {
    style2 = new Style$2({ stroke: new Stroke$2({ width: 0 }) });
  }
  ol_control_CanvasBase.call(this, {
    element: elt,
    style: style2
  });
  this.set("rotateVithView", options.rotateWithView !== false);
  this.setVisible(options.visible !== false);
  this.setImage(options.image || options.src);
};
ol_ext_inherits(ol_control_Compass, ol_control_CanvasBase);
ol_control_Compass.prototype.setImage = function(img) {
  if (img instanceof Image) {
    this.img_ = img;
    this.img_.onload = function() {
      if (this.getMap()) {
        try {
          this.getMap().renderSync();
        } catch (e2) {
        }
      }
    }.bind(this);
  } else if (typeof img === "string") {
    switch (img) {
      case "compact": {
        this.img_ = this.compactCompass_(this.element.clientWidth, this.getStroke().getColor());
        break;
      }
      case "default": {
        this.img_ = this.defaultCompass_(this.element.clientWidth, this.getStroke().getColor());
        break;
      }
      default: {
        this.img_ = new Image();
        this.img_.onload = function() {
          if (this.getMap()) {
            try {
              this.getMap().renderSync();
            } catch (e2) {
            }
          }
        }.bind(this);
        this.img_.src = img;
        break;
      }
    }
  } else {
    this.img_ = this.defaultCompass_(this.element.clientWidth, this.getStroke().getColor());
  }
};
ol_control_Compass.prototype.compactCompass_ = function(s2, color2) {
  var canvas = document.createElement("canvas");
  var ctx = canvas.getContext("2d");
  s2 = canvas.width = canvas.height = s2 || 150;
  var r2 = s2 / 2;
  ctx.translate(r2, r2);
  ctx.fillStyle = color2 || "#963";
  ctx.lineWidth = 5;
  ctx.lineJoin = ctx.lineCap = "round";
  ctx.font = "bold " + r2 * 0.4 + "px sans-serif";
  ctx.textBaseline = "bottom";
  ctx.textAlign = "center";
  ctx.strokeStyle = "#fff";
  ctx.globalAlpha = 0.75;
  ctx.strokeText("N", 0, -r2 / 2);
  ctx.globalAlpha = 1;
  ctx.fillText("N", 0, -r2 / 2);
  ctx.beginPath();
  ctx.moveTo(0, r2 / 4);
  ctx.lineTo(r2 / 3, r2 / 2);
  ctx.lineTo(0, -r2 / 2);
  ctx.lineTo(-r2 / 3, r2 / 2);
  ctx.lineTo(0, r2 / 4);
  ctx.lineWidth = 12;
  ctx.fillStyle = "#fff";
  ctx.globalAlpha = 0.75;
  ctx.fill();
  ctx.stroke();
  ctx.globalAlpha = 1;
  ctx.fillStyle = ctx.strokeStyle = color2 || "#963";
  ctx.lineWidth = 5;
  ctx.beginPath();
  ctx.moveTo(0, r2 / 4);
  ctx.lineTo(0, -r2 / 2);
  ctx.lineTo(r2 / 3, r2 / 2);
  ctx.lineTo(0, r2 / 4);
  ctx.fill();
  ctx.stroke();
  ctx.beginPath();
  ctx.moveTo(0, r2 / 4);
  ctx.lineTo(0, -r2 / 2);
  ctx.lineTo(-r2 / 3, r2 / 2);
  ctx.lineTo(0, r2 / 4);
  ctx.stroke();
  return canvas;
};
ol_control_Compass.prototype.defaultCompass_ = function(s2, color2) {
  var canvas = document.createElement("canvas");
  var ctx = canvas.getContext("2d");
  s2 = canvas.width = canvas.height = s2 || 150;
  var r2 = s2 / 2;
  var r22 = 0.22 * r2;
  function draw(r3, r23) {
    ctx.fillStyle = color2 || "#963";
    ctx.beginPath();
    ctx.moveTo(0, 0);
    ctx.lineTo(r3, 0);
    ctx.lineTo(r23, r23);
    ctx.moveTo(0, 0);
    ctx.lineTo(-r3, 0);
    ctx.lineTo(-r23, -r23);
    ctx.moveTo(0, 0);
    ctx.lineTo(0, r3);
    ctx.lineTo(-r23, r23);
    ctx.moveTo(0, 0);
    ctx.lineTo(0, -r3);
    ctx.lineTo(r23, -r23);
    ctx.moveTo(0, 0);
    ctx.fill();
    ctx.stroke();
  }
  function draw2(r3, r23) {
    ctx.globalCompositeOperation = "destination-out";
    ctx.fillStyle = "#fff";
    ctx.beginPath();
    ctx.moveTo(0, 0);
    ctx.lineTo(r3, 0);
    ctx.lineTo(r23, -r23);
    ctx.moveTo(0, 0);
    ctx.lineTo(-r3, 0);
    ctx.lineTo(-r23, r23);
    ctx.moveTo(0, 0);
    ctx.lineTo(0, r3);
    ctx.lineTo(r23, r23);
    ctx.moveTo(0, 0);
    ctx.lineTo(0, -r3);
    ctx.lineTo(-r23, -r23);
    ctx.moveTo(0, 0);
    ctx.fill();
    ctx.globalCompositeOperation = "source-over";
    ctx.beginPath();
    ctx.moveTo(0, 0);
    ctx.lineTo(r3, 0);
    ctx.lineTo(r23, -r23);
    ctx.moveTo(0, 0);
    ctx.lineTo(-r3, 0);
    ctx.lineTo(-r23, r23);
    ctx.moveTo(0, 0);
    ctx.lineTo(0, r3);
    ctx.lineTo(r23, r23);
    ctx.moveTo(0, 0);
    ctx.lineTo(0, -r3);
    ctx.lineTo(-r23, -r23);
    ctx.moveTo(0, 0);
    ctx.stroke();
  }
  ctx.translate(r2, r2);
  ctx.strokeStyle = color2 || "#963";
  ctx.lineWidth = 1.5;
  ctx.beginPath();
  ctx.arc(0, 0, s2 * 0.41, 0, 2 * Math.PI);
  ctx.arc(0, 0, s2 * 0.44, 0, 2 * Math.PI);
  ctx.stroke();
  ctx.rotate(Math.PI / 4);
  draw(r2 * 0.9, r22 * 0.8);
  draw2(r2 * 0.9, r22 * 0.8);
  ctx.rotate(-Math.PI / 4);
  draw(r2, r22);
  draw2(r2, r22);
  return canvas;
};
ol_control_Compass.prototype.getVisible = function() {
  return ol_ext_element.getStyle(this.element, "display") === "block";
};
ol_control_Compass.prototype.setVisible = function(b2) {
  if (b2)
    this.element.classList.add("ol-visible");
  else
    this.element.classList.remove("ol-visible");
  if (this.getMap())
    this.getMap().render();
};
ol_control_Compass.prototype._draw = function(e2) {
  var ctx = this.getContext(e2);
  if (!ctx || !this.getVisible())
    return;
  var canvas = ctx.canvas;
  var i2, da = [];
  for (i2 = 0; i2 < 8; i2++)
    da[i2] = [Math.cos(Math.PI * i2 / 8), Math.sin(Math.PI * i2 / 8)];
  var ratio = e2.frameState.pixelRatio;
  ctx.save();
  ctx.scale(ratio, ratio);
  var w2 = this.element.clientWidth;
  var h2 = this.element.clientHeight;
  var pos = { left: this.element.offsetLeft, top: this.element.offsetTop };
  var compass = this.img_;
  var rot = e2.frameState.viewState.rotation;
  ctx.beginPath();
  ctx.translate(pos.left + w2 / 2, pos.top + h2 / 2);
  if (this.get("rotateVithView"))
    ctx.rotate(rot);
  if (this.getStroke().getWidth()) {
    ctx.beginPath();
    ctx.strokeStyle = this.getStroke().getColor();
    ctx.lineWidth = this.getStroke().getWidth();
    var m2 = Math.max(canvas.width, canvas.height);
    for (i2 = 0; i2 < 8; i2++) {
      ctx.moveTo(-da[i2][0] * m2, -da[i2][1] * m2);
      ctx.lineTo(da[i2][0] * m2, da[i2][1] * m2);
    }
    ctx.stroke();
  }
  if (compass.width) {
    ctx.drawImage(compass, -w2 / 2, -h2 / 2, w2, h2);
  }
  ctx.closePath();
  ctx.restore();
};
var ol_control_PrintDialog = function(options) {
  if (!options)
    options = {};
  this._lang = options.lang || "en";
  var element = ol_ext_element.create("DIV", {
    className: (options.className || "ol-print") + " ol-unselectable ol-control"
  });
  ol_ext_element.create("BUTTON", {
    type: "button",
    title: options.title || "Print",
    click: function() {
      this.print();
    }.bind(this),
    parent: element
  });
  ol_control_Control.call(this, {
    element
  });
  if (options.openWindow) {
    this.on("print", function(e2) {
      if (e2.canvas) {
        window.open().document.write('<img src="' + e2.canvas.toDataURL() + '"/>');
      }
    });
  }
  options.target = ol_ext_element.create("DIV");
  var printCtrl = this._printCtrl = new ol_control_Print(options);
  printCtrl.on(["print", "error", "printing"], function(e2) {
    content2.setAttribute("data-status", e2.type);
    if (!e2.clipboard) {
      this.dispatchEvent(e2);
    }
  }.bind(this));
  this._compass = new ol_control_Compass({
    src: options.northImage || "compact",
    visible: false,
    className: "olext-print-compass",
    style: new Stroke$2({ color: "#333", width: 0 })
  });
  var printDialog = this._printDialog = new ol_control_Dialog({
    target: document.body,
    closeBox: true,
    className: "ol-ext-print-dialog"
  });
  var content2 = printDialog.getContentElement();
  this._input = {};
  var param = ol_ext_element.create("DIV", {
    className: "ol-print-param",
    parent: content2
  });
  this._pages = [ol_ext_element.create("DIV", {
    className: "ol-page"
  })];
  var printMap = ol_ext_element.create("DIV", {
    className: "ol-map",
    parent: this._pages[0]
  });
  ol_ext_element.create("DIV", {
    html: this._pages[0],
    className: "ol-print-map",
    parent: content2
  });
  ol_ext_element.create("H2", {
    html: this.i18n("title"),
    parent: param
  });
  var ul = ol_ext_element.create("UL", { parent: param });
  var li = ol_ext_element.create("LI", {
    className: "ol-orientation",
    parent: ul
  });
  this._input.orientation = { list: li };
  var label = ol_ext_element.create("LABEL", {
    className: "portrait",
    parent: li
  });
  this._input.orientation.portrait = ol_ext_element.create("INPUT", {
    type: "radio",
    name: "ol-print-orientation",
    value: "portrait",
    checked: true,
    on: { change: function(e2) {
      this.setOrientation(e2.target.value);
    }.bind(this) },
    parent: label
  });
  ol_ext_element.create("SPAN", {
    html: this.i18n("portrait"),
    parent: label
  });
  label = ol_ext_element.create("LABEL", {
    className: "landscape",
    parent: li
  });
  this._input.orientation.landscape = ol_ext_element.create("INPUT", {
    type: "radio",
    name: "ol-print-orientation",
    value: "landscape",
    on: { change: function(e2) {
      this.setOrientation(e2.target.value);
    }.bind(this) },
    parent: label
  });
  ol_ext_element.create("SPAN", {
    html: this.i18n("landscape"),
    parent: label
  });
  var s2;
  li = ol_ext_element.create("LI", {
    html: ol_ext_element.create("LABEL", {
      html: this.i18n("size")
    }),
    className: "ol-size",
    parent: ul
  });
  var size = this._input.size = ol_ext_element.create("SELECT", {
    on: { change: function() {
      this.setSize(size.value || originalSize);
    }.bind(this) },
    parent: li
  });
  for (s2 in this.paperSize) {
    ol_ext_element.create("OPTION", {
      html: s2 + (this.paperSize[s2] ? " - " + this.paperSize[s2][0] + "x" + this.paperSize[s2][1] + " mm" : this.i18n("custom")),
      value: s2,
      parent: size
    });
  }
  li = ol_ext_element.create("LI", {
    html: ol_ext_element.create("LABEL", {
      html: this.i18n("margin")
    }),
    className: "ol-margin",
    parent: ul
  });
  var margin = this._input.margin = ol_ext_element.create("SELECT", {
    on: { change: function() {
      this.setMargin(margin.value);
    }.bind(this) },
    parent: li
  });
  for (s2 in this.marginSize) {
    ol_ext_element.create("OPTION", {
      html: this.i18n(s2) + " - " + this.marginSize[s2] + " mm",
      value: this.marginSize[s2],
      parent: margin
    });
  }
  li = ol_ext_element.create("LI", {
    html: ol_ext_element.create("LABEL", {
      html: this.i18n("scale")
    }),
    className: "ol-scale",
    parent: ul
  });
  var scale2 = this._input.scale = ol_ext_element.create("SELECT", {
    on: { change: function() {
      this.setScale(parseInt(scale2.value));
    }.bind(this) },
    parent: li
  });
  Object.keys(this.scales).forEach(function(s3) {
    ol_ext_element.create("OPTION", {
      html: this.scales[s3],
      value: s3,
      parent: scale2
    });
  }.bind(this));
  li = ol_ext_element.create("LI", {
    className: "ol-legend",
    parent: ul
  });
  var legend = ol_ext_element.createSwitch({
    html: this.i18n("legend"),
    checked: false,
    on: { change: function() {
      extraCtrl.legend.control.setCanvas(legend.checked);
    }.bind(this) },
    parent: li
  });
  li = ol_ext_element.create("LI", {
    className: "ol-print-north",
    parent: ul
  });
  var north = this._input.north = ol_ext_element.createSwitch({
    html: this.i18n("north"),
    checked: "checked",
    on: { change: function() {
      if (north.checked)
        this._compass.element.classList.add("ol-print-compass");
      else
        this._compass.element.classList.remove("ol-print-compass");
      this.getMap().render();
    }.bind(this) },
    parent: li
  });
  li = ol_ext_element.create("LI", {
    className: "ol-print-title",
    parent: ul
  });
  var title = ol_ext_element.createSwitch({
    html: this.i18n("mapTitle"),
    checked: false,
    on: { change: function(e2) {
      extraCtrl.title.control.setVisible(e2.target.checked);
    }.bind(this) },
    parent: li
  });
  var titleText = ol_ext_element.create("INPUT", {
    type: "text",
    placeholder: this.i18n("mapTitle"),
    on: {
      keydown: function(e2) {
        if (e2.keyCode === 13)
          e2.preventDefault();
      },
      keyup: function() {
        extraCtrl.title.control.setTitle(titleText.value);
      },
      change: function() {
        extraCtrl.title.control.setTitle(titleText.value);
      }.bind(this)
    },
    parent: li
  });
  var userElt = ol_ext_element.create("DIV", {
    className: "ol-user-param",
    parent: param
  });
  li = ol_ext_element.create("LI", {
    className: "ol-saveas",
    parent: ul
  });
  var copied = ol_ext_element.create("DIV", {
    html: this.i18n("copied"),
    className: "ol-clipboard-copy",
    parent: li
  });
  var save = ol_ext_element.create("SELECT", {
    on: { change: function() {
      if (this.formats[save.value].clipboard) {
        printCtrl.copyMap(this.formats[save.value], function(isok) {
          if (isok) {
            copied.classList.add("visible");
            setTimeout(function() {
              copied.classList.remove("visible");
            }, 1e3);
          }
        });
      } else {
        var format2 = typeof this.getSize() === "string" ? this.getSize() : null;
        var opt = Object.assign({
          format: format2,
          size: format2 ? this.paperSize[format2] : null,
          orient: this.getOrientation(),
          margin: this.getMargin()
        }, this.formats[save.value]);
        printCtrl.print(opt);
      }
      save.value = "";
    }.bind(this) },
    parent: li
  });
  ol_ext_element.create("OPTION", {
    html: this.i18n("saveas"),
    style: { display: "none" },
    value: "",
    parent: save
  });
  this.formats.forEach(function(format2, i2) {
    if (format2.pdf) {
      if (options.pdf === false)
        return;
    } else if (format2.clipboard) {
      if (options.copy === false)
        return;
    } else if (options.save === false) {
      return;
    }
    ol_ext_element.create("OPTION", {
      html: this.i18n(format2.title),
      value: i2,
      parent: save
    });
  }.bind(this));
  li = ol_ext_element.create("LI", {
    className: "ol-savelegend",
    parent: ul
  });
  var copylegend = ol_ext_element.create("DIV", {
    html: this.i18n("copied"),
    className: "ol-clipboard-copy",
    parent: li
  });
  var saveLegend = ol_ext_element.create("SELECT", {
    on: { change: function() {
      var clegend = extraCtrl.legend.control.getLegend().getCanvas();
      var canvas = document.createElement("CANVAS");
      canvas.width = clegend.width;
      canvas.height = clegend.height;
      var ctx = canvas.getContext("2d");
      ctx.fillStyle = "#fff";
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      ctx.drawImage(clegend, 0, 0);
      if (this.formats[saveLegend.value].clipboard) {
        canvas.toBlob(function(blob) {
          try {
            navigator.clipboard.write([
              new window.ClipboardItem(Object.defineProperty({}, blob.type, {
                value: blob,
                enumerable: true
              }))
            ]);
            copylegend.classList.add("visible");
            setTimeout(function() {
              copylegend.classList.remove("visible");
            }, 1e3);
          } catch (err) {
          }
        }, "image/png");
      } else {
        var image2;
        try {
          image2 = canvas.toDataURL(this.formats[saveLegend.value].imageType, this.formats[saveLegend.value].quality);
          var format2 = typeof this.getSize() === "string" ? this.getSize() : "A4";
          var w2 = canvas.width / 96 * 25.4;
          var h2 = canvas.height / 96 * 25.4;
          var size2 = this.paperSize[format2];
          if (this.getOrientation() === "landscape")
            size2 = [size2[1], size2[0]];
          var position2 = [
            (size2[0] - w2) / 2,
            (size2[1] - h2) / 2
          ];
          this.dispatchEvent({
            type: "print",
            print: {
              legend: true,
              format: format2,
              orientation: this.getOrientation(),
              unit: "mm",
              size: this.paperSize[format2],
              position: position2,
              imageWidth: w2,
              imageHeight: h2
            },
            image: image2,
            imageType: this.formats[saveLegend.value].imageType,
            pdf: this.formats[saveLegend.value].pdf,
            quality: this.formats[saveLegend.value].quality,
            canvas
          });
        } catch (err) {
        }
      }
      saveLegend.value = "";
    }.bind(this) },
    parent: li
  });
  ol_ext_element.create("OPTION", {
    html: this.i18n("saveLegend"),
    style: { display: "none" },
    value: "",
    parent: saveLegend
  });
  this.formats.forEach(function(format2, i2) {
    ol_ext_element.create("OPTION", {
      html: this.i18n(format2.title),
      value: i2,
      parent: saveLegend
    });
  }.bind(this));
  var prButtons = ol_ext_element.create("DIV", {
    className: "ol-ext-buttons",
    parent: param
  });
  ol_ext_element.create("BUTTON", {
    html: this.i18n("printBt"),
    type: "submit",
    click: function(e2) {
      e2.preventDefault();
      window.print();
    },
    parent: prButtons
  });
  ol_ext_element.create("BUTTON", {
    html: this.i18n("cancel"),
    type: "button",
    click: function() {
      printDialog.hide();
    },
    parent: prButtons
  });
  ol_ext_element.create("DIV", {
    html: this.i18n("errorMsg"),
    className: "ol-error",
    parent: param
  });
  var originalTarget;
  var originalSize;
  var scalelistener;
  var extraCtrl = {};
  printDialog.on("show", function() {
    this.dispatchEvent({ type: "show", userElement: userElt, dialog: this._printDialog, page: this.getPage() });
    var map = this.getMap();
    if (!map)
      return;
    document.body.classList.add("ol-print-document");
    originalTarget = map.getTargetElement();
    originalSize = map.getSize();
    if (typeof this.getSize() === "string")
      this.setSize(this.getSize());
    else
      this.setSize(originalSize);
    map.setTarget(printMap);
    if (scalelistener)
      unByKey(scalelistener);
    scalelistener = map.on("moveend", function() {
      this.setScale(ol_sphere_getMapScale(map));
    }.bind(this));
    this.setScale(ol_sphere_getMapScale(map));
    extraCtrl = {};
    this.getMap().getControls().forEach(function(c2) {
      if (c2 instanceof ol_control_Legend) {
        extraCtrl.legend = { control: c2 };
      }
      if (c2 instanceof ol_control_CanvasTitle) {
        extraCtrl.title = { control: c2 };
      }
      if (c2 instanceof ol_control_Compass) {
        if (extraCtrl.compass) {
          c2.element.classList.remove("ol-print-compass");
        } else {
          if (this._input.north.checked)
            c2.element.classList.add("ol-print-compass");
          else
            c2.element.classList.remove("ol-print-compass");
          this._compass = c2;
          extraCtrl.compass = { control: c2 };
        }
      }
    }.bind(this));
    if (extraCtrl.title) {
      title.checked = extraCtrl.title.isVisible = extraCtrl.title.control.getVisible();
      titleText.value = extraCtrl.title.control.getTitle();
      title.parentNode.parentNode.classList.remove("hidden");
    } else {
      title.parentNode.parentNode.classList.add("hidden");
    }
    if (extraCtrl.legend) {
      extraCtrl.legend.ison = extraCtrl.legend.control.onCanvas();
      extraCtrl.legend.collapsed = extraCtrl.legend.control.isCollapsed();
      extraCtrl.legend.control.collapse(false);
      saveLegend.parentNode.classList.remove("hidden");
      legend.parentNode.parentNode.classList.remove("hidden");
      legend.checked = !extraCtrl.legend.collapsed;
      extraCtrl.legend.control.setCanvas(!extraCtrl.legend.collapsed);
    } else {
      saveLegend.parentNode.classList.add("hidden");
      legend.parentNode.parentNode.classList.add("hidden");
    }
  }.bind(this));
  printDialog.on("hide", function() {
    document.body.classList.remove("ol-print-document");
    if (!originalTarget)
      return;
    this.getMap().setTarget(originalTarget);
    originalTarget = null;
    if (scalelistener)
      unByKey(scalelistener);
    if (extraCtrl.title) {
      extraCtrl.title.control.setVisible(extraCtrl.title.isVisible);
    }
    if (extraCtrl.legend) {
      extraCtrl.legend.control.setCanvas(extraCtrl.legend.ison);
      extraCtrl.legend.control.collapse(extraCtrl.legend.collapsed);
    }
    this.dispatchEvent({ type: "hide" });
  }.bind(this));
  window.addEventListener("resize", function() {
    this.setSize();
  }.bind(this));
  if (options.saveAs) {
    this.on("print", function(e2) {
      if (!e2.pdf) {
        e2.canvas.toBlob(function(blob) {
          var name = (e2.print.legend ? "legend." : "map.") + e2.imageType.replace("image/", "");
          options.saveAs(blob, name);
        }, e2.imageType, e2.quality);
      }
    });
  }
  if (options.jsPDF) {
    this.on("print", function(e2) {
      if (e2.pdf) {
        var pdf = new options.jsPDF({
          orientation: e2.print.orientation,
          unit: e2.print.unit,
          format: e2.print.size
        });
        pdf.addImage(e2.image, "JPEG", e2.print.position[0], e2.print.position[0], e2.print.imageWidth, e2.print.imageHeight);
        pdf.save(e2.print.legend ? "legend.pdf" : "map.pdf");
      }
    });
  }
};
ol_ext_inherits(ol_control_PrintDialog, ol_control_Control);
ol_control_PrintDialog.prototype.isOpen = function() {
  return this._printDialog.isOpen();
};
ol_control_PrintDialog.addLang = function(lang, labels) {
  ol_control_PrintDialog.prototype._labels[lang] = labels;
};
ol_control_PrintDialog.prototype.i18n = function(what) {
  var rep = this._labels.en[what] || "bad param";
  if (this._labels[this._lang] && this._labels[this._lang][what]) {
    rep = this._labels[this._lang][what];
  }
  return rep;
};
ol_control_PrintDialog.prototype._labels = {
  en: {
    title: "Print",
    orientation: "Orientation",
    portrait: "Portrait",
    landscape: "Landscape",
    size: "Page size",
    custom: "screen size",
    margin: "Margin",
    scale: "Scale",
    legend: "Legend",
    north: "North arrow",
    mapTitle: "Map title",
    saveas: "Save as...",
    saveLegend: "Save legend...",
    copied: "\u2714 Copied to clipboard",
    errorMsg: "Can't save map canvas...",
    printBt: "Print...",
    clipboardFormat: "copy to clipboard...",
    jpegFormat: "save as jpeg",
    pngFormat: "save as png",
    pdfFormat: "save as pdf",
    none: "none",
    small: "small",
    large: "large",
    cancel: "cancel"
  },
  fr: {
    title: "Imprimer",
    orientation: "Orientation",
    portrait: "Portrait",
    landscape: "Paysage",
    size: "Taille du papier",
    custom: "taille \xE9cran",
    margin: "Marges",
    scale: "Echelle",
    legend: "L\xE9gende",
    north: "Fl\xE8che du nord",
    mapTitle: "Titre de la carte",
    saveas: "Enregistrer sous...",
    saveLegend: "Enregistrer la l\xE9gende...",
    copied: "\u2714 Carte copi\xE9e",
    errorMsg: "Impossible d'enregistrer la carte",
    printBt: "Imprimer",
    clipboardFormat: "copier dans le presse-papier...",
    jpegFormat: "enregistrer un jpeg",
    pngFormat: "enregistrer un png",
    pdfFormat: "enregistrer un pdf",
    none: "aucune",
    small: "petites",
    large: "larges",
    cancel: "annuler"
  },
  de: {
    title: "Drucken",
    orientation: "Ausrichtung",
    portrait: "Hochformat",
    landscape: "Querformat",
    size: "Papierformat",
    custom: "Bildschirmgr\xF6\xDFe",
    margin: "Rand",
    scale: "Ma\xDFstab",
    legend: "Legende",
    north: "Nordpfeil",
    mapTitle: "Kartentitel",
    saveas: "Speichern als...",
    saveLegend: "Legende speichern...",
    copied: "\u2714 In die Zwischenablage kopiert",
    errorMsg: "Kann Karte nicht speichern...",
    printBt: "Drucken...",
    clipboardFormat: "in die Zwischenablage kopieren...",
    jpegFormat: "speichern als jpeg",
    pngFormat: "speichern als png",
    pdfFormat: "speichern als pdf",
    none: "kein",
    small: "klein",
    large: "gro\xDF",
    cancel: "abbrechen"
  },
  zh: {
    title: "\u6253\u5370",
    orientation: "\u65B9\u5411",
    portrait: "\u7EB5\u5411",
    landscape: "\u6A2A\u5411",
    size: "\u9875\u9762\u5927\u5C0F",
    custom: "\u5C4F\u5E55\u5927\u5C0F",
    margin: "\u5916\u8FB9\u8DDD",
    scale: "\u5C3A\u5EA6",
    legend: "\u56FE\u4F8B",
    north: "\u6307\u5317\u9488",
    mapTitle: "\u5730\u56FE\u540D\u5B57",
    saveas: "\u4FDD\u5B58\u4E3A...",
    saveLegend: "\u4FDD\u5B58\u56FE\u4F8B\u4E3A...",
    copied: "\u2714 \u5DF2\u590D\u5236\u5230\u526A\u8D34\u677F",
    errorMsg: "\u65E0\u6CD5\u4FDD\u5B58\u5730\u56FE...",
    printBt: "\u6253\u5370...",
    cancel: "\u53D6\u6D88"
  }
};
ol_control_PrintDialog.prototype.paperSize = {
  "": null,
  "A0": [841, 1189],
  "A1": [594, 841],
  "A2": [420, 594],
  "A3": [297, 420],
  "A4": [210, 297],
  "US Letter": [215.9, 279.4],
  "A5": [148, 210],
  "B4": [257, 364],
  "B5": [182, 257]
};
ol_control_PrintDialog.prototype.marginSize = {
  none: 0,
  small: 5,
  large: 10
};
ol_control_PrintDialog.prototype.formats = [
  {
    title: "clipboardFormat",
    imageType: "image/png",
    clipboard: true
  },
  {
    title: "jpegFormat",
    imageType: "image/jpeg",
    quality: 0.8
  },
  {
    title: "pngFormat",
    imageType: "image/png",
    quality: 0.8
  },
  {
    title: "pdfFormat",
    imageType: "image/jpeg",
    pdf: true
  }
];
ol_control_PrintDialog.prototype.scales = {
  " 5000": "1/5.000",
  " 10000": "1/10.000",
  " 25000": "1/25.000",
  " 50000": "1/50.000",
  " 100000": "1/100.000",
  " 250000": "1/250.000",
  " 1000000": "1/1.000.000"
};
ol_control_PrintDialog.prototype.getOrientation = function() {
  return this._orientation || "portrait";
};
ol_control_PrintDialog.prototype.setOrientation = function(ori) {
  this._orientation = ori === "landscape" ? "landscape" : "portrait";
  this._input.orientation[this._orientation].checked = true;
  this.setSize();
};
ol_control_PrintDialog.prototype.getMargin = function() {
  return this._margin || 0;
};
ol_control_PrintDialog.prototype.setMargin = function(margin) {
  this._margin = margin;
  this._input.margin.value = margin;
  this.setSize();
};
ol_control_PrintDialog.prototype.getSize = function() {
  return this._size;
};
ol_control_PrintDialog.prototype.setSize = function(size) {
  this._printDialog.getContentElement().setAttribute("data-status", "");
  if (size)
    this._size = size;
  else
    size = this._size;
  if (!size)
    return;
  if (typeof size === "string") {
    for (var k2 in this.paperSize) {
      if (k2 && new RegExp(k2, "i").test(size)) {
        size = k2;
      }
    }
    if (!this.paperSize[size])
      size = this._size = "A4";
    this._input.size.value = size;
    size = [
      Math.trunc(this.paperSize[size][0] * 96 / 25.4),
      Math.trunc(this.paperSize[size][1] * 96 / 25.4)
    ];
    if (this.getOrientation() === "landscape") {
      size = [size[1], size[0]];
    }
    this.getPage().classList.remove("margin");
  } else {
    this._input.size.value = "";
    this.getPage().classList.add("margin");
  }
  var printElement = this.getPage();
  var s2 = printElement.parentNode.getBoundingClientRect();
  var scx = (s2.width - 40) / size[0];
  var scy = (s2.height - 40) / size[1];
  var sc = Math.min(scx, scy, 1);
  printElement.style.width = size[0] + "px";
  printElement.style.height = size[1] + "px";
  printElement.style["-webkit-transform"] = printElement.style.transform = "translate(-50%,-50%) scale(" + sc + ")";
  var px = Math.round(5 / sc);
  printElement.style["-webkit-box-shadow"] = printElement.style["box-shadow"] = px + "px " + px + "px " + px + "px rgba(0,0,0,.6)";
  printElement.style["padding"] = this.getMargin() * 96 / 25.4 + "px";
  if (this.getMap()) {
    this.getMap().updateSize();
  }
  this.dispatchEvent({ type: "dialog:refresh" });
};
ol_control_PrintDialog.prototype.getContentElement = function() {
  return this._printDialog.getContentElement();
};
ol_control_PrintDialog.prototype.getUserElement = function() {
  return this._printDialog.getContentElement().querySelector(".ol-user-param");
};
ol_control_PrintDialog.prototype.getPage = function() {
  return this._pages[0];
};
ol_control_PrintDialog.prototype.setMap = function(map) {
  if (this.getMap()) {
    this.getMap().removeControl(this._compass);
    this.getMap().removeControl(this._printCtrl);
    this.getMap().removeControl(this._printDialog);
  }
  ol_control_Control.prototype.setMap.call(this, map);
  if (this.getMap()) {
    this.getMap().addControl(this._compass);
    this.getMap().addControl(this._printCtrl);
    this.getMap().addControl(this._printDialog);
  }
};
ol_control_PrintDialog.prototype.setScale = function(value) {
  ol_sphere_setMapScale(this.getMap(), value);
  this._input.scale.value = " " + Math.round(value / 100) * 100;
};
ol_control_PrintDialog.prototype.getScale = function() {
  return ol_sphere_getMapScale(this.getMap());
};
ol_control_PrintDialog.prototype.print = function(options) {
  options = options || {};
  if (options.size)
    this.setSize(options.size);
  if (options.scale)
    this.setScale(options.scale);
  if (options.orientation)
    this.setOrientation(options.orientation);
  if (options.margin)
    this.setMargin(options.margin);
  this._printDialog.show();
};
ol_control_PrintDialog.prototype.getrintControl = function() {
  return this._printCtrl;
};
var FileSaver_min = { exports: {} };
(function(module, exports2) {
  (function(a2, b2) {
    b2();
  })(commonjsGlobal, function() {
    function b2(a3, b3) {
      return typeof b3 == "undefined" ? b3 = { autoBom: false } : typeof b3 != "object" && (console.warn("Deprecated: Expected third argument to be a object"), b3 = { autoBom: !b3 }), b3.autoBom && /^\s*(?:text\/\S*|application\/xml|\S*\/\S*\+xml)\s*;.*charset\s*=\s*utf-8/i.test(a3.type) ? new Blob(["\uFEFF", a3], { type: a3.type }) : a3;
    }
    function c2(a3, b3, c3) {
      var d3 = new XMLHttpRequest();
      d3.open("GET", a3), d3.responseType = "blob", d3.onload = function() {
        g2(d3.response, b3, c3);
      }, d3.onerror = function() {
        console.error("could not download file");
      }, d3.send();
    }
    function d2(a3) {
      var b3 = new XMLHttpRequest();
      b3.open("HEAD", a3, false);
      try {
        b3.send();
      } catch (a4) {
      }
      return 200 <= b3.status && 299 >= b3.status;
    }
    function e2(a3) {
      try {
        a3.dispatchEvent(new MouseEvent("click"));
      } catch (c3) {
        var b3 = document.createEvent("MouseEvents");
        b3.initMouseEvent("click", true, true, window, 0, 0, 0, 80, 20, false, false, false, false, 0, null), a3.dispatchEvent(b3);
      }
    }
    var f2 = typeof window == "object" && window.window === window ? window : typeof self == "object" && self.self === self ? self : typeof commonjsGlobal == "object" && commonjsGlobal.global === commonjsGlobal ? commonjsGlobal : void 0, a2 = f2.navigator && /Macintosh/.test(navigator.userAgent) && /AppleWebKit/.test(navigator.userAgent) && !/Safari/.test(navigator.userAgent), g2 = f2.saveAs || (typeof window != "object" || window !== f2 ? function() {
    } : "download" in HTMLAnchorElement.prototype && !a2 ? function(b3, g3, h2) {
      var i2 = f2.URL || f2.webkitURL, j2 = document.createElement("a");
      g3 = g3 || b3.name || "download", j2.download = g3, j2.rel = "noopener", typeof b3 == "string" ? (j2.href = b3, j2.origin === location.origin ? e2(j2) : d2(j2.href) ? c2(b3, g3, h2) : e2(j2, j2.target = "_blank")) : (j2.href = i2.createObjectURL(b3), setTimeout(function() {
        i2.revokeObjectURL(j2.href);
      }, 4e4), setTimeout(function() {
        e2(j2);
      }, 0));
    } : "msSaveOrOpenBlob" in navigator ? function(f3, g3, h2) {
      if (g3 = g3 || f3.name || "download", typeof f3 != "string")
        navigator.msSaveOrOpenBlob(b2(f3, h2), g3);
      else if (d2(f3))
        c2(f3, g3, h2);
      else {
        var i2 = document.createElement("a");
        i2.href = f3, i2.target = "_blank", setTimeout(function() {
          e2(i2);
        });
      }
    } : function(b3, d3, e3, g3) {
      if (g3 = g3 || open("", "_blank"), g3 && (g3.document.title = g3.document.body.innerText = "downloading..."), typeof b3 == "string")
        return c2(b3, d3, e3);
      var h2 = b3.type === "application/octet-stream", i2 = /constructor/i.test(f2.HTMLElement) || f2.safari, j2 = /CriOS\/[\d]+/.test(navigator.userAgent);
      if ((j2 || h2 && i2 || a2) && typeof FileReader != "undefined") {
        var k2 = new FileReader();
        k2.onloadend = function() {
          var a3 = k2.result;
          a3 = j2 ? a3 : a3.replace(/^data:[^;]*;/, "data:attachment/file;"), g3 ? g3.location.href = a3 : location = a3, g3 = null;
        }, k2.readAsDataURL(b3);
      } else {
        var l2 = f2.URL || f2.webkitURL, m2 = l2.createObjectURL(b3);
        g3 ? g3.location = m2 : location.href = m2, g3 = null, setTimeout(function() {
          l2.revokeObjectURL(m2);
        }, 4e4);
      }
    });
    f2.saveAs = g2.saveAs = g2, module.exports = g2;
  });
})(FileSaver_min);
function _typeof$2(obj) {
  "@babel/helpers - typeof";
  return _typeof$2 = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(obj2) {
    return typeof obj2;
  } : function(obj2) {
    return obj2 && typeof Symbol == "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
  }, _typeof$2(obj);
}
var u8 = Uint8Array;
var u16 = Uint16Array;
var u32 = Uint32Array;
var fleb = new u8([0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, 0, 0, 0]);
var fdeb = new u8([0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13, 0, 0]);
var clim = new u8([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]);
var freb = function(eb, start2) {
  var b2 = new u16(31);
  for (var i2 = 0; i2 < 31; ++i2) {
    b2[i2] = start2 += 1 << eb[i2 - 1];
  }
  var r2 = new u32(b2[30]);
  for (var i2 = 1; i2 < 30; ++i2) {
    for (var j2 = b2[i2]; j2 < b2[i2 + 1]; ++j2) {
      r2[j2] = j2 - b2[i2] << 5 | i2;
    }
  }
  return [b2, r2];
};
var _a = freb(fleb, 2);
var fl = _a[0];
var revfl = _a[1];
fl[28] = 258, revfl[258] = 28;
var _b = freb(fdeb, 0);
var fd = _b[0];
var revfd = _b[1];
var rev = new u16(32768);
for (i$6 = 0; i$6 < 32768; ++i$6) {
  x$1 = (i$6 & 43690) >>> 1 | (i$6 & 21845) << 1;
  x$1 = (x$1 & 52428) >>> 2 | (x$1 & 13107) << 2;
  x$1 = (x$1 & 61680) >>> 4 | (x$1 & 3855) << 4;
  rev[i$6] = ((x$1 & 65280) >>> 8 | (x$1 & 255) << 8) >>> 1;
}
var x$1;
var i$6;
var hMap = function(cd, mb, r2) {
  var s2 = cd.length;
  var i2 = 0;
  var l2 = new u16(mb);
  for (; i2 < s2; ++i2)
    ++l2[cd[i2] - 1];
  var le2 = new u16(mb);
  for (i2 = 0; i2 < mb; ++i2) {
    le2[i2] = le2[i2 - 1] + l2[i2 - 1] << 1;
  }
  var co;
  if (r2) {
    co = new u16(1 << mb);
    var rvb = 15 - mb;
    for (i2 = 0; i2 < s2; ++i2) {
      if (cd[i2]) {
        var sv = i2 << 4 | cd[i2];
        var r_1 = mb - cd[i2];
        var v2 = le2[cd[i2] - 1]++ << r_1;
        for (var m2 = v2 | (1 << r_1) - 1; v2 <= m2; ++v2) {
          co[rev[v2] >>> rvb] = sv;
        }
      }
    }
  } else {
    co = new u16(s2);
    for (i2 = 0; i2 < s2; ++i2)
      co[i2] = rev[le2[cd[i2] - 1]++] >>> 15 - cd[i2];
  }
  return co;
};
var flt = new u8(288);
for (i$6 = 0; i$6 < 144; ++i$6)
  flt[i$6] = 8;
var i$6;
for (i$6 = 144; i$6 < 256; ++i$6)
  flt[i$6] = 9;
var i$6;
for (i$6 = 256; i$6 < 280; ++i$6)
  flt[i$6] = 7;
var i$6;
for (i$6 = 280; i$6 < 288; ++i$6)
  flt[i$6] = 8;
var i$6;
var fdt = new u8(32);
for (i$6 = 0; i$6 < 32; ++i$6)
  fdt[i$6] = 5;
var i$6;
var flm = hMap(flt, 9, 0);
var flrm = hMap(flt, 9, 1);
var fdm = hMap(fdt, 5, 0);
var fdrm = hMap(fdt, 5, 1);
var max$3 = function(a2) {
  var m2 = a2[0];
  for (var i2 = 1; i2 < a2.length; ++i2) {
    if (a2[i2] > m2)
      m2 = a2[i2];
  }
  return m2;
};
var bits = function(d2, p5, m2) {
  var o2 = p5 / 8 >> 0;
  return (d2[o2] | d2[o2 + 1] << 8) >>> (p5 & 7) & m2;
};
var bits16 = function(d2, p5) {
  var o2 = p5 / 8 >> 0;
  return (d2[o2] | d2[o2 + 1] << 8 | d2[o2 + 2] << 16) >>> (p5 & 7);
};
var shft = function(p5) {
  return (p5 / 8 >> 0) + (p5 & 7 && 1);
};
var slc = function(v2, s2, e2) {
  if (s2 == null || s2 < 0)
    s2 = 0;
  if (e2 == null || e2 > v2.length)
    e2 = v2.length;
  var n2 = new (v2 instanceof u16 ? u16 : v2 instanceof u32 ? u32 : u8)(e2 - s2);
  n2.set(v2.subarray(s2, e2));
  return n2;
};
var inflt = function(dat, buf, st2) {
  var sl = dat.length;
  var noBuf = !buf || st2;
  var noSt = !st2 || st2.i;
  if (!st2)
    st2 = {};
  if (!buf)
    buf = new u8(sl * 3);
  var cbuf = function(l3) {
    var bl = buf.length;
    if (l3 > bl) {
      var nbuf = new u8(Math.max(bl * 2, l3));
      nbuf.set(buf);
      buf = nbuf;
    }
  };
  var final = st2.f || 0, pos = st2.p || 0, bt2 = st2.b || 0, lm = st2.l, dm = st2.d, lbt = st2.m, dbt = st2.n;
  var tbts = sl * 8;
  do {
    if (!lm) {
      st2.f = final = bits(dat, pos, 1);
      var type = bits(dat, pos + 1, 3);
      pos += 3;
      if (!type) {
        var s2 = shft(pos) + 4, l2 = dat[s2 - 4] | dat[s2 - 3] << 8, t3 = s2 + l2;
        if (t3 > sl) {
          if (noSt)
            throw "unexpected EOF";
          break;
        }
        if (noBuf)
          cbuf(bt2 + l2);
        buf.set(dat.subarray(s2, t3), bt2);
        st2.b = bt2 += l2, st2.p = pos = t3 * 8;
        continue;
      } else if (type == 1)
        lm = flrm, dm = fdrm, lbt = 9, dbt = 5;
      else if (type == 2) {
        var hLit = bits(dat, pos, 31) + 257, hcLen = bits(dat, pos + 10, 15) + 4;
        var tl = hLit + bits(dat, pos + 5, 31) + 1;
        pos += 14;
        var ldt = new u8(tl);
        var clt = new u8(19);
        for (var i2 = 0; i2 < hcLen; ++i2) {
          clt[clim[i2]] = bits(dat, pos + i2 * 3, 7);
        }
        pos += hcLen * 3;
        var clb = max$3(clt), clbmsk = (1 << clb) - 1;
        if (!noSt && pos + tl * (clb + 7) > tbts)
          break;
        var clm = hMap(clt, clb, 1);
        for (var i2 = 0; i2 < tl; ) {
          var r2 = clm[bits(dat, pos, clbmsk)];
          pos += r2 & 15;
          var s2 = r2 >>> 4;
          if (s2 < 16) {
            ldt[i2++] = s2;
          } else {
            var c2 = 0, n2 = 0;
            if (s2 == 16)
              n2 = 3 + bits(dat, pos, 3), pos += 2, c2 = ldt[i2 - 1];
            else if (s2 == 17)
              n2 = 3 + bits(dat, pos, 7), pos += 3;
            else if (s2 == 18)
              n2 = 11 + bits(dat, pos, 127), pos += 7;
            while (n2--)
              ldt[i2++] = c2;
          }
        }
        var lt2 = ldt.subarray(0, hLit), dt2 = ldt.subarray(hLit);
        lbt = max$3(lt2);
        dbt = max$3(dt2);
        lm = hMap(lt2, lbt, 1);
        dm = hMap(dt2, dbt, 1);
      } else
        throw "invalid block type";
      if (pos > tbts)
        throw "unexpected EOF";
    }
    if (noBuf)
      cbuf(bt2 + 131072);
    var lms = (1 << lbt) - 1, dms = (1 << dbt) - 1;
    var mxa = lbt + dbt + 18;
    while (noSt || pos + mxa < tbts) {
      var c2 = lm[bits16(dat, pos) & lms], sym = c2 >>> 4;
      pos += c2 & 15;
      if (pos > tbts)
        throw "unexpected EOF";
      if (!c2)
        throw "invalid length/literal";
      if (sym < 256)
        buf[bt2++] = sym;
      else if (sym == 256) {
        lm = null;
        break;
      } else {
        var add2 = sym - 254;
        if (sym > 264) {
          var i2 = sym - 257, b2 = fleb[i2];
          add2 = bits(dat, pos, (1 << b2) - 1) + fl[i2];
          pos += b2;
        }
        var d2 = dm[bits16(dat, pos) & dms], dsym = d2 >>> 4;
        if (!d2)
          throw "invalid distance";
        pos += d2 & 15;
        var dt2 = fd[dsym];
        if (dsym > 3) {
          var b2 = fdeb[dsym];
          dt2 += bits16(dat, pos) & (1 << b2) - 1, pos += b2;
        }
        if (pos > tbts)
          throw "unexpected EOF";
        if (noBuf)
          cbuf(bt2 + 131072);
        var end = bt2 + add2;
        for (; bt2 < end; bt2 += 4) {
          buf[bt2] = buf[bt2 - dt2];
          buf[bt2 + 1] = buf[bt2 + 1 - dt2];
          buf[bt2 + 2] = buf[bt2 + 2 - dt2];
          buf[bt2 + 3] = buf[bt2 + 3 - dt2];
        }
        bt2 = end;
      }
    }
    st2.l = lm, st2.p = pos, st2.b = bt2;
    if (lm)
      final = 1, st2.m = lbt, st2.d = dm, st2.n = dbt;
  } while (!final);
  return bt2 == buf.length ? buf : slc(buf, 0, bt2);
};
var wbits = function(d2, p5, v2) {
  v2 <<= p5 & 7;
  var o2 = p5 / 8 >> 0;
  d2[o2] |= v2;
  d2[o2 + 1] |= v2 >>> 8;
};
var wbits16 = function(d2, p5, v2) {
  v2 <<= p5 & 7;
  var o2 = p5 / 8 >> 0;
  d2[o2] |= v2;
  d2[o2 + 1] |= v2 >>> 8;
  d2[o2 + 2] |= v2 >>> 16;
};
var hTree = function(d2, mb) {
  var t3 = [];
  for (var i2 = 0; i2 < d2.length; ++i2) {
    if (d2[i2])
      t3.push({ s: i2, f: d2[i2] });
  }
  var s2 = t3.length;
  var t22 = t3.slice();
  if (!s2)
    return [new u8(0), 0];
  if (s2 == 1) {
    var v2 = new u8(t3[0].s + 1);
    v2[t3[0].s] = 1;
    return [v2, 1];
  }
  t3.sort(function(a2, b2) {
    return a2.f - b2.f;
  });
  t3.push({ s: -1, f: 25001 });
  var l2 = t3[0], r2 = t3[1], i0 = 0, i1 = 1, i22 = 2;
  t3[0] = { s: -1, f: l2.f + r2.f, l: l2, r: r2 };
  while (i1 != s2 - 1) {
    l2 = t3[t3[i0].f < t3[i22].f ? i0++ : i22++];
    r2 = t3[i0 != i1 && t3[i0].f < t3[i22].f ? i0++ : i22++];
    t3[i1++] = { s: -1, f: l2.f + r2.f, l: l2, r: r2 };
  }
  var maxSym = t22[0].s;
  for (var i2 = 1; i2 < s2; ++i2) {
    if (t22[i2].s > maxSym)
      maxSym = t22[i2].s;
  }
  var tr = new u16(maxSym + 1);
  var mbt = ln(t3[i1 - 1], tr, 0);
  if (mbt > mb) {
    var i2 = 0, dt2 = 0;
    var lft = mbt - mb, cst = 1 << lft;
    t22.sort(function(a2, b2) {
      return tr[b2.s] - tr[a2.s] || a2.f - b2.f;
    });
    for (; i2 < s2; ++i2) {
      var i2_1 = t22[i2].s;
      if (tr[i2_1] > mb) {
        dt2 += cst - (1 << mbt - tr[i2_1]);
        tr[i2_1] = mb;
      } else
        break;
    }
    dt2 >>>= lft;
    while (dt2 > 0) {
      var i2_2 = t22[i2].s;
      if (tr[i2_2] < mb)
        dt2 -= 1 << mb - tr[i2_2]++ - 1;
      else
        ++i2;
    }
    for (; i2 >= 0 && dt2; --i2) {
      var i2_3 = t22[i2].s;
      if (tr[i2_3] == mb) {
        --tr[i2_3];
        ++dt2;
      }
    }
    mbt = mb;
  }
  return [new u8(tr), mbt];
};
var ln = function(n2, l2, d2) {
  return n2.s == -1 ? Math.max(ln(n2.l, l2, d2 + 1), ln(n2.r, l2, d2 + 1)) : l2[n2.s] = d2;
};
var lc = function(c2) {
  var s2 = c2.length;
  while (s2 && !c2[--s2])
    ;
  var cl = new u16(++s2);
  var cli = 0, cln = c2[0], cls = 1;
  var w2 = function(v2) {
    cl[cli++] = v2;
  };
  for (var i2 = 1; i2 <= s2; ++i2) {
    if (c2[i2] == cln && i2 != s2)
      ++cls;
    else {
      if (!cln && cls > 2) {
        for (; cls > 138; cls -= 138)
          w2(32754);
        if (cls > 2) {
          w2(cls > 10 ? cls - 11 << 5 | 28690 : cls - 3 << 5 | 12305);
          cls = 0;
        }
      } else if (cls > 3) {
        w2(cln), --cls;
        for (; cls > 6; cls -= 6)
          w2(8304);
        if (cls > 2)
          w2(cls - 3 << 5 | 8208), cls = 0;
      }
      while (cls--)
        w2(cln);
      cls = 1;
      cln = c2[i2];
    }
  }
  return [cl.subarray(0, cli), s2];
};
var clen = function(cf, cl) {
  var l2 = 0;
  for (var i2 = 0; i2 < cl.length; ++i2)
    l2 += cf[i2] * cl[i2];
  return l2;
};
var wfblk = function(out, pos, dat) {
  var s2 = dat.length;
  var o2 = shft(pos + 2);
  out[o2] = s2 & 255;
  out[o2 + 1] = s2 >>> 8;
  out[o2 + 2] = out[o2] ^ 255;
  out[o2 + 3] = out[o2 + 1] ^ 255;
  for (var i2 = 0; i2 < s2; ++i2)
    out[o2 + i2 + 4] = dat[i2];
  return (o2 + 4 + s2) * 8;
};
var wblk = function(dat, out, final, syms, lf, df, eb, li, bs, bl, p5) {
  wbits(out, p5++, final);
  ++lf[256];
  var _a2 = hTree(lf, 15), dlt = _a2[0], mlb = _a2[1];
  var _b2 = hTree(df, 15), ddt = _b2[0], mdb = _b2[1];
  var _c = lc(dlt), lclt = _c[0], nlc = _c[1];
  var _d = lc(ddt), lcdt = _d[0], ndc = _d[1];
  var lcfreq = new u16(19);
  for (var i2 = 0; i2 < lclt.length; ++i2)
    lcfreq[lclt[i2] & 31]++;
  for (var i2 = 0; i2 < lcdt.length; ++i2)
    lcfreq[lcdt[i2] & 31]++;
  var _e = hTree(lcfreq, 7), lct = _e[0], mlcb = _e[1];
  var nlcc = 19;
  for (; nlcc > 4 && !lct[clim[nlcc - 1]]; --nlcc)
    ;
  var flen = bl + 5 << 3;
  var ftlen = clen(lf, flt) + clen(df, fdt) + eb;
  var dtlen = clen(lf, dlt) + clen(df, ddt) + eb + 14 + 3 * nlcc + clen(lcfreq, lct) + (2 * lcfreq[16] + 3 * lcfreq[17] + 7 * lcfreq[18]);
  if (flen <= ftlen && flen <= dtlen)
    return wfblk(out, p5, dat.subarray(bs, bs + bl));
  var lm, ll, dm, dl;
  wbits(out, p5, 1 + (dtlen < ftlen)), p5 += 2;
  if (dtlen < ftlen) {
    lm = hMap(dlt, mlb, 0), ll = dlt, dm = hMap(ddt, mdb, 0), dl = ddt;
    var llm = hMap(lct, mlcb, 0);
    wbits(out, p5, nlc - 257);
    wbits(out, p5 + 5, ndc - 1);
    wbits(out, p5 + 10, nlcc - 4);
    p5 += 14;
    for (var i2 = 0; i2 < nlcc; ++i2)
      wbits(out, p5 + 3 * i2, lct[clim[i2]]);
    p5 += 3 * nlcc;
    var lcts = [lclt, lcdt];
    for (var it2 = 0; it2 < 2; ++it2) {
      var clct = lcts[it2];
      for (var i2 = 0; i2 < clct.length; ++i2) {
        var len = clct[i2] & 31;
        wbits(out, p5, llm[len]), p5 += lct[len];
        if (len > 15)
          wbits(out, p5, clct[i2] >>> 5 & 127), p5 += clct[i2] >>> 12;
      }
    }
  } else {
    lm = flm, ll = flt, dm = fdm, dl = fdt;
  }
  for (var i2 = 0; i2 < li; ++i2) {
    if (syms[i2] > 255) {
      var len = syms[i2] >>> 18 & 31;
      wbits16(out, p5, lm[len + 257]), p5 += ll[len + 257];
      if (len > 7)
        wbits(out, p5, syms[i2] >>> 23 & 31), p5 += fleb[len];
      var dst = syms[i2] & 31;
      wbits16(out, p5, dm[dst]), p5 += dl[dst];
      if (dst > 3)
        wbits16(out, p5, syms[i2] >>> 5 & 8191), p5 += fdeb[dst];
    } else {
      wbits16(out, p5, lm[syms[i2]]), p5 += ll[syms[i2]];
    }
  }
  wbits16(out, p5, lm[256]);
  return p5 + ll[256];
};
var deo = new u32([65540, 131080, 131088, 131104, 262176, 1048704, 1048832, 2114560, 2117632]);
var et$1 = new u8(0);
var dflt = function(dat, lvl, plvl, pre, post2, lst) {
  var s2 = dat.length;
  var o2 = new u8(pre + s2 + 5 * (1 + Math.floor(s2 / 7e3)) + post2);
  var w2 = o2.subarray(pre, o2.length - post2);
  var pos = 0;
  if (!lvl || s2 < 8) {
    for (var i2 = 0; i2 <= s2; i2 += 65535) {
      var e2 = i2 + 65535;
      if (e2 < s2) {
        pos = wfblk(w2, pos, dat.subarray(i2, e2));
      } else {
        w2[i2] = lst;
        pos = wfblk(w2, pos, dat.subarray(i2, s2));
      }
    }
  } else {
    var opt = deo[lvl - 1];
    var n2 = opt >>> 13, c2 = opt & 8191;
    var msk_1 = (1 << plvl) - 1;
    var prev = new u16(32768), head2 = new u16(msk_1 + 1);
    var bs1_1 = Math.ceil(plvl / 3), bs2_1 = 2 * bs1_1;
    var hsh = function(i3) {
      return (dat[i3] ^ dat[i3 + 1] << bs1_1 ^ dat[i3 + 2] << bs2_1) & msk_1;
    };
    var syms = new u32(25e3);
    var lf = new u16(288), df = new u16(32);
    var lc_1 = 0, eb = 0, i2 = 0, li = 0, wi = 0, bs = 0;
    for (; i2 < s2; ++i2) {
      var hv = hsh(i2);
      var imod = i2 & 32767;
      var pimod = head2[hv];
      prev[imod] = pimod;
      head2[hv] = imod;
      if (wi <= i2) {
        var rem = s2 - i2;
        if ((lc_1 > 7e3 || li > 24576) && rem > 423) {
          pos = wblk(dat, w2, 0, syms, lf, df, eb, li, bs, i2 - bs, pos);
          li = lc_1 = eb = 0, bs = i2;
          for (var j2 = 0; j2 < 286; ++j2)
            lf[j2] = 0;
          for (var j2 = 0; j2 < 30; ++j2)
            df[j2] = 0;
        }
        var l2 = 2, d2 = 0, ch_1 = c2, dif = imod - pimod & 32767;
        if (rem > 2 && hv == hsh(i2 - dif)) {
          var maxn = Math.min(n2, rem) - 1;
          var maxd = Math.min(32767, i2);
          var ml = Math.min(258, rem);
          while (dif <= maxd && --ch_1 && imod != pimod) {
            if (dat[i2 + l2] == dat[i2 + l2 - dif]) {
              var nl = 0;
              for (; nl < ml && dat[i2 + nl] == dat[i2 + nl - dif]; ++nl)
                ;
              if (nl > l2) {
                l2 = nl, d2 = dif;
                if (nl > maxn)
                  break;
                var mmd = Math.min(dif, nl - 2);
                var md = 0;
                for (var j2 = 0; j2 < mmd; ++j2) {
                  var ti = i2 - dif + j2 + 32768 & 32767;
                  var pti = prev[ti];
                  var cd = ti - pti + 32768 & 32767;
                  if (cd > md)
                    md = cd, pimod = ti;
                }
              }
            }
            imod = pimod, pimod = prev[imod];
            dif += imod - pimod + 32768 & 32767;
          }
        }
        if (d2) {
          syms[li++] = 268435456 | revfl[l2] << 18 | revfd[d2];
          var lin = revfl[l2] & 31, din = revfd[d2] & 31;
          eb += fleb[lin] + fdeb[din];
          ++lf[257 + lin];
          ++df[din];
          wi = i2 + l2;
          ++lc_1;
        } else {
          syms[li++] = dat[i2];
          ++lf[dat[i2]];
        }
      }
    }
    pos = wblk(dat, w2, lst, syms, lf, df, eb, li, bs, i2 - bs, pos);
    if (!lst)
      pos = wfblk(w2, pos, et$1);
  }
  return slc(o2, 0, pre + shft(pos) + post2);
};
var adler = function() {
  var a2 = 1, b2 = 0;
  return {
    p: function(d2) {
      var n2 = a2, m2 = b2;
      var l2 = d2.length;
      for (var i2 = 0; i2 != l2; ) {
        var e2 = Math.min(i2 + 5552, l2);
        for (; i2 < e2; ++i2)
          n2 += d2[i2], m2 += n2;
        n2 %= 65521, m2 %= 65521;
      }
      a2 = n2, b2 = m2;
    },
    d: function() {
      return (a2 >>> 8 << 16 | (b2 & 255) << 8 | b2 >>> 8) + ((a2 & 255) << 23) * 2;
    }
  };
};
var dopt = function(dat, opt, pre, post2, st2) {
  return dflt(dat, opt.level == null ? 6 : opt.level, opt.mem == null ? Math.ceil(Math.max(8, Math.min(13, Math.log(dat.length))) * 1.5) : 12 + opt.mem, pre, post2, !st2);
};
var wbytes = function(d2, b2, v2) {
  for (; v2; ++b2)
    d2[b2] = v2, v2 >>>= 8;
};
var zlh = function(c2, o2) {
  var lv = o2.level, fl2 = lv == 0 ? 0 : lv < 6 ? 1 : lv == 9 ? 3 : 2;
  c2[0] = 120, c2[1] = fl2 << 6 | (fl2 ? 32 - 2 * fl2 : 1);
};
var zlv = function(d2) {
  if ((d2[0] & 15) != 8 || d2[0] >>> 4 > 7 || (d2[0] << 8 | d2[1]) % 31)
    throw "invalid zlib data";
  if (d2[1] & 32)
    throw "invalid zlib data: preset dictionaries not supported";
};
function zlibSync(data2, opts) {
  if (opts === void 0) {
    opts = {};
  }
  var a2 = adler();
  a2.p(data2);
  var d2 = dopt(data2, opts, 2, 4);
  return zlh(d2, opts), wbytes(d2, d2.length - 4, a2.d()), d2;
}
function unzlibSync(data2, out) {
  return inflt((zlv(data2), data2.subarray(2, -4)), out);
}
var n$1 = function() {
  return typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : this;
}();
function i$5() {
  n$1.console && typeof n$1.console.log == "function" && n$1.console.log.apply(n$1.console, arguments);
}
var a$2 = { log: i$5, warn: function(t3) {
  n$1.console && (typeof n$1.console.warn == "function" ? n$1.console.warn.apply(n$1.console, arguments) : i$5.call(null, arguments));
}, error: function(t3) {
  n$1.console && (typeof n$1.console.error == "function" ? n$1.console.error.apply(n$1.console, arguments) : i$5(t3));
} };
function o$1(t3, e2, r2) {
  var n2 = new XMLHttpRequest();
  n2.open("GET", t3), n2.responseType = "blob", n2.onload = function() {
    l$1(n2.response, e2, r2);
  }, n2.onerror = function() {
    a$2.error("could not download file");
  }, n2.send();
}
function s$1(t3) {
  var e2 = new XMLHttpRequest();
  e2.open("HEAD", t3, false);
  try {
    e2.send();
  } catch (t4) {
  }
  return e2.status >= 200 && e2.status <= 299;
}
function c$2(t3) {
  try {
    t3.dispatchEvent(new MouseEvent("click"));
  } catch (r2) {
    var e2 = document.createEvent("MouseEvents");
    e2.initMouseEvent("click", true, true, window, 0, 0, 0, 80, 20, false, false, false, false, 0, null), t3.dispatchEvent(e2);
  }
}
var u$2;
var h$1;
var l$1 = n$1.saveAs || ((typeof window == "undefined" ? "undefined" : _typeof$2(window)) !== "object" || window !== n$1 ? function() {
} : typeof HTMLAnchorElement != "undefined" && "download" in HTMLAnchorElement.prototype ? function(t3, e2, r2) {
  var i2 = n$1.URL || n$1.webkitURL, a2 = document.createElement("a");
  e2 = e2 || t3.name || "download", a2.download = e2, a2.rel = "noopener", typeof t3 == "string" ? (a2.href = t3, a2.origin !== location.origin ? s$1(a2.href) ? o$1(t3, e2, r2) : c$2(a2, a2.target = "_blank") : c$2(a2)) : (a2.href = i2.createObjectURL(t3), setTimeout(function() {
    i2.revokeObjectURL(a2.href);
  }, 4e4), setTimeout(function() {
    c$2(a2);
  }, 0));
} : "msSaveOrOpenBlob" in navigator ? function(e2, r2, n2) {
  if (r2 = r2 || e2.name || "download", typeof e2 == "string")
    if (s$1(e2))
      o$1(e2, r2, n2);
    else {
      var i2 = document.createElement("a");
      i2.href = e2, i2.target = "_blank", setTimeout(function() {
        c$2(i2);
      });
    }
  else
    navigator.msSaveOrOpenBlob(function(e3, r3) {
      return r3 === void 0 ? r3 = { autoBom: false } : _typeof$2(r3) !== "object" && (a$2.warn("Deprecated: Expected third argument to be a object"), r3 = { autoBom: !r3 }), r3.autoBom && /^\s*(?:text\/\S*|application\/xml|\S*\/\S*\+xml)\s*;.*charset\s*=\s*utf-8/i.test(e3.type) ? new Blob([String.fromCharCode(65279), e3], { type: e3.type }) : e3;
    }(e2, n2), r2);
} : function(e2, r2, i2, a2) {
  if ((a2 = a2 || open("", "_blank")) && (a2.document.title = a2.document.body.innerText = "downloading..."), typeof e2 == "string")
    return o$1(e2, r2, i2);
  var s2 = e2.type === "application/octet-stream", c2 = /constructor/i.test(n$1.HTMLElement) || n$1.safari, u2 = /CriOS\/[\d]+/.test(navigator.userAgent);
  if ((u2 || s2 && c2) && (typeof FileReader == "undefined" ? "undefined" : _typeof$2(FileReader)) === "object") {
    var h2 = new FileReader();
    h2.onloadend = function() {
      var t3 = h2.result;
      t3 = u2 ? t3 : t3.replace(/^data:[^;]*;/, "data:attachment/file;"), a2 ? a2.location.href = t3 : location = t3, a2 = null;
    }, h2.readAsDataURL(e2);
  } else {
    var l2 = n$1.URL || n$1.webkitURL, f2 = l2.createObjectURL(e2);
    a2 ? a2.location = f2 : location.href = f2, a2 = null, setTimeout(function() {
      l2.revokeObjectURL(f2);
    }, 4e4);
  }
});
function f$2(t3) {
  var e2;
  t3 = t3 || "", this.ok = false, t3.charAt(0) == "#" && (t3 = t3.substr(1, 6));
  t3 = { aliceblue: "f0f8ff", antiquewhite: "faebd7", aqua: "00ffff", aquamarine: "7fffd4", azure: "f0ffff", beige: "f5f5dc", bisque: "ffe4c4", black: "000000", blanchedalmond: "ffebcd", blue: "0000ff", blueviolet: "8a2be2", brown: "a52a2a", burlywood: "deb887", cadetblue: "5f9ea0", chartreuse: "7fff00", chocolate: "d2691e", coral: "ff7f50", cornflowerblue: "6495ed", cornsilk: "fff8dc", crimson: "dc143c", cyan: "00ffff", darkblue: "00008b", darkcyan: "008b8b", darkgoldenrod: "b8860b", darkgray: "a9a9a9", darkgreen: "006400", darkkhaki: "bdb76b", darkmagenta: "8b008b", darkolivegreen: "556b2f", darkorange: "ff8c00", darkorchid: "9932cc", darkred: "8b0000", darksalmon: "e9967a", darkseagreen: "8fbc8f", darkslateblue: "483d8b", darkslategray: "2f4f4f", darkturquoise: "00ced1", darkviolet: "9400d3", deeppink: "ff1493", deepskyblue: "00bfff", dimgray: "696969", dodgerblue: "1e90ff", feldspar: "d19275", firebrick: "b22222", floralwhite: "fffaf0", forestgreen: "228b22", fuchsia: "ff00ff", gainsboro: "dcdcdc", ghostwhite: "f8f8ff", gold: "ffd700", goldenrod: "daa520", gray: "808080", green: "008000", greenyellow: "adff2f", honeydew: "f0fff0", hotpink: "ff69b4", indianred: "cd5c5c", indigo: "4b0082", ivory: "fffff0", khaki: "f0e68c", lavender: "e6e6fa", lavenderblush: "fff0f5", lawngreen: "7cfc00", lemonchiffon: "fffacd", lightblue: "add8e6", lightcoral: "f08080", lightcyan: "e0ffff", lightgoldenrodyellow: "fafad2", lightgrey: "d3d3d3", lightgreen: "90ee90", lightpink: "ffb6c1", lightsalmon: "ffa07a", lightseagreen: "20b2aa", lightskyblue: "87cefa", lightslateblue: "8470ff", lightslategray: "778899", lightsteelblue: "b0c4de", lightyellow: "ffffe0", lime: "00ff00", limegreen: "32cd32", linen: "faf0e6", magenta: "ff00ff", maroon: "800000", mediumaquamarine: "66cdaa", mediumblue: "0000cd", mediumorchid: "ba55d3", mediumpurple: "9370d8", mediumseagreen: "3cb371", mediumslateblue: "7b68ee", mediumspringgreen: "00fa9a", mediumturquoise: "48d1cc", mediumvioletred: "c71585", midnightblue: "191970", mintcream: "f5fffa", mistyrose: "ffe4e1", moccasin: "ffe4b5", navajowhite: "ffdead", navy: "000080", oldlace: "fdf5e6", olive: "808000", olivedrab: "6b8e23", orange: "ffa500", orangered: "ff4500", orchid: "da70d6", palegoldenrod: "eee8aa", palegreen: "98fb98", paleturquoise: "afeeee", palevioletred: "d87093", papayawhip: "ffefd5", peachpuff: "ffdab9", peru: "cd853f", pink: "ffc0cb", plum: "dda0dd", powderblue: "b0e0e6", purple: "800080", red: "ff0000", rosybrown: "bc8f8f", royalblue: "4169e1", saddlebrown: "8b4513", salmon: "fa8072", sandybrown: "f4a460", seagreen: "2e8b57", seashell: "fff5ee", sienna: "a0522d", silver: "c0c0c0", skyblue: "87ceeb", slateblue: "6a5acd", slategray: "708090", snow: "fffafa", springgreen: "00ff7f", steelblue: "4682b4", tan: "d2b48c", teal: "008080", thistle: "d8bfd8", tomato: "ff6347", turquoise: "40e0d0", violet: "ee82ee", violetred: "d02090", wheat: "f5deb3", white: "ffffff", whitesmoke: "f5f5f5", yellow: "ffff00", yellowgreen: "9acd32" }[t3 = (t3 = t3.replace(/ /g, "")).toLowerCase()] || t3;
  for (var r2 = [{ re: /^rgb\((\d{1,3}),\s*(\d{1,3}),\s*(\d{1,3})\)$/, example: ["rgb(123, 234, 45)", "rgb(255,234,245)"], process: function(t4) {
    return [parseInt(t4[1]), parseInt(t4[2]), parseInt(t4[3])];
  } }, { re: /^(\w{2})(\w{2})(\w{2})$/, example: ["#00ff00", "336699"], process: function(t4) {
    return [parseInt(t4[1], 16), parseInt(t4[2], 16), parseInt(t4[3], 16)];
  } }, { re: /^(\w{1})(\w{1})(\w{1})$/, example: ["#fb0", "f0f"], process: function(t4) {
    return [parseInt(t4[1] + t4[1], 16), parseInt(t4[2] + t4[2], 16), parseInt(t4[3] + t4[3], 16)];
  } }], n2 = 0; n2 < r2.length; n2++) {
    var i2 = r2[n2].re, a2 = r2[n2].process, o2 = i2.exec(t3);
    o2 && (e2 = a2(o2), this.r = e2[0], this.g = e2[1], this.b = e2[2], this.ok = true);
  }
  this.r = this.r < 0 || isNaN(this.r) ? 0 : this.r > 255 ? 255 : this.r, this.g = this.g < 0 || isNaN(this.g) ? 0 : this.g > 255 ? 255 : this.g, this.b = this.b < 0 || isNaN(this.b) ? 0 : this.b > 255 ? 255 : this.b, this.toRGB = function() {
    return "rgb(" + this.r + ", " + this.g + ", " + this.b + ")";
  }, this.toHex = function() {
    var t4 = this.r.toString(16), e3 = this.g.toString(16), r3 = this.b.toString(16);
    return t4.length == 1 && (t4 = "0" + t4), e3.length == 1 && (e3 = "0" + e3), r3.length == 1 && (r3 = "0" + r3), "#" + t4 + e3 + r3;
  };
}
function d(t3, e2) {
  var r2 = t3[0], n2 = t3[1], i2 = t3[2], a2 = t3[3];
  r2 = g(r2, n2, i2, a2, e2[0], 7, -680876936), a2 = g(a2, r2, n2, i2, e2[1], 12, -389564586), i2 = g(i2, a2, r2, n2, e2[2], 17, 606105819), n2 = g(n2, i2, a2, r2, e2[3], 22, -1044525330), r2 = g(r2, n2, i2, a2, e2[4], 7, -176418897), a2 = g(a2, r2, n2, i2, e2[5], 12, 1200080426), i2 = g(i2, a2, r2, n2, e2[6], 17, -1473231341), n2 = g(n2, i2, a2, r2, e2[7], 22, -45705983), r2 = g(r2, n2, i2, a2, e2[8], 7, 1770035416), a2 = g(a2, r2, n2, i2, e2[9], 12, -1958414417), i2 = g(i2, a2, r2, n2, e2[10], 17, -42063), n2 = g(n2, i2, a2, r2, e2[11], 22, -1990404162), r2 = g(r2, n2, i2, a2, e2[12], 7, 1804603682), a2 = g(a2, r2, n2, i2, e2[13], 12, -40341101), i2 = g(i2, a2, r2, n2, e2[14], 17, -1502002290), r2 = m$2(r2, n2 = g(n2, i2, a2, r2, e2[15], 22, 1236535329), i2, a2, e2[1], 5, -165796510), a2 = m$2(a2, r2, n2, i2, e2[6], 9, -1069501632), i2 = m$2(i2, a2, r2, n2, e2[11], 14, 643717713), n2 = m$2(n2, i2, a2, r2, e2[0], 20, -373897302), r2 = m$2(r2, n2, i2, a2, e2[5], 5, -701558691), a2 = m$2(a2, r2, n2, i2, e2[10], 9, 38016083), i2 = m$2(i2, a2, r2, n2, e2[15], 14, -660478335), n2 = m$2(n2, i2, a2, r2, e2[4], 20, -405537848), r2 = m$2(r2, n2, i2, a2, e2[9], 5, 568446438), a2 = m$2(a2, r2, n2, i2, e2[14], 9, -1019803690), i2 = m$2(i2, a2, r2, n2, e2[3], 14, -187363961), n2 = m$2(n2, i2, a2, r2, e2[8], 20, 1163531501), r2 = m$2(r2, n2, i2, a2, e2[13], 5, -1444681467), a2 = m$2(a2, r2, n2, i2, e2[2], 9, -51403784), i2 = m$2(i2, a2, r2, n2, e2[7], 14, 1735328473), r2 = v$1(r2, n2 = m$2(n2, i2, a2, r2, e2[12], 20, -1926607734), i2, a2, e2[5], 4, -378558), a2 = v$1(a2, r2, n2, i2, e2[8], 11, -2022574463), i2 = v$1(i2, a2, r2, n2, e2[11], 16, 1839030562), n2 = v$1(n2, i2, a2, r2, e2[14], 23, -35309556), r2 = v$1(r2, n2, i2, a2, e2[1], 4, -1530992060), a2 = v$1(a2, r2, n2, i2, e2[4], 11, 1272893353), i2 = v$1(i2, a2, r2, n2, e2[7], 16, -155497632), n2 = v$1(n2, i2, a2, r2, e2[10], 23, -1094730640), r2 = v$1(r2, n2, i2, a2, e2[13], 4, 681279174), a2 = v$1(a2, r2, n2, i2, e2[0], 11, -358537222), i2 = v$1(i2, a2, r2, n2, e2[3], 16, -722521979), n2 = v$1(n2, i2, a2, r2, e2[6], 23, 76029189), r2 = v$1(r2, n2, i2, a2, e2[9], 4, -640364487), a2 = v$1(a2, r2, n2, i2, e2[12], 11, -421815835), i2 = v$1(i2, a2, r2, n2, e2[15], 16, 530742520), r2 = b(r2, n2 = v$1(n2, i2, a2, r2, e2[2], 23, -995338651), i2, a2, e2[0], 6, -198630844), a2 = b(a2, r2, n2, i2, e2[7], 10, 1126891415), i2 = b(i2, a2, r2, n2, e2[14], 15, -1416354905), n2 = b(n2, i2, a2, r2, e2[5], 21, -57434055), r2 = b(r2, n2, i2, a2, e2[12], 6, 1700485571), a2 = b(a2, r2, n2, i2, e2[3], 10, -1894986606), i2 = b(i2, a2, r2, n2, e2[10], 15, -1051523), n2 = b(n2, i2, a2, r2, e2[1], 21, -2054922799), r2 = b(r2, n2, i2, a2, e2[8], 6, 1873313359), a2 = b(a2, r2, n2, i2, e2[15], 10, -30611744), i2 = b(i2, a2, r2, n2, e2[6], 15, -1560198380), n2 = b(n2, i2, a2, r2, e2[13], 21, 1309151649), r2 = b(r2, n2, i2, a2, e2[4], 6, -145523070), a2 = b(a2, r2, n2, i2, e2[11], 10, -1120210379), i2 = b(i2, a2, r2, n2, e2[2], 15, 718787259), n2 = b(n2, i2, a2, r2, e2[9], 21, -343485551), t3[0] = _$1(r2, t3[0]), t3[1] = _$1(n2, t3[1]), t3[2] = _$1(i2, t3[2]), t3[3] = _$1(a2, t3[3]);
}
function p$1(t3, e2, r2, n2, i2, a2) {
  return e2 = _$1(_$1(e2, t3), _$1(n2, a2)), _$1(e2 << i2 | e2 >>> 32 - i2, r2);
}
function g(t3, e2, r2, n2, i2, a2, o2) {
  return p$1(e2 & r2 | ~e2 & n2, t3, e2, i2, a2, o2);
}
function m$2(t3, e2, r2, n2, i2, a2, o2) {
  return p$1(e2 & n2 | r2 & ~n2, t3, e2, i2, a2, o2);
}
function v$1(t3, e2, r2, n2, i2, a2, o2) {
  return p$1(e2 ^ r2 ^ n2, t3, e2, i2, a2, o2);
}
function b(t3, e2, r2, n2, i2, a2, o2) {
  return p$1(r2 ^ (e2 | ~n2), t3, e2, i2, a2, o2);
}
function y$1(t3) {
  var e2, r2 = t3.length, n2 = [1732584193, -271733879, -1732584194, 271733878];
  for (e2 = 64; e2 <= t3.length; e2 += 64)
    d(n2, w(t3.substring(e2 - 64, e2)));
  t3 = t3.substring(e2 - 64);
  var i2 = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
  for (e2 = 0; e2 < t3.length; e2++)
    i2[e2 >> 2] |= t3.charCodeAt(e2) << (e2 % 4 << 3);
  if (i2[e2 >> 2] |= 128 << (e2 % 4 << 3), e2 > 55)
    for (d(n2, i2), e2 = 0; e2 < 16; e2++)
      i2[e2] = 0;
  return i2[14] = 8 * r2, d(n2, i2), n2;
}
function w(t3) {
  var e2, r2 = [];
  for (e2 = 0; e2 < 64; e2 += 4)
    r2[e2 >> 2] = t3.charCodeAt(e2) + (t3.charCodeAt(e2 + 1) << 8) + (t3.charCodeAt(e2 + 2) << 16) + (t3.charCodeAt(e2 + 3) << 24);
  return r2;
}
u$2 = n$1.atob.bind(n$1), h$1 = n$1.btoa.bind(n$1);
var N$1 = "0123456789abcdef".split("");
function L$1(t3) {
  for (var e2 = "", r2 = 0; r2 < 4; r2++)
    e2 += N$1[t3 >> 8 * r2 + 4 & 15] + N$1[t3 >> 8 * r2 & 15];
  return e2;
}
function A$1(t3) {
  return String.fromCharCode((255 & t3) >> 0, (65280 & t3) >> 8, (16711680 & t3) >> 16, (4278190080 & t3) >> 24);
}
function x(t3) {
  return y$1(t3).map(A$1).join("");
}
var S = function(t3) {
  for (var e2 = 0; e2 < t3.length; e2++)
    t3[e2] = L$1(t3[e2]);
  return t3.join("");
}(y$1("hello")) != "5d41402abc4b2a76b9719d911017c592";
function _$1(t3, e2) {
  if (S) {
    var r2 = (65535 & t3) + (65535 & e2);
    return (t3 >> 16) + (e2 >> 16) + (r2 >> 16) << 16 | 65535 & r2;
  }
  return t3 + e2 & 4294967295;
}
function P(t3, e2) {
  var r2, n2, i2, a2;
  if (t3 !== r2) {
    for (var o2 = (i2 = t3, a2 = 1 + (256 / t3.length >> 0), new Array(a2 + 1).join(i2)), s2 = [], c2 = 0; c2 < 256; c2++)
      s2[c2] = c2;
    var u2 = 0;
    for (c2 = 0; c2 < 256; c2++) {
      var h2 = s2[c2];
      u2 = (u2 + h2 + o2.charCodeAt(c2)) % 256, s2[c2] = s2[u2], s2[u2] = h2;
    }
    r2 = t3, n2 = s2;
  } else
    s2 = n2;
  var l2 = e2.length, f2 = 0, d2 = 0, p5 = "";
  for (c2 = 0; c2 < l2; c2++)
    d2 = (d2 + (h2 = s2[f2 = (f2 + 1) % 256])) % 256, s2[f2] = s2[d2], s2[d2] = h2, o2 = s2[(s2[f2] + s2[d2]) % 256], p5 += String.fromCharCode(e2.charCodeAt(c2) ^ o2);
  return p5;
}
var k = { print: 4, modify: 8, copy: 16, "annot-forms": 32 };
function I(t3, e2, r2, n2) {
  this.v = 1, this.r = 2;
  var i2 = 192;
  t3.forEach(function(t4) {
    if (k.perm !== void 0)
      throw new Error("Invalid permission: " + t4);
    i2 += k[t4];
  }), this.padding = "(\xBFN^Nu\x8AAd\0NV\xFF\xFA\b..\0\xB6\xD0h>\x80/\f\xA9\xFEdSiz";
  var a2 = (e2 + this.padding).substr(0, 32), o2 = (r2 + this.padding).substr(0, 32);
  this.O = this.processOwnerPassword(a2, o2), this.P = -(1 + (255 ^ i2)), this.encryptionKey = x(a2 + this.O + this.lsbFirstWord(this.P) + this.hexToBytes(n2)).substr(0, 5), this.U = P(this.encryptionKey, this.padding);
}
function F$1(t3) {
  if (/[^\u0000-\u00ff]/.test(t3))
    throw new Error("Invalid PDF Name Object: " + t3 + ", Only accept ASCII characters.");
  for (var e2 = "", r2 = t3.length, n2 = 0; n2 < r2; n2++) {
    var i2 = t3.charCodeAt(n2);
    if (i2 < 33 || i2 === 35 || i2 === 37 || i2 === 40 || i2 === 41 || i2 === 47 || i2 === 60 || i2 === 62 || i2 === 91 || i2 === 93 || i2 === 123 || i2 === 125 || i2 > 126)
      e2 += "#" + ("0" + i2.toString(16)).slice(-2);
    else
      e2 += t3[n2];
  }
  return e2;
}
function C(e2) {
  if (_typeof$2(e2) !== "object")
    throw new Error("Invalid Context passed to initialize PubSub (jsPDF-module)");
  var r2 = {};
  this.subscribe = function(t3, e3, n2) {
    if (n2 = n2 || false, typeof t3 != "string" || typeof e3 != "function" || typeof n2 != "boolean")
      throw new Error("Invalid arguments passed to PubSub.subscribe (jsPDF-module)");
    r2.hasOwnProperty(t3) || (r2[t3] = {});
    var i2 = Math.random().toString(35);
    return r2[t3][i2] = [e3, !!n2], i2;
  }, this.unsubscribe = function(t3) {
    for (var e3 in r2)
      if (r2[e3][t3])
        return delete r2[e3][t3], Object.keys(r2[e3]).length === 0 && delete r2[e3], true;
    return false;
  }, this.publish = function(t3) {
    if (r2.hasOwnProperty(t3)) {
      var i2 = Array.prototype.slice.call(arguments, 1), o2 = [];
      for (var s2 in r2[t3]) {
        var c2 = r2[t3][s2];
        try {
          c2[0].apply(e2, i2);
        } catch (t4) {
          n$1.console && a$2.error("jsPDF PubSub Error", t4.message, t4);
        }
        c2[1] && o2.push(s2);
      }
      o2.length && o2.forEach(this.unsubscribe);
    }
  }, this.getTopics = function() {
    return r2;
  };
}
function j(t3) {
  if (!(this instanceof j))
    return new j(t3);
  var e2 = "opacity,stroke-opacity".split(",");
  for (var r2 in t3)
    t3.hasOwnProperty(r2) && e2.indexOf(r2) >= 0 && (this[r2] = t3[r2]);
  this.id = "", this.objectNumber = -1;
}
function O$1(t3, e2) {
  this.gState = t3, this.matrix = e2, this.id = "", this.objectNumber = -1;
}
function B(t3, e2, r2, n2, i2) {
  if (!(this instanceof B))
    return new B(t3, e2, r2, n2, i2);
  this.type = t3 === "axial" ? 2 : 3, this.coords = e2, this.colors = r2, O$1.call(this, n2, i2);
}
function M$1(t3, e2, r2, n2, i2) {
  if (!(this instanceof M$1))
    return new M$1(t3, e2, r2, n2, i2);
  this.boundingBox = t3, this.xStep = e2, this.yStep = r2, this.stream = "", this.cloneIndex = 0, O$1.call(this, n2, i2);
}
function E$1(e2) {
  var r2, i2 = typeof arguments[0] == "string" ? arguments[0] : "p", o2 = arguments[1], s2 = arguments[2], c2 = arguments[3], u2 = [], d2 = 1, p5 = 16, g2 = "S", m2 = null;
  _typeof$2(e2 = e2 || {}) === "object" && (i2 = e2.orientation, o2 = e2.unit || o2, s2 = e2.format || s2, c2 = e2.compress || e2.compressPdf || c2, (m2 = e2.encryption || null) !== null && (m2.userPassword = m2.userPassword || "", m2.ownerPassword = m2.ownerPassword || "", m2.userPermissions = m2.userPermissions || []), d2 = typeof e2.userUnit == "number" ? Math.abs(e2.userUnit) : 1, e2.precision !== void 0 && (r2 = e2.precision), e2.floatPrecision !== void 0 && (p5 = e2.floatPrecision), g2 = e2.defaultPathOperation || "S"), u2 = e2.filters || (c2 === true ? ["FlateEncode"] : u2), o2 = o2 || "mm", i2 = ("" + (i2 || "P")).toLowerCase();
  var v2 = e2.putOnlyUsedFonts || false, b2 = {}, y2 = { internal: {}, __private__: {} };
  y2.__private__.PubSub = C;
  var w2 = "1.3", N2 = y2.__private__.getPdfVersion = function() {
    return w2;
  };
  y2.__private__.setPdfVersion = function(t3) {
    w2 = t3;
  };
  var L2 = { a0: [2383.94, 3370.39], a1: [1683.78, 2383.94], a2: [1190.55, 1683.78], a3: [841.89, 1190.55], a4: [595.28, 841.89], a5: [419.53, 595.28], a6: [297.64, 419.53], a7: [209.76, 297.64], a8: [147.4, 209.76], a9: [104.88, 147.4], a10: [73.7, 104.88], b0: [2834.65, 4008.19], b1: [2004.09, 2834.65], b2: [1417.32, 2004.09], b3: [1000.63, 1417.32], b4: [708.66, 1000.63], b5: [498.9, 708.66], b6: [354.33, 498.9], b7: [249.45, 354.33], b8: [175.75, 249.45], b9: [124.72, 175.75], b10: [87.87, 124.72], c0: [2599.37, 3676.54], c1: [1836.85, 2599.37], c2: [1298.27, 1836.85], c3: [918.43, 1298.27], c4: [649.13, 918.43], c5: [459.21, 649.13], c6: [323.15, 459.21], c7: [229.61, 323.15], c8: [161.57, 229.61], c9: [113.39, 161.57], c10: [79.37, 113.39], dl: [311.81, 623.62], letter: [612, 792], "government-letter": [576, 756], legal: [612, 1008], "junior-legal": [576, 360], ledger: [1224, 792], tabloid: [792, 1224], "credit-card": [153, 243] };
  y2.__private__.getPageFormats = function() {
    return L2;
  };
  var A2 = y2.__private__.getPageFormat = function(t3) {
    return L2[t3];
  };
  s2 = s2 || "a4";
  var x2 = { COMPAT: "compat", ADVANCED: "advanced" }, S2 = x2.COMPAT;
  function _2() {
    this.saveGraphicsState(), lt2(new Vt2(_t2, 0, 0, -_t2, 0, Rr() * _t2).toString() + " cm"), this.setFontSize(this.getFontSize() / _t2), g2 = "n", S2 = x2.ADVANCED;
  }
  function P2() {
    this.restoreGraphicsState(), g2 = "S", S2 = x2.COMPAT;
  }
  var k2 = y2.__private__.combineFontStyleAndFontWeight = function(t3, e3) {
    if (t3 == "bold" && e3 == "normal" || t3 == "bold" && e3 == 400 || t3 == "normal" && e3 == "italic" || t3 == "bold" && e3 == "italic")
      throw new Error("Invalid Combination of fontweight and fontstyle");
    return e3 && (t3 = e3 == 400 || e3 === "normal" ? t3 === "italic" ? "italic" : "normal" : e3 != 700 && e3 !== "bold" || t3 !== "normal" ? (e3 == 700 ? "bold" : e3) + "" + t3 : "bold"), t3;
  };
  y2.advancedAPI = function(t3) {
    var e3 = S2 === x2.COMPAT;
    return e3 && _2.call(this), typeof t3 != "function" || (t3(this), e3 && P2.call(this)), this;
  }, y2.compatAPI = function(t3) {
    var e3 = S2 === x2.ADVANCED;
    return e3 && P2.call(this), typeof t3 != "function" || (t3(this), e3 && _2.call(this)), this;
  }, y2.isAdvancedAPI = function() {
    return S2 === x2.ADVANCED;
  };
  var O2, q2 = function(t3) {
    if (S2 !== x2.ADVANCED)
      throw new Error(t3 + " is only available in 'advanced' API mode. You need to call advancedAPI() first.");
  }, D2 = y2.roundToPrecision = y2.__private__.roundToPrecision = function(t3, e3) {
    var n2 = r2 || e3;
    if (isNaN(t3) || isNaN(n2))
      throw new Error("Invalid argument passed to jsPDF.roundToPrecision");
    return t3.toFixed(n2).replace(/0+$/, "");
  };
  O2 = y2.hpf = y2.__private__.hpf = typeof p5 == "number" ? function(t3) {
    if (isNaN(t3))
      throw new Error("Invalid argument passed to jsPDF.hpf");
    return D2(t3, p5);
  } : p5 === "smart" ? function(t3) {
    if (isNaN(t3))
      throw new Error("Invalid argument passed to jsPDF.hpf");
    return D2(t3, t3 > -1 && t3 < 1 ? 16 : 5);
  } : function(t3) {
    if (isNaN(t3))
      throw new Error("Invalid argument passed to jsPDF.hpf");
    return D2(t3, 16);
  };
  var R2 = y2.f2 = y2.__private__.f2 = function(t3) {
    if (isNaN(t3))
      throw new Error("Invalid argument passed to jsPDF.f2");
    return D2(t3, 2);
  }, T2 = y2.__private__.f3 = function(t3) {
    if (isNaN(t3))
      throw new Error("Invalid argument passed to jsPDF.f3");
    return D2(t3, 3);
  }, z2 = y2.scale = y2.__private__.scale = function(t3) {
    if (isNaN(t3))
      throw new Error("Invalid argument passed to jsPDF.scale");
    return S2 === x2.COMPAT ? t3 * _t2 : S2 === x2.ADVANCED ? t3 : void 0;
  }, U2 = function(t3) {
    return S2 === x2.COMPAT ? Rr() - t3 : S2 === x2.ADVANCED ? t3 : void 0;
  }, H4 = function(t3) {
    return z2(U2(t3));
  };
  y2.__private__.setPrecision = y2.setPrecision = function(t3) {
    typeof parseInt(t3, 10) == "number" && (r2 = parseInt(t3, 10));
  };
  var W2, V2 = "00000000000000000000000000000000", G2 = y2.__private__.getFileId = function() {
    return V2;
  }, Y2 = y2.__private__.setFileId = function(t3) {
    return V2 = t3 !== void 0 && /^[a-fA-F0-9]{32}$/.test(t3) ? t3.toUpperCase() : V2.split("").map(function() {
      return "ABCDEF0123456789".charAt(Math.floor(16 * Math.random()));
    }).join(""), m2 !== null && (Ye = new I(m2.userPermissions, m2.userPassword, m2.ownerPassword, V2)), V2;
  };
  y2.setFileId = function(t3) {
    return Y2(t3), this;
  }, y2.getFileId = function() {
    return G2();
  };
  var J2 = y2.__private__.convertDateToPDFDate = function(t3) {
    var e3 = t3.getTimezoneOffset(), r3 = e3 < 0 ? "+" : "-", n2 = Math.floor(Math.abs(e3 / 60)), i3 = Math.abs(e3 % 60), a2 = [r3, Q2(n2), "'", Q2(i3), "'"].join("");
    return ["D:", t3.getFullYear(), Q2(t3.getMonth() + 1), Q2(t3.getDate()), Q2(t3.getHours()), Q2(t3.getMinutes()), Q2(t3.getSeconds()), a2].join("");
  }, X2 = y2.__private__.convertPDFDateToDate = function(t3) {
    var e3 = parseInt(t3.substr(2, 4), 10), r3 = parseInt(t3.substr(6, 2), 10) - 1, n2 = parseInt(t3.substr(8, 2), 10), i3 = parseInt(t3.substr(10, 2), 10), a2 = parseInt(t3.substr(12, 2), 10), o3 = parseInt(t3.substr(14, 2), 10);
    return new Date(e3, r3, n2, i3, a2, o3, 0);
  }, K2 = y2.__private__.setCreationDate = function(t3) {
    var e3;
    if (t3 === void 0 && (t3 = new Date()), t3 instanceof Date)
      e3 = J2(t3);
    else {
      if (!/^D:(20[0-2][0-9]|203[0-7]|19[7-9][0-9])(0[0-9]|1[0-2])([0-2][0-9]|3[0-1])(0[0-9]|1[0-9]|2[0-3])(0[0-9]|[1-5][0-9])(0[0-9]|[1-5][0-9])(\+0[0-9]|\+1[0-4]|-0[0-9]|-1[0-1])'(0[0-9]|[1-5][0-9])'?$/.test(t3))
        throw new Error("Invalid argument passed to jsPDF.setCreationDate");
      e3 = t3;
    }
    return W2 = e3;
  }, Z2 = y2.__private__.getCreationDate = function(t3) {
    var e3 = W2;
    return t3 === "jsDate" && (e3 = X2(W2)), e3;
  };
  y2.setCreationDate = function(t3) {
    return K2(t3), this;
  }, y2.getCreationDate = function(t3) {
    return Z2(t3);
  };
  var $2, Q2 = y2.__private__.padd2 = function(t3) {
    return ("0" + parseInt(t3)).slice(-2);
  }, tt2 = y2.__private__.padd2Hex = function(t3) {
    return ("00" + (t3 = t3.toString())).substr(t3.length);
  }, et2 = 0, rt2 = [], nt2 = [], it2 = 0, at2 = [], ot2 = [], st2 = false, ct2 = nt2, ut2 = function() {
    et2 = 0, it2 = 0, nt2 = [], rt2 = [], at2 = [], Qt2 = Kt2(), te2 = Kt2();
  };
  y2.__private__.setCustomOutputDestination = function(t3) {
    st2 = true, ct2 = t3;
  };
  var ht2 = function(t3) {
    st2 || (ct2 = t3);
  };
  y2.__private__.resetCustomOutputDestination = function() {
    st2 = false, ct2 = nt2;
  };
  var lt2 = y2.__private__.out = function(t3) {
    return t3 = t3.toString(), it2 += t3.length + 1, ct2.push(t3), ct2;
  }, ft2 = y2.__private__.write = function(t3) {
    return lt2(arguments.length === 1 ? t3.toString() : Array.prototype.join.call(arguments, " "));
  }, dt2 = y2.__private__.getArrayBuffer = function(t3) {
    for (var e3 = t3.length, r3 = new ArrayBuffer(e3), n2 = new Uint8Array(r3); e3--; )
      n2[e3] = t3.charCodeAt(e3);
    return r3;
  }, pt2 = [["Helvetica", "helvetica", "normal", "WinAnsiEncoding"], ["Helvetica-Bold", "helvetica", "bold", "WinAnsiEncoding"], ["Helvetica-Oblique", "helvetica", "italic", "WinAnsiEncoding"], ["Helvetica-BoldOblique", "helvetica", "bolditalic", "WinAnsiEncoding"], ["Courier", "courier", "normal", "WinAnsiEncoding"], ["Courier-Bold", "courier", "bold", "WinAnsiEncoding"], ["Courier-Oblique", "courier", "italic", "WinAnsiEncoding"], ["Courier-BoldOblique", "courier", "bolditalic", "WinAnsiEncoding"], ["Times-Roman", "times", "normal", "WinAnsiEncoding"], ["Times-Bold", "times", "bold", "WinAnsiEncoding"], ["Times-Italic", "times", "italic", "WinAnsiEncoding"], ["Times-BoldItalic", "times", "bolditalic", "WinAnsiEncoding"], ["ZapfDingbats", "zapfdingbats", "normal", null], ["Symbol", "symbol", "normal", null]];
  y2.__private__.getStandardFonts = function() {
    return pt2;
  };
  var gt2 = e2.fontSize || 16;
  y2.__private__.setFontSize = y2.setFontSize = function(t3) {
    return gt2 = S2 === x2.ADVANCED ? t3 / _t2 : t3, this;
  };
  var mt2, vt2 = y2.__private__.getFontSize = y2.getFontSize = function() {
    return S2 === x2.COMPAT ? gt2 : gt2 * _t2;
  }, bt2 = e2.R2L || false;
  y2.__private__.setR2L = y2.setR2L = function(t3) {
    return bt2 = t3, this;
  }, y2.__private__.getR2L = y2.getR2L = function() {
    return bt2;
  };
  var yt2, wt2 = y2.__private__.setZoomMode = function(t3) {
    var e3 = [void 0, null, "fullwidth", "fullheight", "fullpage", "original"];
    if (/^\d*\.?\d*%$/.test(t3))
      mt2 = t3;
    else if (isNaN(t3)) {
      if (e3.indexOf(t3) === -1)
        throw new Error('zoom must be Integer (e.g. 2), a percentage Value (e.g. 300%) or fullwidth, fullheight, fullpage, original. "' + t3 + '" is not recognized.');
      mt2 = t3;
    } else
      mt2 = parseInt(t3, 10);
  };
  y2.__private__.getZoomMode = function() {
    return mt2;
  };
  var Nt2, Lt2 = y2.__private__.setPageMode = function(t3) {
    if ([void 0, null, "UseNone", "UseOutlines", "UseThumbs", "FullScreen"].indexOf(t3) == -1)
      throw new Error('Page mode must be one of UseNone, UseOutlines, UseThumbs, or FullScreen. "' + t3 + '" is not recognized.');
    yt2 = t3;
  };
  y2.__private__.getPageMode = function() {
    return yt2;
  };
  var At2 = y2.__private__.setLayoutMode = function(t3) {
    if ([void 0, null, "continuous", "single", "twoleft", "tworight", "two"].indexOf(t3) == -1)
      throw new Error('Layout mode must be one of continuous, single, twoleft, tworight. "' + t3 + '" is not recognized.');
    Nt2 = t3;
  };
  y2.__private__.getLayoutMode = function() {
    return Nt2;
  }, y2.__private__.setDisplayMode = y2.setDisplayMode = function(t3, e3, r3) {
    return wt2(t3), At2(e3), Lt2(r3), this;
  };
  var xt2 = { title: "", subject: "", author: "", keywords: "", creator: "" };
  y2.__private__.getDocumentProperty = function(t3) {
    if (Object.keys(xt2).indexOf(t3) === -1)
      throw new Error("Invalid argument passed to jsPDF.getDocumentProperty");
    return xt2[t3];
  }, y2.__private__.getDocumentProperties = function() {
    return xt2;
  }, y2.__private__.setDocumentProperties = y2.setProperties = y2.setDocumentProperties = function(t3) {
    for (var e3 in xt2)
      xt2.hasOwnProperty(e3) && t3[e3] && (xt2[e3] = t3[e3]);
    return this;
  }, y2.__private__.setDocumentProperty = function(t3, e3) {
    if (Object.keys(xt2).indexOf(t3) === -1)
      throw new Error("Invalid arguments passed to jsPDF.setDocumentProperty");
    return xt2[t3] = e3;
  };
  var St, _t2, Pt2, kt2, It2, Ft2 = {}, Ct2 = {}, jt2 = [], Ot2 = {}, Bt2 = {}, Mt2 = {}, Et2 = {}, qt2 = null, Dt2 = 0, Rt2 = [], Tt2 = new C(y2), zt2 = e2.hotfixes || [], Ut2 = {}, Ht2 = {}, Wt2 = [], Vt2 = function t3(e3, r3, n2, i3, a2, o3) {
    if (!(this instanceof t3))
      return new t3(e3, r3, n2, i3, a2, o3);
    isNaN(e3) && (e3 = 1), isNaN(r3) && (r3 = 0), isNaN(n2) && (n2 = 0), isNaN(i3) && (i3 = 1), isNaN(a2) && (a2 = 0), isNaN(o3) && (o3 = 0), this._matrix = [e3, r3, n2, i3, a2, o3];
  };
  Object.defineProperty(Vt2.prototype, "sx", { get: function() {
    return this._matrix[0];
  }, set: function(t3) {
    this._matrix[0] = t3;
  } }), Object.defineProperty(Vt2.prototype, "shy", { get: function() {
    return this._matrix[1];
  }, set: function(t3) {
    this._matrix[1] = t3;
  } }), Object.defineProperty(Vt2.prototype, "shx", { get: function() {
    return this._matrix[2];
  }, set: function(t3) {
    this._matrix[2] = t3;
  } }), Object.defineProperty(Vt2.prototype, "sy", { get: function() {
    return this._matrix[3];
  }, set: function(t3) {
    this._matrix[3] = t3;
  } }), Object.defineProperty(Vt2.prototype, "tx", { get: function() {
    return this._matrix[4];
  }, set: function(t3) {
    this._matrix[4] = t3;
  } }), Object.defineProperty(Vt2.prototype, "ty", { get: function() {
    return this._matrix[5];
  }, set: function(t3) {
    this._matrix[5] = t3;
  } }), Object.defineProperty(Vt2.prototype, "a", { get: function() {
    return this._matrix[0];
  }, set: function(t3) {
    this._matrix[0] = t3;
  } }), Object.defineProperty(Vt2.prototype, "b", { get: function() {
    return this._matrix[1];
  }, set: function(t3) {
    this._matrix[1] = t3;
  } }), Object.defineProperty(Vt2.prototype, "c", { get: function() {
    return this._matrix[2];
  }, set: function(t3) {
    this._matrix[2] = t3;
  } }), Object.defineProperty(Vt2.prototype, "d", { get: function() {
    return this._matrix[3];
  }, set: function(t3) {
    this._matrix[3] = t3;
  } }), Object.defineProperty(Vt2.prototype, "e", { get: function() {
    return this._matrix[4];
  }, set: function(t3) {
    this._matrix[4] = t3;
  } }), Object.defineProperty(Vt2.prototype, "f", { get: function() {
    return this._matrix[5];
  }, set: function(t3) {
    this._matrix[5] = t3;
  } }), Object.defineProperty(Vt2.prototype, "rotation", { get: function() {
    return Math.atan2(this.shx, this.sx);
  } }), Object.defineProperty(Vt2.prototype, "scaleX", { get: function() {
    return this.decompose().scale.sx;
  } }), Object.defineProperty(Vt2.prototype, "scaleY", { get: function() {
    return this.decompose().scale.sy;
  } }), Object.defineProperty(Vt2.prototype, "isIdentity", { get: function() {
    return this.sx === 1 && (this.shy === 0 && (this.shx === 0 && (this.sy === 1 && (this.tx === 0 && this.ty === 0))));
  } }), Vt2.prototype.join = function(t3) {
    return [this.sx, this.shy, this.shx, this.sy, this.tx, this.ty].map(O2).join(t3);
  }, Vt2.prototype.multiply = function(t3) {
    var e3 = t3.sx * this.sx + t3.shy * this.shx, r3 = t3.sx * this.shy + t3.shy * this.sy, n2 = t3.shx * this.sx + t3.sy * this.shx, i3 = t3.shx * this.shy + t3.sy * this.sy, a2 = t3.tx * this.sx + t3.ty * this.shx + this.tx, o3 = t3.tx * this.shy + t3.ty * this.sy + this.ty;
    return new Vt2(e3, r3, n2, i3, a2, o3);
  }, Vt2.prototype.decompose = function() {
    var t3 = this.sx, e3 = this.shy, r3 = this.shx, n2 = this.sy, i3 = this.tx, a2 = this.ty, o3 = Math.sqrt(t3 * t3 + e3 * e3), s3 = (t3 /= o3) * r3 + (e3 /= o3) * n2;
    r3 -= t3 * s3, n2 -= e3 * s3;
    var c3 = Math.sqrt(r3 * r3 + n2 * n2);
    return s3 /= c3, t3 * (n2 /= c3) < e3 * (r3 /= c3) && (t3 = -t3, e3 = -e3, s3 = -s3, o3 = -o3), { scale: new Vt2(o3, 0, 0, c3, 0, 0), translate: new Vt2(1, 0, 0, 1, i3, a2), rotate: new Vt2(t3, e3, -e3, t3, 0, 0), skew: new Vt2(1, 0, s3, 1, 0, 0) };
  }, Vt2.prototype.toString = function(t3) {
    return this.join(" ");
  }, Vt2.prototype.inversed = function() {
    var t3 = this.sx, e3 = this.shy, r3 = this.shx, n2 = this.sy, i3 = this.tx, a2 = this.ty, o3 = 1 / (t3 * n2 - e3 * r3), s3 = n2 * o3, c3 = -e3 * o3, u3 = -r3 * o3, h2 = t3 * o3;
    return new Vt2(s3, c3, u3, h2, -s3 * i3 - u3 * a2, -c3 * i3 - h2 * a2);
  }, Vt2.prototype.applyToPoint = function(t3) {
    var e3 = t3.x * this.sx + t3.y * this.shx + this.tx, r3 = t3.x * this.shy + t3.y * this.sy + this.ty;
    return new Cr(e3, r3);
  }, Vt2.prototype.applyToRectangle = function(t3) {
    var e3 = this.applyToPoint(t3), r3 = this.applyToPoint(new Cr(t3.x + t3.w, t3.y + t3.h));
    return new jr(e3.x, e3.y, r3.x - e3.x, r3.y - e3.y);
  }, Vt2.prototype.clone = function() {
    var t3 = this.sx, e3 = this.shy, r3 = this.shx, n2 = this.sy, i3 = this.tx, a2 = this.ty;
    return new Vt2(t3, e3, r3, n2, i3, a2);
  }, y2.Matrix = Vt2;
  var Gt2 = y2.matrixMult = function(t3, e3) {
    return e3.multiply(t3);
  }, Yt2 = new Vt2(1, 0, 0, 1, 0, 0);
  y2.unitMatrix = y2.identityMatrix = Yt2;
  var Jt2 = function(t3, e3) {
    if (!Bt2[t3]) {
      var r3 = (e3 instanceof B ? "Sh" : "P") + (Object.keys(Ot2).length + 1).toString(10);
      e3.id = r3, Bt2[t3] = r3, Ot2[r3] = e3, Tt2.publish("addPattern", e3);
    }
  };
  y2.ShadingPattern = B, y2.TilingPattern = M$1, y2.addShadingPattern = function(t3, e3) {
    return q2("addShadingPattern()"), Jt2(t3, e3), this;
  }, y2.beginTilingPattern = function(t3) {
    q2("beginTilingPattern()"), Br(t3.boundingBox[0], t3.boundingBox[1], t3.boundingBox[2] - t3.boundingBox[0], t3.boundingBox[3] - t3.boundingBox[1], t3.matrix);
  }, y2.endTilingPattern = function(t3, e3) {
    q2("endTilingPattern()"), e3.stream = ot2[$2].join("\n"), Jt2(t3, e3), Tt2.publish("endTilingPattern", e3), Wt2.pop().restore();
  };
  var Xt2 = y2.__private__.newObject = function() {
    var t3 = Kt2();
    return Zt2(t3, true), t3;
  }, Kt2 = y2.__private__.newObjectDeferred = function() {
    return et2++, rt2[et2] = function() {
      return it2;
    }, et2;
  }, Zt2 = function(t3, e3) {
    return e3 = typeof e3 == "boolean" && e3, rt2[t3] = it2, e3 && lt2(t3 + " 0 obj"), t3;
  }, $t2 = y2.__private__.newAdditionalObject = function() {
    var t3 = { objId: Kt2(), content: "" };
    return at2.push(t3), t3;
  }, Qt2 = Kt2(), te2 = Kt2(), ee2 = y2.__private__.decodeColorString = function(t3) {
    var e3 = t3.split(" ");
    if (e3.length !== 2 || e3[1] !== "g" && e3[1] !== "G") {
      if (e3.length === 5 && (e3[4] === "k" || e3[4] === "K")) {
        e3 = [(1 - e3[0]) * (1 - e3[3]), (1 - e3[1]) * (1 - e3[3]), (1 - e3[2]) * (1 - e3[3]), "r"];
      }
    } else {
      var r3 = parseFloat(e3[0]);
      e3 = [r3, r3, r3, "r"];
    }
    for (var n2 = "#", i3 = 0; i3 < 3; i3++)
      n2 += ("0" + Math.floor(255 * parseFloat(e3[i3])).toString(16)).slice(-2);
    return n2;
  }, re2 = y2.__private__.encodeColorString = function(e3) {
    var r3;
    typeof e3 == "string" && (e3 = { ch1: e3 });
    var n2 = e3.ch1, i3 = e3.ch2, a2 = e3.ch3, o3 = e3.ch4, s3 = e3.pdfColorType === "draw" ? ["G", "RG", "K"] : ["g", "rg", "k"];
    if (typeof n2 == "string" && n2.charAt(0) !== "#") {
      var c3 = new f$2(n2);
      if (c3.ok)
        n2 = c3.toHex();
      else if (!/^\d*\.?\d*$/.test(n2))
        throw new Error('Invalid color "' + n2 + '" passed to jsPDF.encodeColorString.');
    }
    if (typeof n2 == "string" && /^#[0-9A-Fa-f]{3}$/.test(n2) && (n2 = "#" + n2[1] + n2[1] + n2[2] + n2[2] + n2[3] + n2[3]), typeof n2 == "string" && /^#[0-9A-Fa-f]{6}$/.test(n2)) {
      var u3 = parseInt(n2.substr(1), 16);
      n2 = u3 >> 16 & 255, i3 = u3 >> 8 & 255, a2 = 255 & u3;
    }
    if (i3 === void 0 || o3 === void 0 && n2 === i3 && i3 === a2)
      if (typeof n2 == "string")
        r3 = n2 + " " + s3[0];
      else
        switch (e3.precision) {
          case 2:
            r3 = R2(n2 / 255) + " " + s3[0];
            break;
          case 3:
          default:
            r3 = T2(n2 / 255) + " " + s3[0];
        }
    else if (o3 === void 0 || _typeof$2(o3) === "object") {
      if (o3 && !isNaN(o3.a) && o3.a === 0)
        return r3 = ["1.", "1.", "1.", s3[1]].join(" ");
      if (typeof n2 == "string")
        r3 = [n2, i3, a2, s3[1]].join(" ");
      else
        switch (e3.precision) {
          case 2:
            r3 = [R2(n2 / 255), R2(i3 / 255), R2(a2 / 255), s3[1]].join(" ");
            break;
          default:
          case 3:
            r3 = [T2(n2 / 255), T2(i3 / 255), T2(a2 / 255), s3[1]].join(" ");
        }
    } else if (typeof n2 == "string")
      r3 = [n2, i3, a2, o3, s3[2]].join(" ");
    else
      switch (e3.precision) {
        case 2:
          r3 = [R2(n2), R2(i3), R2(a2), R2(o3), s3[2]].join(" ");
          break;
        case 3:
        default:
          r3 = [T2(n2), T2(i3), T2(a2), T2(o3), s3[2]].join(" ");
      }
    return r3;
  }, ne2 = y2.__private__.getFilters = function() {
    return u2;
  }, ie2 = y2.__private__.putStream = function(t3) {
    var e3 = (t3 = t3 || {}).data || "", r3 = t3.filters || ne2(), n2 = t3.alreadyAppliedFilters || [], i3 = t3.addLength1 || false, a2 = e3.length, o3 = t3.objectId, s3 = function(t4) {
      return t4;
    };
    if (m2 !== null && o3 === void 0)
      throw new Error("ObjectId must be passed to putStream for file encryption");
    m2 !== null && (s3 = Ye.encryptor(o3, 0));
    var c3 = {};
    r3 === true && (r3 = ["FlateEncode"]);
    var u3 = t3.additionalKeyValues || [], h2 = (c3 = E$1.API.processDataByFilters !== void 0 ? E$1.API.processDataByFilters(e3, r3) : { data: e3, reverseChain: [] }).reverseChain + (Array.isArray(n2) ? n2.join(" ") : n2.toString());
    if (c3.data.length !== 0 && (u3.push({ key: "Length", value: c3.data.length }), i3 === true && u3.push({ key: "Length1", value: a2 })), h2.length != 0)
      if (h2.split("/").length - 1 == 1)
        u3.push({ key: "Filter", value: h2 });
      else {
        u3.push({ key: "Filter", value: "[" + h2 + "]" });
        for (var l2 = 0; l2 < u3.length; l2 += 1)
          if (u3[l2].key === "DecodeParms") {
            for (var f2 = [], d3 = 0; d3 < c3.reverseChain.split("/").length - 1; d3 += 1)
              f2.push("null");
            f2.push(u3[l2].value), u3[l2].value = "[" + f2.join(" ") + "]";
          }
      }
    lt2("<<");
    for (var p6 = 0; p6 < u3.length; p6++)
      lt2("/" + u3[p6].key + " " + u3[p6].value);
    lt2(">>"), c3.data.length !== 0 && (lt2("stream"), lt2(s3(c3.data)), lt2("endstream"));
  }, ae2 = y2.__private__.putPage = function(t3) {
    var e3 = t3.number, r3 = t3.data, n2 = t3.objId, i3 = t3.contentsObjId;
    Zt2(n2, true), lt2("<</Type /Page"), lt2("/Parent " + t3.rootDictionaryObjId + " 0 R"), lt2("/Resources " + t3.resourceDictionaryObjId + " 0 R"), lt2("/MediaBox [" + parseFloat(O2(t3.mediaBox.bottomLeftX)) + " " + parseFloat(O2(t3.mediaBox.bottomLeftY)) + " " + O2(t3.mediaBox.topRightX) + " " + O2(t3.mediaBox.topRightY) + "]"), t3.cropBox !== null && lt2("/CropBox [" + O2(t3.cropBox.bottomLeftX) + " " + O2(t3.cropBox.bottomLeftY) + " " + O2(t3.cropBox.topRightX) + " " + O2(t3.cropBox.topRightY) + "]"), t3.bleedBox !== null && lt2("/BleedBox [" + O2(t3.bleedBox.bottomLeftX) + " " + O2(t3.bleedBox.bottomLeftY) + " " + O2(t3.bleedBox.topRightX) + " " + O2(t3.bleedBox.topRightY) + "]"), t3.trimBox !== null && lt2("/TrimBox [" + O2(t3.trimBox.bottomLeftX) + " " + O2(t3.trimBox.bottomLeftY) + " " + O2(t3.trimBox.topRightX) + " " + O2(t3.trimBox.topRightY) + "]"), t3.artBox !== null && lt2("/ArtBox [" + O2(t3.artBox.bottomLeftX) + " " + O2(t3.artBox.bottomLeftY) + " " + O2(t3.artBox.topRightX) + " " + O2(t3.artBox.topRightY) + "]"), typeof t3.userUnit == "number" && t3.userUnit !== 1 && lt2("/UserUnit " + t3.userUnit), Tt2.publish("putPage", { objId: n2, pageContext: Rt2[e3], pageNumber: e3, page: r3 }), lt2("/Contents " + i3 + " 0 R"), lt2(">>"), lt2("endobj");
    var a2 = r3.join("\n");
    return S2 === x2.ADVANCED && (a2 += "\nQ"), Zt2(i3, true), ie2({ data: a2, filters: ne2(), objectId: i3 }), lt2("endobj"), n2;
  }, oe2 = y2.__private__.putPages = function() {
    var t3, e3, r3 = [];
    for (t3 = 1; t3 <= Dt2; t3++)
      Rt2[t3].objId = Kt2(), Rt2[t3].contentsObjId = Kt2();
    for (t3 = 1; t3 <= Dt2; t3++)
      r3.push(ae2({ number: t3, data: ot2[t3], objId: Rt2[t3].objId, contentsObjId: Rt2[t3].contentsObjId, mediaBox: Rt2[t3].mediaBox, cropBox: Rt2[t3].cropBox, bleedBox: Rt2[t3].bleedBox, trimBox: Rt2[t3].trimBox, artBox: Rt2[t3].artBox, userUnit: Rt2[t3].userUnit, rootDictionaryObjId: Qt2, resourceDictionaryObjId: te2 }));
    Zt2(Qt2, true), lt2("<</Type /Pages");
    var n2 = "/Kids [";
    for (e3 = 0; e3 < Dt2; e3++)
      n2 += r3[e3] + " 0 R ";
    lt2(n2 + "]"), lt2("/Count " + Dt2), lt2(">>"), lt2("endobj"), Tt2.publish("postPutPages");
  }, se2 = function(t3) {
    Tt2.publish("putFont", { font: t3, out: lt2, newObject: Xt2, putStream: ie2 }), t3.isAlreadyPutted !== true && (t3.objectNumber = Xt2(), lt2("<<"), lt2("/Type /Font"), lt2("/BaseFont /" + F$1(t3.postScriptName)), lt2("/Subtype /Type1"), typeof t3.encoding == "string" && lt2("/Encoding /" + t3.encoding), lt2("/FirstChar 32"), lt2("/LastChar 255"), lt2(">>"), lt2("endobj"));
  }, ce2 = function() {
    for (var t3 in Ft2)
      Ft2.hasOwnProperty(t3) && (v2 === false || v2 === true && b2.hasOwnProperty(t3)) && se2(Ft2[t3]);
  }, ue2 = function(t3) {
    t3.objectNumber = Xt2();
    var e3 = [];
    e3.push({ key: "Type", value: "/XObject" }), e3.push({ key: "Subtype", value: "/Form" }), e3.push({ key: "BBox", value: "[" + [O2(t3.x), O2(t3.y), O2(t3.x + t3.width), O2(t3.y + t3.height)].join(" ") + "]" }), e3.push({ key: "Matrix", value: "[" + t3.matrix.toString() + "]" });
    var r3 = t3.pages[1].join("\n");
    ie2({ data: r3, additionalKeyValues: e3, objectId: t3.objectNumber }), lt2("endobj");
  }, he2 = function() {
    for (var t3 in Ut2)
      Ut2.hasOwnProperty(t3) && ue2(Ut2[t3]);
  }, le2 = function(t3, e3) {
    var r3, n2 = [], i3 = 1 / (e3 - 1);
    for (r3 = 0; r3 < 1; r3 += i3)
      n2.push(r3);
    if (n2.push(1), t3[0].offset != 0) {
      var a2 = { offset: 0, color: t3[0].color };
      t3.unshift(a2);
    }
    if (t3[t3.length - 1].offset != 1) {
      var o3 = { offset: 1, color: t3[t3.length - 1].color };
      t3.push(o3);
    }
    for (var s3 = "", c3 = 0, u3 = 0; u3 < n2.length; u3++) {
      for (r3 = n2[u3]; r3 > t3[c3 + 1].offset; )
        c3++;
      var h2 = t3[c3].offset, l2 = (r3 - h2) / (t3[c3 + 1].offset - h2), f2 = t3[c3].color, d3 = t3[c3 + 1].color;
      s3 += tt2(Math.round((1 - l2) * f2[0] + l2 * d3[0]).toString(16)) + tt2(Math.round((1 - l2) * f2[1] + l2 * d3[1]).toString(16)) + tt2(Math.round((1 - l2) * f2[2] + l2 * d3[2]).toString(16));
    }
    return s3.trim();
  }, fe2 = function(t3, e3) {
    e3 || (e3 = 21);
    var r3 = Xt2(), n2 = le2(t3.colors, e3), i3 = [];
    i3.push({ key: "FunctionType", value: "0" }), i3.push({ key: "Domain", value: "[0.0 1.0]" }), i3.push({ key: "Size", value: "[" + e3 + "]" }), i3.push({ key: "BitsPerSample", value: "8" }), i3.push({ key: "Range", value: "[0.0 1.0 0.0 1.0 0.0 1.0]" }), i3.push({ key: "Decode", value: "[0.0 1.0 0.0 1.0 0.0 1.0]" }), ie2({ data: n2, additionalKeyValues: i3, alreadyAppliedFilters: ["/ASCIIHexDecode"], objectId: r3 }), lt2("endobj"), t3.objectNumber = Xt2(), lt2("<< /ShadingType " + t3.type), lt2("/ColorSpace /DeviceRGB");
    var a2 = "/Coords [" + O2(parseFloat(t3.coords[0])) + " " + O2(parseFloat(t3.coords[1])) + " ";
    t3.type === 2 ? a2 += O2(parseFloat(t3.coords[2])) + " " + O2(parseFloat(t3.coords[3])) : a2 += O2(parseFloat(t3.coords[2])) + " " + O2(parseFloat(t3.coords[3])) + " " + O2(parseFloat(t3.coords[4])) + " " + O2(parseFloat(t3.coords[5])), lt2(a2 += "]"), t3.matrix && lt2("/Matrix [" + t3.matrix.toString() + "]"), lt2("/Function " + r3 + " 0 R"), lt2("/Extend [true true]"), lt2(">>"), lt2("endobj");
  }, de2 = function(t3, e3) {
    var r3 = Kt2(), n2 = Xt2();
    e3.push({ resourcesOid: r3, objectOid: n2 }), t3.objectNumber = n2;
    var i3 = [];
    i3.push({ key: "Type", value: "/Pattern" }), i3.push({ key: "PatternType", value: "1" }), i3.push({ key: "PaintType", value: "1" }), i3.push({ key: "TilingType", value: "1" }), i3.push({ key: "BBox", value: "[" + t3.boundingBox.map(O2).join(" ") + "]" }), i3.push({ key: "XStep", value: O2(t3.xStep) }), i3.push({ key: "YStep", value: O2(t3.yStep) }), i3.push({ key: "Resources", value: r3 + " 0 R" }), t3.matrix && i3.push({ key: "Matrix", value: "[" + t3.matrix.toString() + "]" }), ie2({ data: t3.stream, additionalKeyValues: i3, objectId: t3.objectNumber }), lt2("endobj");
  }, pe2 = function(t3) {
    var e3;
    for (e3 in Ot2)
      Ot2.hasOwnProperty(e3) && (Ot2[e3] instanceof B ? fe2(Ot2[e3]) : Ot2[e3] instanceof M$1 && de2(Ot2[e3], t3));
  }, ge2 = function(t3) {
    for (var e3 in t3.objectNumber = Xt2(), lt2("<<"), t3)
      switch (e3) {
        case "opacity":
          lt2("/ca " + R2(t3[e3]));
          break;
        case "stroke-opacity":
          lt2("/CA " + R2(t3[e3]));
      }
    lt2(">>"), lt2("endobj");
  }, me2 = function() {
    var t3;
    for (t3 in Mt2)
      Mt2.hasOwnProperty(t3) && ge2(Mt2[t3]);
  }, ve2 = function() {
    for (var t3 in lt2("/XObject <<"), Ut2)
      Ut2.hasOwnProperty(t3) && Ut2[t3].objectNumber >= 0 && lt2("/" + t3 + " " + Ut2[t3].objectNumber + " 0 R");
    Tt2.publish("putXobjectDict"), lt2(">>");
  }, be2 = function() {
    Ye.oid = Xt2(), lt2("<<"), lt2("/Filter /Standard"), lt2("/V " + Ye.v), lt2("/R " + Ye.r), lt2("/U <" + Ye.toHexString(Ye.U) + ">"), lt2("/O <" + Ye.toHexString(Ye.O) + ">"), lt2("/P " + Ye.P), lt2(">>"), lt2("endobj");
  }, ye2 = function() {
    for (var t3 in lt2("/Font <<"), Ft2)
      Ft2.hasOwnProperty(t3) && (v2 === false || v2 === true && b2.hasOwnProperty(t3)) && lt2("/" + t3 + " " + Ft2[t3].objectNumber + " 0 R");
    lt2(">>");
  }, we2 = function() {
    if (Object.keys(Ot2).length > 0) {
      for (var t3 in lt2("/Shading <<"), Ot2)
        Ot2.hasOwnProperty(t3) && Ot2[t3] instanceof B && Ot2[t3].objectNumber >= 0 && lt2("/" + t3 + " " + Ot2[t3].objectNumber + " 0 R");
      Tt2.publish("putShadingPatternDict"), lt2(">>");
    }
  }, Ne2 = function(t3) {
    if (Object.keys(Ot2).length > 0) {
      for (var e3 in lt2("/Pattern <<"), Ot2)
        Ot2.hasOwnProperty(e3) && Ot2[e3] instanceof y2.TilingPattern && Ot2[e3].objectNumber >= 0 && Ot2[e3].objectNumber < t3 && lt2("/" + e3 + " " + Ot2[e3].objectNumber + " 0 R");
      Tt2.publish("putTilingPatternDict"), lt2(">>");
    }
  }, Le2 = function() {
    if (Object.keys(Mt2).length > 0) {
      var t3;
      for (t3 in lt2("/ExtGState <<"), Mt2)
        Mt2.hasOwnProperty(t3) && Mt2[t3].objectNumber >= 0 && lt2("/" + t3 + " " + Mt2[t3].objectNumber + " 0 R");
      Tt2.publish("putGStateDict"), lt2(">>");
    }
  }, Ae = function(t3) {
    Zt2(t3.resourcesOid, true), lt2("<<"), lt2("/ProcSet [/PDF /Text /ImageB /ImageC /ImageI]"), ye2(), we2(), Ne2(t3.objectOid), Le2(), ve2(), lt2(">>"), lt2("endobj");
  }, xe = function() {
    var t3 = [];
    ce2(), me2(), he2(), pe2(t3), Tt2.publish("putResources"), t3.forEach(Ae), Ae({ resourcesOid: te2, objectOid: Number.MAX_SAFE_INTEGER }), Tt2.publish("postPutResources");
  }, Se = function() {
    Tt2.publish("putAdditionalObjects");
    for (var t3 = 0; t3 < at2.length; t3++) {
      var e3 = at2[t3];
      Zt2(e3.objId, true), lt2(e3.content), lt2("endobj");
    }
    Tt2.publish("postPutAdditionalObjects");
  }, _e = function(t3) {
    Ct2[t3.fontName] = Ct2[t3.fontName] || {}, Ct2[t3.fontName][t3.fontStyle] = t3.id;
  }, Pe = function(t3, e3, r3, n2, i3) {
    var a2 = { id: "F" + (Object.keys(Ft2).length + 1).toString(10), postScriptName: t3, fontName: e3, fontStyle: r3, encoding: n2, isStandardFont: i3 || false, metadata: {} };
    return Tt2.publish("addFont", { font: a2, instance: this }), Ft2[a2.id] = a2, _e(a2), a2.id;
  }, ke = function(t3) {
    for (var e3 = 0, r3 = pt2.length; e3 < r3; e3++) {
      var n2 = Pe.call(this, t3[e3][0], t3[e3][1], t3[e3][2], pt2[e3][3], true);
      v2 === false && (b2[n2] = true);
      var i3 = t3[e3][0].split("-");
      _e({ id: n2, fontName: i3[0], fontStyle: i3[1] || "" });
    }
    Tt2.publish("addFonts", { fonts: Ft2, dictionary: Ct2 });
  }, Ie = function(t3) {
    return t3.foo = function() {
      try {
        return t3.apply(this, arguments);
      } catch (t4) {
        var e3 = t4.stack || "";
        ~e3.indexOf(" at ") && (e3 = e3.split(" at ")[1]);
        var r3 = "Error in function " + e3.split("\n")[0].split("<")[0] + ": " + t4.message;
        if (!n$1.console)
          throw new Error(r3);
        n$1.console.error(r3, t4), n$1.alert && alert(r3);
      }
    }, t3.foo.bar = t3, t3.foo;
  }, Fe = function(t3, e3) {
    var r3, n2, i3, a2, o3, s3, c3, u3, h2;
    if (i3 = (e3 = e3 || {}).sourceEncoding || "Unicode", o3 = e3.outputEncoding, (e3.autoencode || o3) && Ft2[St].metadata && Ft2[St].metadata[i3] && Ft2[St].metadata[i3].encoding && (a2 = Ft2[St].metadata[i3].encoding, !o3 && Ft2[St].encoding && (o3 = Ft2[St].encoding), !o3 && a2.codePages && (o3 = a2.codePages[0]), typeof o3 == "string" && (o3 = a2[o3]), o3)) {
      for (c3 = false, s3 = [], r3 = 0, n2 = t3.length; r3 < n2; r3++)
        (u3 = o3[t3.charCodeAt(r3)]) ? s3.push(String.fromCharCode(u3)) : s3.push(t3[r3]), s3[r3].charCodeAt(0) >> 8 && (c3 = true);
      t3 = s3.join("");
    }
    for (r3 = t3.length; c3 === void 0 && r3 !== 0; )
      t3.charCodeAt(r3 - 1) >> 8 && (c3 = true), r3--;
    if (!c3)
      return t3;
    for (s3 = e3.noBOM ? [] : [254, 255], r3 = 0, n2 = t3.length; r3 < n2; r3++) {
      if ((h2 = (u3 = t3.charCodeAt(r3)) >> 8) >> 8)
        throw new Error("Character at position " + r3 + " of string '" + t3 + "' exceeds 16bits. Cannot be encoded into UCS-2 BE");
      s3.push(h2), s3.push(u3 - (h2 << 8));
    }
    return String.fromCharCode.apply(void 0, s3);
  }, Ce = y2.__private__.pdfEscape = y2.pdfEscape = function(t3, e3) {
    return Fe(t3, e3).replace(/\\/g, "\\\\").replace(/\(/g, "\\(").replace(/\)/g, "\\)");
  }, je = y2.__private__.beginPage = function(t3) {
    ot2[++Dt2] = [], Rt2[Dt2] = { objId: 0, contentsObjId: 0, userUnit: Number(d2), artBox: null, bleedBox: null, cropBox: null, trimBox: null, mediaBox: { bottomLeftX: 0, bottomLeftY: 0, topRightX: Number(t3[0]), topRightY: Number(t3[1]) } }, Me(Dt2), ht2(ot2[$2]);
  }, Oe = function(t3, e3) {
    var r3, n2, o3;
    switch (i2 = e3 || i2, typeof t3 == "string" && (r3 = A2(t3.toLowerCase()), Array.isArray(r3) && (n2 = r3[0], o3 = r3[1])), Array.isArray(t3) && (n2 = t3[0] * _t2, o3 = t3[1] * _t2), isNaN(n2) && (n2 = s2[0], o3 = s2[1]), (n2 > 14400 || o3 > 14400) && (a$2.warn("A page in a PDF can not be wider or taller than 14400 userUnit. jsPDF limits the width/height to 14400"), n2 = Math.min(14400, n2), o3 = Math.min(14400, o3)), s2 = [n2, o3], i2.substr(0, 1)) {
      case "l":
        o3 > n2 && (s2 = [o3, n2]);
        break;
      case "p":
        n2 > o3 && (s2 = [o3, n2]);
    }
    je(s2), pr(fr), lt2(Lr), kr !== 0 && lt2(kr + " J"), Ir !== 0 && lt2(Ir + " j"), Tt2.publish("addPage", { pageNumber: Dt2 });
  }, Be = function(t3) {
    t3 > 0 && t3 <= Dt2 && (ot2.splice(t3, 1), Rt2.splice(t3, 1), Dt2--, $2 > Dt2 && ($2 = Dt2), this.setPage($2));
  }, Me = function(t3) {
    t3 > 0 && t3 <= Dt2 && ($2 = t3);
  }, Ee = y2.__private__.getNumberOfPages = y2.getNumberOfPages = function() {
    return ot2.length - 1;
  }, qe = function(t3, e3, r3) {
    var n2, i3 = void 0;
    return r3 = r3 || {}, t3 = t3 !== void 0 ? t3 : Ft2[St].fontName, e3 = e3 !== void 0 ? e3 : Ft2[St].fontStyle, n2 = t3.toLowerCase(), Ct2[n2] !== void 0 && Ct2[n2][e3] !== void 0 ? i3 = Ct2[n2][e3] : Ct2[t3] !== void 0 && Ct2[t3][e3] !== void 0 ? i3 = Ct2[t3][e3] : r3.disableWarning === false && a$2.warn("Unable to look up font label for font '" + t3 + "', '" + e3 + "'. Refer to getFontList() for available fonts."), i3 || r3.noFallback || (i3 = Ct2.times[e3]) == null && (i3 = Ct2.times.normal), i3;
  }, De = y2.__private__.putInfo = function() {
    var t3 = Xt2(), e3 = function(t4) {
      return t4;
    };
    for (var r3 in m2 !== null && (e3 = Ye.encryptor(t3, 0)), lt2("<<"), lt2("/Producer (" + Ce(e3("jsPDF " + E$1.version)) + ")"), xt2)
      xt2.hasOwnProperty(r3) && xt2[r3] && lt2("/" + r3.substr(0, 1).toUpperCase() + r3.substr(1) + " (" + Ce(e3(xt2[r3])) + ")");
    lt2("/CreationDate (" + Ce(e3(W2)) + ")"), lt2(">>"), lt2("endobj");
  }, Re = y2.__private__.putCatalog = function(t3) {
    var e3 = (t3 = t3 || {}).rootDictionaryObjId || Qt2;
    switch (Xt2(), lt2("<<"), lt2("/Type /Catalog"), lt2("/Pages " + e3 + " 0 R"), mt2 || (mt2 = "fullwidth"), mt2) {
      case "fullwidth":
        lt2("/OpenAction [3 0 R /FitH null]");
        break;
      case "fullheight":
        lt2("/OpenAction [3 0 R /FitV null]");
        break;
      case "fullpage":
        lt2("/OpenAction [3 0 R /Fit]");
        break;
      case "original":
        lt2("/OpenAction [3 0 R /XYZ null null 1]");
        break;
      default:
        var r3 = "" + mt2;
        r3.substr(r3.length - 1) === "%" && (mt2 = parseInt(mt2) / 100), typeof mt2 == "number" && lt2("/OpenAction [3 0 R /XYZ null null " + R2(mt2) + "]");
    }
    switch (Nt2 || (Nt2 = "continuous"), Nt2) {
      case "continuous":
        lt2("/PageLayout /OneColumn");
        break;
      case "single":
        lt2("/PageLayout /SinglePage");
        break;
      case "two":
      case "twoleft":
        lt2("/PageLayout /TwoColumnLeft");
        break;
      case "tworight":
        lt2("/PageLayout /TwoColumnRight");
    }
    yt2 && lt2("/PageMode /" + yt2), Tt2.publish("putCatalog"), lt2(">>"), lt2("endobj");
  }, Te = y2.__private__.putTrailer = function() {
    lt2("trailer"), lt2("<<"), lt2("/Size " + (et2 + 1)), lt2("/Root " + et2 + " 0 R"), lt2("/Info " + (et2 - 1) + " 0 R"), m2 !== null && lt2("/Encrypt " + Ye.oid + " 0 R"), lt2("/ID [ <" + V2 + "> <" + V2 + "> ]"), lt2(">>");
  }, ze = y2.__private__.putHeader = function() {
    lt2("%PDF-" + w2), lt2("%\xBA\xDF\xAC\xE0");
  }, Ue = y2.__private__.putXRef = function() {
    var t3 = "0000000000";
    lt2("xref"), lt2("0 " + (et2 + 1)), lt2("0000000000 65535 f ");
    for (var e3 = 1; e3 <= et2; e3++) {
      typeof rt2[e3] == "function" ? lt2((t3 + rt2[e3]()).slice(-10) + " 00000 n ") : rt2[e3] !== void 0 ? lt2((t3 + rt2[e3]).slice(-10) + " 00000 n ") : lt2("0000000000 00000 n ");
    }
  }, He = y2.__private__.buildDocument = function() {
    ut2(), ht2(nt2), Tt2.publish("buildDocument"), ze(), oe2(), Se(), xe(), m2 !== null && be2(), De(), Re();
    var t3 = it2;
    return Ue(), Te(), lt2("startxref"), lt2("" + t3), lt2("%%EOF"), ht2(ot2[$2]), nt2.join("\n");
  }, We = y2.__private__.getBlob = function(t3) {
    return new Blob([dt2(t3)], { type: "application/pdf" });
  }, Ve = y2.output = y2.__private__.output = Ie(function(t3, e3) {
    switch (typeof (e3 = e3 || {}) == "string" ? e3 = { filename: e3 } : e3.filename = e3.filename || "generated.pdf", t3) {
      case void 0:
        return He();
      case "save":
        y2.save(e3.filename);
        break;
      case "arraybuffer":
        return dt2(He());
      case "blob":
        return We(He());
      case "bloburi":
      case "bloburl":
        if (n$1.URL !== void 0 && typeof n$1.URL.createObjectURL == "function")
          return n$1.URL && n$1.URL.createObjectURL(We(He())) || void 0;
        a$2.warn("bloburl is not supported by your system, because URL.createObjectURL is not supported by your browser.");
        break;
      case "datauristring":
      case "dataurlstring":
        var r3 = "", i3 = He();
        try {
          r3 = h$1(i3);
        } catch (t4) {
          r3 = h$1(unescape(encodeURIComponent(i3)));
        }
        return "data:application/pdf;filename=" + e3.filename + ";base64," + r3;
      case "pdfobjectnewwindow":
        if (Object.prototype.toString.call(n$1) === "[object Window]") {
          var o3 = '<html><style>html, body { padding: 0; margin: 0; } iframe { width: 100%; height: 100%; border: 0;}  </style><body><script src="' + (e3.pdfObjectUrl || "https://cdnjs.cloudflare.com/ajax/libs/pdfobject/2.1.1/pdfobject.min.js") + '"><\/script><script >PDFObject.embed("' + this.output("dataurlstring") + '", ' + JSON.stringify(e3) + ");<\/script></body></html>", s3 = n$1.open();
          return s3 !== null && s3.document.write(o3), s3;
        }
        throw new Error("The option pdfobjectnewwindow just works in a browser-environment.");
      case "pdfjsnewwindow":
        if (Object.prototype.toString.call(n$1) === "[object Window]") {
          var c3 = '<html><style>html, body { padding: 0; margin: 0; } iframe { width: 100%; height: 100%; border: 0;}  </style><body><iframe id="pdfViewer" src="' + (e3.pdfJsUrl || "examples/PDF.js/web/viewer.html") + "?file=&downloadName=" + e3.filename + '" width="500px" height="400px" /></body></html>', u3 = n$1.open();
          if (u3 !== null) {
            u3.document.write(c3);
            var l2 = this;
            u3.document.documentElement.querySelector("#pdfViewer").onload = function() {
              u3.document.title = e3.filename, u3.document.documentElement.querySelector("#pdfViewer").contentWindow.PDFViewerApplication.open(l2.output("bloburl"));
            };
          }
          return u3;
        }
        throw new Error("The option pdfjsnewwindow just works in a browser-environment.");
      case "dataurlnewwindow":
        if (Object.prototype.toString.call(n$1) !== "[object Window]")
          throw new Error("The option dataurlnewwindow just works in a browser-environment.");
        var f2 = '<html><style>html, body { padding: 0; margin: 0; } iframe { width: 100%; height: 100%; border: 0;}  </style><body><iframe src="' + this.output("datauristring", e3) + '"></iframe></body></html>', d3 = n$1.open();
        if (d3 !== null && (d3.document.write(f2), d3.document.title = e3.filename), d3 || typeof safari == "undefined")
          return d3;
        break;
      case "datauri":
      case "dataurl":
        return n$1.document.location.href = this.output("datauristring", e3);
      default:
        return null;
    }
  }), Ge = function(t3) {
    return Array.isArray(zt2) === true && zt2.indexOf(t3) > -1;
  };
  switch (o2) {
    case "pt":
      _t2 = 1;
      break;
    case "mm":
      _t2 = 72 / 25.4;
      break;
    case "cm":
      _t2 = 72 / 2.54;
      break;
    case "in":
      _t2 = 72;
      break;
    case "px":
      _t2 = Ge("px_scaling") == 1 ? 0.75 : 96 / 72;
      break;
    case "pc":
    case "em":
      _t2 = 12;
      break;
    case "ex":
      _t2 = 6;
      break;
    default:
      if (typeof o2 != "number")
        throw new Error("Invalid unit: " + o2);
      _t2 = o2;
  }
  var Ye = null;
  K2(), Y2();
  var Je = function(t3) {
    return m2 !== null ? Ye.encryptor(t3, 0) : function(t4) {
      return t4;
    };
  }, Xe = y2.__private__.getPageInfo = y2.getPageInfo = function(t3) {
    if (isNaN(t3) || t3 % 1 != 0)
      throw new Error("Invalid argument passed to jsPDF.getPageInfo");
    return { objId: Rt2[t3].objId, pageNumber: t3, pageContext: Rt2[t3] };
  }, Ke = y2.__private__.getPageInfoByObjId = function(t3) {
    if (isNaN(t3) || t3 % 1 != 0)
      throw new Error("Invalid argument passed to jsPDF.getPageInfoByObjId");
    for (var e3 in Rt2)
      if (Rt2[e3].objId === t3)
        break;
    return Xe(e3);
  }, Ze = y2.__private__.getCurrentPageInfo = y2.getCurrentPageInfo = function() {
    return { objId: Rt2[$2].objId, pageNumber: $2, pageContext: Rt2[$2] };
  };
  y2.addPage = function() {
    return Oe.apply(this, arguments), this;
  }, y2.setPage = function() {
    return Me.apply(this, arguments), ht2.call(this, ot2[$2]), this;
  }, y2.insertPage = function(t3) {
    return this.addPage(), this.movePage($2, t3), this;
  }, y2.movePage = function(t3, e3) {
    var r3, n2;
    if (t3 > e3) {
      r3 = ot2[t3], n2 = Rt2[t3];
      for (var i3 = t3; i3 > e3; i3--)
        ot2[i3] = ot2[i3 - 1], Rt2[i3] = Rt2[i3 - 1];
      ot2[e3] = r3, Rt2[e3] = n2, this.setPage(e3);
    } else if (t3 < e3) {
      r3 = ot2[t3], n2 = Rt2[t3];
      for (var a2 = t3; a2 < e3; a2++)
        ot2[a2] = ot2[a2 + 1], Rt2[a2] = Rt2[a2 + 1];
      ot2[e3] = r3, Rt2[e3] = n2, this.setPage(e3);
    }
    return this;
  }, y2.deletePage = function() {
    return Be.apply(this, arguments), this;
  }, y2.__private__.text = y2.text = function(e3, r3, n2, i3, a2) {
    var o3, s3, c3, u3, h2, l2, f2, d3, p6, g3 = (i3 = i3 || {}).scope || this;
    if (typeof e3 == "number" && typeof r3 == "number" && (typeof n2 == "string" || Array.isArray(n2))) {
      var m3 = n2;
      n2 = r3, r3 = e3, e3 = m3;
    }
    if (arguments[3] instanceof Vt2 == false ? (c3 = arguments[4], u3 = arguments[5], _typeof$2(f2 = arguments[3]) === "object" && f2 !== null || (typeof c3 == "string" && (u3 = c3, c3 = null), typeof f2 == "string" && (u3 = f2, f2 = null), typeof f2 == "number" && (c3 = f2, f2 = null), i3 = { flags: f2, angle: c3, align: u3 })) : (q2("The transform parameter of text() with a Matrix value"), p6 = a2), isNaN(r3) || isNaN(n2) || e3 == null)
      throw new Error("Invalid arguments passed to jsPDF.text");
    if (e3.length === 0)
      return g3;
    var v3 = "", y3 = false, w3 = typeof i3.lineHeightFactor == "number" ? i3.lineHeightFactor : lr, N3 = g3.internal.scaleFactor;
    function L3(t3) {
      return t3 = t3.split("	").join(Array(i3.TabLen || 9).join(" ")), Ce(t3, f2);
    }
    function A3(t3) {
      for (var e4, r4 = t3.concat(), n3 = [], i4 = r4.length; i4--; )
        typeof (e4 = r4.shift()) == "string" ? n3.push(e4) : Array.isArray(t3) && (e4.length === 1 || e4[1] === void 0 && e4[2] === void 0) ? n3.push(e4[0]) : n3.push([e4[0], e4[1], e4[2]]);
      return n3;
    }
    function _3(t3, e4) {
      var r4;
      if (typeof t3 == "string")
        r4 = e4(t3)[0];
      else if (Array.isArray(t3)) {
        for (var n3, i4, a3 = t3.concat(), o4 = [], s4 = a3.length; s4--; )
          typeof (n3 = a3.shift()) == "string" ? o4.push(e4(n3)[0]) : Array.isArray(n3) && typeof n3[0] == "string" && (i4 = e4(n3[0], n3[1], n3[2]), o4.push([i4[0], i4[1], i4[2]]));
        r4 = o4;
      }
      return r4;
    }
    var P3 = false, k3 = true;
    if (typeof e3 == "string")
      P3 = true;
    else if (Array.isArray(e3)) {
      var I2 = e3.concat();
      s3 = [];
      for (var F2, C2 = I2.length; C2--; )
        (typeof (F2 = I2.shift()) != "string" || Array.isArray(F2) && typeof F2[0] != "string") && (k3 = false);
      P3 = k3;
    }
    if (P3 === false)
      throw new Error('Type of text must be string or Array. "' + e3 + '" is not recognized.');
    typeof e3 == "string" && (e3 = e3.match(/[\r?\n]/) ? e3.split(/\r\n|\r|\n/g) : [e3]);
    var j2 = gt2 / g3.internal.scaleFactor, B3 = j2 * (w3 - 1);
    switch (i3.baseline) {
      case "bottom":
        n2 -= B3;
        break;
      case "top":
        n2 += j2 - B3;
        break;
      case "hanging":
        n2 += j2 - 2 * B3;
        break;
      case "middle":
        n2 += j2 / 2 - B3;
    }
    if ((l2 = i3.maxWidth || 0) > 0 && (typeof e3 == "string" ? e3 = g3.splitTextToSize(e3, l2) : Object.prototype.toString.call(e3) === "[object Array]" && (e3 = e3.reduce(function(t3, e4) {
      return t3.concat(g3.splitTextToSize(e4, l2));
    }, []))), o3 = { text: e3, x: r3, y: n2, options: i3, mutex: { pdfEscape: Ce, activeFontKey: St, fonts: Ft2, activeFontSize: gt2 } }, Tt2.publish("preProcessText", o3), e3 = o3.text, c3 = (i3 = o3.options).angle, p6 instanceof Vt2 == false && c3 && typeof c3 == "number") {
      c3 *= Math.PI / 180, i3.rotationDirection === 0 && (c3 = -c3), S2 === x2.ADVANCED && (c3 = -c3);
      var M2 = Math.cos(c3), E2 = Math.sin(c3);
      p6 = new Vt2(M2, E2, -E2, M2, 0, 0);
    } else
      c3 && c3 instanceof Vt2 && (p6 = c3);
    S2 !== x2.ADVANCED || p6 || (p6 = Yt2), (h2 = i3.charSpace || _r) !== void 0 && (v3 += O2(z2(h2)) + " Tc\n", this.setCharSpace(this.getCharSpace() || 0)), (d3 = i3.horizontalScale) !== void 0 && (v3 += O2(100 * d3) + " Tz\n");
    i3.lang;
    var D3 = -1, R3 = i3.renderingMode !== void 0 ? i3.renderingMode : i3.stroke, T3 = g3.internal.getCurrentPageInfo().pageContext;
    switch (R3) {
      case 0:
      case false:
      case "fill":
        D3 = 0;
        break;
      case 1:
      case true:
      case "stroke":
        D3 = 1;
        break;
      case 2:
      case "fillThenStroke":
        D3 = 2;
        break;
      case 3:
      case "invisible":
        D3 = 3;
        break;
      case 4:
      case "fillAndAddForClipping":
        D3 = 4;
        break;
      case 5:
      case "strokeAndAddPathForClipping":
        D3 = 5;
        break;
      case 6:
      case "fillThenStrokeAndAddToPathForClipping":
        D3 = 6;
        break;
      case 7:
      case "addToPathForClipping":
        D3 = 7;
    }
    var U3 = T3.usedRenderingMode !== void 0 ? T3.usedRenderingMode : -1;
    D3 !== -1 ? v3 += D3 + " Tr\n" : U3 !== -1 && (v3 += "0 Tr\n"), D3 !== -1 && (T3.usedRenderingMode = D3), u3 = i3.align || "left";
    var H5, W3 = gt2 * w3, V3 = g3.internal.pageSize.getWidth(), G3 = Ft2[St];
    h2 = i3.charSpace || _r, l2 = i3.maxWidth || 0, f2 = Object.assign({ autoencode: true, noBOM: true }, i3.flags);
    var Y3 = [];
    if (Object.prototype.toString.call(e3) === "[object Array]") {
      var J3;
      s3 = A3(e3), u3 !== "left" && (H5 = s3.map(function(t3) {
        return g3.getStringUnitWidth(t3, { font: G3, charSpace: h2, fontSize: gt2, doKerning: false }) * gt2 / N3;
      }));
      var X3, K3 = 0;
      if (u3 === "right") {
        r3 -= H5[0], e3 = [], C2 = s3.length;
        for (var Z3 = 0; Z3 < C2; Z3++)
          Z3 === 0 ? (X3 = br(r3), J3 = yr(n2)) : (X3 = z2(K3 - H5[Z3]), J3 = -W3), e3.push([s3[Z3], X3, J3]), K3 = H5[Z3];
      } else if (u3 === "center") {
        r3 -= H5[0] / 2, e3 = [], C2 = s3.length;
        for (var $3 = 0; $3 < C2; $3++)
          $3 === 0 ? (X3 = br(r3), J3 = yr(n2)) : (X3 = z2((K3 - H5[$3]) / 2), J3 = -W3), e3.push([s3[$3], X3, J3]), K3 = H5[$3];
      } else if (u3 === "left") {
        e3 = [], C2 = s3.length;
        for (var Q3 = 0; Q3 < C2; Q3++)
          e3.push(s3[Q3]);
      } else {
        if (u3 !== "justify")
          throw new Error('Unrecognized alignment option, use "left", "center", "right" or "justify".');
        e3 = [], C2 = s3.length, l2 = l2 !== 0 ? l2 : V3;
        for (var tt3 = 0; tt3 < C2; tt3++)
          J3 = tt3 === 0 ? yr(n2) : -W3, X3 = tt3 === 0 ? br(r3) : 0, tt3 < C2 - 1 ? Y3.push(O2(z2((l2 - H5[tt3]) / (s3[tt3].split(" ").length - 1)))) : Y3.push(0), e3.push([s3[tt3], X3, J3]);
      }
    }
    var et3 = typeof i3.R2L == "boolean" ? i3.R2L : bt2;
    et3 === true && (e3 = _3(e3, function(t3, e4, r4) {
      return [t3.split("").reverse().join(""), e4, r4];
    })), o3 = { text: e3, x: r3, y: n2, options: i3, mutex: { pdfEscape: Ce, activeFontKey: St, fonts: Ft2, activeFontSize: gt2 } }, Tt2.publish("postProcessText", o3), e3 = o3.text, y3 = o3.mutex.isHex || false;
    var rt3 = Ft2[St].encoding;
    rt3 !== "WinAnsiEncoding" && rt3 !== "StandardEncoding" || (e3 = _3(e3, function(t3, e4, r4) {
      return [L3(t3), e4, r4];
    })), s3 = A3(e3), e3 = [];
    for (var nt3, it3, at3, ot3 = 0, st3 = 1, ct3 = Array.isArray(s3[0]) ? st3 : ot3, ut3 = "", ht3 = function(t3, e4, r4) {
      var n3 = "";
      return r4 instanceof Vt2 ? (r4 = typeof i3.angle == "number" ? Gt2(r4, new Vt2(1, 0, 0, 1, t3, e4)) : Gt2(new Vt2(1, 0, 0, 1, t3, e4), r4), S2 === x2.ADVANCED && (r4 = Gt2(new Vt2(1, 0, 0, -1, 0, 0), r4)), n3 = r4.join(" ") + " Tm\n") : n3 = O2(t3) + " " + O2(e4) + " Td\n", n3;
    }, ft3 = 0; ft3 < s3.length; ft3++) {
      switch (ut3 = "", ct3) {
        case st3:
          at3 = (y3 ? "<" : "(") + s3[ft3][0] + (y3 ? ">" : ")"), nt3 = parseFloat(s3[ft3][1]), it3 = parseFloat(s3[ft3][2]);
          break;
        case ot3:
          at3 = (y3 ? "<" : "(") + s3[ft3] + (y3 ? ">" : ")"), nt3 = br(r3), it3 = yr(n2);
      }
      Y3 !== void 0 && Y3[ft3] !== void 0 && (ut3 = Y3[ft3] + " Tw\n"), ft3 === 0 ? e3.push(ut3 + ht3(nt3, it3, p6) + at3) : ct3 === ot3 ? e3.push(ut3 + at3) : ct3 === st3 && e3.push(ut3 + ht3(nt3, it3, p6) + at3);
    }
    e3 = ct3 === ot3 ? e3.join(" Tj\nT* ") : e3.join(" Tj\n"), e3 += " Tj\n";
    var dt3 = "BT\n/";
    return dt3 += St + " " + gt2 + " Tf\n", dt3 += O2(gt2 * w3) + " TL\n", dt3 += xr + "\n", dt3 += v3, dt3 += e3, lt2(dt3 += "ET"), b2[St] = true, g3;
  };
  var $e = y2.__private__.clip = y2.clip = function(t3) {
    return lt2(t3 === "evenodd" ? "W*" : "W"), this;
  };
  y2.clipEvenOdd = function() {
    return $e("evenodd");
  }, y2.__private__.discardPath = y2.discardPath = function() {
    return lt2("n"), this;
  };
  var Qe = y2.__private__.isValidStyle = function(t3) {
    var e3 = false;
    return [void 0, null, "S", "D", "F", "DF", "FD", "f", "f*", "B", "B*", "n"].indexOf(t3) !== -1 && (e3 = true), e3;
  };
  y2.__private__.setDefaultPathOperation = y2.setDefaultPathOperation = function(t3) {
    return Qe(t3) && (g2 = t3), this;
  };
  var tr = y2.__private__.getStyle = y2.getStyle = function(t3) {
    var e3 = g2;
    switch (t3) {
      case "D":
      case "S":
        e3 = "S";
        break;
      case "F":
        e3 = "f";
        break;
      case "FD":
      case "DF":
        e3 = "B";
        break;
      case "f":
      case "f*":
      case "B":
      case "B*":
        e3 = t3;
    }
    return e3;
  }, er = y2.close = function() {
    return lt2("h"), this;
  };
  y2.stroke = function() {
    return lt2("S"), this;
  }, y2.fill = function(t3) {
    return rr("f", t3), this;
  }, y2.fillEvenOdd = function(t3) {
    return rr("f*", t3), this;
  }, y2.fillStroke = function(t3) {
    return rr("B", t3), this;
  }, y2.fillStrokeEvenOdd = function(t3) {
    return rr("B*", t3), this;
  };
  var rr = function(e3, r3) {
    _typeof$2(r3) === "object" ? ar(r3, e3) : lt2(e3);
  }, nr = function(t3) {
    t3 === null || S2 === x2.ADVANCED && t3 === void 0 || (t3 = tr(t3), lt2(t3));
  };
  function ir(t3, e3, r3, n2, i3) {
    var a2 = new M$1(e3 || this.boundingBox, r3 || this.xStep, n2 || this.yStep, this.gState, i3 || this.matrix);
    a2.stream = this.stream;
    var o3 = t3 + "$$" + this.cloneIndex++ + "$$";
    return Jt2(o3, a2), a2;
  }
  var ar = function(t3, e3) {
    var r3 = Bt2[t3.key], n2 = Ot2[r3];
    if (n2 instanceof B)
      lt2("q"), lt2(or(e3)), n2.gState && y2.setGState(n2.gState), lt2(t3.matrix.toString() + " cm"), lt2("/" + r3 + " sh"), lt2("Q");
    else if (n2 instanceof M$1) {
      var i3 = new Vt2(1, 0, 0, -1, 0, Rr());
      t3.matrix && (i3 = i3.multiply(t3.matrix || Yt2), r3 = ir.call(n2, t3.key, t3.boundingBox, t3.xStep, t3.yStep, i3).id), lt2("q"), lt2("/Pattern cs"), lt2("/" + r3 + " scn"), n2.gState && y2.setGState(n2.gState), lt2(e3), lt2("Q");
    }
  }, or = function(t3) {
    switch (t3) {
      case "f":
      case "F":
        return "W n";
      case "f*":
        return "W* n";
      case "B":
        return "W S";
      case "B*":
        return "W* S";
      case "S":
        return "W S";
      case "n":
        return "W n";
    }
  }, sr = y2.moveTo = function(t3, e3) {
    return lt2(O2(z2(t3)) + " " + O2(H4(e3)) + " m"), this;
  }, cr = y2.lineTo = function(t3, e3) {
    return lt2(O2(z2(t3)) + " " + O2(H4(e3)) + " l"), this;
  }, ur = y2.curveTo = function(t3, e3, r3, n2, i3, a2) {
    return lt2([O2(z2(t3)), O2(H4(e3)), O2(z2(r3)), O2(H4(n2)), O2(z2(i3)), O2(H4(a2)), "c"].join(" ")), this;
  };
  y2.__private__.line = y2.line = function(t3, e3, r3, n2, i3) {
    if (isNaN(t3) || isNaN(e3) || isNaN(r3) || isNaN(n2) || !Qe(i3))
      throw new Error("Invalid arguments passed to jsPDF.line");
    return S2 === x2.COMPAT ? this.lines([[r3 - t3, n2 - e3]], t3, e3, [1, 1], i3 || "S") : this.lines([[r3 - t3, n2 - e3]], t3, e3, [1, 1]).stroke();
  }, y2.__private__.lines = y2.lines = function(t3, e3, r3, n2, i3, a2) {
    var o3, s3, c3, u3, h2, l2, f2, d3, p6, g3, m3, v3;
    if (typeof t3 == "number" && (v3 = r3, r3 = e3, e3 = t3, t3 = v3), n2 = n2 || [1, 1], a2 = a2 || false, isNaN(e3) || isNaN(r3) || !Array.isArray(t3) || !Array.isArray(n2) || !Qe(i3) || typeof a2 != "boolean")
      throw new Error("Invalid arguments passed to jsPDF.lines");
    for (sr(e3, r3), o3 = n2[0], s3 = n2[1], u3 = t3.length, g3 = e3, m3 = r3, c3 = 0; c3 < u3; c3++)
      (h2 = t3[c3]).length === 2 ? (g3 = h2[0] * o3 + g3, m3 = h2[1] * s3 + m3, cr(g3, m3)) : (l2 = h2[0] * o3 + g3, f2 = h2[1] * s3 + m3, d3 = h2[2] * o3 + g3, p6 = h2[3] * s3 + m3, g3 = h2[4] * o3 + g3, m3 = h2[5] * s3 + m3, ur(l2, f2, d3, p6, g3, m3));
    return a2 && er(), nr(i3), this;
  }, y2.path = function(t3) {
    for (var e3 = 0; e3 < t3.length; e3++) {
      var r3 = t3[e3], n2 = r3.c;
      switch (r3.op) {
        case "m":
          sr(n2[0], n2[1]);
          break;
        case "l":
          cr(n2[0], n2[1]);
          break;
        case "c":
          ur.apply(this, n2);
          break;
        case "h":
          er();
      }
    }
    return this;
  }, y2.__private__.rect = y2.rect = function(t3, e3, r3, n2, i3) {
    if (isNaN(t3) || isNaN(e3) || isNaN(r3) || isNaN(n2) || !Qe(i3))
      throw new Error("Invalid arguments passed to jsPDF.rect");
    return S2 === x2.COMPAT && (n2 = -n2), lt2([O2(z2(t3)), O2(H4(e3)), O2(z2(r3)), O2(z2(n2)), "re"].join(" ")), nr(i3), this;
  }, y2.__private__.triangle = y2.triangle = function(t3, e3, r3, n2, i3, a2, o3) {
    if (isNaN(t3) || isNaN(e3) || isNaN(r3) || isNaN(n2) || isNaN(i3) || isNaN(a2) || !Qe(o3))
      throw new Error("Invalid arguments passed to jsPDF.triangle");
    return this.lines([[r3 - t3, n2 - e3], [i3 - r3, a2 - n2], [t3 - i3, e3 - a2]], t3, e3, [1, 1], o3, true), this;
  }, y2.__private__.roundedRect = y2.roundedRect = function(t3, e3, r3, n2, i3, a2, o3) {
    if (isNaN(t3) || isNaN(e3) || isNaN(r3) || isNaN(n2) || isNaN(i3) || isNaN(a2) || !Qe(o3))
      throw new Error("Invalid arguments passed to jsPDF.roundedRect");
    var s3 = 4 / 3 * (Math.SQRT2 - 1);
    return i3 = Math.min(i3, 0.5 * r3), a2 = Math.min(a2, 0.5 * n2), this.lines([[r3 - 2 * i3, 0], [i3 * s3, 0, i3, a2 - a2 * s3, i3, a2], [0, n2 - 2 * a2], [0, a2 * s3, -i3 * s3, a2, -i3, a2], [2 * i3 - r3, 0], [-i3 * s3, 0, -i3, -a2 * s3, -i3, -a2], [0, 2 * a2 - n2], [0, -a2 * s3, i3 * s3, -a2, i3, -a2]], t3 + i3, e3, [1, 1], o3, true), this;
  }, y2.__private__.ellipse = y2.ellipse = function(t3, e3, r3, n2, i3) {
    if (isNaN(t3) || isNaN(e3) || isNaN(r3) || isNaN(n2) || !Qe(i3))
      throw new Error("Invalid arguments passed to jsPDF.ellipse");
    var a2 = 4 / 3 * (Math.SQRT2 - 1) * r3, o3 = 4 / 3 * (Math.SQRT2 - 1) * n2;
    return sr(t3 + r3, e3), ur(t3 + r3, e3 - o3, t3 + a2, e3 - n2, t3, e3 - n2), ur(t3 - a2, e3 - n2, t3 - r3, e3 - o3, t3 - r3, e3), ur(t3 - r3, e3 + o3, t3 - a2, e3 + n2, t3, e3 + n2), ur(t3 + a2, e3 + n2, t3 + r3, e3 + o3, t3 + r3, e3), nr(i3), this;
  }, y2.__private__.circle = y2.circle = function(t3, e3, r3, n2) {
    if (isNaN(t3) || isNaN(e3) || isNaN(r3) || !Qe(n2))
      throw new Error("Invalid arguments passed to jsPDF.circle");
    return this.ellipse(t3, e3, r3, r3, n2);
  }, y2.setFont = function(t3, e3, r3) {
    return r3 && (e3 = k2(e3, r3)), St = qe(t3, e3, { disableWarning: false }), this;
  };
  var hr = y2.__private__.getFont = y2.getFont = function() {
    return Ft2[qe.apply(y2, arguments)];
  };
  y2.__private__.getFontList = y2.getFontList = function() {
    var t3, e3, r3 = {};
    for (t3 in Ct2)
      if (Ct2.hasOwnProperty(t3))
        for (e3 in r3[t3] = [], Ct2[t3])
          Ct2[t3].hasOwnProperty(e3) && r3[t3].push(e3);
    return r3;
  }, y2.addFont = function(t3, e3, r3, n2, i3) {
    var a2 = ["StandardEncoding", "MacRomanEncoding", "Identity-H", "WinAnsiEncoding"];
    return arguments[3] && a2.indexOf(arguments[3]) !== -1 ? i3 = arguments[3] : arguments[3] && a2.indexOf(arguments[3]) == -1 && (r3 = k2(r3, n2)), i3 = i3 || "Identity-H", Pe.call(this, t3, e3, r3, i3);
  };
  var lr, fr = e2.lineWidth || 0.200025, dr = y2.__private__.getLineWidth = y2.getLineWidth = function() {
    return fr;
  }, pr = y2.__private__.setLineWidth = y2.setLineWidth = function(t3) {
    return fr = t3, lt2(O2(z2(t3)) + " w"), this;
  };
  y2.__private__.setLineDash = E$1.API.setLineDash = E$1.API.setLineDashPattern = function(t3, e3) {
    if (t3 = t3 || [], e3 = e3 || 0, isNaN(e3) || !Array.isArray(t3))
      throw new Error("Invalid arguments passed to jsPDF.setLineDash");
    return t3 = t3.map(function(t4) {
      return O2(z2(t4));
    }).join(" "), e3 = O2(z2(e3)), lt2("[" + t3 + "] " + e3 + " d"), this;
  };
  var gr = y2.__private__.getLineHeight = y2.getLineHeight = function() {
    return gt2 * lr;
  };
  y2.__private__.getLineHeight = y2.getLineHeight = function() {
    return gt2 * lr;
  };
  var mr = y2.__private__.setLineHeightFactor = y2.setLineHeightFactor = function(t3) {
    return typeof (t3 = t3 || 1.15) == "number" && (lr = t3), this;
  }, vr = y2.__private__.getLineHeightFactor = y2.getLineHeightFactor = function() {
    return lr;
  };
  mr(e2.lineHeight);
  var br = y2.__private__.getHorizontalCoordinate = function(t3) {
    return z2(t3);
  }, yr = y2.__private__.getVerticalCoordinate = function(t3) {
    return S2 === x2.ADVANCED ? t3 : Rt2[$2].mediaBox.topRightY - Rt2[$2].mediaBox.bottomLeftY - z2(t3);
  }, wr = y2.__private__.getHorizontalCoordinateString = y2.getHorizontalCoordinateString = function(t3) {
    return O2(br(t3));
  }, Nr = y2.__private__.getVerticalCoordinateString = y2.getVerticalCoordinateString = function(t3) {
    return O2(yr(t3));
  }, Lr = e2.strokeColor || "0 G";
  y2.__private__.getStrokeColor = y2.getDrawColor = function() {
    return ee2(Lr);
  }, y2.__private__.setStrokeColor = y2.setDrawColor = function(t3, e3, r3, n2) {
    return Lr = re2({ ch1: t3, ch2: e3, ch3: r3, ch4: n2, pdfColorType: "draw", precision: 2 }), lt2(Lr), this;
  };
  var Ar = e2.fillColor || "0 g";
  y2.__private__.getFillColor = y2.getFillColor = function() {
    return ee2(Ar);
  }, y2.__private__.setFillColor = y2.setFillColor = function(t3, e3, r3, n2) {
    return Ar = re2({ ch1: t3, ch2: e3, ch3: r3, ch4: n2, pdfColorType: "fill", precision: 2 }), lt2(Ar), this;
  };
  var xr = e2.textColor || "0 g", Sr = y2.__private__.getTextColor = y2.getTextColor = function() {
    return ee2(xr);
  };
  y2.__private__.setTextColor = y2.setTextColor = function(t3, e3, r3, n2) {
    return xr = re2({ ch1: t3, ch2: e3, ch3: r3, ch4: n2, pdfColorType: "text", precision: 3 }), this;
  };
  var _r = e2.charSpace, Pr = y2.__private__.getCharSpace = y2.getCharSpace = function() {
    return parseFloat(_r || 0);
  };
  y2.__private__.setCharSpace = y2.setCharSpace = function(t3) {
    if (isNaN(t3))
      throw new Error("Invalid argument passed to jsPDF.setCharSpace");
    return _r = t3, this;
  };
  var kr = 0;
  y2.CapJoinStyles = { 0: 0, butt: 0, but: 0, miter: 0, 1: 1, round: 1, rounded: 1, circle: 1, 2: 2, projecting: 2, project: 2, square: 2, bevel: 2 }, y2.__private__.setLineCap = y2.setLineCap = function(t3) {
    var e3 = y2.CapJoinStyles[t3];
    if (e3 === void 0)
      throw new Error("Line cap style of '" + t3 + "' is not recognized. See or extend .CapJoinStyles property for valid styles");
    return kr = e3, lt2(e3 + " J"), this;
  };
  var Ir = 0;
  y2.__private__.setLineJoin = y2.setLineJoin = function(t3) {
    var e3 = y2.CapJoinStyles[t3];
    if (e3 === void 0)
      throw new Error("Line join style of '" + t3 + "' is not recognized. See or extend .CapJoinStyles property for valid styles");
    return Ir = e3, lt2(e3 + " j"), this;
  }, y2.__private__.setLineMiterLimit = y2.__private__.setMiterLimit = y2.setLineMiterLimit = y2.setMiterLimit = function(t3) {
    if (t3 = t3 || 0, isNaN(t3))
      throw new Error("Invalid argument passed to jsPDF.setLineMiterLimit");
    return lt2(O2(z2(t3)) + " M"), this;
  }, y2.GState = j, y2.setGState = function(t3) {
    (t3 = typeof t3 == "string" ? Mt2[Et2[t3]] : Fr(null, t3)).equals(qt2) || (lt2("/" + t3.id + " gs"), qt2 = t3);
  };
  var Fr = function(t3, e3) {
    if (!t3 || !Et2[t3]) {
      var r3 = false;
      for (var n2 in Mt2)
        if (Mt2.hasOwnProperty(n2) && Mt2[n2].equals(e3)) {
          r3 = true;
          break;
        }
      if (r3)
        e3 = Mt2[n2];
      else {
        var i3 = "GS" + (Object.keys(Mt2).length + 1).toString(10);
        Mt2[i3] = e3, e3.id = i3;
      }
      return t3 && (Et2[t3] = e3.id), Tt2.publish("addGState", e3), e3;
    }
  };
  y2.addGState = function(t3, e3) {
    return Fr(t3, e3), this;
  }, y2.saveGraphicsState = function() {
    return lt2("q"), jt2.push({ key: St, size: gt2, color: xr }), this;
  }, y2.restoreGraphicsState = function() {
    lt2("Q");
    var t3 = jt2.pop();
    return St = t3.key, gt2 = t3.size, xr = t3.color, qt2 = null, this;
  }, y2.setCurrentTransformationMatrix = function(t3) {
    return lt2(t3.toString() + " cm"), this;
  }, y2.comment = function(t3) {
    return lt2("#" + t3), this;
  };
  var Cr = function(t3, e3) {
    var r3 = t3 || 0;
    Object.defineProperty(this, "x", { enumerable: true, get: function() {
      return r3;
    }, set: function(t4) {
      isNaN(t4) || (r3 = parseFloat(t4));
    } });
    var n2 = e3 || 0;
    Object.defineProperty(this, "y", { enumerable: true, get: function() {
      return n2;
    }, set: function(t4) {
      isNaN(t4) || (n2 = parseFloat(t4));
    } });
    var i3 = "pt";
    return Object.defineProperty(this, "type", { enumerable: true, get: function() {
      return i3;
    }, set: function(t4) {
      i3 = t4.toString();
    } }), this;
  }, jr = function(t3, e3, r3, n2) {
    Cr.call(this, t3, e3), this.type = "rect";
    var i3 = r3 || 0;
    Object.defineProperty(this, "w", { enumerable: true, get: function() {
      return i3;
    }, set: function(t4) {
      isNaN(t4) || (i3 = parseFloat(t4));
    } });
    var a2 = n2 || 0;
    return Object.defineProperty(this, "h", { enumerable: true, get: function() {
      return a2;
    }, set: function(t4) {
      isNaN(t4) || (a2 = parseFloat(t4));
    } }), this;
  }, Or = function() {
    this.page = Dt2, this.currentPage = $2, this.pages = ot2.slice(0), this.pagesContext = Rt2.slice(0), this.x = Pt2, this.y = kt2, this.matrix = It2, this.width = qr($2), this.height = Rr($2), this.outputDestination = ct2, this.id = "", this.objectNumber = -1;
  };
  Or.prototype.restore = function() {
    Dt2 = this.page, $2 = this.currentPage, Rt2 = this.pagesContext, ot2 = this.pages, Pt2 = this.x, kt2 = this.y, It2 = this.matrix, Dr($2, this.width), Tr($2, this.height), ct2 = this.outputDestination;
  };
  var Br = function(t3, e3, r3, n2, i3) {
    Wt2.push(new Or()), Dt2 = $2 = 0, ot2 = [], Pt2 = t3, kt2 = e3, It2 = i3, je([r3, n2]);
  }, Mr = function(t3) {
    if (Ht2[t3])
      Wt2.pop().restore();
    else {
      var e3 = new Or(), r3 = "Xo" + (Object.keys(Ut2).length + 1).toString(10);
      e3.id = r3, Ht2[t3] = r3, Ut2[r3] = e3, Tt2.publish("addFormObject", e3), Wt2.pop().restore();
    }
  };
  for (var Er in y2.beginFormObject = function(t3, e3, r3, n2, i3) {
    return Br(t3, e3, r3, n2, i3), this;
  }, y2.endFormObject = function(t3) {
    return Mr(t3), this;
  }, y2.doFormObject = function(t3, e3) {
    var r3 = Ut2[Ht2[t3]];
    return lt2("q"), lt2(e3.toString() + " cm"), lt2("/" + r3.id + " Do"), lt2("Q"), this;
  }, y2.getFormObject = function(t3) {
    var e3 = Ut2[Ht2[t3]];
    return { x: e3.x, y: e3.y, width: e3.width, height: e3.height, matrix: e3.matrix };
  }, y2.save = function(t3, e3) {
    return t3 = t3 || "generated.pdf", (e3 = e3 || {}).returnPromise = e3.returnPromise || false, e3.returnPromise === false ? (l$1(We(He()), t3), typeof l$1.unload == "function" && n$1.setTimeout && setTimeout(l$1.unload, 911), this) : new Promise(function(e4, r3) {
      try {
        var i3 = l$1(We(He()), t3);
        typeof l$1.unload == "function" && n$1.setTimeout && setTimeout(l$1.unload, 911), e4(i3);
      } catch (t4) {
        r3(t4.message);
      }
    });
  }, E$1.API)
    E$1.API.hasOwnProperty(Er) && (Er === "events" && E$1.API.events.length ? function(t3, e3) {
      var r3, n2, i3;
      for (i3 = e3.length - 1; i3 !== -1; i3--)
        r3 = e3[i3][0], n2 = e3[i3][1], t3.subscribe.apply(t3, [r3].concat(typeof n2 == "function" ? [n2] : n2));
    }(Tt2, E$1.API.events) : y2[Er] = E$1.API[Er]);
  var qr = y2.getPageWidth = function(t3) {
    return (Rt2[t3 = t3 || $2].mediaBox.topRightX - Rt2[t3].mediaBox.bottomLeftX) / _t2;
  }, Dr = y2.setPageWidth = function(t3, e3) {
    Rt2[t3].mediaBox.topRightX = e3 * _t2 + Rt2[t3].mediaBox.bottomLeftX;
  }, Rr = y2.getPageHeight = function(t3) {
    return (Rt2[t3 = t3 || $2].mediaBox.topRightY - Rt2[t3].mediaBox.bottomLeftY) / _t2;
  }, Tr = y2.setPageHeight = function(t3, e3) {
    Rt2[t3].mediaBox.topRightY = e3 * _t2 + Rt2[t3].mediaBox.bottomLeftY;
  };
  return y2.internal = { pdfEscape: Ce, getStyle: tr, getFont: hr, getFontSize: vt2, getCharSpace: Pr, getTextColor: Sr, getLineHeight: gr, getLineHeightFactor: vr, getLineWidth: dr, write: ft2, getHorizontalCoordinate: br, getVerticalCoordinate: yr, getCoordinateString: wr, getVerticalCoordinateString: Nr, collections: {}, newObject: Xt2, newAdditionalObject: $t2, newObjectDeferred: Kt2, newObjectDeferredBegin: Zt2, getFilters: ne2, putStream: ie2, events: Tt2, scaleFactor: _t2, pageSize: { getWidth: function() {
    return qr($2);
  }, setWidth: function(t3) {
    Dr($2, t3);
  }, getHeight: function() {
    return Rr($2);
  }, setHeight: function(t3) {
    Tr($2, t3);
  } }, encryptionOptions: m2, encryption: Ye, getEncryptor: Je, output: Ve, getNumberOfPages: Ee, pages: ot2, out: lt2, f2: R2, f3: T2, getPageInfo: Xe, getPageInfoByObjId: Ke, getCurrentPageInfo: Ze, getPDFVersion: N2, Point: Cr, Rectangle: jr, Matrix: Vt2, hasHotfix: Ge }, Object.defineProperty(y2.internal.pageSize, "width", { get: function() {
    return qr($2);
  }, set: function(t3) {
    Dr($2, t3);
  }, enumerable: true, configurable: true }), Object.defineProperty(y2.internal.pageSize, "height", { get: function() {
    return Rr($2);
  }, set: function(t3) {
    Tr($2, t3);
  }, enumerable: true, configurable: true }), ke.call(y2, pt2), St = "F1", Oe(s2, i2), Tt2.publish("initialized"), y2;
}
I.prototype.lsbFirstWord = function(t3) {
  return String.fromCharCode(t3 >> 0 & 255, t3 >> 8 & 255, t3 >> 16 & 255, t3 >> 24 & 255);
}, I.prototype.toHexString = function(t3) {
  return t3.split("").map(function(t4) {
    return ("0" + (255 & t4.charCodeAt(0)).toString(16)).slice(-2);
  }).join("");
}, I.prototype.hexToBytes = function(t3) {
  for (var e2 = [], r2 = 0; r2 < t3.length; r2 += 2)
    e2.push(String.fromCharCode(parseInt(t3.substr(r2, 2), 16)));
  return e2.join("");
}, I.prototype.processOwnerPassword = function(t3, e2) {
  return P(x(e2).substr(0, 5), t3);
}, I.prototype.encryptor = function(t3, e2) {
  var r2 = x(this.encryptionKey + String.fromCharCode(255 & t3, t3 >> 8 & 255, t3 >> 16 & 255, 255 & e2, e2 >> 8 & 255)).substr(0, 10);
  return function(t4) {
    return P(r2, t4);
  };
}, j.prototype.equals = function(e2) {
  var r2, n2 = "id,objectNumber,equals";
  if (!e2 || _typeof$2(e2) !== _typeof$2(this))
    return false;
  var i2 = 0;
  for (r2 in this)
    if (!(n2.indexOf(r2) >= 0)) {
      if (this.hasOwnProperty(r2) && !e2.hasOwnProperty(r2))
        return false;
      if (this[r2] !== e2[r2])
        return false;
      i2++;
    }
  for (r2 in e2)
    e2.hasOwnProperty(r2) && n2.indexOf(r2) < 0 && i2--;
  return i2 === 0;
}, E$1.API = { events: [] }, E$1.version = "2.5.0";
var q = E$1.API;
var D = 1;
var R = function(t3) {
  return t3.replace(/\\/g, "\\\\").replace(/\(/g, "\\(").replace(/\)/g, "\\)");
};
var T$2 = function(t3) {
  return t3.replace(/\\\\/g, "\\").replace(/\\\(/g, "(").replace(/\\\)/g, ")");
};
var z$1 = function(t3) {
  return t3.toFixed(2);
};
var U$1 = function(t3) {
  return t3.toFixed(5);
};
q.__acroform__ = {};
var H = function(t3, e2) {
  t3.prototype = Object.create(e2.prototype), t3.prototype.constructor = t3;
};
var W = function(t3) {
  return t3 * D;
};
var V$1 = function(t3) {
  var e2 = new ut(), r2 = At.internal.getHeight(t3) || 0, n2 = At.internal.getWidth(t3) || 0;
  return e2.BBox = [0, 0, Number(z$1(n2)), Number(z$1(r2))], e2;
};
var G = q.__acroform__.setBit = function(t3, e2) {
  if (t3 = t3 || 0, e2 = e2 || 0, isNaN(t3) || isNaN(e2))
    throw new Error("Invalid arguments passed to jsPDF.API.__acroform__.setBit");
  return t3 |= 1 << e2;
};
var Y = q.__acroform__.clearBit = function(t3, e2) {
  if (t3 = t3 || 0, e2 = e2 || 0, isNaN(t3) || isNaN(e2))
    throw new Error("Invalid arguments passed to jsPDF.API.__acroform__.clearBit");
  return t3 &= ~(1 << e2);
};
var J = q.__acroform__.getBit = function(t3, e2) {
  if (isNaN(t3) || isNaN(e2))
    throw new Error("Invalid arguments passed to jsPDF.API.__acroform__.getBit");
  return (t3 & 1 << e2) == 0 ? 0 : 1;
};
var X = q.__acroform__.getBitForPdf = function(t3, e2) {
  if (isNaN(t3) || isNaN(e2))
    throw new Error("Invalid arguments passed to jsPDF.API.__acroform__.getBitForPdf");
  return J(t3, e2 - 1);
};
var K = q.__acroform__.setBitForPdf = function(t3, e2) {
  if (isNaN(t3) || isNaN(e2))
    throw new Error("Invalid arguments passed to jsPDF.API.__acroform__.setBitForPdf");
  return G(t3, e2 - 1);
};
var Z$2 = q.__acroform__.clearBitForPdf = function(t3, e2) {
  if (isNaN(t3) || isNaN(e2))
    throw new Error("Invalid arguments passed to jsPDF.API.__acroform__.clearBitForPdf");
  return Y(t3, e2 - 1);
};
var $$a = q.__acroform__.calculateCoordinates = function(t3, e2) {
  var r2 = e2.internal.getHorizontalCoordinate, n2 = e2.internal.getVerticalCoordinate, i2 = t3[0], a2 = t3[1], o2 = t3[2], s2 = t3[3], c2 = {};
  return c2.lowerLeft_X = r2(i2) || 0, c2.lowerLeft_Y = n2(a2 + s2) || 0, c2.upperRight_X = r2(i2 + o2) || 0, c2.upperRight_Y = n2(a2) || 0, [Number(z$1(c2.lowerLeft_X)), Number(z$1(c2.lowerLeft_Y)), Number(z$1(c2.upperRight_X)), Number(z$1(c2.upperRight_Y))];
};
var Q = function(t3) {
  if (t3.appearanceStreamContent)
    return t3.appearanceStreamContent;
  if (t3.V || t3.DV) {
    var e2 = [], r2 = t3._V || t3.DV, n2 = tt(t3, r2), i2 = t3.scope.internal.getFont(t3.fontName, t3.fontStyle).id;
    e2.push("/Tx BMC"), e2.push("q"), e2.push("BT"), e2.push(t3.scope.__private__.encodeColorString(t3.color)), e2.push("/" + i2 + " " + z$1(n2.fontSize) + " Tf"), e2.push("1 0 0 1 0 0 Tm"), e2.push(n2.text), e2.push("ET"), e2.push("Q"), e2.push("EMC");
    var a2 = V$1(t3);
    return a2.scope = t3.scope, a2.stream = e2.join("\n"), a2;
  }
};
var tt = function(t3, e2) {
  var r2 = t3.fontSize === 0 ? t3.maxFontSize : t3.fontSize, n2 = { text: "", fontSize: "" }, i2 = (e2 = (e2 = e2.substr(0, 1) == "(" ? e2.substr(1) : e2).substr(e2.length - 1) == ")" ? e2.substr(0, e2.length - 1) : e2).split(" ");
  i2 = t3.multiline ? i2.map(function(t4) {
    return t4.split("\n");
  }) : i2.map(function(t4) {
    return [t4];
  });
  var a2 = r2, o2 = At.internal.getHeight(t3) || 0;
  o2 = o2 < 0 ? -o2 : o2;
  var s2 = At.internal.getWidth(t3) || 0;
  s2 = s2 < 0 ? -s2 : s2;
  var c2 = function(e3, r3, n3) {
    if (e3 + 1 < i2.length) {
      var a3 = r3 + " " + i2[e3 + 1][0];
      return et(a3, t3, n3).width <= s2 - 4;
    }
    return false;
  };
  a2++;
  t:
    for (; a2 > 0; ) {
      e2 = "", a2--;
      var u2, h2, l2 = et("3", t3, a2).height, f2 = t3.multiline ? o2 - a2 : (o2 - l2) / 2, d2 = f2 += 2, p5 = 0, g2 = 0, m2 = 0;
      if (a2 <= 0) {
        e2 = "(...) Tj\n", e2 += "% Width of Text: " + et(e2, t3, a2 = 12).width + ", FieldWidth:" + s2 + "\n";
        break;
      }
      for (var v2 = "", b2 = 0, y2 = 0; y2 < i2.length; y2++)
        if (i2.hasOwnProperty(y2)) {
          var w2 = false;
          if (i2[y2].length !== 1 && m2 !== i2[y2].length - 1) {
            if ((l2 + 2) * (b2 + 2) + 2 > o2)
              continue t;
            v2 += i2[y2][m2], w2 = true, g2 = y2, y2--;
          } else {
            v2 = (v2 += i2[y2][m2] + " ").substr(v2.length - 1) == " " ? v2.substr(0, v2.length - 1) : v2;
            var N2 = parseInt(y2), L2 = c2(N2, v2, a2), A2 = y2 >= i2.length - 1;
            if (L2 && !A2) {
              v2 += " ", m2 = 0;
              continue;
            }
            if (L2 || A2) {
              if (A2)
                g2 = N2;
              else if (t3.multiline && (l2 + 2) * (b2 + 2) + 2 > o2)
                continue t;
            } else {
              if (!t3.multiline)
                continue t;
              if ((l2 + 2) * (b2 + 2) + 2 > o2)
                continue t;
              g2 = N2;
            }
          }
          for (var x2 = "", S2 = p5; S2 <= g2; S2++) {
            var _2 = i2[S2];
            if (t3.multiline) {
              if (S2 === g2) {
                x2 += _2[m2] + " ", m2 = (m2 + 1) % _2.length;
                continue;
              }
              if (S2 === p5) {
                x2 += _2[_2.length - 1] + " ";
                continue;
              }
            }
            x2 += _2[0] + " ";
          }
          switch (x2 = x2.substr(x2.length - 1) == " " ? x2.substr(0, x2.length - 1) : x2, h2 = et(x2, t3, a2).width, t3.textAlign) {
            case "right":
              u2 = s2 - h2 - 2;
              break;
            case "center":
              u2 = (s2 - h2) / 2;
              break;
            case "left":
            default:
              u2 = 2;
          }
          e2 += z$1(u2) + " " + z$1(d2) + " Td\n", e2 += "(" + R(x2) + ") Tj\n", e2 += -z$1(u2) + " 0 Td\n", d2 = -(a2 + 2), h2 = 0, p5 = w2 ? g2 : g2 + 1, b2++, v2 = "";
        }
      break;
    }
  return n2.text = e2, n2.fontSize = a2, n2;
};
var et = function(t3, e2, r2) {
  var n2 = e2.scope.internal.getFont(e2.fontName, e2.fontStyle), i2 = e2.scope.getStringUnitWidth(t3, { font: n2, fontSize: parseFloat(r2), charSpace: 0 }) * parseFloat(r2);
  return { height: e2.scope.getStringUnitWidth("3", { font: n2, fontSize: parseFloat(r2), charSpace: 0 }) * parseFloat(r2) * 1.5, width: i2 };
};
var rt = { fields: [], xForms: [], acroFormDictionaryRoot: null, printedOut: false, internal: null, isInitialized: false };
var nt = function(t3, e2) {
  var r2 = { type: "reference", object: t3 };
  e2.internal.getPageInfo(t3.page).pageContext.annotations.find(function(t4) {
    return t4.type === r2.type && t4.object === r2.object;
  }) === void 0 && e2.internal.getPageInfo(t3.page).pageContext.annotations.push(r2);
};
var it = function(e2, r2) {
  for (var n2 in e2)
    if (e2.hasOwnProperty(n2)) {
      var i2 = n2, a2 = e2[n2];
      r2.internal.newObjectDeferredBegin(a2.objId, true), _typeof$2(a2) === "object" && typeof a2.putStream == "function" && a2.putStream(), delete e2[i2];
    }
};
var at = function(e2, r2) {
  if (r2.scope = e2, e2.internal !== void 0 && (e2.internal.acroformPlugin === void 0 || e2.internal.acroformPlugin.isInitialized === false)) {
    if (lt.FieldNum = 0, e2.internal.acroformPlugin = JSON.parse(JSON.stringify(rt)), e2.internal.acroformPlugin.acroFormDictionaryRoot)
      throw new Error("Exception while creating AcroformDictionary");
    D = e2.internal.scaleFactor, e2.internal.acroformPlugin.acroFormDictionaryRoot = new ht(), e2.internal.acroformPlugin.acroFormDictionaryRoot.scope = e2, e2.internal.acroformPlugin.acroFormDictionaryRoot._eventID = e2.internal.events.subscribe("postPutResources", function() {
      !function(t3) {
        t3.internal.events.unsubscribe(t3.internal.acroformPlugin.acroFormDictionaryRoot._eventID), delete t3.internal.acroformPlugin.acroFormDictionaryRoot._eventID, t3.internal.acroformPlugin.printedOut = true;
      }(e2);
    }), e2.internal.events.subscribe("buildDocument", function() {
      !function(t3) {
        t3.internal.acroformPlugin.acroFormDictionaryRoot.objId = void 0;
        var e3 = t3.internal.acroformPlugin.acroFormDictionaryRoot.Fields;
        for (var r3 in e3)
          if (e3.hasOwnProperty(r3)) {
            var n2 = e3[r3];
            n2.objId = void 0, n2.hasAnnotation && nt(n2, t3);
          }
      }(e2);
    }), e2.internal.events.subscribe("putCatalog", function() {
      !function(t3) {
        if (t3.internal.acroformPlugin.acroFormDictionaryRoot === void 0)
          throw new Error("putCatalogCallback: Root missing.");
        t3.internal.write("/AcroForm " + t3.internal.acroformPlugin.acroFormDictionaryRoot.objId + " 0 R");
      }(e2);
    }), e2.internal.events.subscribe("postPutPages", function(r3) {
      !function(e3, r4) {
        var n2 = !e3;
        for (var i2 in e3 || (r4.internal.newObjectDeferredBegin(r4.internal.acroformPlugin.acroFormDictionaryRoot.objId, true), r4.internal.acroformPlugin.acroFormDictionaryRoot.putStream()), e3 = e3 || r4.internal.acroformPlugin.acroFormDictionaryRoot.Kids)
          if (e3.hasOwnProperty(i2)) {
            var a2 = e3[i2], o2 = [], s2 = a2.Rect;
            if (a2.Rect && (a2.Rect = $$a(a2.Rect, r4)), r4.internal.newObjectDeferredBegin(a2.objId, true), a2.DA = At.createDefaultAppearanceStream(a2), _typeof$2(a2) === "object" && typeof a2.getKeyValueListForStream == "function" && (o2 = a2.getKeyValueListForStream()), a2.Rect = s2, a2.hasAppearanceStream && !a2.appearanceStreamContent) {
              var c2 = Q(a2);
              o2.push({ key: "AP", value: "<</N " + c2 + ">>" }), r4.internal.acroformPlugin.xForms.push(c2);
            }
            if (a2.appearanceStreamContent) {
              var u2 = "";
              for (var h2 in a2.appearanceStreamContent)
                if (a2.appearanceStreamContent.hasOwnProperty(h2)) {
                  var l2 = a2.appearanceStreamContent[h2];
                  if (u2 += "/" + h2 + " ", u2 += "<<", Object.keys(l2).length >= 1 || Array.isArray(l2)) {
                    for (var i2 in l2)
                      if (l2.hasOwnProperty(i2)) {
                        var f2 = l2[i2];
                        typeof f2 == "function" && (f2 = f2.call(r4, a2)), u2 += "/" + i2 + " " + f2 + " ", r4.internal.acroformPlugin.xForms.indexOf(f2) >= 0 || r4.internal.acroformPlugin.xForms.push(f2);
                      }
                  } else
                    typeof (f2 = l2) == "function" && (f2 = f2.call(r4, a2)), u2 += "/" + i2 + " " + f2, r4.internal.acroformPlugin.xForms.indexOf(f2) >= 0 || r4.internal.acroformPlugin.xForms.push(f2);
                  u2 += ">>";
                }
              o2.push({ key: "AP", value: "<<\n" + u2 + ">>" });
            }
            r4.internal.putStream({ additionalKeyValues: o2, objectId: a2.objId }), r4.internal.out("endobj");
          }
        n2 && it(r4.internal.acroformPlugin.xForms, r4);
      }(r3, e2);
    }), e2.internal.acroformPlugin.isInitialized = true;
  }
};
var ot = q.__acroform__.arrayToPdfArray = function(e2, r2, n2) {
  var i2 = function(t3) {
    return t3;
  };
  if (Array.isArray(e2)) {
    for (var a2 = "[", o2 = 0; o2 < e2.length; o2++)
      switch (o2 !== 0 && (a2 += " "), _typeof$2(e2[o2])) {
        case "boolean":
        case "number":
        case "object":
          a2 += e2[o2].toString();
          break;
        case "string":
          e2[o2].substr(0, 1) !== "/" ? (r2 !== void 0 && n2 && (i2 = n2.internal.getEncryptor(r2)), a2 += "(" + R(i2(e2[o2].toString())) + ")") : a2 += e2[o2].toString();
      }
    return a2 += "]";
  }
  throw new Error("Invalid argument passed to jsPDF.__acroform__.arrayToPdfArray");
};
var st = function(t3, e2, r2) {
  var n2 = function(t4) {
    return t4;
  };
  return e2 !== void 0 && r2 && (n2 = r2.internal.getEncryptor(e2)), (t3 = t3 || "").toString(), t3 = "(" + R(n2(t3)) + ")";
};
var ct = function() {
  this._objId = void 0, this._scope = void 0, Object.defineProperty(this, "objId", { get: function() {
    if (this._objId === void 0) {
      if (this.scope === void 0)
        return;
      this._objId = this.scope.internal.newObjectDeferred();
    }
    return this._objId;
  }, set: function(t3) {
    this._objId = t3;
  } }), Object.defineProperty(this, "scope", { value: this._scope, writable: true });
};
ct.prototype.toString = function() {
  return this.objId + " 0 R";
}, ct.prototype.putStream = function() {
  var t3 = this.getKeyValueListForStream();
  this.scope.internal.putStream({ data: this.stream, additionalKeyValues: t3, objectId: this.objId }), this.scope.internal.out("endobj");
}, ct.prototype.getKeyValueListForStream = function() {
  var t3 = [], e2 = Object.getOwnPropertyNames(this).filter(function(t4) {
    return t4 != "content" && t4 != "appearanceStreamContent" && t4 != "scope" && t4 != "objId" && t4.substring(0, 1) != "_";
  });
  for (var r2 in e2)
    if (Object.getOwnPropertyDescriptor(this, e2[r2]).configurable === false) {
      var n2 = e2[r2], i2 = this[n2];
      i2 && (Array.isArray(i2) ? t3.push({ key: n2, value: ot(i2, this.objId, this.scope) }) : i2 instanceof ct ? (i2.scope = this.scope, t3.push({ key: n2, value: i2.objId + " 0 R" })) : typeof i2 != "function" && t3.push({ key: n2, value: i2 }));
    }
  return t3;
};
var ut = function() {
  ct.call(this), Object.defineProperty(this, "Type", { value: "/XObject", configurable: false, writable: true }), Object.defineProperty(this, "Subtype", { value: "/Form", configurable: false, writable: true }), Object.defineProperty(this, "FormType", { value: 1, configurable: false, writable: true });
  var t3, e2 = [];
  Object.defineProperty(this, "BBox", { configurable: false, get: function() {
    return e2;
  }, set: function(t4) {
    e2 = t4;
  } }), Object.defineProperty(this, "Resources", { value: "2 0 R", configurable: false, writable: true }), Object.defineProperty(this, "stream", { enumerable: false, configurable: true, set: function(e3) {
    t3 = e3.trim();
  }, get: function() {
    return t3 || null;
  } });
};
H(ut, ct);
var ht = function() {
  ct.call(this);
  var t3, e2 = [];
  Object.defineProperty(this, "Kids", { enumerable: false, configurable: true, get: function() {
    return e2.length > 0 ? e2 : void 0;
  } }), Object.defineProperty(this, "Fields", { enumerable: false, configurable: false, get: function() {
    return e2;
  } }), Object.defineProperty(this, "DA", { enumerable: false, configurable: false, get: function() {
    if (t3) {
      var e3 = function(t4) {
        return t4;
      };
      return this.scope && (e3 = this.scope.internal.getEncryptor(this.objId)), "(" + R(e3(t3)) + ")";
    }
  }, set: function(e3) {
    t3 = e3;
  } });
};
H(ht, ct);
var lt = function t() {
  ct.call(this);
  var e2 = 4;
  Object.defineProperty(this, "F", { enumerable: false, configurable: false, get: function() {
    return e2;
  }, set: function(t3) {
    if (isNaN(t3))
      throw new Error('Invalid value "' + t3 + '" for attribute F supplied.');
    e2 = t3;
  } }), Object.defineProperty(this, "showWhenPrinted", { enumerable: true, configurable: true, get: function() {
    return Boolean(X(e2, 3));
  }, set: function(t3) {
    Boolean(t3) === true ? this.F = K(e2, 3) : this.F = Z$2(e2, 3);
  } });
  var r2 = 0;
  Object.defineProperty(this, "Ff", { enumerable: false, configurable: false, get: function() {
    return r2;
  }, set: function(t3) {
    if (isNaN(t3))
      throw new Error('Invalid value "' + t3 + '" for attribute Ff supplied.');
    r2 = t3;
  } });
  var n2 = [];
  Object.defineProperty(this, "Rect", { enumerable: false, configurable: false, get: function() {
    if (n2.length !== 0)
      return n2;
  }, set: function(t3) {
    n2 = t3 !== void 0 ? t3 : [];
  } }), Object.defineProperty(this, "x", { enumerable: true, configurable: true, get: function() {
    return !n2 || isNaN(n2[0]) ? 0 : n2[0];
  }, set: function(t3) {
    n2[0] = t3;
  } }), Object.defineProperty(this, "y", { enumerable: true, configurable: true, get: function() {
    return !n2 || isNaN(n2[1]) ? 0 : n2[1];
  }, set: function(t3) {
    n2[1] = t3;
  } }), Object.defineProperty(this, "width", { enumerable: true, configurable: true, get: function() {
    return !n2 || isNaN(n2[2]) ? 0 : n2[2];
  }, set: function(t3) {
    n2[2] = t3;
  } }), Object.defineProperty(this, "height", { enumerable: true, configurable: true, get: function() {
    return !n2 || isNaN(n2[3]) ? 0 : n2[3];
  }, set: function(t3) {
    n2[3] = t3;
  } });
  var i2 = "";
  Object.defineProperty(this, "FT", { enumerable: true, configurable: false, get: function() {
    return i2;
  }, set: function(t3) {
    switch (t3) {
      case "/Btn":
      case "/Tx":
      case "/Ch":
      case "/Sig":
        i2 = t3;
        break;
      default:
        throw new Error('Invalid value "' + t3 + '" for attribute FT supplied.');
    }
  } });
  var a2 = null;
  Object.defineProperty(this, "T", { enumerable: true, configurable: false, get: function() {
    if (!a2 || a2.length < 1) {
      if (this instanceof yt)
        return;
      a2 = "FieldObject" + t.FieldNum++;
    }
    var e3 = function(t3) {
      return t3;
    };
    return this.scope && (e3 = this.scope.internal.getEncryptor(this.objId)), "(" + R(e3(a2)) + ")";
  }, set: function(t3) {
    a2 = t3.toString();
  } }), Object.defineProperty(this, "fieldName", { configurable: true, enumerable: true, get: function() {
    return a2;
  }, set: function(t3) {
    a2 = t3;
  } });
  var o2 = "helvetica";
  Object.defineProperty(this, "fontName", { enumerable: true, configurable: true, get: function() {
    return o2;
  }, set: function(t3) {
    o2 = t3;
  } });
  var s2 = "normal";
  Object.defineProperty(this, "fontStyle", { enumerable: true, configurable: true, get: function() {
    return s2;
  }, set: function(t3) {
    s2 = t3;
  } });
  var c2 = 0;
  Object.defineProperty(this, "fontSize", { enumerable: true, configurable: true, get: function() {
    return c2;
  }, set: function(t3) {
    c2 = t3;
  } });
  var u2 = void 0;
  Object.defineProperty(this, "maxFontSize", { enumerable: true, configurable: true, get: function() {
    return u2 === void 0 ? 50 / D : u2;
  }, set: function(t3) {
    u2 = t3;
  } });
  var h2 = "black";
  Object.defineProperty(this, "color", { enumerable: true, configurable: true, get: function() {
    return h2;
  }, set: function(t3) {
    h2 = t3;
  } });
  var l2 = "/F1 0 Tf 0 g";
  Object.defineProperty(this, "DA", { enumerable: true, configurable: false, get: function() {
    if (!(!l2 || this instanceof yt || this instanceof Nt))
      return st(l2, this.objId, this.scope);
  }, set: function(t3) {
    t3 = t3.toString(), l2 = t3;
  } });
  var f2 = null;
  Object.defineProperty(this, "DV", { enumerable: false, configurable: false, get: function() {
    if (f2)
      return this instanceof mt == false ? st(f2, this.objId, this.scope) : f2;
  }, set: function(t3) {
    t3 = t3.toString(), f2 = this instanceof mt == false ? t3.substr(0, 1) === "(" ? T$2(t3.substr(1, t3.length - 2)) : T$2(t3) : t3;
  } }), Object.defineProperty(this, "defaultValue", { enumerable: true, configurable: true, get: function() {
    return this instanceof mt == true ? T$2(f2.substr(1, f2.length - 1)) : f2;
  }, set: function(t3) {
    t3 = t3.toString(), f2 = this instanceof mt == true ? "/" + t3 : t3;
  } });
  var d2 = null;
  Object.defineProperty(this, "_V", { enumerable: false, configurable: false, get: function() {
    if (d2)
      return d2;
  }, set: function(t3) {
    this.V = t3;
  } }), Object.defineProperty(this, "V", { enumerable: false, configurable: false, get: function() {
    if (d2)
      return this instanceof mt == false ? st(d2, this.objId, this.scope) : d2;
  }, set: function(t3) {
    t3 = t3.toString(), d2 = this instanceof mt == false ? t3.substr(0, 1) === "(" ? T$2(t3.substr(1, t3.length - 2)) : T$2(t3) : t3;
  } }), Object.defineProperty(this, "value", { enumerable: true, configurable: true, get: function() {
    return this instanceof mt == true ? T$2(d2.substr(1, d2.length - 1)) : d2;
  }, set: function(t3) {
    t3 = t3.toString(), d2 = this instanceof mt == true ? "/" + t3 : t3;
  } }), Object.defineProperty(this, "hasAnnotation", { enumerable: true, configurable: true, get: function() {
    return this.Rect;
  } }), Object.defineProperty(this, "Type", { enumerable: true, configurable: false, get: function() {
    return this.hasAnnotation ? "/Annot" : null;
  } }), Object.defineProperty(this, "Subtype", { enumerable: true, configurable: false, get: function() {
    return this.hasAnnotation ? "/Widget" : null;
  } });
  var p5, g2 = false;
  Object.defineProperty(this, "hasAppearanceStream", { enumerable: true, configurable: true, get: function() {
    return g2;
  }, set: function(t3) {
    t3 = Boolean(t3), g2 = t3;
  } }), Object.defineProperty(this, "page", { enumerable: true, configurable: true, get: function() {
    if (p5)
      return p5;
  }, set: function(t3) {
    p5 = t3;
  } }), Object.defineProperty(this, "readOnly", { enumerable: true, configurable: true, get: function() {
    return Boolean(X(this.Ff, 1));
  }, set: function(t3) {
    Boolean(t3) === true ? this.Ff = K(this.Ff, 1) : this.Ff = Z$2(this.Ff, 1);
  } }), Object.defineProperty(this, "required", { enumerable: true, configurable: true, get: function() {
    return Boolean(X(this.Ff, 2));
  }, set: function(t3) {
    Boolean(t3) === true ? this.Ff = K(this.Ff, 2) : this.Ff = Z$2(this.Ff, 2);
  } }), Object.defineProperty(this, "noExport", { enumerable: true, configurable: true, get: function() {
    return Boolean(X(this.Ff, 3));
  }, set: function(t3) {
    Boolean(t3) === true ? this.Ff = K(this.Ff, 3) : this.Ff = Z$2(this.Ff, 3);
  } });
  var m2 = null;
  Object.defineProperty(this, "Q", { enumerable: true, configurable: false, get: function() {
    if (m2 !== null)
      return m2;
  }, set: function(t3) {
    if ([0, 1, 2].indexOf(t3) === -1)
      throw new Error('Invalid value "' + t3 + '" for attribute Q supplied.');
    m2 = t3;
  } }), Object.defineProperty(this, "textAlign", { get: function() {
    var t3;
    switch (m2) {
      case 0:
      default:
        t3 = "left";
        break;
      case 1:
        t3 = "center";
        break;
      case 2:
        t3 = "right";
    }
    return t3;
  }, configurable: true, enumerable: true, set: function(t3) {
    switch (t3) {
      case "right":
      case 2:
        m2 = 2;
        break;
      case "center":
      case 1:
        m2 = 1;
        break;
      case "left":
      case 0:
      default:
        m2 = 0;
    }
  } });
};
H(lt, ct);
var ft = function() {
  lt.call(this), this.FT = "/Ch", this.V = "()", this.fontName = "zapfdingbats";
  var t3 = 0;
  Object.defineProperty(this, "TI", { enumerable: true, configurable: false, get: function() {
    return t3;
  }, set: function(e3) {
    t3 = e3;
  } }), Object.defineProperty(this, "topIndex", { enumerable: true, configurable: true, get: function() {
    return t3;
  }, set: function(e3) {
    t3 = e3;
  } });
  var e2 = [];
  Object.defineProperty(this, "Opt", { enumerable: true, configurable: false, get: function() {
    return ot(e2, this.objId, this.scope);
  }, set: function(t4) {
    var r2, n2;
    n2 = [], typeof (r2 = t4) == "string" && (n2 = function(t5, e3, r3) {
      r3 || (r3 = 1);
      for (var n3, i2 = []; n3 = e3.exec(t5); )
        i2.push(n3[r3]);
      return i2;
    }(r2, /\((.*?)\)/g)), e2 = n2;
  } }), this.getOptions = function() {
    return e2;
  }, this.setOptions = function(t4) {
    e2 = t4, this.sort && e2.sort();
  }, this.addOption = function(t4) {
    t4 = (t4 = t4 || "").toString(), e2.push(t4), this.sort && e2.sort();
  }, this.removeOption = function(t4, r2) {
    for (r2 = r2 || false, t4 = (t4 = t4 || "").toString(); e2.indexOf(t4) !== -1 && (e2.splice(e2.indexOf(t4), 1), r2 !== false); )
      ;
  }, Object.defineProperty(this, "combo", { enumerable: true, configurable: true, get: function() {
    return Boolean(X(this.Ff, 18));
  }, set: function(t4) {
    Boolean(t4) === true ? this.Ff = K(this.Ff, 18) : this.Ff = Z$2(this.Ff, 18);
  } }), Object.defineProperty(this, "edit", { enumerable: true, configurable: true, get: function() {
    return Boolean(X(this.Ff, 19));
  }, set: function(t4) {
    this.combo === true && (Boolean(t4) === true ? this.Ff = K(this.Ff, 19) : this.Ff = Z$2(this.Ff, 19));
  } }), Object.defineProperty(this, "sort", { enumerable: true, configurable: true, get: function() {
    return Boolean(X(this.Ff, 20));
  }, set: function(t4) {
    Boolean(t4) === true ? (this.Ff = K(this.Ff, 20), e2.sort()) : this.Ff = Z$2(this.Ff, 20);
  } }), Object.defineProperty(this, "multiSelect", { enumerable: true, configurable: true, get: function() {
    return Boolean(X(this.Ff, 22));
  }, set: function(t4) {
    Boolean(t4) === true ? this.Ff = K(this.Ff, 22) : this.Ff = Z$2(this.Ff, 22);
  } }), Object.defineProperty(this, "doNotSpellCheck", { enumerable: true, configurable: true, get: function() {
    return Boolean(X(this.Ff, 23));
  }, set: function(t4) {
    Boolean(t4) === true ? this.Ff = K(this.Ff, 23) : this.Ff = Z$2(this.Ff, 23);
  } }), Object.defineProperty(this, "commitOnSelChange", { enumerable: true, configurable: true, get: function() {
    return Boolean(X(this.Ff, 27));
  }, set: function(t4) {
    Boolean(t4) === true ? this.Ff = K(this.Ff, 27) : this.Ff = Z$2(this.Ff, 27);
  } }), this.hasAppearanceStream = false;
};
H(ft, lt);
var dt = function() {
  ft.call(this), this.fontName = "helvetica", this.combo = false;
};
H(dt, ft);
var pt = function() {
  dt.call(this), this.combo = true;
};
H(pt, dt);
var gt = function() {
  pt.call(this), this.edit = true;
};
H(gt, pt);
var mt = function() {
  lt.call(this), this.FT = "/Btn", Object.defineProperty(this, "noToggleToOff", { enumerable: true, configurable: true, get: function() {
    return Boolean(X(this.Ff, 15));
  }, set: function(t3) {
    Boolean(t3) === true ? this.Ff = K(this.Ff, 15) : this.Ff = Z$2(this.Ff, 15);
  } }), Object.defineProperty(this, "radio", { enumerable: true, configurable: true, get: function() {
    return Boolean(X(this.Ff, 16));
  }, set: function(t3) {
    Boolean(t3) === true ? this.Ff = K(this.Ff, 16) : this.Ff = Z$2(this.Ff, 16);
  } }), Object.defineProperty(this, "pushButton", { enumerable: true, configurable: true, get: function() {
    return Boolean(X(this.Ff, 17));
  }, set: function(t3) {
    Boolean(t3) === true ? this.Ff = K(this.Ff, 17) : this.Ff = Z$2(this.Ff, 17);
  } }), Object.defineProperty(this, "radioIsUnison", { enumerable: true, configurable: true, get: function() {
    return Boolean(X(this.Ff, 26));
  }, set: function(t3) {
    Boolean(t3) === true ? this.Ff = K(this.Ff, 26) : this.Ff = Z$2(this.Ff, 26);
  } });
  var e2, r2 = {};
  Object.defineProperty(this, "MK", { enumerable: false, configurable: false, get: function() {
    var t3 = function(t4) {
      return t4;
    };
    if (this.scope && (t3 = this.scope.internal.getEncryptor(this.objId)), Object.keys(r2).length !== 0) {
      var e3, n2 = [];
      for (e3 in n2.push("<<"), r2)
        n2.push("/" + e3 + " (" + R(t3(r2[e3])) + ")");
      return n2.push(">>"), n2.join("\n");
    }
  }, set: function(e3) {
    _typeof$2(e3) === "object" && (r2 = e3);
  } }), Object.defineProperty(this, "caption", { enumerable: true, configurable: true, get: function() {
    return r2.CA || "";
  }, set: function(t3) {
    typeof t3 == "string" && (r2.CA = t3);
  } }), Object.defineProperty(this, "AS", { enumerable: false, configurable: false, get: function() {
    return e2;
  }, set: function(t3) {
    e2 = t3;
  } }), Object.defineProperty(this, "appearanceState", { enumerable: true, configurable: true, get: function() {
    return e2.substr(1, e2.length - 1);
  }, set: function(t3) {
    e2 = "/" + t3;
  } });
};
H(mt, lt);
var vt = function() {
  mt.call(this), this.pushButton = true;
};
H(vt, mt);
var bt = function() {
  mt.call(this), this.radio = true, this.pushButton = false;
  var t3 = [];
  Object.defineProperty(this, "Kids", { enumerable: true, configurable: false, get: function() {
    return t3;
  }, set: function(e2) {
    t3 = e2 !== void 0 ? e2 : [];
  } });
};
H(bt, mt);
var yt = function() {
  var e2, r2;
  lt.call(this), Object.defineProperty(this, "Parent", { enumerable: false, configurable: false, get: function() {
    return e2;
  }, set: function(t3) {
    e2 = t3;
  } }), Object.defineProperty(this, "optionName", { enumerable: false, configurable: true, get: function() {
    return r2;
  }, set: function(t3) {
    r2 = t3;
  } });
  var n2, i2 = {};
  Object.defineProperty(this, "MK", { enumerable: false, configurable: false, get: function() {
    var t3 = function(t4) {
      return t4;
    };
    this.scope && (t3 = this.scope.internal.getEncryptor(this.objId));
    var e3, r3 = [];
    for (e3 in r3.push("<<"), i2)
      r3.push("/" + e3 + " (" + R(t3(i2[e3])) + ")");
    return r3.push(">>"), r3.join("\n");
  }, set: function(e3) {
    _typeof$2(e3) === "object" && (i2 = e3);
  } }), Object.defineProperty(this, "caption", { enumerable: true, configurable: true, get: function() {
    return i2.CA || "";
  }, set: function(t3) {
    typeof t3 == "string" && (i2.CA = t3);
  } }), Object.defineProperty(this, "AS", { enumerable: false, configurable: false, get: function() {
    return n2;
  }, set: function(t3) {
    n2 = t3;
  } }), Object.defineProperty(this, "appearanceState", { enumerable: true, configurable: true, get: function() {
    return n2.substr(1, n2.length - 1);
  }, set: function(t3) {
    n2 = "/" + t3;
  } }), this.caption = "l", this.appearanceState = "Off", this._AppearanceType = At.RadioButton.Circle, this.appearanceStreamContent = this._AppearanceType.createAppearanceStream(this.optionName);
};
H(yt, lt), bt.prototype.setAppearance = function(t3) {
  if (!("createAppearanceStream" in t3) || !("getCA" in t3))
    throw new Error("Couldn't assign Appearance to RadioButton. Appearance was Invalid!");
  for (var e2 in this.Kids)
    if (this.Kids.hasOwnProperty(e2)) {
      var r2 = this.Kids[e2];
      r2.appearanceStreamContent = t3.createAppearanceStream(r2.optionName), r2.caption = t3.getCA();
    }
}, bt.prototype.createOption = function(t3) {
  var e2 = new yt();
  return e2.Parent = this, e2.optionName = t3, this.Kids.push(e2), xt.call(this.scope, e2), e2;
};
var wt = function() {
  mt.call(this), this.fontName = "zapfdingbats", this.caption = "3", this.appearanceState = "On", this.value = "On", this.textAlign = "center", this.appearanceStreamContent = At.CheckBox.createAppearanceStream();
};
H(wt, mt);
var Nt = function() {
  lt.call(this), this.FT = "/Tx", Object.defineProperty(this, "multiline", { enumerable: true, configurable: true, get: function() {
    return Boolean(X(this.Ff, 13));
  }, set: function(t4) {
    Boolean(t4) === true ? this.Ff = K(this.Ff, 13) : this.Ff = Z$2(this.Ff, 13);
  } }), Object.defineProperty(this, "fileSelect", { enumerable: true, configurable: true, get: function() {
    return Boolean(X(this.Ff, 21));
  }, set: function(t4) {
    Boolean(t4) === true ? this.Ff = K(this.Ff, 21) : this.Ff = Z$2(this.Ff, 21);
  } }), Object.defineProperty(this, "doNotSpellCheck", { enumerable: true, configurable: true, get: function() {
    return Boolean(X(this.Ff, 23));
  }, set: function(t4) {
    Boolean(t4) === true ? this.Ff = K(this.Ff, 23) : this.Ff = Z$2(this.Ff, 23);
  } }), Object.defineProperty(this, "doNotScroll", { enumerable: true, configurable: true, get: function() {
    return Boolean(X(this.Ff, 24));
  }, set: function(t4) {
    Boolean(t4) === true ? this.Ff = K(this.Ff, 24) : this.Ff = Z$2(this.Ff, 24);
  } }), Object.defineProperty(this, "comb", { enumerable: true, configurable: true, get: function() {
    return Boolean(X(this.Ff, 25));
  }, set: function(t4) {
    Boolean(t4) === true ? this.Ff = K(this.Ff, 25) : this.Ff = Z$2(this.Ff, 25);
  } }), Object.defineProperty(this, "richText", { enumerable: true, configurable: true, get: function() {
    return Boolean(X(this.Ff, 26));
  }, set: function(t4) {
    Boolean(t4) === true ? this.Ff = K(this.Ff, 26) : this.Ff = Z$2(this.Ff, 26);
  } });
  var t3 = null;
  Object.defineProperty(this, "MaxLen", { enumerable: true, configurable: false, get: function() {
    return t3;
  }, set: function(e2) {
    t3 = e2;
  } }), Object.defineProperty(this, "maxLength", { enumerable: true, configurable: true, get: function() {
    return t3;
  }, set: function(e2) {
    Number.isInteger(e2) && (t3 = e2);
  } }), Object.defineProperty(this, "hasAppearanceStream", { enumerable: true, configurable: true, get: function() {
    return this.V || this.DV;
  } });
};
H(Nt, lt);
var Lt = function() {
  Nt.call(this), Object.defineProperty(this, "password", { enumerable: true, configurable: true, get: function() {
    return Boolean(X(this.Ff, 14));
  }, set: function(t3) {
    Boolean(t3) === true ? this.Ff = K(this.Ff, 14) : this.Ff = Z$2(this.Ff, 14);
  } }), this.password = true;
};
H(Lt, Nt);
var At = { CheckBox: { createAppearanceStream: function() {
  return { N: { On: At.CheckBox.YesNormal }, D: { On: At.CheckBox.YesPushDown, Off: At.CheckBox.OffPushDown } };
}, YesPushDown: function(t3) {
  var e2 = V$1(t3);
  e2.scope = t3.scope;
  var r2 = [], n2 = t3.scope.internal.getFont(t3.fontName, t3.fontStyle).id, i2 = t3.scope.__private__.encodeColorString(t3.color), a2 = tt(t3, t3.caption);
  return r2.push("0.749023 g"), r2.push("0 0 " + z$1(At.internal.getWidth(t3)) + " " + z$1(At.internal.getHeight(t3)) + " re"), r2.push("f"), r2.push("BMC"), r2.push("q"), r2.push("0 0 1 rg"), r2.push("/" + n2 + " " + z$1(a2.fontSize) + " Tf " + i2), r2.push("BT"), r2.push(a2.text), r2.push("ET"), r2.push("Q"), r2.push("EMC"), e2.stream = r2.join("\n"), e2;
}, YesNormal: function(t3) {
  var e2 = V$1(t3);
  e2.scope = t3.scope;
  var r2 = t3.scope.internal.getFont(t3.fontName, t3.fontStyle).id, n2 = t3.scope.__private__.encodeColorString(t3.color), i2 = [], a2 = At.internal.getHeight(t3), o2 = At.internal.getWidth(t3), s2 = tt(t3, t3.caption);
  return i2.push("1 g"), i2.push("0 0 " + z$1(o2) + " " + z$1(a2) + " re"), i2.push("f"), i2.push("q"), i2.push("0 0 1 rg"), i2.push("0 0 " + z$1(o2 - 1) + " " + z$1(a2 - 1) + " re"), i2.push("W"), i2.push("n"), i2.push("0 g"), i2.push("BT"), i2.push("/" + r2 + " " + z$1(s2.fontSize) + " Tf " + n2), i2.push(s2.text), i2.push("ET"), i2.push("Q"), e2.stream = i2.join("\n"), e2;
}, OffPushDown: function(t3) {
  var e2 = V$1(t3);
  e2.scope = t3.scope;
  var r2 = [];
  return r2.push("0.749023 g"), r2.push("0 0 " + z$1(At.internal.getWidth(t3)) + " " + z$1(At.internal.getHeight(t3)) + " re"), r2.push("f"), e2.stream = r2.join("\n"), e2;
} }, RadioButton: { Circle: { createAppearanceStream: function(t3) {
  var e2 = { D: { Off: At.RadioButton.Circle.OffPushDown }, N: {} };
  return e2.N[t3] = At.RadioButton.Circle.YesNormal, e2.D[t3] = At.RadioButton.Circle.YesPushDown, e2;
}, getCA: function() {
  return "l";
}, YesNormal: function(t3) {
  var e2 = V$1(t3);
  e2.scope = t3.scope;
  var r2 = [], n2 = At.internal.getWidth(t3) <= At.internal.getHeight(t3) ? At.internal.getWidth(t3) / 4 : At.internal.getHeight(t3) / 4;
  n2 = Number((0.9 * n2).toFixed(5));
  var i2 = At.internal.Bezier_C, a2 = Number((n2 * i2).toFixed(5));
  return r2.push("q"), r2.push("1 0 0 1 " + U$1(At.internal.getWidth(t3) / 2) + " " + U$1(At.internal.getHeight(t3) / 2) + " cm"), r2.push(n2 + " 0 m"), r2.push(n2 + " " + a2 + " " + a2 + " " + n2 + " 0 " + n2 + " c"), r2.push("-" + a2 + " " + n2 + " -" + n2 + " " + a2 + " -" + n2 + " 0 c"), r2.push("-" + n2 + " -" + a2 + " -" + a2 + " -" + n2 + " 0 -" + n2 + " c"), r2.push(a2 + " -" + n2 + " " + n2 + " -" + a2 + " " + n2 + " 0 c"), r2.push("f"), r2.push("Q"), e2.stream = r2.join("\n"), e2;
}, YesPushDown: function(t3) {
  var e2 = V$1(t3);
  e2.scope = t3.scope;
  var r2 = [], n2 = At.internal.getWidth(t3) <= At.internal.getHeight(t3) ? At.internal.getWidth(t3) / 4 : At.internal.getHeight(t3) / 4;
  n2 = Number((0.9 * n2).toFixed(5));
  var i2 = Number((2 * n2).toFixed(5)), a2 = Number((i2 * At.internal.Bezier_C).toFixed(5)), o2 = Number((n2 * At.internal.Bezier_C).toFixed(5));
  return r2.push("0.749023 g"), r2.push("q"), r2.push("1 0 0 1 " + U$1(At.internal.getWidth(t3) / 2) + " " + U$1(At.internal.getHeight(t3) / 2) + " cm"), r2.push(i2 + " 0 m"), r2.push(i2 + " " + a2 + " " + a2 + " " + i2 + " 0 " + i2 + " c"), r2.push("-" + a2 + " " + i2 + " -" + i2 + " " + a2 + " -" + i2 + " 0 c"), r2.push("-" + i2 + " -" + a2 + " -" + a2 + " -" + i2 + " 0 -" + i2 + " c"), r2.push(a2 + " -" + i2 + " " + i2 + " -" + a2 + " " + i2 + " 0 c"), r2.push("f"), r2.push("Q"), r2.push("0 g"), r2.push("q"), r2.push("1 0 0 1 " + U$1(At.internal.getWidth(t3) / 2) + " " + U$1(At.internal.getHeight(t3) / 2) + " cm"), r2.push(n2 + " 0 m"), r2.push(n2 + " " + o2 + " " + o2 + " " + n2 + " 0 " + n2 + " c"), r2.push("-" + o2 + " " + n2 + " -" + n2 + " " + o2 + " -" + n2 + " 0 c"), r2.push("-" + n2 + " -" + o2 + " -" + o2 + " -" + n2 + " 0 -" + n2 + " c"), r2.push(o2 + " -" + n2 + " " + n2 + " -" + o2 + " " + n2 + " 0 c"), r2.push("f"), r2.push("Q"), e2.stream = r2.join("\n"), e2;
}, OffPushDown: function(t3) {
  var e2 = V$1(t3);
  e2.scope = t3.scope;
  var r2 = [], n2 = At.internal.getWidth(t3) <= At.internal.getHeight(t3) ? At.internal.getWidth(t3) / 4 : At.internal.getHeight(t3) / 4;
  n2 = Number((0.9 * n2).toFixed(5));
  var i2 = Number((2 * n2).toFixed(5)), a2 = Number((i2 * At.internal.Bezier_C).toFixed(5));
  return r2.push("0.749023 g"), r2.push("q"), r2.push("1 0 0 1 " + U$1(At.internal.getWidth(t3) / 2) + " " + U$1(At.internal.getHeight(t3) / 2) + " cm"), r2.push(i2 + " 0 m"), r2.push(i2 + " " + a2 + " " + a2 + " " + i2 + " 0 " + i2 + " c"), r2.push("-" + a2 + " " + i2 + " -" + i2 + " " + a2 + " -" + i2 + " 0 c"), r2.push("-" + i2 + " -" + a2 + " -" + a2 + " -" + i2 + " 0 -" + i2 + " c"), r2.push(a2 + " -" + i2 + " " + i2 + " -" + a2 + " " + i2 + " 0 c"), r2.push("f"), r2.push("Q"), e2.stream = r2.join("\n"), e2;
} }, Cross: { createAppearanceStream: function(t3) {
  var e2 = { D: { Off: At.RadioButton.Cross.OffPushDown }, N: {} };
  return e2.N[t3] = At.RadioButton.Cross.YesNormal, e2.D[t3] = At.RadioButton.Cross.YesPushDown, e2;
}, getCA: function() {
  return "8";
}, YesNormal: function(t3) {
  var e2 = V$1(t3);
  e2.scope = t3.scope;
  var r2 = [], n2 = At.internal.calculateCross(t3);
  return r2.push("q"), r2.push("1 1 " + z$1(At.internal.getWidth(t3) - 2) + " " + z$1(At.internal.getHeight(t3) - 2) + " re"), r2.push("W"), r2.push("n"), r2.push(z$1(n2.x1.x) + " " + z$1(n2.x1.y) + " m"), r2.push(z$1(n2.x2.x) + " " + z$1(n2.x2.y) + " l"), r2.push(z$1(n2.x4.x) + " " + z$1(n2.x4.y) + " m"), r2.push(z$1(n2.x3.x) + " " + z$1(n2.x3.y) + " l"), r2.push("s"), r2.push("Q"), e2.stream = r2.join("\n"), e2;
}, YesPushDown: function(t3) {
  var e2 = V$1(t3);
  e2.scope = t3.scope;
  var r2 = At.internal.calculateCross(t3), n2 = [];
  return n2.push("0.749023 g"), n2.push("0 0 " + z$1(At.internal.getWidth(t3)) + " " + z$1(At.internal.getHeight(t3)) + " re"), n2.push("f"), n2.push("q"), n2.push("1 1 " + z$1(At.internal.getWidth(t3) - 2) + " " + z$1(At.internal.getHeight(t3) - 2) + " re"), n2.push("W"), n2.push("n"), n2.push(z$1(r2.x1.x) + " " + z$1(r2.x1.y) + " m"), n2.push(z$1(r2.x2.x) + " " + z$1(r2.x2.y) + " l"), n2.push(z$1(r2.x4.x) + " " + z$1(r2.x4.y) + " m"), n2.push(z$1(r2.x3.x) + " " + z$1(r2.x3.y) + " l"), n2.push("s"), n2.push("Q"), e2.stream = n2.join("\n"), e2;
}, OffPushDown: function(t3) {
  var e2 = V$1(t3);
  e2.scope = t3.scope;
  var r2 = [];
  return r2.push("0.749023 g"), r2.push("0 0 " + z$1(At.internal.getWidth(t3)) + " " + z$1(At.internal.getHeight(t3)) + " re"), r2.push("f"), e2.stream = r2.join("\n"), e2;
} } }, createDefaultAppearanceStream: function(t3) {
  var e2 = t3.scope.internal.getFont(t3.fontName, t3.fontStyle).id, r2 = t3.scope.__private__.encodeColorString(t3.color);
  return "/" + e2 + " " + t3.fontSize + " Tf " + r2;
} };
At.internal = { Bezier_C: 0.551915024494, calculateCross: function(t3) {
  var e2 = At.internal.getWidth(t3), r2 = At.internal.getHeight(t3), n2 = Math.min(e2, r2);
  return { x1: { x: (e2 - n2) / 2, y: (r2 - n2) / 2 + n2 }, x2: { x: (e2 - n2) / 2 + n2, y: (r2 - n2) / 2 }, x3: { x: (e2 - n2) / 2, y: (r2 - n2) / 2 }, x4: { x: (e2 - n2) / 2 + n2, y: (r2 - n2) / 2 + n2 } };
} }, At.internal.getWidth = function(e2) {
  var r2 = 0;
  return _typeof$2(e2) === "object" && (r2 = W(e2.Rect[2])), r2;
}, At.internal.getHeight = function(e2) {
  var r2 = 0;
  return _typeof$2(e2) === "object" && (r2 = W(e2.Rect[3])), r2;
};
var xt = q.addField = function(t3) {
  if (at(this, t3), !(t3 instanceof lt))
    throw new Error("Invalid argument passed to jsPDF.addField.");
  var e2;
  return (e2 = t3).scope.internal.acroformPlugin.printedOut && (e2.scope.internal.acroformPlugin.printedOut = false, e2.scope.internal.acroformPlugin.acroFormDictionaryRoot = null), e2.scope.internal.acroformPlugin.acroFormDictionaryRoot.Fields.push(e2), t3.page = t3.scope.internal.getCurrentPageInfo().pageNumber, this;
};
q.AcroFormChoiceField = ft, q.AcroFormListBox = dt, q.AcroFormComboBox = pt, q.AcroFormEditBox = gt, q.AcroFormButton = mt, q.AcroFormPushButton = vt, q.AcroFormRadioButton = bt, q.AcroFormCheckBox = wt, q.AcroFormTextField = Nt, q.AcroFormPasswordField = Lt, q.AcroFormAppearance = At, q.AcroForm = { ChoiceField: ft, ListBox: dt, ComboBox: pt, EditBox: gt, Button: mt, PushButton: vt, RadioButton: bt, CheckBox: wt, TextField: Nt, PasswordField: Lt, Appearance: At }, E$1.AcroForm = { ChoiceField: ft, ListBox: dt, ComboBox: pt, EditBox: gt, Button: mt, PushButton: vt, RadioButton: bt, CheckBox: wt, TextField: Nt, PasswordField: Lt, Appearance: At };
E$1.AcroForm;
function _t(t3) {
  return t3.reduce(function(t4, e2, r2) {
    return t4[e2] = r2, t4;
  }, {});
}
!function(e2) {
  e2.__addimage__ = {};
  var r2 = "UNKNOWN", n2 = { PNG: [[137, 80, 78, 71]], TIFF: [[77, 77, 0, 42], [73, 73, 42, 0]], JPEG: [[255, 216, 255, 224, void 0, void 0, 74, 70, 73, 70, 0], [255, 216, 255, 225, void 0, void 0, 69, 120, 105, 102, 0, 0], [255, 216, 255, 219], [255, 216, 255, 238]], JPEG2000: [[0, 0, 0, 12, 106, 80, 32, 32]], GIF87a: [[71, 73, 70, 56, 55, 97]], GIF89a: [[71, 73, 70, 56, 57, 97]], WEBP: [[82, 73, 70, 70, void 0, void 0, void 0, void 0, 87, 69, 66, 80]], BMP: [[66, 77], [66, 65], [67, 73], [67, 80], [73, 67], [80, 84]] }, i2 = e2.__addimage__.getImageFileTypeByImageData = function(t3, e3) {
    var i3, a3, o3, s3, c3, u2 = r2;
    if ((e3 = e3 || r2) === "RGBA" || t3.data !== void 0 && t3.data instanceof Uint8ClampedArray && "height" in t3 && "width" in t3)
      return "RGBA";
    if (x2(t3))
      for (c3 in n2)
        for (o3 = n2[c3], i3 = 0; i3 < o3.length; i3 += 1) {
          for (s3 = true, a3 = 0; a3 < o3[i3].length; a3 += 1)
            if (o3[i3][a3] !== void 0 && o3[i3][a3] !== t3[a3]) {
              s3 = false;
              break;
            }
          if (s3 === true) {
            u2 = c3;
            break;
          }
        }
    else
      for (c3 in n2)
        for (o3 = n2[c3], i3 = 0; i3 < o3.length; i3 += 1) {
          for (s3 = true, a3 = 0; a3 < o3[i3].length; a3 += 1)
            if (o3[i3][a3] !== void 0 && o3[i3][a3] !== t3.charCodeAt(a3)) {
              s3 = false;
              break;
            }
          if (s3 === true) {
            u2 = c3;
            break;
          }
        }
    return u2 === r2 && e3 !== r2 && (u2 = e3), u2;
  }, a2 = function t3(e3) {
    for (var r3 = this.internal.write, n3 = this.internal.putStream, i3 = (0, this.internal.getFilters)(); i3.indexOf("FlateEncode") !== -1; )
      i3.splice(i3.indexOf("FlateEncode"), 1);
    e3.objectId = this.internal.newObject();
    var a3 = [];
    if (a3.push({ key: "Type", value: "/XObject" }), a3.push({ key: "Subtype", value: "/Image" }), a3.push({ key: "Width", value: e3.width }), a3.push({ key: "Height", value: e3.height }), e3.colorSpace === b2.INDEXED ? a3.push({ key: "ColorSpace", value: "[/Indexed /DeviceRGB " + (e3.palette.length / 3 - 1) + " " + ("sMask" in e3 && e3.sMask !== void 0 ? e3.objectId + 2 : e3.objectId + 1) + " 0 R]" }) : (a3.push({ key: "ColorSpace", value: "/" + e3.colorSpace }), e3.colorSpace === b2.DEVICE_CMYK && a3.push({ key: "Decode", value: "[1 0 1 0 1 0 1 0]" })), a3.push({ key: "BitsPerComponent", value: e3.bitsPerComponent }), "decodeParameters" in e3 && e3.decodeParameters !== void 0 && a3.push({ key: "DecodeParms", value: "<<" + e3.decodeParameters + ">>" }), "transparency" in e3 && Array.isArray(e3.transparency)) {
      for (var o3 = "", s3 = 0, c3 = e3.transparency.length; s3 < c3; s3++)
        o3 += e3.transparency[s3] + " " + e3.transparency[s3] + " ";
      a3.push({ key: "Mask", value: "[" + o3 + "]" });
    }
    e3.sMask !== void 0 && a3.push({ key: "SMask", value: e3.objectId + 1 + " 0 R" });
    var u2 = e3.filter !== void 0 ? ["/" + e3.filter] : void 0;
    if (n3({ data: e3.data, additionalKeyValues: a3, alreadyAppliedFilters: u2, objectId: e3.objectId }), r3("endobj"), "sMask" in e3 && e3.sMask !== void 0) {
      var h3 = "/Predictor " + e3.predictor + " /Colors 1 /BitsPerComponent " + e3.bitsPerComponent + " /Columns " + e3.width, l3 = { width: e3.width, height: e3.height, colorSpace: "DeviceGray", bitsPerComponent: e3.bitsPerComponent, decodeParameters: h3, data: e3.sMask };
      "filter" in e3 && (l3.filter = e3.filter), t3.call(this, l3);
    }
    if (e3.colorSpace === b2.INDEXED) {
      var f3 = this.internal.newObject();
      n3({ data: _2(new Uint8Array(e3.palette)), objectId: f3 }), r3("endobj");
    }
  }, o2 = function() {
    var t3 = this.internal.collections.addImage_images;
    for (var e3 in t3)
      a2.call(this, t3[e3]);
  }, s2 = function() {
    var t3, e3 = this.internal.collections.addImage_images, r3 = this.internal.write;
    for (var n3 in e3)
      r3("/I" + (t3 = e3[n3]).index, t3.objectId, "0", "R");
  }, c2 = function() {
    this.internal.collections.addImage_images || (this.internal.collections.addImage_images = {}, this.internal.events.subscribe("putResources", o2), this.internal.events.subscribe("putXobjectDict", s2));
  }, h2 = function() {
    var t3 = this.internal.collections.addImage_images;
    return c2.call(this), t3;
  }, l2 = function() {
    return Object.keys(this.internal.collections.addImage_images).length;
  }, f2 = function(t3) {
    return typeof e2["process" + t3.toUpperCase()] == "function";
  }, d2 = function(e3) {
    return _typeof$2(e3) === "object" && e3.nodeType === 1;
  }, p5 = function(t3, r3) {
    if (t3.nodeName === "IMG" && t3.hasAttribute("src")) {
      var n3 = "" + t3.getAttribute("src");
      if (n3.indexOf("data:image/") === 0)
        return u$2(unescape(n3).split("base64,").pop());
      var i3 = e2.loadFile(n3, true);
      if (i3 !== void 0)
        return i3;
    }
    if (t3.nodeName === "CANVAS") {
      if (t3.width === 0 || t3.height === 0)
        throw new Error("Given canvas must have data. Canvas width: " + t3.width + ", height: " + t3.height);
      var a3;
      switch (r3) {
        case "PNG":
          a3 = "image/png";
          break;
        case "WEBP":
          a3 = "image/webp";
          break;
        case "JPEG":
        case "JPG":
        default:
          a3 = "image/jpeg";
      }
      return u$2(t3.toDataURL(a3, 1).split("base64,").pop());
    }
  }, g2 = function(t3) {
    var e3 = this.internal.collections.addImage_images;
    if (e3) {
      for (var r3 in e3)
        if (t3 === e3[r3].alias)
          return e3[r3];
    }
  }, m2 = function(t3, e3, r3) {
    return t3 || e3 || (t3 = -96, e3 = -96), t3 < 0 && (t3 = -1 * r3.width * 72 / t3 / this.internal.scaleFactor), e3 < 0 && (e3 = -1 * r3.height * 72 / e3 / this.internal.scaleFactor), t3 === 0 && (t3 = e3 * r3.width / r3.height), e3 === 0 && (e3 = t3 * r3.height / r3.width), [t3, e3];
  }, v2 = function(t3, e3, r3, n3, i3, a3) {
    var o3 = m2.call(this, r3, n3, i3), s3 = this.internal.getCoordinateString, c3 = this.internal.getVerticalCoordinateString, u2 = h2.call(this);
    if (r3 = o3[0], n3 = o3[1], u2[i3.index] = i3, a3) {
      a3 *= Math.PI / 180;
      var l3 = Math.cos(a3), f3 = Math.sin(a3), d3 = function(t4) {
        return t4.toFixed(4);
      }, p6 = [d3(l3), d3(f3), d3(-1 * f3), d3(l3), 0, 0, "cm"];
    }
    this.internal.write("q"), a3 ? (this.internal.write([1, "0", "0", 1, s3(t3), c3(e3 + n3), "cm"].join(" ")), this.internal.write(p6.join(" ")), this.internal.write([s3(r3), "0", "0", s3(n3), "0", "0", "cm"].join(" "))) : this.internal.write([s3(r3), "0", "0", s3(n3), s3(t3), c3(e3 + n3), "cm"].join(" ")), this.isAdvancedAPI() && this.internal.write([1, 0, 0, -1, 0, 0, "cm"].join(" ")), this.internal.write("/I" + i3.index + " Do"), this.internal.write("Q");
  }, b2 = e2.color_spaces = { DEVICE_RGB: "DeviceRGB", DEVICE_GRAY: "DeviceGray", DEVICE_CMYK: "DeviceCMYK", CAL_GREY: "CalGray", CAL_RGB: "CalRGB", LAB: "Lab", ICC_BASED: "ICCBased", INDEXED: "Indexed", PATTERN: "Pattern", SEPARATION: "Separation", DEVICE_N: "DeviceN" };
  e2.decode = { DCT_DECODE: "DCTDecode", FLATE_DECODE: "FlateDecode", LZW_DECODE: "LZWDecode", JPX_DECODE: "JPXDecode", JBIG2_DECODE: "JBIG2Decode", ASCII85_DECODE: "ASCII85Decode", ASCII_HEX_DECODE: "ASCIIHexDecode", RUN_LENGTH_DECODE: "RunLengthDecode", CCITT_FAX_DECODE: "CCITTFaxDecode" };
  var y2 = e2.image_compression = { NONE: "NONE", FAST: "FAST", MEDIUM: "MEDIUM", SLOW: "SLOW" }, w2 = e2.__addimage__.sHashCode = function(t3) {
    var e3, r3, n3 = 0;
    if (typeof t3 == "string")
      for (r3 = t3.length, e3 = 0; e3 < r3; e3++)
        n3 = (n3 << 5) - n3 + t3.charCodeAt(e3), n3 |= 0;
    else if (x2(t3))
      for (r3 = t3.byteLength / 2, e3 = 0; e3 < r3; e3++)
        n3 = (n3 << 5) - n3 + t3[e3], n3 |= 0;
    return n3;
  }, N2 = e2.__addimage__.validateStringAsBase64 = function(t3) {
    (t3 = t3 || "").toString().trim();
    var e3 = true;
    return t3.length === 0 && (e3 = false), t3.length % 4 != 0 && (e3 = false), /^[A-Za-z0-9+/]+$/.test(t3.substr(0, t3.length - 2)) === false && (e3 = false), /^[A-Za-z0-9/][A-Za-z0-9+/]|[A-Za-z0-9+/]=|==$/.test(t3.substr(-2)) === false && (e3 = false), e3;
  }, L2 = e2.__addimage__.extractImageFromDataUrl = function(t3) {
    var e3 = (t3 = t3 || "").split("base64,"), r3 = null;
    if (e3.length === 2) {
      var n3 = /^data:(\w*\/\w*);*(charset=(?!charset=)[\w=-]*)*;*$/.exec(e3[0]);
      Array.isArray(n3) && (r3 = { mimeType: n3[1], charset: n3[2], data: e3[1] });
    }
    return r3;
  }, A2 = e2.__addimage__.supportsArrayBuffer = function() {
    return typeof ArrayBuffer != "undefined" && typeof Uint8Array != "undefined";
  };
  e2.__addimage__.isArrayBuffer = function(t3) {
    return A2() && t3 instanceof ArrayBuffer;
  };
  var x2 = e2.__addimage__.isArrayBufferView = function(t3) {
    return A2() && typeof Uint32Array != "undefined" && (t3 instanceof Int8Array || t3 instanceof Uint8Array || typeof Uint8ClampedArray != "undefined" && t3 instanceof Uint8ClampedArray || t3 instanceof Int16Array || t3 instanceof Uint16Array || t3 instanceof Int32Array || t3 instanceof Uint32Array || t3 instanceof Float32Array || t3 instanceof Float64Array);
  }, S2 = e2.__addimage__.binaryStringToUint8Array = function(t3) {
    for (var e3 = t3.length, r3 = new Uint8Array(e3), n3 = 0; n3 < e3; n3++)
      r3[n3] = t3.charCodeAt(n3);
    return r3;
  }, _2 = e2.__addimage__.arrayBufferToBinaryString = function(t3) {
    for (var e3 = "", r3 = x2(t3) ? t3 : new Uint8Array(t3), n3 = 0; n3 < r3.length; n3 += 8192)
      e3 += String.fromCharCode.apply(null, r3.subarray(n3, n3 + 8192));
    return e3;
  };
  e2.addImage = function() {
    var e3, n3, i3, a3, o3, s3, u2, h3, l3;
    if (typeof arguments[1] == "number" ? (n3 = r2, i3 = arguments[1], a3 = arguments[2], o3 = arguments[3], s3 = arguments[4], u2 = arguments[5], h3 = arguments[6], l3 = arguments[7]) : (n3 = arguments[1], i3 = arguments[2], a3 = arguments[3], o3 = arguments[4], s3 = arguments[5], u2 = arguments[6], h3 = arguments[7], l3 = arguments[8]), _typeof$2(e3 = arguments[0]) === "object" && !d2(e3) && "imageData" in e3) {
      var f3 = e3;
      e3 = f3.imageData, n3 = f3.format || n3 || r2, i3 = f3.x || i3 || 0, a3 = f3.y || a3 || 0, o3 = f3.w || f3.width || o3, s3 = f3.h || f3.height || s3, u2 = f3.alias || u2, h3 = f3.compression || h3, l3 = f3.rotation || f3.angle || l3;
    }
    var p6 = this.internal.getFilters();
    if (h3 === void 0 && p6.indexOf("FlateEncode") !== -1 && (h3 = "SLOW"), isNaN(i3) || isNaN(a3))
      throw new Error("Invalid coordinates passed to jsPDF.addImage");
    c2.call(this);
    var g3 = P2.call(this, e3, n3, u2, h3);
    return v2.call(this, i3, a3, o3, s3, g3, l3), this;
  };
  var P2 = function(t3, n3, a3, o3) {
    var s3, c3, u2;
    if (typeof t3 == "string" && i2(t3) === r2) {
      t3 = unescape(t3);
      var h3 = k2(t3, false);
      (h3 !== "" || (h3 = e2.loadFile(t3, true)) !== void 0) && (t3 = h3);
    }
    if (d2(t3) && (t3 = p5(t3, n3)), n3 = i2(t3, n3), !f2(n3))
      throw new Error("addImage does not support files of type '" + n3 + "', please ensure that a plugin for '" + n3 + "' support is added.");
    if (((u2 = a3) == null || u2.length === 0) && (a3 = function(t4) {
      return typeof t4 == "string" || x2(t4) ? w2(t4) : x2(t4.data) ? w2(t4.data) : null;
    }(t3)), (s3 = g2.call(this, a3)) || (A2() && (t3 instanceof Uint8Array || n3 === "RGBA" || (c3 = t3, t3 = S2(t3))), s3 = this["process" + n3.toUpperCase()](t3, l2.call(this), a3, function(t4) {
      return t4 && typeof t4 == "string" && (t4 = t4.toUpperCase()), t4 in e2.image_compression ? t4 : y2.NONE;
    }(o3), c3)), !s3)
      throw new Error("An unknown error occurred whilst processing the image.");
    return s3;
  }, k2 = e2.__addimage__.convertBase64ToBinaryString = function(t3, e3) {
    var r3;
    e3 = typeof e3 != "boolean" || e3;
    var n3, i3 = "";
    if (typeof t3 == "string") {
      n3 = (r3 = L2(t3)) !== null ? r3.data : t3;
      try {
        i3 = u$2(n3);
      } catch (t4) {
        if (e3)
          throw N2(n3) ? new Error("atob-Error in jsPDF.convertBase64ToBinaryString " + t4.message) : new Error("Supplied Data is not a valid base64-String jsPDF.convertBase64ToBinaryString ");
      }
    }
    return i3;
  };
  e2.getImageProperties = function(t3) {
    var n3, a3, o3 = "";
    if (d2(t3) && (t3 = p5(t3)), typeof t3 == "string" && i2(t3) === r2 && ((o3 = k2(t3, false)) === "" && (o3 = e2.loadFile(t3) || ""), t3 = o3), a3 = i2(t3), !f2(a3))
      throw new Error("addImage does not support files of type '" + a3 + "', please ensure that a plugin for '" + a3 + "' support is added.");
    if (!A2() || t3 instanceof Uint8Array || (t3 = S2(t3)), !(n3 = this["process" + a3.toUpperCase()](t3)))
      throw new Error("An unknown error occurred whilst processing the image");
    return n3.fileType = a3, n3;
  };
}(E$1.API), function(t3) {
  var e2 = function(t4) {
    if (t4 !== void 0 && t4 != "")
      return true;
  };
  E$1.API.events.push(["addPage", function(t4) {
    this.internal.getPageInfo(t4.pageNumber).pageContext.annotations = [];
  }]), t3.events.push(["putPage", function(t4) {
    for (var r2, n2, i2, a2 = this.internal.getCoordinateString, o2 = this.internal.getVerticalCoordinateString, s2 = this.internal.getPageInfoByObjId(t4.objId), c2 = t4.pageContext.annotations, u2 = false, h2 = 0; h2 < c2.length && !u2; h2++)
      switch ((r2 = c2[h2]).type) {
        case "link":
          (e2(r2.options.url) || e2(r2.options.pageNumber)) && (u2 = true);
          break;
        case "reference":
        case "text":
        case "freetext":
          u2 = true;
      }
    if (u2 != 0) {
      this.internal.write("/Annots [");
      for (var l2 = 0; l2 < c2.length; l2++) {
        r2 = c2[l2];
        var f2 = this.internal.pdfEscape, d2 = this.internal.getEncryptor(t4.objId);
        switch (r2.type) {
          case "reference":
            this.internal.write(" " + r2.object.objId + " 0 R ");
            break;
          case "text":
            var p5 = this.internal.newAdditionalObject(), g2 = this.internal.newAdditionalObject(), m2 = this.internal.getEncryptor(p5.objId), v2 = r2.title || "Note";
            i2 = "<</Type /Annot /Subtype /Text " + (n2 = "/Rect [" + a2(r2.bounds.x) + " " + o2(r2.bounds.y + r2.bounds.h) + " " + a2(r2.bounds.x + r2.bounds.w) + " " + o2(r2.bounds.y) + "] ") + "/Contents (" + f2(m2(r2.contents)) + ")", i2 += " /Popup " + g2.objId + " 0 R", i2 += " /P " + s2.objId + " 0 R", i2 += " /T (" + f2(m2(v2)) + ") >>", p5.content = i2;
            var b2 = p5.objId + " 0 R";
            i2 = "<</Type /Annot /Subtype /Popup " + (n2 = "/Rect [" + a2(r2.bounds.x + 30) + " " + o2(r2.bounds.y + r2.bounds.h) + " " + a2(r2.bounds.x + r2.bounds.w + 30) + " " + o2(r2.bounds.y) + "] ") + " /Parent " + b2, r2.open && (i2 += " /Open true"), i2 += " >>", g2.content = i2, this.internal.write(p5.objId, "0 R", g2.objId, "0 R");
            break;
          case "freetext":
            n2 = "/Rect [" + a2(r2.bounds.x) + " " + o2(r2.bounds.y) + " " + a2(r2.bounds.x + r2.bounds.w) + " " + o2(r2.bounds.y + r2.bounds.h) + "] ";
            var y2 = r2.color || "#000000";
            i2 = "<</Type /Annot /Subtype /FreeText " + n2 + "/Contents (" + f2(d2(r2.contents)) + ")", i2 += " /DS(font: Helvetica,sans-serif 12.0pt; text-align:left; color:#" + y2 + ")", i2 += " /Border [0 0 0]", i2 += " >>", this.internal.write(i2);
            break;
          case "link":
            if (r2.options.name) {
              var w2 = this.annotations._nameMap[r2.options.name];
              r2.options.pageNumber = w2.page, r2.options.top = w2.y;
            } else
              r2.options.top || (r2.options.top = 0);
            if (n2 = "/Rect [" + r2.finalBounds.x + " " + r2.finalBounds.y + " " + r2.finalBounds.w + " " + r2.finalBounds.h + "] ", i2 = "", r2.options.url)
              i2 = "<</Type /Annot /Subtype /Link " + n2 + "/Border [0 0 0] /A <</S /URI /URI (" + f2(d2(r2.options.url)) + ") >>";
            else if (r2.options.pageNumber) {
              switch (i2 = "<</Type /Annot /Subtype /Link " + n2 + "/Border [0 0 0] /Dest [" + this.internal.getPageInfo(r2.options.pageNumber).objId + " 0 R", r2.options.magFactor = r2.options.magFactor || "XYZ", r2.options.magFactor) {
                case "Fit":
                  i2 += " /Fit]";
                  break;
                case "FitH":
                  i2 += " /FitH " + r2.options.top + "]";
                  break;
                case "FitV":
                  r2.options.left = r2.options.left || 0, i2 += " /FitV " + r2.options.left + "]";
                  break;
                case "XYZ":
                default:
                  var N2 = o2(r2.options.top);
                  r2.options.left = r2.options.left || 0, r2.options.zoom === void 0 && (r2.options.zoom = 0), i2 += " /XYZ " + r2.options.left + " " + N2 + " " + r2.options.zoom + "]";
              }
            }
            i2 != "" && (i2 += " >>", this.internal.write(i2));
        }
      }
      this.internal.write("]");
    }
  }]), t3.createAnnotation = function(t4) {
    var e3 = this.internal.getCurrentPageInfo();
    switch (t4.type) {
      case "link":
        this.link(t4.bounds.x, t4.bounds.y, t4.bounds.w, t4.bounds.h, t4);
        break;
      case "text":
      case "freetext":
        e3.pageContext.annotations.push(t4);
    }
  }, t3.link = function(t4, e3, r2, n2, i2) {
    var a2 = this.internal.getCurrentPageInfo(), o2 = this.internal.getCoordinateString, s2 = this.internal.getVerticalCoordinateString;
    a2.pageContext.annotations.push({ finalBounds: { x: o2(t4), y: s2(e3), w: o2(t4 + r2), h: s2(e3 + n2) }, options: i2, type: "link" });
  }, t3.textWithLink = function(t4, e3, r2, n2) {
    var i2, a2, o2 = this.getTextWidth(t4), s2 = this.internal.getLineHeight() / this.internal.scaleFactor;
    if (n2.maxWidth !== void 0) {
      a2 = n2.maxWidth;
      var c2 = this.splitTextToSize(t4, a2).length;
      i2 = Math.ceil(s2 * c2);
    } else
      a2 = o2, i2 = s2;
    return this.text(t4, e3, r2, n2), r2 += 0.2 * s2, n2.align === "center" && (e3 -= o2 / 2), n2.align === "right" && (e3 -= o2), this.link(e3, r2 - s2, a2, i2, n2), o2;
  }, t3.getTextWidth = function(t4) {
    var e3 = this.internal.getFontSize();
    return this.getStringUnitWidth(t4) * e3 / this.internal.scaleFactor;
  };
}(E$1.API), function(t3) {
  var e2 = { 1569: [65152], 1570: [65153, 65154], 1571: [65155, 65156], 1572: [65157, 65158], 1573: [65159, 65160], 1574: [65161, 65162, 65163, 65164], 1575: [65165, 65166], 1576: [65167, 65168, 65169, 65170], 1577: [65171, 65172], 1578: [65173, 65174, 65175, 65176], 1579: [65177, 65178, 65179, 65180], 1580: [65181, 65182, 65183, 65184], 1581: [65185, 65186, 65187, 65188], 1582: [65189, 65190, 65191, 65192], 1583: [65193, 65194], 1584: [65195, 65196], 1585: [65197, 65198], 1586: [65199, 65200], 1587: [65201, 65202, 65203, 65204], 1588: [65205, 65206, 65207, 65208], 1589: [65209, 65210, 65211, 65212], 1590: [65213, 65214, 65215, 65216], 1591: [65217, 65218, 65219, 65220], 1592: [65221, 65222, 65223, 65224], 1593: [65225, 65226, 65227, 65228], 1594: [65229, 65230, 65231, 65232], 1601: [65233, 65234, 65235, 65236], 1602: [65237, 65238, 65239, 65240], 1603: [65241, 65242, 65243, 65244], 1604: [65245, 65246, 65247, 65248], 1605: [65249, 65250, 65251, 65252], 1606: [65253, 65254, 65255, 65256], 1607: [65257, 65258, 65259, 65260], 1608: [65261, 65262], 1609: [65263, 65264, 64488, 64489], 1610: [65265, 65266, 65267, 65268], 1649: [64336, 64337], 1655: [64477], 1657: [64358, 64359, 64360, 64361], 1658: [64350, 64351, 64352, 64353], 1659: [64338, 64339, 64340, 64341], 1662: [64342, 64343, 64344, 64345], 1663: [64354, 64355, 64356, 64357], 1664: [64346, 64347, 64348, 64349], 1667: [64374, 64375, 64376, 64377], 1668: [64370, 64371, 64372, 64373], 1670: [64378, 64379, 64380, 64381], 1671: [64382, 64383, 64384, 64385], 1672: [64392, 64393], 1676: [64388, 64389], 1677: [64386, 64387], 1678: [64390, 64391], 1681: [64396, 64397], 1688: [64394, 64395], 1700: [64362, 64363, 64364, 64365], 1702: [64366, 64367, 64368, 64369], 1705: [64398, 64399, 64400, 64401], 1709: [64467, 64468, 64469, 64470], 1711: [64402, 64403, 64404, 64405], 1713: [64410, 64411, 64412, 64413], 1715: [64406, 64407, 64408, 64409], 1722: [64414, 64415], 1723: [64416, 64417, 64418, 64419], 1726: [64426, 64427, 64428, 64429], 1728: [64420, 64421], 1729: [64422, 64423, 64424, 64425], 1733: [64480, 64481], 1734: [64473, 64474], 1735: [64471, 64472], 1736: [64475, 64476], 1737: [64482, 64483], 1739: [64478, 64479], 1740: [64508, 64509, 64510, 64511], 1744: [64484, 64485, 64486, 64487], 1746: [64430, 64431], 1747: [64432, 64433] }, r2 = { 65247: { 65154: 65269, 65156: 65271, 65160: 65273, 65166: 65275 }, 65248: { 65154: 65270, 65156: 65272, 65160: 65274, 65166: 65276 }, 65165: { 65247: { 65248: { 65258: 65010 } } }, 1617: { 1612: 64606, 1613: 64607, 1614: 64608, 1615: 64609, 1616: 64610 } }, n2 = { 1612: 64606, 1613: 64607, 1614: 64608, 1615: 64609, 1616: 64610 }, i2 = [1570, 1571, 1573, 1575];
  t3.__arabicParser__ = {};
  var a2 = t3.__arabicParser__.isInArabicSubstitutionA = function(t4) {
    return e2[t4.charCodeAt(0)] !== void 0;
  }, o2 = t3.__arabicParser__.isArabicLetter = function(t4) {
    return typeof t4 == "string" && /^[\u0600-\u06FF\u0750-\u077F\u08A0-\u08FF\uFB50-\uFDFF\uFE70-\uFEFF]+$/.test(t4);
  }, s2 = t3.__arabicParser__.isArabicEndLetter = function(t4) {
    return o2(t4) && a2(t4) && e2[t4.charCodeAt(0)].length <= 2;
  }, c2 = t3.__arabicParser__.isArabicAlfLetter = function(t4) {
    return o2(t4) && i2.indexOf(t4.charCodeAt(0)) >= 0;
  };
  t3.__arabicParser__.arabicLetterHasIsolatedForm = function(t4) {
    return o2(t4) && a2(t4) && e2[t4.charCodeAt(0)].length >= 1;
  };
  var u2 = t3.__arabicParser__.arabicLetterHasFinalForm = function(t4) {
    return o2(t4) && a2(t4) && e2[t4.charCodeAt(0)].length >= 2;
  };
  t3.__arabicParser__.arabicLetterHasInitialForm = function(t4) {
    return o2(t4) && a2(t4) && e2[t4.charCodeAt(0)].length >= 3;
  };
  var h2 = t3.__arabicParser__.arabicLetterHasMedialForm = function(t4) {
    return o2(t4) && a2(t4) && e2[t4.charCodeAt(0)].length == 4;
  }, l2 = t3.__arabicParser__.resolveLigatures = function(t4) {
    var e3 = 0, n3 = r2, i3 = "", a3 = 0;
    for (e3 = 0; e3 < t4.length; e3 += 1)
      n3[t4.charCodeAt(e3)] !== void 0 ? (a3++, typeof (n3 = n3[t4.charCodeAt(e3)]) == "number" && (i3 += String.fromCharCode(n3), n3 = r2, a3 = 0), e3 === t4.length - 1 && (n3 = r2, i3 += t4.charAt(e3 - (a3 - 1)), e3 -= a3 - 1, a3 = 0)) : (n3 = r2, i3 += t4.charAt(e3 - a3), e3 -= a3, a3 = 0);
    return i3;
  };
  t3.__arabicParser__.isArabicDiacritic = function(t4) {
    return t4 !== void 0 && n2[t4.charCodeAt(0)] !== void 0;
  };
  var f2 = t3.__arabicParser__.getCorrectForm = function(t4, e3, r3) {
    return o2(t4) ? a2(t4) === false ? -1 : !u2(t4) || !o2(e3) && !o2(r3) || !o2(r3) && s2(e3) || s2(t4) && !o2(e3) || s2(t4) && c2(e3) || s2(t4) && s2(e3) ? 0 : h2(t4) && o2(e3) && !s2(e3) && o2(r3) && u2(r3) ? 3 : s2(t4) || !o2(r3) ? 1 : 2 : -1;
  }, d2 = function(t4) {
    var r3 = 0, n3 = 0, i3 = 0, a3 = "", s3 = "", c3 = "", u3 = (t4 = t4 || "").split("\\s+"), h3 = [];
    for (r3 = 0; r3 < u3.length; r3 += 1) {
      for (h3.push(""), n3 = 0; n3 < u3[r3].length; n3 += 1)
        a3 = u3[r3][n3], s3 = u3[r3][n3 - 1], c3 = u3[r3][n3 + 1], o2(a3) ? (i3 = f2(a3, s3, c3), h3[r3] += i3 !== -1 ? String.fromCharCode(e2[a3.charCodeAt(0)][i3]) : a3) : h3[r3] += a3;
      h3[r3] = l2(h3[r3]);
    }
    return h3.join(" ");
  }, p5 = t3.__arabicParser__.processArabic = t3.processArabic = function() {
    var t4, e3 = typeof arguments[0] == "string" ? arguments[0] : arguments[0].text, r3 = [];
    if (Array.isArray(e3)) {
      var n3 = 0;
      for (r3 = [], n3 = 0; n3 < e3.length; n3 += 1)
        Array.isArray(e3[n3]) ? r3.push([d2(e3[n3][0]), e3[n3][1], e3[n3][2]]) : r3.push([d2(e3[n3])]);
      t4 = r3;
    } else
      t4 = d2(e3);
    return typeof arguments[0] == "string" ? t4 : (arguments[0].text = t4, arguments[0]);
  };
  t3.events.push(["preProcessText", p5]);
}(E$1.API), E$1.API.autoPrint = function(t3) {
  var e2;
  switch ((t3 = t3 || {}).variant = t3.variant || "non-conform", t3.variant) {
    case "javascript":
      this.addJS("print({});");
      break;
    case "non-conform":
    default:
      this.internal.events.subscribe("postPutResources", function() {
        e2 = this.internal.newObject(), this.internal.out("<<"), this.internal.out("/S /Named"), this.internal.out("/Type /Action"), this.internal.out("/N /Print"), this.internal.out(">>"), this.internal.out("endobj");
      }), this.internal.events.subscribe("putCatalog", function() {
        this.internal.out("/OpenAction " + e2 + " 0 R");
      });
  }
  return this;
}, function(t3) {
  var e2 = function() {
    var t4 = void 0;
    Object.defineProperty(this, "pdf", { get: function() {
      return t4;
    }, set: function(e4) {
      t4 = e4;
    } });
    var e3 = 150;
    Object.defineProperty(this, "width", { get: function() {
      return e3;
    }, set: function(t5) {
      e3 = isNaN(t5) || Number.isInteger(t5) === false || t5 < 0 ? 150 : t5, this.getContext("2d").pageWrapXEnabled && (this.getContext("2d").pageWrapX = e3 + 1);
    } });
    var r2 = 300;
    Object.defineProperty(this, "height", { get: function() {
      return r2;
    }, set: function(t5) {
      r2 = isNaN(t5) || Number.isInteger(t5) === false || t5 < 0 ? 300 : t5, this.getContext("2d").pageWrapYEnabled && (this.getContext("2d").pageWrapY = r2 + 1);
    } });
    var n2 = [];
    Object.defineProperty(this, "childNodes", { get: function() {
      return n2;
    }, set: function(t5) {
      n2 = t5;
    } });
    var i2 = {};
    Object.defineProperty(this, "style", { get: function() {
      return i2;
    }, set: function(t5) {
      i2 = t5;
    } }), Object.defineProperty(this, "parentNode", {});
  };
  e2.prototype.getContext = function(t4, e3) {
    var r2;
    if ((t4 = t4 || "2d") !== "2d")
      return null;
    for (r2 in e3)
      this.pdf.context2d.hasOwnProperty(r2) && (this.pdf.context2d[r2] = e3[r2]);
    return this.pdf.context2d._canvas = this, this.pdf.context2d;
  }, e2.prototype.toDataURL = function() {
    throw new Error("toDataURL is not implemented.");
  }, t3.events.push(["initialized", function() {
    this.canvas = new e2(), this.canvas.pdf = this;
  }]);
}(E$1.API), function(e2) {
  var r2 = { left: 0, top: 0, bottom: 0, right: 0 }, n2 = false, i2 = function() {
    this.internal.__cell__ === void 0 && (this.internal.__cell__ = {}, this.internal.__cell__.padding = 3, this.internal.__cell__.headerFunction = void 0, this.internal.__cell__.margins = Object.assign({}, r2), this.internal.__cell__.margins.width = this.getPageWidth(), a2.call(this));
  }, a2 = function() {
    this.internal.__cell__.lastCell = new o2(), this.internal.__cell__.pages = 1;
  }, o2 = function() {
    var t3 = arguments[0];
    Object.defineProperty(this, "x", { enumerable: true, get: function() {
      return t3;
    }, set: function(e4) {
      t3 = e4;
    } });
    var e3 = arguments[1];
    Object.defineProperty(this, "y", { enumerable: true, get: function() {
      return e3;
    }, set: function(t4) {
      e3 = t4;
    } });
    var r3 = arguments[2];
    Object.defineProperty(this, "width", { enumerable: true, get: function() {
      return r3;
    }, set: function(t4) {
      r3 = t4;
    } });
    var n3 = arguments[3];
    Object.defineProperty(this, "height", { enumerable: true, get: function() {
      return n3;
    }, set: function(t4) {
      n3 = t4;
    } });
    var i3 = arguments[4];
    Object.defineProperty(this, "text", { enumerable: true, get: function() {
      return i3;
    }, set: function(t4) {
      i3 = t4;
    } });
    var a3 = arguments[5];
    Object.defineProperty(this, "lineNumber", { enumerable: true, get: function() {
      return a3;
    }, set: function(t4) {
      a3 = t4;
    } });
    var o3 = arguments[6];
    return Object.defineProperty(this, "align", { enumerable: true, get: function() {
      return o3;
    }, set: function(t4) {
      o3 = t4;
    } }), this;
  };
  o2.prototype.clone = function() {
    return new o2(this.x, this.y, this.width, this.height, this.text, this.lineNumber, this.align);
  }, o2.prototype.toArray = function() {
    return [this.x, this.y, this.width, this.height, this.text, this.lineNumber, this.align];
  }, e2.setHeaderFunction = function(t3) {
    return i2.call(this), this.internal.__cell__.headerFunction = typeof t3 == "function" ? t3 : void 0, this;
  }, e2.getTextDimensions = function(t3, e3) {
    i2.call(this);
    var r3 = (e3 = e3 || {}).fontSize || this.getFontSize(), n3 = e3.font || this.getFont(), a3 = e3.scaleFactor || this.internal.scaleFactor, o3 = 0, s3 = 0, c3 = 0, u2 = this;
    if (!Array.isArray(t3) && typeof t3 != "string") {
      if (typeof t3 != "number")
        throw new Error("getTextDimensions expects text-parameter to be of type String or type Number or an Array of Strings.");
      t3 = String(t3);
    }
    var h2 = e3.maxWidth;
    h2 > 0 ? typeof t3 == "string" ? t3 = this.splitTextToSize(t3, h2) : Object.prototype.toString.call(t3) === "[object Array]" && (t3 = t3.reduce(function(t4, e4) {
      return t4.concat(u2.splitTextToSize(e4, h2));
    }, [])) : t3 = Array.isArray(t3) ? t3 : [t3];
    for (var l2 = 0; l2 < t3.length; l2++)
      o3 < (c3 = this.getStringUnitWidth(t3[l2], { font: n3 }) * r3) && (o3 = c3);
    return o3 !== 0 && (s3 = t3.length), { w: o3 /= a3, h: Math.max((s3 * r3 * this.getLineHeightFactor() - r3 * (this.getLineHeightFactor() - 1)) / a3, 0) };
  }, e2.cellAddPage = function() {
    i2.call(this), this.addPage();
    var t3 = this.internal.__cell__.margins || r2;
    return this.internal.__cell__.lastCell = new o2(t3.left, t3.top, void 0, void 0), this.internal.__cell__.pages += 1, this;
  };
  var s2 = e2.cell = function() {
    var t3;
    t3 = arguments[0] instanceof o2 ? arguments[0] : new o2(arguments[0], arguments[1], arguments[2], arguments[3], arguments[4], arguments[5]), i2.call(this);
    var e3 = this.internal.__cell__.lastCell, a3 = this.internal.__cell__.padding, s3 = this.internal.__cell__.margins || r2, c3 = this.internal.__cell__.tableHeaderRow, u2 = this.internal.__cell__.printHeaders;
    return e3.lineNumber !== void 0 && (e3.lineNumber === t3.lineNumber ? (t3.x = (e3.x || 0) + (e3.width || 0), t3.y = e3.y || 0) : e3.y + e3.height + t3.height + s3.bottom > this.getPageHeight() ? (this.cellAddPage(), t3.y = s3.top, u2 && c3 && (this.printHeaderRow(t3.lineNumber, true), t3.y += c3[0].height)) : t3.y = e3.y + e3.height || t3.y), t3.text[0] !== void 0 && (this.rect(t3.x, t3.y, t3.width, t3.height, n2 === true ? "FD" : void 0), t3.align === "right" ? this.text(t3.text, t3.x + t3.width - a3, t3.y + a3, { align: "right", baseline: "top" }) : t3.align === "center" ? this.text(t3.text, t3.x + t3.width / 2, t3.y + a3, { align: "center", baseline: "top", maxWidth: t3.width - a3 - a3 }) : this.text(t3.text, t3.x + a3, t3.y + a3, { align: "left", baseline: "top", maxWidth: t3.width - a3 - a3 })), this.internal.__cell__.lastCell = t3, this;
  };
  e2.table = function(e3, n3, u2, h2, l2) {
    if (i2.call(this), !u2)
      throw new Error("No data for PDF table.");
    var f2, d2, p5, g2, m2 = [], v2 = [], b2 = [], y2 = {}, w2 = {}, N2 = [], L2 = [], A2 = (l2 = l2 || {}).autoSize || false, x2 = l2.printHeaders !== false, S2 = l2.css && l2.css["font-size"] !== void 0 ? 16 * l2.css["font-size"] : l2.fontSize || 12, _2 = l2.margins || Object.assign({ width: this.getPageWidth() }, r2), P2 = typeof l2.padding == "number" ? l2.padding : 3, k2 = l2.headerBackgroundColor || "#c8c8c8", I2 = l2.headerTextColor || "#000";
    if (a2.call(this), this.internal.__cell__.printHeaders = x2, this.internal.__cell__.margins = _2, this.internal.__cell__.table_font_size = S2, this.internal.__cell__.padding = P2, this.internal.__cell__.headerBackgroundColor = k2, this.internal.__cell__.headerTextColor = I2, this.setFontSize(S2), h2 == null)
      v2 = m2 = Object.keys(u2[0]), b2 = m2.map(function() {
        return "left";
      });
    else if (Array.isArray(h2) && _typeof$2(h2[0]) === "object")
      for (m2 = h2.map(function(t3) {
        return t3.name;
      }), v2 = h2.map(function(t3) {
        return t3.prompt || t3.name || "";
      }), b2 = h2.map(function(t3) {
        return t3.align || "left";
      }), f2 = 0; f2 < h2.length; f2 += 1)
        w2[h2[f2].name] = h2[f2].width * (19.049976 / 25.4);
    else
      Array.isArray(h2) && typeof h2[0] == "string" && (v2 = m2 = h2, b2 = m2.map(function() {
        return "left";
      }));
    if (A2 || Array.isArray(h2) && typeof h2[0] == "string")
      for (f2 = 0; f2 < m2.length; f2 += 1) {
        for (y2[g2 = m2[f2]] = u2.map(function(t3) {
          return t3[g2];
        }), this.setFont(void 0, "bold"), N2.push(this.getTextDimensions(v2[f2], { fontSize: this.internal.__cell__.table_font_size, scaleFactor: this.internal.scaleFactor }).w), d2 = y2[g2], this.setFont(void 0, "normal"), p5 = 0; p5 < d2.length; p5 += 1)
          N2.push(this.getTextDimensions(d2[p5], { fontSize: this.internal.__cell__.table_font_size, scaleFactor: this.internal.scaleFactor }).w);
        w2[g2] = Math.max.apply(null, N2) + P2 + P2, N2 = [];
      }
    if (x2) {
      var F2 = {};
      for (f2 = 0; f2 < m2.length; f2 += 1)
        F2[m2[f2]] = {}, F2[m2[f2]].text = v2[f2], F2[m2[f2]].align = b2[f2];
      var C2 = c2.call(this, F2, w2);
      L2 = m2.map(function(t3) {
        return new o2(e3, n3, w2[t3], C2, F2[t3].text, void 0, F2[t3].align);
      }), this.setTableHeaderRow(L2), this.printHeaderRow(1, false);
    }
    var j2 = h2.reduce(function(t3, e4) {
      return t3[e4.name] = e4.align, t3;
    }, {});
    for (f2 = 0; f2 < u2.length; f2 += 1) {
      "rowStart" in l2 && l2.rowStart instanceof Function && l2.rowStart({ row: f2, data: u2[f2] }, this);
      var O2 = c2.call(this, u2[f2], w2);
      for (p5 = 0; p5 < m2.length; p5 += 1) {
        var B3 = u2[f2][m2[p5]];
        "cellStart" in l2 && l2.cellStart instanceof Function && l2.cellStart({ row: f2, col: p5, data: B3 }, this), s2.call(this, new o2(e3, n3, w2[m2[p5]], O2, B3, f2 + 2, j2[m2[p5]]));
      }
    }
    return this.internal.__cell__.table_x = e3, this.internal.__cell__.table_y = n3, this;
  };
  var c2 = function(t3, e3) {
    var r3 = this.internal.__cell__.padding, n3 = this.internal.__cell__.table_font_size, i3 = this.internal.scaleFactor;
    return Object.keys(t3).map(function(n4) {
      var i4 = t3[n4];
      return this.splitTextToSize(i4.hasOwnProperty("text") ? i4.text : i4, e3[n4] - r3 - r3);
    }, this).map(function(t4) {
      return this.getLineHeightFactor() * t4.length * n3 / i3 + r3 + r3;
    }, this).reduce(function(t4, e4) {
      return Math.max(t4, e4);
    }, 0);
  };
  e2.setTableHeaderRow = function(t3) {
    i2.call(this), this.internal.__cell__.tableHeaderRow = t3;
  }, e2.printHeaderRow = function(t3, e3) {
    if (i2.call(this), !this.internal.__cell__.tableHeaderRow)
      throw new Error("Property tableHeaderRow does not exist.");
    var r3;
    if (n2 = true, typeof this.internal.__cell__.headerFunction == "function") {
      var a3 = this.internal.__cell__.headerFunction(this, this.internal.__cell__.pages);
      this.internal.__cell__.lastCell = new o2(a3[0], a3[1], a3[2], a3[3], void 0, -1);
    }
    this.setFont(void 0, "bold");
    for (var c3 = [], u2 = 0; u2 < this.internal.__cell__.tableHeaderRow.length; u2 += 1) {
      r3 = this.internal.__cell__.tableHeaderRow[u2].clone(), e3 && (r3.y = this.internal.__cell__.margins.top || 0, c3.push(r3)), r3.lineNumber = t3;
      var h2 = this.getTextColor();
      this.setTextColor(this.internal.__cell__.headerTextColor), this.setFillColor(this.internal.__cell__.headerBackgroundColor), s2.call(this, r3), this.setTextColor(h2);
    }
    c3.length > 0 && this.setTableHeaderRow(c3), this.setFont(void 0, "normal"), n2 = false;
  };
}(E$1.API);
var Pt = { italic: ["italic", "oblique", "normal"], oblique: ["oblique", "italic", "normal"], normal: ["normal", "oblique", "italic"] };
var kt = ["ultra-condensed", "extra-condensed", "condensed", "semi-condensed", "normal", "semi-expanded", "expanded", "extra-expanded", "ultra-expanded"];
var It = _t(kt);
var Ft = [100, 200, 300, 400, 500, 600, 700, 800, 900];
var Ct = _t(Ft);
function jt(t3) {
  var e2 = t3.family.replace(/"|'/g, "").toLowerCase(), r2 = function(t4) {
    return Pt[t4 = t4 || "normal"] ? t4 : "normal";
  }(t3.style), n2 = function(t4) {
    if (!t4)
      return 400;
    if (typeof t4 == "number")
      return t4 >= 100 && t4 <= 900 && t4 % 100 == 0 ? t4 : 400;
    if (/^\d00$/.test(t4))
      return parseInt(t4);
    switch (t4) {
      case "bold":
        return 700;
      case "normal":
      default:
        return 400;
    }
  }(t3.weight), i2 = function(t4) {
    return typeof It[t4 = t4 || "normal"] == "number" ? t4 : "normal";
  }(t3.stretch);
  return { family: e2, style: r2, weight: n2, stretch: i2, src: t3.src || [], ref: t3.ref || { name: e2, style: [i2, r2, n2].join(" ") } };
}
function Ot(t3, e2, r2, n2) {
  var i2;
  for (i2 = r2; i2 >= 0 && i2 < e2.length; i2 += n2)
    if (t3[e2[i2]])
      return t3[e2[i2]];
  for (i2 = r2; i2 >= 0 && i2 < e2.length; i2 -= n2)
    if (t3[e2[i2]])
      return t3[e2[i2]];
}
var Bt = { "sans-serif": "helvetica", fixed: "courier", monospace: "courier", terminal: "courier", cursive: "times", fantasy: "times", serif: "times" };
var Mt = { caption: "times", icon: "times", menu: "times", "message-box": "times", "small-caption": "times", "status-bar": "times" };
function Et(t3) {
  return [t3.stretch, t3.style, t3.weight, t3.family].join(" ");
}
function qt(t3, e2, r2) {
  for (var n2 = (r2 = r2 || {}).defaultFontFamily || "times", i2 = Object.assign({}, Bt, r2.genericFontFamilies || {}), a2 = null, o2 = null, s2 = 0; s2 < e2.length; ++s2)
    if (i2[(a2 = jt(e2[s2])).family] && (a2.family = i2[a2.family]), t3.hasOwnProperty(a2.family)) {
      o2 = t3[a2.family];
      break;
    }
  if (!(o2 = o2 || t3[n2]))
    throw new Error("Could not find a font-family for the rule '" + Et(a2) + "' and default family '" + n2 + "'.");
  if (o2 = function(t4, e3) {
    if (e3[t4])
      return e3[t4];
    var r3 = It[t4], n3 = r3 <= It.normal ? -1 : 1, i3 = Ot(e3, kt, r3, n3);
    if (!i3)
      throw new Error("Could not find a matching font-stretch value for " + t4);
    return i3;
  }(a2.stretch, o2), o2 = function(t4, e3) {
    if (e3[t4])
      return e3[t4];
    for (var r3 = Pt[t4], n3 = 0; n3 < r3.length; ++n3)
      if (e3[r3[n3]])
        return e3[r3[n3]];
    throw new Error("Could not find a matching font-style for " + t4);
  }(a2.style, o2), !(o2 = function(t4, e3) {
    if (e3[t4])
      return e3[t4];
    if (t4 === 400 && e3[500])
      return e3[500];
    if (t4 === 500 && e3[400])
      return e3[400];
    var r3 = Ct[t4], n3 = Ot(e3, Ft, r3, t4 < 400 ? -1 : 1);
    if (!n3)
      throw new Error("Could not find a matching font-weight for value " + t4);
    return n3;
  }(a2.weight, o2)))
    throw new Error("Failed to resolve a font for the rule '" + Et(a2) + "'.");
  return o2;
}
function Dt(t3) {
  return t3.trimLeft();
}
function Rt(t3, e2) {
  for (var r2 = 0; r2 < t3.length; ) {
    if (t3.charAt(r2) === e2)
      return [t3.substring(0, r2), t3.substring(r2 + 1)];
    r2 += 1;
  }
  return null;
}
function Tt(t3) {
  var e2 = t3.match(/^(-[a-z_]|[a-z_])[a-z0-9_-]*/i);
  return e2 === null ? null : [e2[0], t3.substring(e2[0].length)];
}
var zt;
var Ut;
var Ht;
var Wt = ["times"];
!function(e2) {
  var r2, n2, i2, o2, s2, c2, u2, h2, l2, d2 = function(t3) {
    return t3 = t3 || {}, this.isStrokeTransparent = t3.isStrokeTransparent || false, this.strokeOpacity = t3.strokeOpacity || 1, this.strokeStyle = t3.strokeStyle || "#000000", this.fillStyle = t3.fillStyle || "#000000", this.isFillTransparent = t3.isFillTransparent || false, this.fillOpacity = t3.fillOpacity || 1, this.font = t3.font || "10px sans-serif", this.textBaseline = t3.textBaseline || "alphabetic", this.textAlign = t3.textAlign || "left", this.lineWidth = t3.lineWidth || 1, this.lineJoin = t3.lineJoin || "miter", this.lineCap = t3.lineCap || "butt", this.path = t3.path || [], this.transform = t3.transform !== void 0 ? t3.transform.clone() : new h2(), this.globalCompositeOperation = t3.globalCompositeOperation || "normal", this.globalAlpha = t3.globalAlpha || 1, this.clip_path = t3.clip_path || [], this.currentPoint = t3.currentPoint || new c2(), this.miterLimit = t3.miterLimit || 10, this.lastPoint = t3.lastPoint || new c2(), this.lineDashOffset = t3.lineDashOffset || 0, this.lineDash = t3.lineDash || [], this.margin = t3.margin || [0, 0, 0, 0], this.prevPageLastElemOffset = t3.prevPageLastElemOffset || 0, this.ignoreClearRect = typeof t3.ignoreClearRect != "boolean" || t3.ignoreClearRect, this;
  };
  e2.events.push(["initialized", function() {
    this.context2d = new p5(this), r2 = this.internal.f2, n2 = this.internal.getCoordinateString, i2 = this.internal.getVerticalCoordinateString, o2 = this.internal.getHorizontalCoordinate, s2 = this.internal.getVerticalCoordinate, c2 = this.internal.Point, u2 = this.internal.Rectangle, h2 = this.internal.Matrix, l2 = new d2();
  }]);
  var p5 = function(t3) {
    Object.defineProperty(this, "canvas", { get: function() {
      return { parentNode: false, style: false };
    } });
    var e3 = t3;
    Object.defineProperty(this, "pdf", { get: function() {
      return e3;
    } });
    var r3 = false;
    Object.defineProperty(this, "pageWrapXEnabled", { get: function() {
      return r3;
    }, set: function(t4) {
      r3 = Boolean(t4);
    } });
    var n3 = false;
    Object.defineProperty(this, "pageWrapYEnabled", { get: function() {
      return n3;
    }, set: function(t4) {
      n3 = Boolean(t4);
    } });
    var i3 = 0;
    Object.defineProperty(this, "posX", { get: function() {
      return i3;
    }, set: function(t4) {
      isNaN(t4) || (i3 = t4);
    } });
    var a2 = 0;
    Object.defineProperty(this, "posY", { get: function() {
      return a2;
    }, set: function(t4) {
      isNaN(t4) || (a2 = t4);
    } }), Object.defineProperty(this, "margin", { get: function() {
      return l2.margin;
    }, set: function(t4) {
      var e4;
      typeof t4 == "number" ? e4 = [t4, t4, t4, t4] : ((e4 = new Array(4))[0] = t4[0], e4[1] = t4.length >= 2 ? t4[1] : e4[0], e4[2] = t4.length >= 3 ? t4[2] : e4[0], e4[3] = t4.length >= 4 ? t4[3] : e4[1]), l2.margin = e4;
    } });
    var o3 = false;
    Object.defineProperty(this, "autoPaging", { get: function() {
      return o3;
    }, set: function(t4) {
      o3 = t4;
    } });
    var s3 = 0;
    Object.defineProperty(this, "lastBreak", { get: function() {
      return s3;
    }, set: function(t4) {
      s3 = t4;
    } });
    var c3 = [];
    Object.defineProperty(this, "pageBreaks", { get: function() {
      return c3;
    }, set: function(t4) {
      c3 = t4;
    } }), Object.defineProperty(this, "ctx", { get: function() {
      return l2;
    }, set: function(t4) {
      t4 instanceof d2 && (l2 = t4);
    } }), Object.defineProperty(this, "path", { get: function() {
      return l2.path;
    }, set: function(t4) {
      l2.path = t4;
    } });
    var u3 = [];
    Object.defineProperty(this, "ctxStack", { get: function() {
      return u3;
    }, set: function(t4) {
      u3 = t4;
    } }), Object.defineProperty(this, "fillStyle", { get: function() {
      return this.ctx.fillStyle;
    }, set: function(t4) {
      var e4;
      e4 = g2(t4), this.ctx.fillStyle = e4.style, this.ctx.isFillTransparent = e4.a === 0, this.ctx.fillOpacity = e4.a, this.pdf.setFillColor(e4.r, e4.g, e4.b, { a: e4.a }), this.pdf.setTextColor(e4.r, e4.g, e4.b, { a: e4.a });
    } }), Object.defineProperty(this, "strokeStyle", { get: function() {
      return this.ctx.strokeStyle;
    }, set: function(t4) {
      var e4 = g2(t4);
      this.ctx.strokeStyle = e4.style, this.ctx.isStrokeTransparent = e4.a === 0, this.ctx.strokeOpacity = e4.a, e4.a === 0 ? this.pdf.setDrawColor(255, 255, 255) : (e4.a, this.pdf.setDrawColor(e4.r, e4.g, e4.b));
    } }), Object.defineProperty(this, "lineCap", { get: function() {
      return this.ctx.lineCap;
    }, set: function(t4) {
      ["butt", "round", "square"].indexOf(t4) !== -1 && (this.ctx.lineCap = t4, this.pdf.setLineCap(t4));
    } }), Object.defineProperty(this, "lineWidth", { get: function() {
      return this.ctx.lineWidth;
    }, set: function(t4) {
      isNaN(t4) || (this.ctx.lineWidth = t4, this.pdf.setLineWidth(t4));
    } }), Object.defineProperty(this, "lineJoin", { get: function() {
      return this.ctx.lineJoin;
    }, set: function(t4) {
      ["bevel", "round", "miter"].indexOf(t4) !== -1 && (this.ctx.lineJoin = t4, this.pdf.setLineJoin(t4));
    } }), Object.defineProperty(this, "miterLimit", { get: function() {
      return this.ctx.miterLimit;
    }, set: function(t4) {
      isNaN(t4) || (this.ctx.miterLimit = t4, this.pdf.setMiterLimit(t4));
    } }), Object.defineProperty(this, "textBaseline", { get: function() {
      return this.ctx.textBaseline;
    }, set: function(t4) {
      this.ctx.textBaseline = t4;
    } }), Object.defineProperty(this, "textAlign", { get: function() {
      return this.ctx.textAlign;
    }, set: function(t4) {
      ["right", "end", "center", "left", "start"].indexOf(t4) !== -1 && (this.ctx.textAlign = t4);
    } });
    var h3 = null;
    function f2(t4, e4) {
      if (h3 === null) {
        var r4 = function(t5) {
          var e5 = [];
          return Object.keys(t5).forEach(function(r5) {
            t5[r5].forEach(function(t6) {
              var n4 = null;
              switch (t6) {
                case "bold":
                  n4 = { family: r5, weight: "bold" };
                  break;
                case "italic":
                  n4 = { family: r5, style: "italic" };
                  break;
                case "bolditalic":
                  n4 = { family: r5, weight: "bold", style: "italic" };
                  break;
                case "":
                case "normal":
                  n4 = { family: r5 };
              }
              n4 !== null && (n4.ref = { name: r5, style: t6 }, e5.push(n4));
            });
          }), e5;
        }(t4.getFontList());
        h3 = function(t5) {
          for (var e5 = {}, r5 = 0; r5 < t5.length; ++r5) {
            var n4 = jt(t5[r5]), i4 = n4.family, a3 = n4.stretch, o4 = n4.style, s4 = n4.weight;
            e5[i4] = e5[i4] || {}, e5[i4][a3] = e5[i4][a3] || {}, e5[i4][a3][o4] = e5[i4][a3][o4] || {}, e5[i4][a3][o4][s4] = n4;
          }
          return e5;
        }(r4.concat(e4));
      }
      return h3;
    }
    var p6 = null;
    Object.defineProperty(this, "fontFaces", { get: function() {
      return p6;
    }, set: function(t4) {
      h3 = null, p6 = t4;
    } }), Object.defineProperty(this, "font", { get: function() {
      return this.ctx.font;
    }, set: function(t4) {
      var e4;
      if (this.ctx.font = t4, (e4 = /^\s*(?=(?:(?:[-a-z]+\s*){0,2}(italic|oblique))?)(?=(?:(?:[-a-z]+\s*){0,2}(small-caps))?)(?=(?:(?:[-a-z]+\s*){0,2}(bold(?:er)?|lighter|[1-9]00))?)(?:(?:normal|\1|\2|\3)\s*){0,3}((?:xx?-)?(?:small|large)|medium|smaller|larger|[.\d]+(?:\%|in|[cem]m|ex|p[ctx]))(?:\s*\/\s*(normal|[.\d]+(?:\%|in|[cem]m|ex|p[ctx])))?\s*([-_,\"\'\sa-z]+?)\s*$/i.exec(t4)) !== null) {
        var r4 = e4[1], n4 = (e4[2], e4[3]), i4 = e4[4], a3 = (e4[5], e4[6]), o4 = /^([.\d]+)((?:%|in|[cem]m|ex|p[ctx]))$/i.exec(i4)[2];
        i4 = o4 === "px" ? Math.floor(parseFloat(i4) * this.pdf.internal.scaleFactor) : o4 === "em" ? Math.floor(parseFloat(i4) * this.pdf.getFontSize()) : Math.floor(parseFloat(i4) * this.pdf.internal.scaleFactor), this.pdf.setFontSize(i4);
        var s4 = function(t5) {
          var e5, r5, n5 = [], i5 = t5.trim();
          if (i5 === "")
            return Wt;
          if (i5 in Mt)
            return [Mt[i5]];
          for (; i5 !== ""; ) {
            switch (r5 = null, e5 = (i5 = Dt(i5)).charAt(0)) {
              case '"':
              case "'":
                r5 = Rt(i5.substring(1), e5);
                break;
              default:
                r5 = Tt(i5);
            }
            if (r5 === null)
              return Wt;
            if (n5.push(r5[0]), (i5 = Dt(r5[1])) !== "" && i5.charAt(0) !== ",")
              return Wt;
            i5 = i5.replace(/^,/, "");
          }
          return n5;
        }(a3);
        if (this.fontFaces) {
          var c4 = qt(f2(this.pdf, this.fontFaces), s4.map(function(t5) {
            return { family: t5, stretch: "normal", weight: n4, style: r4 };
          }));
          this.pdf.setFont(c4.ref.name, c4.ref.style);
        } else {
          var u4 = "";
          (n4 === "bold" || parseInt(n4, 10) >= 700 || r4 === "bold") && (u4 = "bold"), r4 === "italic" && (u4 += "italic"), u4.length === 0 && (u4 = "normal");
          for (var h4 = "", l3 = { arial: "Helvetica", Arial: "Helvetica", verdana: "Helvetica", Verdana: "Helvetica", helvetica: "Helvetica", Helvetica: "Helvetica", "sans-serif": "Helvetica", fixed: "Courier", monospace: "Courier", terminal: "Courier", cursive: "Times", fantasy: "Times", serif: "Times" }, d3 = 0; d3 < s4.length; d3++) {
            if (this.pdf.internal.getFont(s4[d3], u4, { noFallback: true, disableWarning: true }) !== void 0) {
              h4 = s4[d3];
              break;
            }
            if (u4 === "bolditalic" && this.pdf.internal.getFont(s4[d3], "bold", { noFallback: true, disableWarning: true }) !== void 0)
              h4 = s4[d3], u4 = "bold";
            else if (this.pdf.internal.getFont(s4[d3], "normal", { noFallback: true, disableWarning: true }) !== void 0) {
              h4 = s4[d3], u4 = "normal";
              break;
            }
          }
          if (h4 === "") {
            for (var p7 = 0; p7 < s4.length; p7++)
              if (l3[s4[p7]]) {
                h4 = l3[s4[p7]];
                break;
              }
          }
          h4 = h4 === "" ? "Times" : h4, this.pdf.setFont(h4, u4);
        }
      }
    } }), Object.defineProperty(this, "globalCompositeOperation", { get: function() {
      return this.ctx.globalCompositeOperation;
    }, set: function(t4) {
      this.ctx.globalCompositeOperation = t4;
    } }), Object.defineProperty(this, "globalAlpha", { get: function() {
      return this.ctx.globalAlpha;
    }, set: function(t4) {
      this.ctx.globalAlpha = t4;
    } }), Object.defineProperty(this, "lineDashOffset", { get: function() {
      return this.ctx.lineDashOffset;
    }, set: function(t4) {
      this.ctx.lineDashOffset = t4, T2.call(this);
    } }), Object.defineProperty(this, "lineDash", { get: function() {
      return this.ctx.lineDash;
    }, set: function(t4) {
      this.ctx.lineDash = t4, T2.call(this);
    } }), Object.defineProperty(this, "ignoreClearRect", { get: function() {
      return this.ctx.ignoreClearRect;
    }, set: function(t4) {
      this.ctx.ignoreClearRect = Boolean(t4);
    } });
  };
  p5.prototype.setLineDash = function(t3) {
    this.lineDash = t3;
  }, p5.prototype.getLineDash = function() {
    return this.lineDash.length % 2 ? this.lineDash.concat(this.lineDash) : this.lineDash.slice();
  }, p5.prototype.fill = function() {
    A2.call(this, "fill", false);
  }, p5.prototype.stroke = function() {
    A2.call(this, "stroke", false);
  }, p5.prototype.beginPath = function() {
    this.path = [{ type: "begin" }];
  }, p5.prototype.moveTo = function(t3, e3) {
    if (isNaN(t3) || isNaN(e3))
      throw a$2.error("jsPDF.context2d.moveTo: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.moveTo");
    var r3 = this.ctx.transform.applyToPoint(new c2(t3, e3));
    this.path.push({ type: "mt", x: r3.x, y: r3.y }), this.ctx.lastPoint = new c2(t3, e3);
  }, p5.prototype.closePath = function() {
    var e3 = new c2(0, 0), r3 = 0;
    for (r3 = this.path.length - 1; r3 !== -1; r3--)
      if (this.path[r3].type === "begin" && _typeof$2(this.path[r3 + 1]) === "object" && typeof this.path[r3 + 1].x == "number") {
        e3 = new c2(this.path[r3 + 1].x, this.path[r3 + 1].y);
        break;
      }
    this.path.push({ type: "close" }), this.ctx.lastPoint = new c2(e3.x, e3.y);
  }, p5.prototype.lineTo = function(t3, e3) {
    if (isNaN(t3) || isNaN(e3))
      throw a$2.error("jsPDF.context2d.lineTo: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.lineTo");
    var r3 = this.ctx.transform.applyToPoint(new c2(t3, e3));
    this.path.push({ type: "lt", x: r3.x, y: r3.y }), this.ctx.lastPoint = new c2(r3.x, r3.y);
  }, p5.prototype.clip = function() {
    this.ctx.clip_path = JSON.parse(JSON.stringify(this.path)), A2.call(this, null, true);
  }, p5.prototype.quadraticCurveTo = function(t3, e3, r3, n3) {
    if (isNaN(r3) || isNaN(n3) || isNaN(t3) || isNaN(e3))
      throw a$2.error("jsPDF.context2d.quadraticCurveTo: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.quadraticCurveTo");
    var i3 = this.ctx.transform.applyToPoint(new c2(r3, n3)), o3 = this.ctx.transform.applyToPoint(new c2(t3, e3));
    this.path.push({ type: "qct", x1: o3.x, y1: o3.y, x: i3.x, y: i3.y }), this.ctx.lastPoint = new c2(i3.x, i3.y);
  }, p5.prototype.bezierCurveTo = function(t3, e3, r3, n3, i3, o3) {
    if (isNaN(i3) || isNaN(o3) || isNaN(t3) || isNaN(e3) || isNaN(r3) || isNaN(n3))
      throw a$2.error("jsPDF.context2d.bezierCurveTo: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.bezierCurveTo");
    var s3 = this.ctx.transform.applyToPoint(new c2(i3, o3)), u3 = this.ctx.transform.applyToPoint(new c2(t3, e3)), h3 = this.ctx.transform.applyToPoint(new c2(r3, n3));
    this.path.push({ type: "bct", x1: u3.x, y1: u3.y, x2: h3.x, y2: h3.y, x: s3.x, y: s3.y }), this.ctx.lastPoint = new c2(s3.x, s3.y);
  }, p5.prototype.arc = function(t3, e3, r3, n3, i3, o3) {
    if (isNaN(t3) || isNaN(e3) || isNaN(r3) || isNaN(n3) || isNaN(i3))
      throw a$2.error("jsPDF.context2d.arc: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.arc");
    if (o3 = Boolean(o3), !this.ctx.transform.isIdentity) {
      var s3 = this.ctx.transform.applyToPoint(new c2(t3, e3));
      t3 = s3.x, e3 = s3.y;
      var u3 = this.ctx.transform.applyToPoint(new c2(0, r3)), h3 = this.ctx.transform.applyToPoint(new c2(0, 0));
      r3 = Math.sqrt(Math.pow(u3.x - h3.x, 2) + Math.pow(u3.y - h3.y, 2));
    }
    Math.abs(i3 - n3) >= 2 * Math.PI && (n3 = 0, i3 = 2 * Math.PI), this.path.push({ type: "arc", x: t3, y: e3, radius: r3, startAngle: n3, endAngle: i3, counterclockwise: o3 });
  }, p5.prototype.arcTo = function(t3, e3, r3, n3, i3) {
    throw new Error("arcTo not implemented.");
  }, p5.prototype.rect = function(t3, e3, r3, n3) {
    if (isNaN(t3) || isNaN(e3) || isNaN(r3) || isNaN(n3))
      throw a$2.error("jsPDF.context2d.rect: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.rect");
    this.moveTo(t3, e3), this.lineTo(t3 + r3, e3), this.lineTo(t3 + r3, e3 + n3), this.lineTo(t3, e3 + n3), this.lineTo(t3, e3), this.lineTo(t3 + r3, e3), this.lineTo(t3, e3);
  }, p5.prototype.fillRect = function(t3, e3, r3, n3) {
    if (isNaN(t3) || isNaN(e3) || isNaN(r3) || isNaN(n3))
      throw a$2.error("jsPDF.context2d.fillRect: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.fillRect");
    if (!m2.call(this)) {
      var i3 = {};
      this.lineCap !== "butt" && (i3.lineCap = this.lineCap, this.lineCap = "butt"), this.lineJoin !== "miter" && (i3.lineJoin = this.lineJoin, this.lineJoin = "miter"), this.beginPath(), this.rect(t3, e3, r3, n3), this.fill(), i3.hasOwnProperty("lineCap") && (this.lineCap = i3.lineCap), i3.hasOwnProperty("lineJoin") && (this.lineJoin = i3.lineJoin);
    }
  }, p5.prototype.strokeRect = function(t3, e3, r3, n3) {
    if (isNaN(t3) || isNaN(e3) || isNaN(r3) || isNaN(n3))
      throw a$2.error("jsPDF.context2d.strokeRect: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.strokeRect");
    v2.call(this) || (this.beginPath(), this.rect(t3, e3, r3, n3), this.stroke());
  }, p5.prototype.clearRect = function(t3, e3, r3, n3) {
    if (isNaN(t3) || isNaN(e3) || isNaN(r3) || isNaN(n3))
      throw a$2.error("jsPDF.context2d.clearRect: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.clearRect");
    this.ignoreClearRect || (this.fillStyle = "#ffffff", this.fillRect(t3, e3, r3, n3));
  }, p5.prototype.save = function(t3) {
    t3 = typeof t3 != "boolean" || t3;
    for (var e3 = this.pdf.internal.getCurrentPageInfo().pageNumber, r3 = 0; r3 < this.pdf.internal.getNumberOfPages(); r3++)
      this.pdf.setPage(r3 + 1), this.pdf.internal.out("q");
    if (this.pdf.setPage(e3), t3) {
      this.ctx.fontSize = this.pdf.internal.getFontSize();
      var n3 = new d2(this.ctx);
      this.ctxStack.push(this.ctx), this.ctx = n3;
    }
  }, p5.prototype.restore = function(t3) {
    t3 = typeof t3 != "boolean" || t3;
    for (var e3 = this.pdf.internal.getCurrentPageInfo().pageNumber, r3 = 0; r3 < this.pdf.internal.getNumberOfPages(); r3++)
      this.pdf.setPage(r3 + 1), this.pdf.internal.out("Q");
    this.pdf.setPage(e3), t3 && this.ctxStack.length !== 0 && (this.ctx = this.ctxStack.pop(), this.fillStyle = this.ctx.fillStyle, this.strokeStyle = this.ctx.strokeStyle, this.font = this.ctx.font, this.lineCap = this.ctx.lineCap, this.lineWidth = this.ctx.lineWidth, this.lineJoin = this.ctx.lineJoin, this.lineDash = this.ctx.lineDash, this.lineDashOffset = this.ctx.lineDashOffset);
  }, p5.prototype.toDataURL = function() {
    throw new Error("toDataUrl not implemented.");
  };
  var g2 = function(t3) {
    var e3, r3, n3, i3;
    if (t3.isCanvasGradient === true && (t3 = t3.getColor()), !t3)
      return { r: 0, g: 0, b: 0, a: 0, style: t3 };
    if (/transparent|rgba\s*\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*,\s*0+\s*\)/.test(t3))
      e3 = 0, r3 = 0, n3 = 0, i3 = 0;
    else {
      var a2 = /rgb\s*\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*\)/.exec(t3);
      if (a2 !== null)
        e3 = parseInt(a2[1]), r3 = parseInt(a2[2]), n3 = parseInt(a2[3]), i3 = 1;
      else if ((a2 = /rgba\s*\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*,\s*([\d.]+)\s*\)/.exec(t3)) !== null)
        e3 = parseInt(a2[1]), r3 = parseInt(a2[2]), n3 = parseInt(a2[3]), i3 = parseFloat(a2[4]);
      else {
        if (i3 = 1, typeof t3 == "string" && t3.charAt(0) !== "#") {
          var o3 = new f$2(t3);
          t3 = o3.ok ? o3.toHex() : "#000000";
        }
        t3.length === 4 ? (e3 = t3.substring(1, 2), e3 += e3, r3 = t3.substring(2, 3), r3 += r3, n3 = t3.substring(3, 4), n3 += n3) : (e3 = t3.substring(1, 3), r3 = t3.substring(3, 5), n3 = t3.substring(5, 7)), e3 = parseInt(e3, 16), r3 = parseInt(r3, 16), n3 = parseInt(n3, 16);
      }
    }
    return { r: e3, g: r3, b: n3, a: i3, style: t3 };
  }, m2 = function() {
    return this.ctx.isFillTransparent || this.globalAlpha == 0;
  }, v2 = function() {
    return Boolean(this.ctx.isStrokeTransparent || this.globalAlpha == 0);
  };
  p5.prototype.fillText = function(t3, e3, r3, n3) {
    if (isNaN(e3) || isNaN(r3) || typeof t3 != "string")
      throw a$2.error("jsPDF.context2d.fillText: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.fillText");
    if (n3 = isNaN(n3) ? void 0 : n3, !m2.call(this)) {
      var i3 = q2(this.ctx.transform.rotation), o3 = this.ctx.transform.scaleX;
      C2.call(this, { text: t3, x: e3, y: r3, scale: o3, angle: i3, align: this.textAlign, maxWidth: n3 });
    }
  }, p5.prototype.strokeText = function(t3, e3, r3, n3) {
    if (isNaN(e3) || isNaN(r3) || typeof t3 != "string")
      throw a$2.error("jsPDF.context2d.strokeText: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.strokeText");
    if (!v2.call(this)) {
      n3 = isNaN(n3) ? void 0 : n3;
      var i3 = q2(this.ctx.transform.rotation), o3 = this.ctx.transform.scaleX;
      C2.call(this, { text: t3, x: e3, y: r3, scale: o3, renderingMode: "stroke", angle: i3, align: this.textAlign, maxWidth: n3 });
    }
  }, p5.prototype.measureText = function(t3) {
    if (typeof t3 != "string")
      throw a$2.error("jsPDF.context2d.measureText: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.measureText");
    var e3 = this.pdf, r3 = this.pdf.internal.scaleFactor, n3 = e3.internal.getFontSize(), i3 = e3.getStringUnitWidth(t3) * n3 / e3.internal.scaleFactor, o3 = function(t4) {
      var e4 = (t4 = t4 || {}).width || 0;
      return Object.defineProperty(this, "width", { get: function() {
        return e4;
      } }), this;
    };
    return new o3({ width: i3 *= Math.round(96 * r3 / 72 * 1e4) / 1e4 });
  }, p5.prototype.scale = function(t3, e3) {
    if (isNaN(t3) || isNaN(e3))
      throw a$2.error("jsPDF.context2d.scale: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.scale");
    var r3 = new h2(t3, 0, 0, e3, 0, 0);
    this.ctx.transform = this.ctx.transform.multiply(r3);
  }, p5.prototype.rotate = function(t3) {
    if (isNaN(t3))
      throw a$2.error("jsPDF.context2d.rotate: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.rotate");
    var e3 = new h2(Math.cos(t3), Math.sin(t3), -Math.sin(t3), Math.cos(t3), 0, 0);
    this.ctx.transform = this.ctx.transform.multiply(e3);
  }, p5.prototype.translate = function(t3, e3) {
    if (isNaN(t3) || isNaN(e3))
      throw a$2.error("jsPDF.context2d.translate: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.translate");
    var r3 = new h2(1, 0, 0, 1, t3, e3);
    this.ctx.transform = this.ctx.transform.multiply(r3);
  }, p5.prototype.transform = function(t3, e3, r3, n3, i3, o3) {
    if (isNaN(t3) || isNaN(e3) || isNaN(r3) || isNaN(n3) || isNaN(i3) || isNaN(o3))
      throw a$2.error("jsPDF.context2d.transform: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.transform");
    var s3 = new h2(t3, e3, r3, n3, i3, o3);
    this.ctx.transform = this.ctx.transform.multiply(s3);
  }, p5.prototype.setTransform = function(t3, e3, r3, n3, i3, a2) {
    t3 = isNaN(t3) ? 1 : t3, e3 = isNaN(e3) ? 0 : e3, r3 = isNaN(r3) ? 0 : r3, n3 = isNaN(n3) ? 1 : n3, i3 = isNaN(i3) ? 0 : i3, a2 = isNaN(a2) ? 0 : a2, this.ctx.transform = new h2(t3, e3, r3, n3, i3, a2);
  };
  var b2 = function() {
    return this.margin[0] > 0 || this.margin[1] > 0 || this.margin[2] > 0 || this.margin[3] > 0;
  };
  p5.prototype.drawImage = function(t3, e3, r3, n3, i3, a2, o3, s3, c3) {
    var l3 = this.pdf.getImageProperties(t3), f2 = 1, d3 = 1, p6 = 1, g3 = 1;
    n3 !== void 0 && s3 !== void 0 && (p6 = s3 / n3, g3 = c3 / i3, f2 = l3.width / n3 * s3 / n3, d3 = l3.height / i3 * c3 / i3), a2 === void 0 && (a2 = e3, o3 = r3, e3 = 0, r3 = 0), n3 !== void 0 && s3 === void 0 && (s3 = n3, c3 = i3), n3 === void 0 && s3 === void 0 && (s3 = l3.width, c3 = l3.height);
    for (var m3, v3 = this.ctx.transform.decompose(), w3 = q2(v3.rotate.shx), A3 = new h2(), S3 = (A3 = (A3 = (A3 = A3.multiply(v3.translate)).multiply(v3.skew)).multiply(v3.scale)).applyToRectangle(new u2(a2 - e3 * p6, o3 - r3 * g3, n3 * f2, i3 * d3)), _3 = y2.call(this, S3), P3 = [], k3 = 0; k3 < _3.length; k3 += 1)
      P3.indexOf(_3[k3]) === -1 && P3.push(_3[k3]);
    if (L2(P3), this.autoPaging)
      for (var I3 = P3[0], F3 = P3[P3.length - 1], C3 = I3; C3 < F3 + 1; C3++) {
        this.pdf.setPage(C3);
        var j3 = this.pdf.internal.pageSize.width - this.margin[3] - this.margin[1], O3 = C3 === 1 ? this.posY + this.margin[0] : this.margin[0], B4 = this.pdf.internal.pageSize.height - this.posY - this.margin[0] - this.margin[2], M3 = this.pdf.internal.pageSize.height - this.margin[0] - this.margin[2], E3 = C3 === 1 ? 0 : B4 + (C3 - 2) * M3;
        if (this.ctx.clip_path.length !== 0) {
          var D3 = this.path;
          m3 = JSON.parse(JSON.stringify(this.ctx.clip_path)), this.path = N2(m3, this.posX + this.margin[3], -E3 + O3 + this.ctx.prevPageLastElemOffset), x2.call(this, "fill", true), this.path = D3;
        }
        var R3 = JSON.parse(JSON.stringify(S3));
        R3 = N2([R3], this.posX + this.margin[3], -E3 + O3 + this.ctx.prevPageLastElemOffset)[0];
        var T3 = (C3 > I3 || C3 < F3) && b2.call(this);
        T3 && (this.pdf.saveGraphicsState(), this.pdf.rect(this.margin[3], this.margin[0], j3, M3, null).clip().discardPath()), this.pdf.addImage(t3, "JPEG", R3.x, R3.y, R3.w, R3.h, null, null, w3), T3 && this.pdf.restoreGraphicsState();
      }
    else
      this.pdf.addImage(t3, "JPEG", S3.x, S3.y, S3.w, S3.h, null, null, w3);
  };
  var y2 = function(t3, e3, r3) {
    var n3 = [];
    e3 = e3 || this.pdf.internal.pageSize.width, r3 = r3 || this.pdf.internal.pageSize.height - this.margin[0] - this.margin[2];
    var i3 = this.posY + this.ctx.prevPageLastElemOffset;
    switch (t3.type) {
      default:
      case "mt":
      case "lt":
        n3.push(Math.floor((t3.y + i3) / r3) + 1);
        break;
      case "arc":
        n3.push(Math.floor((t3.y + i3 - t3.radius) / r3) + 1), n3.push(Math.floor((t3.y + i3 + t3.radius) / r3) + 1);
        break;
      case "qct":
        var a2 = D2(this.ctx.lastPoint.x, this.ctx.lastPoint.y, t3.x1, t3.y1, t3.x, t3.y);
        n3.push(Math.floor((a2.y + i3) / r3) + 1), n3.push(Math.floor((a2.y + a2.h + i3) / r3) + 1);
        break;
      case "bct":
        var o3 = R2(this.ctx.lastPoint.x, this.ctx.lastPoint.y, t3.x1, t3.y1, t3.x2, t3.y2, t3.x, t3.y);
        n3.push(Math.floor((o3.y + i3) / r3) + 1), n3.push(Math.floor((o3.y + o3.h + i3) / r3) + 1);
        break;
      case "rect":
        n3.push(Math.floor((t3.y + i3) / r3) + 1), n3.push(Math.floor((t3.y + t3.h + i3) / r3) + 1);
    }
    for (var s3 = 0; s3 < n3.length; s3 += 1)
      for (; this.pdf.internal.getNumberOfPages() < n3[s3]; )
        w2.call(this);
    return n3;
  }, w2 = function() {
    var t3 = this.fillStyle, e3 = this.strokeStyle, r3 = this.font, n3 = this.lineCap, i3 = this.lineWidth, a2 = this.lineJoin;
    this.pdf.addPage(), this.fillStyle = t3, this.strokeStyle = e3, this.font = r3, this.lineCap = n3, this.lineWidth = i3, this.lineJoin = a2;
  }, N2 = function(t3, e3, r3) {
    for (var n3 = 0; n3 < t3.length; n3++)
      switch (t3[n3].type) {
        case "bct":
          t3[n3].x2 += e3, t3[n3].y2 += r3;
        case "qct":
          t3[n3].x1 += e3, t3[n3].y1 += r3;
        case "mt":
        case "lt":
        case "arc":
        default:
          t3[n3].x += e3, t3[n3].y += r3;
      }
    return t3;
  }, L2 = function(t3) {
    return t3.sort(function(t4, e3) {
      return t4 - e3;
    });
  }, A2 = function(t3, e3) {
    for (var r3, n3, i3 = this.fillStyle, a2 = this.strokeStyle, o3 = this.lineCap, s3 = this.lineWidth, c3 = Math.abs(s3 * this.ctx.transform.scaleX), u3 = this.lineJoin, h3 = JSON.parse(JSON.stringify(this.path)), l3 = JSON.parse(JSON.stringify(this.path)), f2 = [], d3 = 0; d3 < l3.length; d3++)
      if (l3[d3].x !== void 0)
        for (var p6 = y2.call(this, l3[d3]), g3 = 0; g3 < p6.length; g3 += 1)
          f2.indexOf(p6[g3]) === -1 && f2.push(p6[g3]);
    for (var m3 = 0; m3 < f2.length; m3++)
      for (; this.pdf.internal.getNumberOfPages() < f2[m3]; )
        w2.call(this);
    if (L2(f2), this.autoPaging)
      for (var v3 = f2[0], A3 = f2[f2.length - 1], S3 = v3; S3 < A3 + 1; S3++) {
        this.pdf.setPage(S3), this.fillStyle = i3, this.strokeStyle = a2, this.lineCap = o3, this.lineWidth = c3, this.lineJoin = u3;
        var _3 = this.pdf.internal.pageSize.width - this.margin[3] - this.margin[1], P3 = S3 === 1 ? this.posY + this.margin[0] : this.margin[0], k3 = this.pdf.internal.pageSize.height - this.posY - this.margin[0] - this.margin[2], I3 = this.pdf.internal.pageSize.height - this.margin[0] - this.margin[2], F3 = S3 === 1 ? 0 : k3 + (S3 - 2) * I3;
        if (this.ctx.clip_path.length !== 0) {
          var C3 = this.path;
          r3 = JSON.parse(JSON.stringify(this.ctx.clip_path)), this.path = N2(r3, this.posX + this.margin[3], -F3 + P3 + this.ctx.prevPageLastElemOffset), x2.call(this, t3, true), this.path = C3;
        }
        if (n3 = JSON.parse(JSON.stringify(h3)), this.path = N2(n3, this.posX + this.margin[3], -F3 + P3 + this.ctx.prevPageLastElemOffset), e3 === false || S3 === 0) {
          var j3 = (S3 > v3 || S3 < A3) && b2.call(this);
          j3 && (this.pdf.saveGraphicsState(), this.pdf.rect(this.margin[3], this.margin[0], _3, I3, null).clip().discardPath()), x2.call(this, t3, e3), j3 && this.pdf.restoreGraphicsState();
        }
        this.lineWidth = s3;
      }
    else
      this.lineWidth = c3, x2.call(this, t3, e3), this.lineWidth = s3;
    this.path = h3;
  }, x2 = function(t3, e3) {
    if ((t3 !== "stroke" || e3 || !v2.call(this)) && (t3 === "stroke" || e3 || !m2.call(this))) {
      for (var r3, n3, i3 = [], a2 = this.path, o3 = 0; o3 < a2.length; o3++) {
        var s3 = a2[o3];
        switch (s3.type) {
          case "begin":
            i3.push({ begin: true });
            break;
          case "close":
            i3.push({ close: true });
            break;
          case "mt":
            i3.push({ start: s3, deltas: [], abs: [] });
            break;
          case "lt":
            var c3 = i3.length;
            if (a2[o3 - 1] && !isNaN(a2[o3 - 1].x) && (r3 = [s3.x - a2[o3 - 1].x, s3.y - a2[o3 - 1].y], c3 > 0)) {
              for (; c3 >= 0; c3--)
                if (i3[c3 - 1].close !== true && i3[c3 - 1].begin !== true) {
                  i3[c3 - 1].deltas.push(r3), i3[c3 - 1].abs.push(s3);
                  break;
                }
            }
            break;
          case "bct":
            r3 = [s3.x1 - a2[o3 - 1].x, s3.y1 - a2[o3 - 1].y, s3.x2 - a2[o3 - 1].x, s3.y2 - a2[o3 - 1].y, s3.x - a2[o3 - 1].x, s3.y - a2[o3 - 1].y], i3[i3.length - 1].deltas.push(r3);
            break;
          case "qct":
            var u3 = a2[o3 - 1].x + 2 / 3 * (s3.x1 - a2[o3 - 1].x), h3 = a2[o3 - 1].y + 2 / 3 * (s3.y1 - a2[o3 - 1].y), l3 = s3.x + 2 / 3 * (s3.x1 - s3.x), f2 = s3.y + 2 / 3 * (s3.y1 - s3.y), d3 = s3.x, p6 = s3.y;
            r3 = [u3 - a2[o3 - 1].x, h3 - a2[o3 - 1].y, l3 - a2[o3 - 1].x, f2 - a2[o3 - 1].y, d3 - a2[o3 - 1].x, p6 - a2[o3 - 1].y], i3[i3.length - 1].deltas.push(r3);
            break;
          case "arc":
            i3.push({ deltas: [], abs: [], arc: true }), Array.isArray(i3[i3.length - 1].abs) && i3[i3.length - 1].abs.push(s3);
        }
      }
      n3 = e3 ? null : t3 === "stroke" ? "stroke" : "fill";
      for (var g3 = false, b3 = 0; b3 < i3.length; b3++)
        if (i3[b3].arc)
          for (var y3 = i3[b3].abs, w3 = 0; w3 < y3.length; w3++) {
            var N3 = y3[w3];
            N3.type === "arc" ? P2.call(this, N3.x, N3.y, N3.radius, N3.startAngle, N3.endAngle, N3.counterclockwise, void 0, e3, !g3) : j2.call(this, N3.x, N3.y), g3 = true;
          }
        else if (i3[b3].close === true)
          this.pdf.internal.out("h"), g3 = false;
        else if (i3[b3].begin !== true) {
          var L3 = i3[b3].start.x, A3 = i3[b3].start.y;
          O2.call(this, i3[b3].deltas, L3, A3), g3 = true;
        }
      n3 && k2.call(this, n3), e3 && I2.call(this);
    }
  }, S2 = function(t3) {
    var e3 = this.pdf.internal.getFontSize() / this.pdf.internal.scaleFactor, r3 = e3 * (this.pdf.internal.getLineHeightFactor() - 1);
    switch (this.ctx.textBaseline) {
      case "bottom":
        return t3 - r3;
      case "top":
        return t3 + e3 - r3;
      case "hanging":
        return t3 + e3 - 2 * r3;
      case "middle":
        return t3 + e3 / 2 - r3;
      case "ideographic":
        return t3;
      case "alphabetic":
      default:
        return t3;
    }
  }, _2 = function(t3) {
    return t3 + this.pdf.internal.getFontSize() / this.pdf.internal.scaleFactor * (this.pdf.internal.getLineHeightFactor() - 1);
  };
  p5.prototype.createLinearGradient = function() {
    var t3 = function() {
    };
    return t3.colorStops = [], t3.addColorStop = function(t4, e3) {
      this.colorStops.push([t4, e3]);
    }, t3.getColor = function() {
      return this.colorStops.length === 0 ? "#000000" : this.colorStops[0][1];
    }, t3.isCanvasGradient = true, t3;
  }, p5.prototype.createPattern = function() {
    return this.createLinearGradient();
  }, p5.prototype.createRadialGradient = function() {
    return this.createLinearGradient();
  };
  var P2 = function(t3, e3, r3, n3, i3, a2, o3, s3, c3) {
    for (var u3 = M2.call(this, r3, n3, i3, a2), h3 = 0; h3 < u3.length; h3++) {
      var l3 = u3[h3];
      h3 === 0 && (c3 ? F2.call(this, l3.x1 + t3, l3.y1 + e3) : j2.call(this, l3.x1 + t3, l3.y1 + e3)), B3.call(this, t3, e3, l3.x2, l3.y2, l3.x3, l3.y3, l3.x4, l3.y4);
    }
    s3 ? I2.call(this) : k2.call(this, o3);
  }, k2 = function(t3) {
    switch (t3) {
      case "stroke":
        this.pdf.internal.out("S");
        break;
      case "fill":
        this.pdf.internal.out("f");
    }
  }, I2 = function() {
    this.pdf.clip(), this.pdf.discardPath();
  }, F2 = function(t3, e3) {
    this.pdf.internal.out(n2(t3) + " " + i2(e3) + " m");
  }, C2 = function(t3) {
    var e3;
    switch (t3.align) {
      case "right":
      case "end":
        e3 = "right";
        break;
      case "center":
        e3 = "center";
        break;
      case "left":
      case "start":
      default:
        e3 = "left";
    }
    var r3 = this.pdf.getTextDimensions(t3.text), n3 = S2.call(this, t3.y), i3 = _2.call(this, n3) - r3.h, a2 = this.ctx.transform.applyToPoint(new c2(t3.x, n3)), o3 = this.ctx.transform.decompose(), s3 = new h2();
    s3 = (s3 = (s3 = s3.multiply(o3.translate)).multiply(o3.skew)).multiply(o3.scale);
    for (var l3, f2, d3, p6 = this.ctx.transform.applyToRectangle(new u2(t3.x, n3, r3.w, r3.h)), g3 = s3.applyToRectangle(new u2(t3.x, i3, r3.w, r3.h)), m3 = y2.call(this, g3), v3 = [], w3 = 0; w3 < m3.length; w3 += 1)
      v3.indexOf(m3[w3]) === -1 && v3.push(m3[w3]);
    if (L2(v3), this.autoPaging)
      for (var A3 = v3[0], P3 = v3[v3.length - 1], k3 = A3; k3 < P3 + 1; k3++) {
        this.pdf.setPage(k3);
        var I3 = k3 === 1 ? this.posY + this.margin[0] : this.margin[0], F3 = this.pdf.internal.pageSize.height - this.posY - this.margin[0] - this.margin[2], C3 = this.pdf.internal.pageSize.height - this.margin[2], j3 = C3 - this.margin[0], O3 = this.pdf.internal.pageSize.width - this.margin[1], B4 = O3 - this.margin[3], M3 = k3 === 1 ? 0 : F3 + (k3 - 2) * j3;
        if (this.ctx.clip_path.length !== 0) {
          var E3 = this.path;
          l3 = JSON.parse(JSON.stringify(this.ctx.clip_path)), this.path = N2(l3, this.posX + this.margin[3], -1 * M3 + I3), x2.call(this, "fill", true), this.path = E3;
        }
        var q3 = N2([JSON.parse(JSON.stringify(g3))], this.posX + this.margin[3], -M3 + I3 + this.ctx.prevPageLastElemOffset)[0];
        t3.scale >= 0.01 && (f2 = this.pdf.internal.getFontSize(), this.pdf.setFontSize(f2 * t3.scale), d3 = this.lineWidth, this.lineWidth = d3 * t3.scale);
        var D3 = this.autoPaging !== "text";
        if (D3 || q3.y + q3.h <= C3) {
          if (D3 || q3.y >= I3 && q3.x <= O3) {
            var R3 = D3 ? t3.text : this.pdf.splitTextToSize(t3.text, t3.maxWidth || O3 - q3.x)[0], T3 = N2([JSON.parse(JSON.stringify(p6))], this.posX + this.margin[3], -M3 + I3 + this.ctx.prevPageLastElemOffset)[0], z2 = D3 && (k3 > A3 || k3 < P3) && b2.call(this);
            z2 && (this.pdf.saveGraphicsState(), this.pdf.rect(this.margin[3], this.margin[0], B4, j3, null).clip().discardPath()), this.pdf.text(R3, T3.x, T3.y, { angle: t3.angle, align: e3, renderingMode: t3.renderingMode }), z2 && this.pdf.restoreGraphicsState();
          }
        } else
          q3.y < C3 && (this.ctx.prevPageLastElemOffset += C3 - q3.y);
        t3.scale >= 0.01 && (this.pdf.setFontSize(f2), this.lineWidth = d3);
      }
    else
      t3.scale >= 0.01 && (f2 = this.pdf.internal.getFontSize(), this.pdf.setFontSize(f2 * t3.scale), d3 = this.lineWidth, this.lineWidth = d3 * t3.scale), this.pdf.text(t3.text, a2.x + this.posX, a2.y + this.posY, { angle: t3.angle, align: e3, renderingMode: t3.renderingMode, maxWidth: t3.maxWidth }), t3.scale >= 0.01 && (this.pdf.setFontSize(f2), this.lineWidth = d3);
  }, j2 = function(t3, e3, r3, a2) {
    r3 = r3 || 0, a2 = a2 || 0, this.pdf.internal.out(n2(t3 + r3) + " " + i2(e3 + a2) + " l");
  }, O2 = function(t3, e3, r3) {
    return this.pdf.lines(t3, e3, r3, null, null);
  }, B3 = function(t3, e3, n3, i3, a2, c3, u3, h3) {
    this.pdf.internal.out([r2(o2(n3 + t3)), r2(s2(i3 + e3)), r2(o2(a2 + t3)), r2(s2(c3 + e3)), r2(o2(u3 + t3)), r2(s2(h3 + e3)), "c"].join(" "));
  }, M2 = function(t3, e3, r3, n3) {
    for (var i3 = 2 * Math.PI, a2 = Math.PI / 2; e3 > r3; )
      e3 -= i3;
    var o3 = Math.abs(r3 - e3);
    o3 < i3 && n3 && (o3 = i3 - o3);
    for (var s3 = [], c3 = n3 ? -1 : 1, u3 = e3; o3 > 1e-5; ) {
      var h3 = u3 + c3 * Math.min(o3, a2);
      s3.push(E2.call(this, t3, u3, h3)), o3 -= Math.abs(h3 - u3), u3 = h3;
    }
    return s3;
  }, E2 = function(t3, e3, r3) {
    var n3 = (r3 - e3) / 2, i3 = t3 * Math.cos(n3), a2 = t3 * Math.sin(n3), o3 = i3, s3 = -a2, c3 = o3 * o3 + s3 * s3, u3 = c3 + o3 * i3 + s3 * a2, h3 = 4 / 3 * (Math.sqrt(2 * c3 * u3) - u3) / (o3 * a2 - s3 * i3), l3 = o3 - h3 * s3, f2 = s3 + h3 * o3, d3 = l3, p6 = -f2, g3 = n3 + e3, m3 = Math.cos(g3), v3 = Math.sin(g3);
    return { x1: t3 * Math.cos(e3), y1: t3 * Math.sin(e3), x2: l3 * m3 - f2 * v3, y2: l3 * v3 + f2 * m3, x3: d3 * m3 - p6 * v3, y3: d3 * v3 + p6 * m3, x4: t3 * Math.cos(r3), y4: t3 * Math.sin(r3) };
  }, q2 = function(t3) {
    return 180 * t3 / Math.PI;
  }, D2 = function(t3, e3, r3, n3, i3, a2) {
    var o3 = t3 + 0.5 * (r3 - t3), s3 = e3 + 0.5 * (n3 - e3), c3 = i3 + 0.5 * (r3 - i3), h3 = a2 + 0.5 * (n3 - a2), l3 = Math.min(t3, i3, o3, c3), f2 = Math.max(t3, i3, o3, c3), d3 = Math.min(e3, a2, s3, h3), p6 = Math.max(e3, a2, s3, h3);
    return new u2(l3, d3, f2 - l3, p6 - d3);
  }, R2 = function(t3, e3, r3, n3, i3, a2, o3, s3) {
    var c3, h3, l3, f2, d3, p6, g3, m3, v3, b3, y3, w3, N3, L3, A3 = r3 - t3, x3 = n3 - e3, S3 = i3 - r3, _3 = a2 - n3, P3 = o3 - i3, k3 = s3 - a2;
    for (h3 = 0; h3 < 41; h3++)
      v3 = (g3 = (l3 = t3 + (c3 = h3 / 40) * A3) + c3 * ((d3 = r3 + c3 * S3) - l3)) + c3 * (d3 + c3 * (i3 + c3 * P3 - d3) - g3), b3 = (m3 = (f2 = e3 + c3 * x3) + c3 * ((p6 = n3 + c3 * _3) - f2)) + c3 * (p6 + c3 * (a2 + c3 * k3 - p6) - m3), h3 == 0 ? (y3 = v3, w3 = b3, N3 = v3, L3 = b3) : (y3 = Math.min(y3, v3), w3 = Math.min(w3, b3), N3 = Math.max(N3, v3), L3 = Math.max(L3, b3));
    return new u2(Math.round(y3), Math.round(w3), Math.round(N3 - y3), Math.round(L3 - w3));
  }, T2 = function() {
    if (this.prevLineDash || this.ctx.lineDash.length || this.ctx.lineDashOffset) {
      var t3, e3, r3 = (t3 = this.ctx.lineDash, e3 = this.ctx.lineDashOffset, JSON.stringify({ lineDash: t3, lineDashOffset: e3 }));
      this.prevLineDash !== r3 && (this.pdf.setLineDash(this.ctx.lineDash, this.ctx.lineDashOffset), this.prevLineDash = r3);
    }
  };
}(E$1.API), function(t3) {
  var r2 = function(t4) {
    var e2, r3, n3, i3, a3, o2, s2, c2, u2, h2;
    for (/[^\x00-\xFF]/.test(t4), r3 = [], n3 = 0, i3 = (t4 += e2 = "\0\0\0\0".slice(t4.length % 4 || 4)).length; i3 > n3; n3 += 4)
      (a3 = (t4.charCodeAt(n3) << 24) + (t4.charCodeAt(n3 + 1) << 16) + (t4.charCodeAt(n3 + 2) << 8) + t4.charCodeAt(n3 + 3)) !== 0 ? (o2 = (a3 = ((a3 = ((a3 = ((a3 = (a3 - (h2 = a3 % 85)) / 85) - (u2 = a3 % 85)) / 85) - (c2 = a3 % 85)) / 85) - (s2 = a3 % 85)) / 85) % 85, r3.push(o2 + 33, s2 + 33, c2 + 33, u2 + 33, h2 + 33)) : r3.push(122);
    return function(t5, e3) {
      for (var r4 = e3; r4 > 0; r4--)
        t5.pop();
    }(r3, e2.length), String.fromCharCode.apply(String, r3) + "~>";
  }, n2 = function(t4) {
    var e2, r3, n3, i3, a3, o2 = String, s2 = "length", c2 = 255, u2 = "charCodeAt", h2 = "slice", l2 = "replace";
    for (t4[h2](-2), t4 = t4[h2](0, -2)[l2](/\s/g, "")[l2]("z", "!!!!!"), n3 = [], i3 = 0, a3 = (t4 += e2 = "uuuuu"[h2](t4[s2] % 5 || 5))[s2]; a3 > i3; i3 += 5)
      r3 = 52200625 * (t4[u2](i3) - 33) + 614125 * (t4[u2](i3 + 1) - 33) + 7225 * (t4[u2](i3 + 2) - 33) + 85 * (t4[u2](i3 + 3) - 33) + (t4[u2](i3 + 4) - 33), n3.push(c2 & r3 >> 24, c2 & r3 >> 16, c2 & r3 >> 8, c2 & r3);
    return function(t5, e3) {
      for (var r4 = e3; r4 > 0; r4--)
        t5.pop();
    }(n3, e2[s2]), o2.fromCharCode.apply(o2, n3);
  }, i2 = function(t4) {
    var e2 = new RegExp(/^([0-9A-Fa-f]{2})+$/);
    if ((t4 = t4.replace(/\s/g, "")).indexOf(">") !== -1 && (t4 = t4.substr(0, t4.indexOf(">"))), t4.length % 2 && (t4 += "0"), e2.test(t4) === false)
      return "";
    for (var r3 = "", n3 = 0; n3 < t4.length; n3 += 2)
      r3 += String.fromCharCode("0x" + (t4[n3] + t4[n3 + 1]));
    return r3;
  }, a2 = function(t4) {
    for (var r3 = new Uint8Array(t4.length), n3 = t4.length; n3--; )
      r3[n3] = t4.charCodeAt(n3);
    return t4 = (r3 = zlibSync(r3)).reduce(function(t5, e2) {
      return t5 + String.fromCharCode(e2);
    }, "");
  };
  t3.processDataByFilters = function(t4, e2) {
    var o2 = 0, s2 = t4 || "", c2 = [];
    for (typeof (e2 = e2 || []) == "string" && (e2 = [e2]), o2 = 0; o2 < e2.length; o2 += 1)
      switch (e2[o2]) {
        case "ASCII85Decode":
        case "/ASCII85Decode":
          s2 = n2(s2), c2.push("/ASCII85Encode");
          break;
        case "ASCII85Encode":
        case "/ASCII85Encode":
          s2 = r2(s2), c2.push("/ASCII85Decode");
          break;
        case "ASCIIHexDecode":
        case "/ASCIIHexDecode":
          s2 = i2(s2), c2.push("/ASCIIHexEncode");
          break;
        case "ASCIIHexEncode":
        case "/ASCIIHexEncode":
          s2 = s2.split("").map(function(t5) {
            return ("0" + t5.charCodeAt().toString(16)).slice(-2);
          }).join("") + ">", c2.push("/ASCIIHexDecode");
          break;
        case "FlateEncode":
        case "/FlateEncode":
          s2 = a2(s2), c2.push("/FlateDecode");
          break;
        default:
          throw new Error('The filter: "' + e2[o2] + '" is not implemented');
      }
    return { data: s2, reverseChain: c2.reverse().join(" ") };
  };
}(E$1.API), function(t3) {
  t3.loadFile = function(t4, e2, r2) {
    return function(t5, e3, r3) {
      e3 = e3 !== false, r3 = typeof r3 == "function" ? r3 : function() {
      };
      var n2 = void 0;
      try {
        n2 = function(t6, e4, r4) {
          var n3 = new XMLHttpRequest(), i2 = 0, a2 = function(t7) {
            var e5 = t7.length, r5 = [], n4 = String.fromCharCode;
            for (i2 = 0; i2 < e5; i2 += 1)
              r5.push(n4(255 & t7.charCodeAt(i2)));
            return r5.join("");
          };
          if (n3.open("GET", t6, !e4), n3.overrideMimeType("text/plain; charset=x-user-defined"), e4 === false && (n3.onload = function() {
            n3.status === 200 ? r4(a2(this.responseText)) : r4(void 0);
          }), n3.send(null), e4 && n3.status === 200)
            return a2(n3.responseText);
        }(t5, e3, r3);
      } catch (t6) {
      }
      return n2;
    }(t4, e2, r2);
  }, t3.loadImageFile = t3.loadFile;
}(E$1.API), function(e2) {
  function r2() {
    return (n$1.html2canvas ? Promise.resolve(n$1.html2canvas) : Promise.resolve().then(function() {
      return html2canvas_esm;
    })).catch(function(t3) {
      return Promise.reject(new Error("Could not load html2canvas: " + t3));
    }).then(function(t3) {
      return t3.default ? t3.default : t3;
    });
  }
  function i2() {
    return (n$1.DOMPurify ? Promise.resolve(n$1.DOMPurify) : Promise.resolve().then(function() {
      return purify_es;
    })).catch(function(t3) {
      return Promise.reject(new Error("Could not load dompurify: " + t3));
    }).then(function(t3) {
      return t3.default ? t3.default : t3;
    });
  }
  var a2 = function(e3) {
    var r3 = _typeof$2(e3);
    return r3 === "undefined" ? "undefined" : r3 === "string" || e3 instanceof String ? "string" : r3 === "number" || e3 instanceof Number ? "number" : r3 === "function" || e3 instanceof Function ? "function" : e3 && e3.constructor === Array ? "array" : e3 && e3.nodeType === 1 ? "element" : r3 === "object" ? "object" : "unknown";
  }, o2 = function(t3, e3) {
    var r3 = document.createElement(t3);
    for (var n2 in e3.className && (r3.className = e3.className), e3.innerHTML && e3.dompurify && (r3.innerHTML = e3.dompurify.sanitize(e3.innerHTML)), e3.style)
      r3.style[n2] = e3.style[n2];
    return r3;
  }, s2 = function t3(e3) {
    var r3 = Object.assign(t3.convert(Promise.resolve()), JSON.parse(JSON.stringify(t3.template))), n2 = t3.convert(Promise.resolve(), r3);
    return n2 = (n2 = n2.setProgress(1, t3, 1, [t3])).set(e3);
  };
  (s2.prototype = Object.create(Promise.prototype)).constructor = s2, s2.convert = function(t3, e3) {
    return t3.__proto__ = e3 || s2.prototype, t3;
  }, s2.template = { prop: { src: null, container: null, overlay: null, canvas: null, img: null, pdf: null, pageSize: null, callback: function() {
  } }, progress: { val: 0, state: null, n: 0, stack: [] }, opt: { filename: "file.pdf", margin: [0, 0, 0, 0], enableLinks: true, x: 0, y: 0, html2canvas: {}, jsPDF: {}, backgroundColor: "transparent" } }, s2.prototype.from = function(t3, e3) {
    return this.then(function() {
      switch (e3 = e3 || function(t4) {
        switch (a2(t4)) {
          case "string":
            return "string";
          case "element":
            return t4.nodeName.toLowerCase() === "canvas" ? "canvas" : "element";
          default:
            return "unknown";
        }
      }(t3)) {
        case "string":
          return this.then(i2).then(function(e4) {
            return this.set({ src: o2("div", { innerHTML: t3, dompurify: e4 }) });
          });
        case "element":
          return this.set({ src: t3 });
        case "canvas":
          return this.set({ canvas: t3 });
        case "img":
          return this.set({ img: t3 });
        default:
          return this.error("Unknown source type.");
      }
    });
  }, s2.prototype.to = function(t3) {
    switch (t3) {
      case "container":
        return this.toContainer();
      case "canvas":
        return this.toCanvas();
      case "img":
        return this.toImg();
      case "pdf":
        return this.toPdf();
      default:
        return this.error("Invalid target.");
    }
  }, s2.prototype.toContainer = function() {
    return this.thenList([function() {
      return this.prop.src || this.error("Cannot duplicate - no source HTML.");
    }, function() {
      return this.prop.pageSize || this.setPageSize();
    }]).then(function() {
      var t3 = { position: "relative", display: "inline-block", width: (typeof this.opt.width != "number" || isNaN(this.opt.width) || typeof this.opt.windowWidth != "number" || isNaN(this.opt.windowWidth) ? Math.max(this.prop.src.clientWidth, this.prop.src.scrollWidth, this.prop.src.offsetWidth) : this.opt.windowWidth) + "px", left: 0, right: 0, top: 0, margin: "auto", backgroundColor: this.opt.backgroundColor }, e3 = function t4(e4, r3) {
        for (var n2 = e4.nodeType === 3 ? document.createTextNode(e4.nodeValue) : e4.cloneNode(false), i3 = e4.firstChild; i3; i3 = i3.nextSibling)
          r3 !== true && i3.nodeType === 1 && i3.nodeName === "SCRIPT" || n2.appendChild(t4(i3, r3));
        return e4.nodeType === 1 && (e4.nodeName === "CANVAS" ? (n2.width = e4.width, n2.height = e4.height, n2.getContext("2d").drawImage(e4, 0, 0)) : e4.nodeName !== "TEXTAREA" && e4.nodeName !== "SELECT" || (n2.value = e4.value), n2.addEventListener("load", function() {
          n2.scrollTop = e4.scrollTop, n2.scrollLeft = e4.scrollLeft;
        }, true)), n2;
      }(this.prop.src, this.opt.html2canvas.javascriptEnabled);
      e3.tagName === "BODY" && (t3.height = Math.max(document.body.scrollHeight, document.body.offsetHeight, document.documentElement.clientHeight, document.documentElement.scrollHeight, document.documentElement.offsetHeight) + "px"), this.prop.overlay = o2("div", { className: "html2pdf__overlay", style: { position: "fixed", overflow: "hidden", zIndex: 1e3, left: "-100000px", right: 0, bottom: 0, top: 0 } }), this.prop.container = o2("div", { className: "html2pdf__container", style: t3 }), this.prop.container.appendChild(e3), this.prop.container.firstChild.appendChild(o2("div", { style: { clear: "both", border: "0 none transparent", margin: 0, padding: 0, height: 0 } })), this.prop.container.style.float = "none", this.prop.overlay.appendChild(this.prop.container), document.body.appendChild(this.prop.overlay), this.prop.container.firstChild.style.position = "relative", this.prop.container.height = Math.max(this.prop.container.firstChild.clientHeight, this.prop.container.firstChild.scrollHeight, this.prop.container.firstChild.offsetHeight) + "px";
    });
  }, s2.prototype.toCanvas = function() {
    var t3 = [function() {
      return document.body.contains(this.prop.container) || this.toContainer();
    }];
    return this.thenList(t3).then(r2).then(function(t4) {
      var e3 = Object.assign({}, this.opt.html2canvas);
      return delete e3.onrendered, t4(this.prop.container, e3);
    }).then(function(t4) {
      (this.opt.html2canvas.onrendered || function() {
      })(t4), this.prop.canvas = t4, document.body.removeChild(this.prop.overlay);
    });
  }, s2.prototype.toContext2d = function() {
    var t3 = [function() {
      return document.body.contains(this.prop.container) || this.toContainer();
    }];
    return this.thenList(t3).then(r2).then(function(t4) {
      var e3 = this.opt.jsPDF, r3 = this.opt.fontFaces, n2 = typeof this.opt.width != "number" || isNaN(this.opt.width) || typeof this.opt.windowWidth != "number" || isNaN(this.opt.windowWidth) ? 1 : this.opt.width / this.opt.windowWidth, i3 = Object.assign({ async: true, allowTaint: true, scale: n2, scrollX: this.opt.scrollX || 0, scrollY: this.opt.scrollY || 0, backgroundColor: "#ffffff", imageTimeout: 15e3, logging: true, proxy: null, removeContainer: true, foreignObjectRendering: false, useCORS: false }, this.opt.html2canvas);
      if (delete i3.onrendered, e3.context2d.autoPaging = this.opt.autoPaging === void 0 || this.opt.autoPaging, e3.context2d.posX = this.opt.x, e3.context2d.posY = this.opt.y, e3.context2d.margin = this.opt.margin, e3.context2d.fontFaces = r3, r3)
        for (var a3 = 0; a3 < r3.length; ++a3) {
          var o3 = r3[a3], s3 = o3.src.find(function(t5) {
            return t5.format === "truetype";
          });
          s3 && e3.addFont(s3.url, o3.ref.name, o3.ref.style);
        }
      return i3.windowHeight = i3.windowHeight || 0, i3.windowHeight = i3.windowHeight == 0 ? Math.max(this.prop.container.clientHeight, this.prop.container.scrollHeight, this.prop.container.offsetHeight) : i3.windowHeight, e3.context2d.save(true), t4(this.prop.container, i3);
    }).then(function(t4) {
      this.opt.jsPDF.context2d.restore(true), (this.opt.html2canvas.onrendered || function() {
      })(t4), this.prop.canvas = t4, document.body.removeChild(this.prop.overlay);
    });
  }, s2.prototype.toImg = function() {
    return this.thenList([function() {
      return this.prop.canvas || this.toCanvas();
    }]).then(function() {
      var t3 = this.prop.canvas.toDataURL("image/" + this.opt.image.type, this.opt.image.quality);
      this.prop.img = document.createElement("img"), this.prop.img.src = t3;
    });
  }, s2.prototype.toPdf = function() {
    return this.thenList([function() {
      return this.toContext2d();
    }]).then(function() {
      this.prop.pdf = this.prop.pdf || this.opt.jsPDF;
    });
  }, s2.prototype.output = function(t3, e3, r3) {
    return (r3 = r3 || "pdf").toLowerCase() === "img" || r3.toLowerCase() === "image" ? this.outputImg(t3, e3) : this.outputPdf(t3, e3);
  }, s2.prototype.outputPdf = function(t3, e3) {
    return this.thenList([function() {
      return this.prop.pdf || this.toPdf();
    }]).then(function() {
      return this.prop.pdf.output(t3, e3);
    });
  }, s2.prototype.outputImg = function(t3) {
    return this.thenList([function() {
      return this.prop.img || this.toImg();
    }]).then(function() {
      switch (t3) {
        case void 0:
        case "img":
          return this.prop.img;
        case "datauristring":
        case "dataurlstring":
          return this.prop.img.src;
        case "datauri":
        case "dataurl":
          return document.location.href = this.prop.img.src;
        default:
          throw 'Image output type "' + t3 + '" is not supported.';
      }
    });
  }, s2.prototype.save = function(t3) {
    return this.thenList([function() {
      return this.prop.pdf || this.toPdf();
    }]).set(t3 ? { filename: t3 } : null).then(function() {
      this.prop.pdf.save(this.opt.filename);
    });
  }, s2.prototype.doCallback = function() {
    return this.thenList([function() {
      return this.prop.pdf || this.toPdf();
    }]).then(function() {
      this.prop.callback(this.prop.pdf);
    });
  }, s2.prototype.set = function(t3) {
    if (a2(t3) !== "object")
      return this;
    var e3 = Object.keys(t3 || {}).map(function(e4) {
      if (e4 in s2.template.prop)
        return function() {
          this.prop[e4] = t3[e4];
        };
      switch (e4) {
        case "margin":
          return this.setMargin.bind(this, t3.margin);
        case "jsPDF":
          return function() {
            return this.opt.jsPDF = t3.jsPDF, this.setPageSize();
          };
        case "pageSize":
          return this.setPageSize.bind(this, t3.pageSize);
        default:
          return function() {
            this.opt[e4] = t3[e4];
          };
      }
    }, this);
    return this.then(function() {
      return this.thenList(e3);
    });
  }, s2.prototype.get = function(t3, e3) {
    return this.then(function() {
      var r3 = t3 in s2.template.prop ? this.prop[t3] : this.opt[t3];
      return e3 ? e3(r3) : r3;
    });
  }, s2.prototype.setMargin = function(t3) {
    return this.then(function() {
      switch (a2(t3)) {
        case "number":
          t3 = [t3, t3, t3, t3];
        case "array":
          if (t3.length === 2 && (t3 = [t3[0], t3[1], t3[0], t3[1]]), t3.length === 4)
            break;
        default:
          return this.error("Invalid margin array.");
      }
      this.opt.margin = t3;
    }).then(this.setPageSize);
  }, s2.prototype.setPageSize = function(t3) {
    function e3(t4, e4) {
      return Math.floor(t4 * e4 / 72 * 96);
    }
    return this.then(function() {
      (t3 = t3 || E$1.getPageSize(this.opt.jsPDF)).hasOwnProperty("inner") || (t3.inner = { width: t3.width - this.opt.margin[1] - this.opt.margin[3], height: t3.height - this.opt.margin[0] - this.opt.margin[2] }, t3.inner.px = { width: e3(t3.inner.width, t3.k), height: e3(t3.inner.height, t3.k) }, t3.inner.ratio = t3.inner.height / t3.inner.width), this.prop.pageSize = t3;
    });
  }, s2.prototype.setProgress = function(t3, e3, r3, n2) {
    return t3 != null && (this.progress.val = t3), e3 != null && (this.progress.state = e3), r3 != null && (this.progress.n = r3), n2 != null && (this.progress.stack = n2), this.progress.ratio = this.progress.val / this.progress.state, this;
  }, s2.prototype.updateProgress = function(t3, e3, r3, n2) {
    return this.setProgress(t3 ? this.progress.val + t3 : null, e3 || null, r3 ? this.progress.n + r3 : null, n2 ? this.progress.stack.concat(n2) : null);
  }, s2.prototype.then = function(t3, e3) {
    var r3 = this;
    return this.thenCore(t3, e3, function(t4, e4) {
      return r3.updateProgress(null, null, 1, [t4]), Promise.prototype.then.call(this, function(e5) {
        return r3.updateProgress(null, t4), e5;
      }).then(t4, e4).then(function(t5) {
        return r3.updateProgress(1), t5;
      });
    });
  }, s2.prototype.thenCore = function(t3, e3, r3) {
    r3 = r3 || Promise.prototype.then;
    t3 && (t3 = t3.bind(this)), e3 && (e3 = e3.bind(this));
    var n2 = Promise.toString().indexOf("[native code]") !== -1 && Promise.name === "Promise" ? this : s2.convert(Object.assign({}, this), Promise.prototype), i3 = r3.call(n2, t3, e3);
    return s2.convert(i3, this.__proto__);
  }, s2.prototype.thenExternal = function(t3, e3) {
    return Promise.prototype.then.call(this, t3, e3);
  }, s2.prototype.thenList = function(t3) {
    var e3 = this;
    return t3.forEach(function(t4) {
      e3 = e3.thenCore(t4);
    }), e3;
  }, s2.prototype.catch = function(t3) {
    t3 && (t3 = t3.bind(this));
    var e3 = Promise.prototype.catch.call(this, t3);
    return s2.convert(e3, this);
  }, s2.prototype.catchExternal = function(t3) {
    return Promise.prototype.catch.call(this, t3);
  }, s2.prototype.error = function(t3) {
    return this.then(function() {
      throw new Error(t3);
    });
  }, s2.prototype.using = s2.prototype.set, s2.prototype.saveAs = s2.prototype.save, s2.prototype.export = s2.prototype.output, s2.prototype.run = s2.prototype.then, E$1.getPageSize = function(e3, r3, n2) {
    if (_typeof$2(e3) === "object") {
      var i3 = e3;
      e3 = i3.orientation, r3 = i3.unit || r3, n2 = i3.format || n2;
    }
    r3 = r3 || "mm", n2 = n2 || "a4", e3 = ("" + (e3 || "P")).toLowerCase();
    var a3, o3 = ("" + n2).toLowerCase(), s3 = { a0: [2383.94, 3370.39], a1: [1683.78, 2383.94], a2: [1190.55, 1683.78], a3: [841.89, 1190.55], a4: [595.28, 841.89], a5: [419.53, 595.28], a6: [297.64, 419.53], a7: [209.76, 297.64], a8: [147.4, 209.76], a9: [104.88, 147.4], a10: [73.7, 104.88], b0: [2834.65, 4008.19], b1: [2004.09, 2834.65], b2: [1417.32, 2004.09], b3: [1000.63, 1417.32], b4: [708.66, 1000.63], b5: [498.9, 708.66], b6: [354.33, 498.9], b7: [249.45, 354.33], b8: [175.75, 249.45], b9: [124.72, 175.75], b10: [87.87, 124.72], c0: [2599.37, 3676.54], c1: [1836.85, 2599.37], c2: [1298.27, 1836.85], c3: [918.43, 1298.27], c4: [649.13, 918.43], c5: [459.21, 649.13], c6: [323.15, 459.21], c7: [229.61, 323.15], c8: [161.57, 229.61], c9: [113.39, 161.57], c10: [79.37, 113.39], dl: [311.81, 623.62], letter: [612, 792], "government-letter": [576, 756], legal: [612, 1008], "junior-legal": [576, 360], ledger: [1224, 792], tabloid: [792, 1224], "credit-card": [153, 243] };
    switch (r3) {
      case "pt":
        a3 = 1;
        break;
      case "mm":
        a3 = 72 / 25.4;
        break;
      case "cm":
        a3 = 72 / 2.54;
        break;
      case "in":
        a3 = 72;
        break;
      case "px":
        a3 = 0.75;
        break;
      case "pc":
      case "em":
        a3 = 12;
        break;
      case "ex":
        a3 = 6;
        break;
      default:
        throw "Invalid unit: " + r3;
    }
    var c2, u2 = 0, h2 = 0;
    if (s3.hasOwnProperty(o3))
      u2 = s3[o3][1] / a3, h2 = s3[o3][0] / a3;
    else
      try {
        u2 = n2[1], h2 = n2[0];
      } catch (t3) {
        throw new Error("Invalid format: " + n2);
      }
    if (e3 === "p" || e3 === "portrait")
      e3 = "p", h2 > u2 && (c2 = h2, h2 = u2, u2 = c2);
    else {
      if (e3 !== "l" && e3 !== "landscape")
        throw "Invalid orientation: " + e3;
      e3 = "l", u2 > h2 && (c2 = h2, h2 = u2, u2 = c2);
    }
    return { width: h2, height: u2, unit: r3, k: a3, orientation: e3 };
  }, e2.html = function(t3, e3) {
    (e3 = e3 || {}).callback = e3.callback || function() {
    }, e3.html2canvas = e3.html2canvas || {}, e3.html2canvas.canvas = e3.html2canvas.canvas || this.canvas, e3.jsPDF = e3.jsPDF || this, e3.fontFaces = e3.fontFaces ? e3.fontFaces.map(jt) : null;
    var r3 = new s2(e3);
    return e3.worker ? r3 : r3.from(t3).doCallback();
  };
}(E$1.API), E$1.API.addJS = function(t3) {
  return Ht = t3, this.internal.events.subscribe("postPutResources", function() {
    zt = this.internal.newObject(), this.internal.out("<<"), this.internal.out("/Names [(EmbeddedJS) " + (zt + 1) + " 0 R]"), this.internal.out(">>"), this.internal.out("endobj"), Ut = this.internal.newObject(), this.internal.out("<<"), this.internal.out("/S /JavaScript"), this.internal.out("/JS (" + Ht + ")"), this.internal.out(">>"), this.internal.out("endobj");
  }), this.internal.events.subscribe("putCatalog", function() {
    zt !== void 0 && Ut !== void 0 && this.internal.out("/Names <</JavaScript " + zt + " 0 R>>");
  }), this;
}, function(t3) {
  var e2;
  t3.events.push(["postPutResources", function() {
    var t4 = this, r2 = /^(\d+) 0 obj$/;
    if (this.outline.root.children.length > 0)
      for (var n2 = t4.outline.render().split(/\r\n/), i2 = 0; i2 < n2.length; i2++) {
        var a2 = n2[i2], o2 = r2.exec(a2);
        if (o2 != null) {
          var s2 = o2[1];
          t4.internal.newObjectDeferredBegin(s2, false);
        }
        t4.internal.write(a2);
      }
    if (this.outline.createNamedDestinations) {
      var c2 = this.internal.pages.length, u2 = [];
      for (i2 = 0; i2 < c2; i2++) {
        var h2 = t4.internal.newObject();
        u2.push(h2);
        var l2 = t4.internal.getPageInfo(i2 + 1);
        t4.internal.write("<< /D[" + l2.objId + " 0 R /XYZ null null null]>> endobj");
      }
      var f2 = t4.internal.newObject();
      t4.internal.write("<< /Names [ ");
      for (i2 = 0; i2 < u2.length; i2++)
        t4.internal.write("(page_" + (i2 + 1) + ")" + u2[i2] + " 0 R");
      t4.internal.write(" ] >>", "endobj"), e2 = t4.internal.newObject(), t4.internal.write("<< /Dests " + f2 + " 0 R"), t4.internal.write(">>", "endobj");
    }
  }]), t3.events.push(["putCatalog", function() {
    this.outline.root.children.length > 0 && (this.internal.write("/Outlines", this.outline.makeRef(this.outline.root)), this.outline.createNamedDestinations && this.internal.write("/Names " + e2 + " 0 R"));
  }]), t3.events.push(["initialized", function() {
    var t4 = this;
    t4.outline = { createNamedDestinations: false, root: { children: [] } }, t4.outline.add = function(t5, e3, r2) {
      var n2 = { title: e3, options: r2, children: [] };
      return t5 == null && (t5 = this.root), t5.children.push(n2), n2;
    }, t4.outline.render = function() {
      return this.ctx = {}, this.ctx.val = "", this.ctx.pdf = t4, this.genIds_r(this.root), this.renderRoot(this.root), this.renderItems(this.root), this.ctx.val;
    }, t4.outline.genIds_r = function(e3) {
      e3.id = t4.internal.newObjectDeferred();
      for (var r2 = 0; r2 < e3.children.length; r2++)
        this.genIds_r(e3.children[r2]);
    }, t4.outline.renderRoot = function(t5) {
      this.objStart(t5), this.line("/Type /Outlines"), t5.children.length > 0 && (this.line("/First " + this.makeRef(t5.children[0])), this.line("/Last " + this.makeRef(t5.children[t5.children.length - 1]))), this.line("/Count " + this.count_r({ count: 0 }, t5)), this.objEnd();
    }, t4.outline.renderItems = function(e3) {
      for (var r2 = this.ctx.pdf.internal.getVerticalCoordinateString, n2 = 0; n2 < e3.children.length; n2++) {
        var i2 = e3.children[n2];
        this.objStart(i2), this.line("/Title " + this.makeString(i2.title)), this.line("/Parent " + this.makeRef(e3)), n2 > 0 && this.line("/Prev " + this.makeRef(e3.children[n2 - 1])), n2 < e3.children.length - 1 && this.line("/Next " + this.makeRef(e3.children[n2 + 1])), i2.children.length > 0 && (this.line("/First " + this.makeRef(i2.children[0])), this.line("/Last " + this.makeRef(i2.children[i2.children.length - 1])));
        var a2 = this.count = this.count_r({ count: 0 }, i2);
        if (a2 > 0 && this.line("/Count " + a2), i2.options && i2.options.pageNumber) {
          var o2 = t4.internal.getPageInfo(i2.options.pageNumber);
          this.line("/Dest [" + o2.objId + " 0 R /XYZ 0 " + r2(0) + " 0]");
        }
        this.objEnd();
      }
      for (var s2 = 0; s2 < e3.children.length; s2++)
        this.renderItems(e3.children[s2]);
    }, t4.outline.line = function(t5) {
      this.ctx.val += t5 + "\r\n";
    }, t4.outline.makeRef = function(t5) {
      return t5.id + " 0 R";
    }, t4.outline.makeString = function(e3) {
      return "(" + t4.internal.pdfEscape(e3) + ")";
    }, t4.outline.objStart = function(t5) {
      this.ctx.val += "\r\n" + t5.id + " 0 obj\r\n<<\r\n";
    }, t4.outline.objEnd = function() {
      this.ctx.val += ">> \r\nendobj\r\n";
    }, t4.outline.count_r = function(t5, e3) {
      for (var r2 = 0; r2 < e3.children.length; r2++)
        t5.count++, this.count_r(t5, e3.children[r2]);
      return t5.count;
    };
  }]);
}(E$1.API), function(t3) {
  var e2 = [192, 193, 194, 195, 196, 197, 198, 199];
  t3.processJPEG = function(t4, r2, n2, i2, a2, o2) {
    var s2, c2 = this.decode.DCT_DECODE, u2 = null;
    if (typeof t4 == "string" || this.__addimage__.isArrayBuffer(t4) || this.__addimage__.isArrayBufferView(t4)) {
      switch (t4 = a2 || t4, t4 = this.__addimage__.isArrayBuffer(t4) ? new Uint8Array(t4) : t4, (s2 = function(t5) {
        for (var r3, n3 = 256 * t5.charCodeAt(4) + t5.charCodeAt(5), i3 = t5.length, a3 = { width: 0, height: 0, numcomponents: 1 }, o3 = 4; o3 < i3; o3 += 2) {
          if (o3 += n3, e2.indexOf(t5.charCodeAt(o3 + 1)) !== -1) {
            r3 = 256 * t5.charCodeAt(o3 + 5) + t5.charCodeAt(o3 + 6), a3 = { width: 256 * t5.charCodeAt(o3 + 7) + t5.charCodeAt(o3 + 8), height: r3, numcomponents: t5.charCodeAt(o3 + 9) };
            break;
          }
          n3 = 256 * t5.charCodeAt(o3 + 2) + t5.charCodeAt(o3 + 3);
        }
        return a3;
      }(t4 = this.__addimage__.isArrayBufferView(t4) ? this.__addimage__.arrayBufferToBinaryString(t4) : t4)).numcomponents) {
        case 1:
          o2 = this.color_spaces.DEVICE_GRAY;
          break;
        case 4:
          o2 = this.color_spaces.DEVICE_CMYK;
          break;
        case 3:
          o2 = this.color_spaces.DEVICE_RGB;
      }
      u2 = { data: t4, width: s2.width, height: s2.height, colorSpace: o2, bitsPerComponent: 8, filter: c2, index: r2, alias: n2 };
    }
    return u2;
  };
}(E$1.API);
var Vt;
var Gt;
var Yt;
var Jt;
var Xt;
var Kt = function() {
  var t3, e2, i2;
  function a2(t4) {
    var e3, r2, n2, i3, a3, o3, s2, c2, u2, h2, l2, f2, d2, p5;
    for (this.data = t4, this.pos = 8, this.palette = [], this.imgData = [], this.transparency = {}, this.animation = null, this.text = {}, o3 = null; ; ) {
      switch (e3 = this.readUInt32(), u2 = function() {
        var t5, e4;
        for (e4 = [], t5 = 0; t5 < 4; ++t5)
          e4.push(String.fromCharCode(this.data[this.pos++]));
        return e4;
      }.call(this).join("")) {
        case "IHDR":
          this.width = this.readUInt32(), this.height = this.readUInt32(), this.bits = this.data[this.pos++], this.colorType = this.data[this.pos++], this.compressionMethod = this.data[this.pos++], this.filterMethod = this.data[this.pos++], this.interlaceMethod = this.data[this.pos++];
          break;
        case "acTL":
          this.animation = { numFrames: this.readUInt32(), numPlays: this.readUInt32() || 1 / 0, frames: [] };
          break;
        case "PLTE":
          this.palette = this.read(e3);
          break;
        case "fcTL":
          o3 && this.animation.frames.push(o3), this.pos += 4, o3 = { width: this.readUInt32(), height: this.readUInt32(), xOffset: this.readUInt32(), yOffset: this.readUInt32() }, a3 = this.readUInt16(), i3 = this.readUInt16() || 100, o3.delay = 1e3 * a3 / i3, o3.disposeOp = this.data[this.pos++], o3.blendOp = this.data[this.pos++], o3.data = [];
          break;
        case "IDAT":
        case "fdAT":
          for (u2 === "fdAT" && (this.pos += 4, e3 -= 4), t4 = (o3 != null ? o3.data : void 0) || this.imgData, f2 = 0; 0 <= e3 ? f2 < e3 : f2 > e3; 0 <= e3 ? ++f2 : --f2)
            t4.push(this.data[this.pos++]);
          break;
        case "tRNS":
          switch (this.transparency = {}, this.colorType) {
            case 3:
              if (n2 = this.palette.length / 3, this.transparency.indexed = this.read(e3), this.transparency.indexed.length > n2)
                throw new Error("More transparent colors than palette size");
              if ((h2 = n2 - this.transparency.indexed.length) > 0)
                for (d2 = 0; 0 <= h2 ? d2 < h2 : d2 > h2; 0 <= h2 ? ++d2 : --d2)
                  this.transparency.indexed.push(255);
              break;
            case 0:
              this.transparency.grayscale = this.read(e3)[0];
              break;
            case 2:
              this.transparency.rgb = this.read(e3);
          }
          break;
        case "tEXt":
          s2 = (l2 = this.read(e3)).indexOf(0), c2 = String.fromCharCode.apply(String, l2.slice(0, s2)), this.text[c2] = String.fromCharCode.apply(String, l2.slice(s2 + 1));
          break;
        case "IEND":
          return o3 && this.animation.frames.push(o3), this.colors = function() {
            switch (this.colorType) {
              case 0:
              case 3:
              case 4:
                return 1;
              case 2:
              case 6:
                return 3;
            }
          }.call(this), this.hasAlphaChannel = (p5 = this.colorType) === 4 || p5 === 6, r2 = this.colors + (this.hasAlphaChannel ? 1 : 0), this.pixelBitlength = this.bits * r2, this.colorSpace = function() {
            switch (this.colors) {
              case 1:
                return "DeviceGray";
              case 3:
                return "DeviceRGB";
            }
          }.call(this), void (this.imgData = new Uint8Array(this.imgData));
        default:
          this.pos += e3;
      }
      if (this.pos += 4, this.pos > this.data.length)
        throw new Error("Incomplete or corrupt PNG file");
    }
  }
  a2.prototype.read = function(t4) {
    var e3, r2;
    for (r2 = [], e3 = 0; 0 <= t4 ? e3 < t4 : e3 > t4; 0 <= t4 ? ++e3 : --e3)
      r2.push(this.data[this.pos++]);
    return r2;
  }, a2.prototype.readUInt32 = function() {
    return this.data[this.pos++] << 24 | this.data[this.pos++] << 16 | this.data[this.pos++] << 8 | this.data[this.pos++];
  }, a2.prototype.readUInt16 = function() {
    return this.data[this.pos++] << 8 | this.data[this.pos++];
  }, a2.prototype.decodePixels = function(t4) {
    var e3 = this.pixelBitlength / 8, n2 = new Uint8Array(this.width * this.height * e3), i3 = 0, a3 = this;
    if (t4 == null && (t4 = this.imgData), t4.length === 0)
      return new Uint8Array(0);
    function o3(r2, o4, s2, c2) {
      var u2, h2, l2, f2, d2, p5, g2, m2, v2, b2, y2, w2, N2, L2, A2, x2, S2, _2, P2, k2, I2, F2 = Math.ceil((a3.width - r2) / s2), C2 = Math.ceil((a3.height - o4) / c2), j2 = a3.width == F2 && a3.height == C2;
      for (L2 = e3 * F2, w2 = j2 ? n2 : new Uint8Array(L2 * C2), p5 = t4.length, N2 = 0, h2 = 0; N2 < C2 && i3 < p5; ) {
        switch (t4[i3++]) {
          case 0:
            for (f2 = S2 = 0; S2 < L2; f2 = S2 += 1)
              w2[h2++] = t4[i3++];
            break;
          case 1:
            for (f2 = _2 = 0; _2 < L2; f2 = _2 += 1)
              u2 = t4[i3++], d2 = f2 < e3 ? 0 : w2[h2 - e3], w2[h2++] = (u2 + d2) % 256;
            break;
          case 2:
            for (f2 = P2 = 0; P2 < L2; f2 = P2 += 1)
              u2 = t4[i3++], l2 = (f2 - f2 % e3) / e3, A2 = N2 && w2[(N2 - 1) * L2 + l2 * e3 + f2 % e3], w2[h2++] = (A2 + u2) % 256;
            break;
          case 3:
            for (f2 = k2 = 0; k2 < L2; f2 = k2 += 1)
              u2 = t4[i3++], l2 = (f2 - f2 % e3) / e3, d2 = f2 < e3 ? 0 : w2[h2 - e3], A2 = N2 && w2[(N2 - 1) * L2 + l2 * e3 + f2 % e3], w2[h2++] = (u2 + Math.floor((d2 + A2) / 2)) % 256;
            break;
          case 4:
            for (f2 = I2 = 0; I2 < L2; f2 = I2 += 1)
              u2 = t4[i3++], l2 = (f2 - f2 % e3) / e3, d2 = f2 < e3 ? 0 : w2[h2 - e3], N2 === 0 ? A2 = x2 = 0 : (A2 = w2[(N2 - 1) * L2 + l2 * e3 + f2 % e3], x2 = l2 && w2[(N2 - 1) * L2 + (l2 - 1) * e3 + f2 % e3]), g2 = d2 + A2 - x2, m2 = Math.abs(g2 - d2), b2 = Math.abs(g2 - A2), y2 = Math.abs(g2 - x2), v2 = m2 <= b2 && m2 <= y2 ? d2 : b2 <= y2 ? A2 : x2, w2[h2++] = (u2 + v2) % 256;
            break;
          default:
            throw new Error("Invalid filter algorithm: " + t4[i3 - 1]);
        }
        if (!j2) {
          var O2 = ((o4 + N2 * c2) * a3.width + r2) * e3, B3 = N2 * L2;
          for (f2 = 0; f2 < F2; f2 += 1) {
            for (var M2 = 0; M2 < e3; M2 += 1)
              n2[O2++] = w2[B3++];
            O2 += (s2 - 1) * e3;
          }
        }
        N2++;
      }
    }
    return t4 = unzlibSync(t4), a3.interlaceMethod == 1 ? (o3(0, 0, 8, 8), o3(4, 0, 8, 8), o3(0, 4, 4, 8), o3(2, 0, 4, 4), o3(0, 2, 2, 4), o3(1, 0, 2, 2), o3(0, 1, 1, 2)) : o3(0, 0, 1, 1), n2;
  }, a2.prototype.decodePalette = function() {
    var t4, e3, r2, n2, i3, a3, o3, s2, c2;
    for (r2 = this.palette, a3 = this.transparency.indexed || [], i3 = new Uint8Array((a3.length || 0) + r2.length), n2 = 0, t4 = 0, e3 = o3 = 0, s2 = r2.length; o3 < s2; e3 = o3 += 3)
      i3[n2++] = r2[e3], i3[n2++] = r2[e3 + 1], i3[n2++] = r2[e3 + 2], i3[n2++] = (c2 = a3[t4++]) != null ? c2 : 255;
    return i3;
  }, a2.prototype.copyToImageData = function(t4, e3) {
    var r2, n2, i3, a3, o3, s2, c2, u2, h2, l2, f2;
    if (n2 = this.colors, h2 = null, r2 = this.hasAlphaChannel, this.palette.length && (h2 = (f2 = this._decodedPalette) != null ? f2 : this._decodedPalette = this.decodePalette(), n2 = 4, r2 = true), u2 = (i3 = t4.data || t4).length, o3 = h2 || e3, a3 = s2 = 0, n2 === 1)
      for (; a3 < u2; )
        c2 = h2 ? 4 * e3[a3 / 4] : s2, l2 = o3[c2++], i3[a3++] = l2, i3[a3++] = l2, i3[a3++] = l2, i3[a3++] = r2 ? o3[c2++] : 255, s2 = c2;
    else
      for (; a3 < u2; )
        c2 = h2 ? 4 * e3[a3 / 4] : s2, i3[a3++] = o3[c2++], i3[a3++] = o3[c2++], i3[a3++] = o3[c2++], i3[a3++] = r2 ? o3[c2++] : 255, s2 = c2;
  }, a2.prototype.decode = function() {
    var t4;
    return t4 = new Uint8Array(this.width * this.height * 4), this.copyToImageData(t4, this.decodePixels()), t4;
  };
  var o2 = function() {
    if (Object.prototype.toString.call(n$1) === "[object Window]") {
      try {
        e2 = n$1.document.createElement("canvas"), i2 = e2.getContext("2d");
      } catch (t4) {
        return false;
      }
      return true;
    }
    return false;
  };
  return o2(), t3 = function(t4) {
    var r2;
    if (o2() === true)
      return i2.width = t4.width, i2.height = t4.height, i2.clearRect(0, 0, t4.width, t4.height), i2.putImageData(t4, 0, 0), (r2 = new Image()).src = e2.toDataURL(), r2;
    throw new Error("This method requires a Browser with Canvas-capability.");
  }, a2.prototype.decodeFrames = function(e3) {
    var r2, n2, i3, a3, o3, s2, c2, u2;
    if (this.animation) {
      for (u2 = [], n2 = o3 = 0, s2 = (c2 = this.animation.frames).length; o3 < s2; n2 = ++o3)
        r2 = c2[n2], i3 = e3.createImageData(r2.width, r2.height), a3 = this.decodePixels(new Uint8Array(r2.data)), this.copyToImageData(i3, a3), r2.imageData = i3, u2.push(r2.image = t3(i3));
      return u2;
    }
  }, a2.prototype.renderFrame = function(t4, e3) {
    var r2, n2, i3;
    return r2 = (n2 = this.animation.frames)[e3], i3 = n2[e3 - 1], e3 === 0 && t4.clearRect(0, 0, this.width, this.height), (i3 != null ? i3.disposeOp : void 0) === 1 ? t4.clearRect(i3.xOffset, i3.yOffset, i3.width, i3.height) : (i3 != null ? i3.disposeOp : void 0) === 2 && t4.putImageData(i3.imageData, i3.xOffset, i3.yOffset), r2.blendOp === 0 && t4.clearRect(r2.xOffset, r2.yOffset, r2.width, r2.height), t4.drawImage(r2.image, r2.xOffset, r2.yOffset);
  }, a2.prototype.animate = function(t4) {
    var e3, r2, n2, i3, a3, o3, s2 = this;
    return r2 = 0, o3 = this.animation, i3 = o3.numFrames, n2 = o3.frames, a3 = o3.numPlays, (e3 = function() {
      var o4, c2;
      if (o4 = r2++ % i3, c2 = n2[o4], s2.renderFrame(t4, o4), i3 > 1 && r2 / i3 < a3)
        return s2.animation._timeout = setTimeout(e3, c2.delay);
    })();
  }, a2.prototype.stopAnimation = function() {
    var t4;
    return clearTimeout((t4 = this.animation) != null ? t4._timeout : void 0);
  }, a2.prototype.render = function(t4) {
    var e3, r2;
    return t4._png && t4._png.stopAnimation(), t4._png = this, t4.width = this.width, t4.height = this.height, e3 = t4.getContext("2d"), this.animation ? (this.decodeFrames(e3), this.animate(e3)) : (r2 = e3.createImageData(this.width, this.height), this.copyToImageData(r2, this.decodePixels()), e3.putImageData(r2, 0, 0));
  }, a2;
}();
function Zt(t3) {
  var e2 = 0;
  if (t3[e2++] !== 71 || t3[e2++] !== 73 || t3[e2++] !== 70 || t3[e2++] !== 56 || (t3[e2++] + 1 & 253) != 56 || t3[e2++] !== 97)
    throw new Error("Invalid GIF 87a/89a header.");
  var r2 = t3[e2++] | t3[e2++] << 8, n2 = t3[e2++] | t3[e2++] << 8, i2 = t3[e2++], a2 = i2 >> 7, o2 = 1 << (7 & i2) + 1;
  t3[e2++];
  t3[e2++];
  var s2 = null, c2 = null;
  a2 && (s2 = e2, c2 = o2, e2 += 3 * o2);
  var u2 = true, h2 = [], l2 = 0, f2 = null, d2 = 0, p5 = null;
  for (this.width = r2, this.height = n2; u2 && e2 < t3.length; )
    switch (t3[e2++]) {
      case 33:
        switch (t3[e2++]) {
          case 255:
            if (t3[e2] !== 11 || t3[e2 + 1] == 78 && t3[e2 + 2] == 69 && t3[e2 + 3] == 84 && t3[e2 + 4] == 83 && t3[e2 + 5] == 67 && t3[e2 + 6] == 65 && t3[e2 + 7] == 80 && t3[e2 + 8] == 69 && t3[e2 + 9] == 50 && t3[e2 + 10] == 46 && t3[e2 + 11] == 48 && t3[e2 + 12] == 3 && t3[e2 + 13] == 1 && t3[e2 + 16] == 0)
              e2 += 14, p5 = t3[e2++] | t3[e2++] << 8, e2++;
            else
              for (e2 += 12; ; ) {
                if (!((P2 = t3[e2++]) >= 0))
                  throw Error("Invalid block size");
                if (P2 === 0)
                  break;
                e2 += P2;
              }
            break;
          case 249:
            if (t3[e2++] !== 4 || t3[e2 + 4] !== 0)
              throw new Error("Invalid graphics extension block.");
            var g2 = t3[e2++];
            l2 = t3[e2++] | t3[e2++] << 8, f2 = t3[e2++], (1 & g2) == 0 && (f2 = null), d2 = g2 >> 2 & 7, e2++;
            break;
          case 254:
            for (; ; ) {
              if (!((P2 = t3[e2++]) >= 0))
                throw Error("Invalid block size");
              if (P2 === 0)
                break;
              e2 += P2;
            }
            break;
          default:
            throw new Error("Unknown graphic control label: 0x" + t3[e2 - 1].toString(16));
        }
        break;
      case 44:
        var m2 = t3[e2++] | t3[e2++] << 8, v2 = t3[e2++] | t3[e2++] << 8, b2 = t3[e2++] | t3[e2++] << 8, y2 = t3[e2++] | t3[e2++] << 8, w2 = t3[e2++], N2 = w2 >> 6 & 1, L2 = 1 << (7 & w2) + 1, A2 = s2, x2 = c2, S2 = false;
        if (w2 >> 7) {
          S2 = true;
          A2 = e2, x2 = L2, e2 += 3 * L2;
        }
        var _2 = e2;
        for (e2++; ; ) {
          var P2;
          if (!((P2 = t3[e2++]) >= 0))
            throw Error("Invalid block size");
          if (P2 === 0)
            break;
          e2 += P2;
        }
        h2.push({ x: m2, y: v2, width: b2, height: y2, has_local_palette: S2, palette_offset: A2, palette_size: x2, data_offset: _2, data_length: e2 - _2, transparent_index: f2, interlaced: !!N2, delay: l2, disposal: d2 });
        break;
      case 59:
        u2 = false;
        break;
      default:
        throw new Error("Unknown gif block: 0x" + t3[e2 - 1].toString(16));
    }
  this.numFrames = function() {
    return h2.length;
  }, this.loopCount = function() {
    return p5;
  }, this.frameInfo = function(t4) {
    if (t4 < 0 || t4 >= h2.length)
      throw new Error("Frame index out of range.");
    return h2[t4];
  }, this.decodeAndBlitFrameBGRA = function(e3, n3) {
    var i3 = this.frameInfo(e3), a3 = i3.width * i3.height, o3 = new Uint8Array(a3);
    $t(t3, i3.data_offset, o3, a3);
    var s3 = i3.palette_offset, c3 = i3.transparent_index;
    c3 === null && (c3 = 256);
    var u3 = i3.width, h3 = r2 - u3, l3 = u3, f3 = 4 * (i3.y * r2 + i3.x), d3 = 4 * ((i3.y + i3.height) * r2 + i3.x), p6 = f3, g3 = 4 * h3;
    i3.interlaced === true && (g3 += 4 * r2 * 7);
    for (var m3 = 8, v3 = 0, b3 = o3.length; v3 < b3; ++v3) {
      var y3 = o3[v3];
      if (l3 === 0 && (l3 = u3, (p6 += g3) >= d3 && (g3 = 4 * h3 + 4 * r2 * (m3 - 1), p6 = f3 + (u3 + h3) * (m3 << 1), m3 >>= 1)), y3 === c3)
        p6 += 4;
      else {
        var w3 = t3[s3 + 3 * y3], N3 = t3[s3 + 3 * y3 + 1], L3 = t3[s3 + 3 * y3 + 2];
        n3[p6++] = L3, n3[p6++] = N3, n3[p6++] = w3, n3[p6++] = 255;
      }
      --l3;
    }
  }, this.decodeAndBlitFrameRGBA = function(e3, n3) {
    var i3 = this.frameInfo(e3), a3 = i3.width * i3.height, o3 = new Uint8Array(a3);
    $t(t3, i3.data_offset, o3, a3);
    var s3 = i3.palette_offset, c3 = i3.transparent_index;
    c3 === null && (c3 = 256);
    var u3 = i3.width, h3 = r2 - u3, l3 = u3, f3 = 4 * (i3.y * r2 + i3.x), d3 = 4 * ((i3.y + i3.height) * r2 + i3.x), p6 = f3, g3 = 4 * h3;
    i3.interlaced === true && (g3 += 4 * r2 * 7);
    for (var m3 = 8, v3 = 0, b3 = o3.length; v3 < b3; ++v3) {
      var y3 = o3[v3];
      if (l3 === 0 && (l3 = u3, (p6 += g3) >= d3 && (g3 = 4 * h3 + 4 * r2 * (m3 - 1), p6 = f3 + (u3 + h3) * (m3 << 1), m3 >>= 1)), y3 === c3)
        p6 += 4;
      else {
        var w3 = t3[s3 + 3 * y3], N3 = t3[s3 + 3 * y3 + 1], L3 = t3[s3 + 3 * y3 + 2];
        n3[p6++] = w3, n3[p6++] = N3, n3[p6++] = L3, n3[p6++] = 255;
      }
      --l3;
    }
  };
}
function $t(t3, e2, r2, n2) {
  for (var i2 = t3[e2++], o2 = 1 << i2, s2 = o2 + 1, c2 = s2 + 1, u2 = i2 + 1, h2 = (1 << u2) - 1, l2 = 0, f2 = 0, d2 = 0, p5 = t3[e2++], g2 = new Int32Array(4096), m2 = null; ; ) {
    for (; l2 < 16 && p5 !== 0; )
      f2 |= t3[e2++] << l2, l2 += 8, p5 === 1 ? p5 = t3[e2++] : --p5;
    if (l2 < u2)
      break;
    var v2 = f2 & h2;
    if (f2 >>= u2, l2 -= u2, v2 !== o2) {
      if (v2 === s2)
        break;
      for (var b2 = v2 < c2 ? v2 : m2, y2 = 0, w2 = b2; w2 > o2; )
        w2 = g2[w2] >> 8, ++y2;
      var N2 = w2;
      if (d2 + y2 + (b2 !== v2 ? 1 : 0) > n2)
        return void a$2.log("Warning, gif stream longer than expected.");
      r2[d2++] = N2;
      var L2 = d2 += y2;
      for (b2 !== v2 && (r2[d2++] = N2), w2 = b2; y2--; )
        w2 = g2[w2], r2[--L2] = 255 & w2, w2 >>= 8;
      m2 !== null && c2 < 4096 && (g2[c2++] = m2 << 8 | N2, c2 >= h2 + 1 && u2 < 12 && (++u2, h2 = h2 << 1 | 1)), m2 = v2;
    } else
      c2 = s2 + 1, h2 = (1 << (u2 = i2 + 1)) - 1, m2 = null;
  }
  return d2 !== n2 && a$2.log("Warning, gif stream shorter than expected."), r2;
}
function Qt(t3) {
  var e2, r2, n2, i2, a2, o2 = Math.floor, s2 = new Array(64), c2 = new Array(64), u2 = new Array(64), h2 = new Array(64), l2 = new Array(65535), f2 = new Array(65535), d2 = new Array(64), p5 = new Array(64), g2 = [], m2 = 0, v2 = 7, b2 = new Array(64), y2 = new Array(64), w2 = new Array(64), N2 = new Array(256), L2 = new Array(2048), A2 = [0, 1, 5, 6, 14, 15, 27, 28, 2, 4, 7, 13, 16, 26, 29, 42, 3, 8, 12, 17, 25, 30, 41, 43, 9, 11, 18, 24, 31, 40, 44, 53, 10, 19, 23, 32, 39, 45, 52, 54, 20, 22, 33, 38, 46, 51, 55, 60, 21, 34, 37, 47, 50, 56, 59, 61, 35, 36, 48, 49, 57, 58, 62, 63], x2 = [0, 0, 1, 5, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0], S2 = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11], _2 = [0, 0, 2, 1, 3, 3, 2, 4, 3, 5, 5, 4, 4, 0, 0, 1, 125], P2 = [1, 2, 3, 0, 4, 17, 5, 18, 33, 49, 65, 6, 19, 81, 97, 7, 34, 113, 20, 50, 129, 145, 161, 8, 35, 66, 177, 193, 21, 82, 209, 240, 36, 51, 98, 114, 130, 9, 10, 22, 23, 24, 25, 26, 37, 38, 39, 40, 41, 42, 52, 53, 54, 55, 56, 57, 58, 67, 68, 69, 70, 71, 72, 73, 74, 83, 84, 85, 86, 87, 88, 89, 90, 99, 100, 101, 102, 103, 104, 105, 106, 115, 116, 117, 118, 119, 120, 121, 122, 131, 132, 133, 134, 135, 136, 137, 138, 146, 147, 148, 149, 150, 151, 152, 153, 154, 162, 163, 164, 165, 166, 167, 168, 169, 170, 178, 179, 180, 181, 182, 183, 184, 185, 186, 194, 195, 196, 197, 198, 199, 200, 201, 202, 210, 211, 212, 213, 214, 215, 216, 217, 218, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250], k2 = [0, 0, 3, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0], I2 = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11], F2 = [0, 0, 2, 1, 2, 4, 4, 3, 4, 7, 5, 4, 4, 0, 1, 2, 119], C2 = [0, 1, 2, 3, 17, 4, 5, 33, 49, 6, 18, 65, 81, 7, 97, 113, 19, 34, 50, 129, 8, 20, 66, 145, 161, 177, 193, 9, 35, 51, 82, 240, 21, 98, 114, 209, 10, 22, 36, 52, 225, 37, 241, 23, 24, 25, 26, 38, 39, 40, 41, 42, 53, 54, 55, 56, 57, 58, 67, 68, 69, 70, 71, 72, 73, 74, 83, 84, 85, 86, 87, 88, 89, 90, 99, 100, 101, 102, 103, 104, 105, 106, 115, 116, 117, 118, 119, 120, 121, 122, 130, 131, 132, 133, 134, 135, 136, 137, 138, 146, 147, 148, 149, 150, 151, 152, 153, 154, 162, 163, 164, 165, 166, 167, 168, 169, 170, 178, 179, 180, 181, 182, 183, 184, 185, 186, 194, 195, 196, 197, 198, 199, 200, 201, 202, 210, 211, 212, 213, 214, 215, 216, 217, 218, 226, 227, 228, 229, 230, 231, 232, 233, 234, 242, 243, 244, 245, 246, 247, 248, 249, 250];
  function j2(t4, e3) {
    for (var r3 = 0, n3 = 0, i3 = new Array(), a3 = 1; a3 <= 16; a3++) {
      for (var o3 = 1; o3 <= t4[a3]; o3++)
        i3[e3[n3]] = [], i3[e3[n3]][0] = r3, i3[e3[n3]][1] = a3, n3++, r3++;
      r3 *= 2;
    }
    return i3;
  }
  function O2(t4) {
    for (var e3 = t4[0], r3 = t4[1] - 1; r3 >= 0; )
      e3 & 1 << r3 && (m2 |= 1 << v2), r3--, --v2 < 0 && (m2 == 255 ? (B3(255), B3(0)) : B3(m2), v2 = 7, m2 = 0);
  }
  function B3(t4) {
    g2.push(t4);
  }
  function M2(t4) {
    B3(t4 >> 8 & 255), B3(255 & t4);
  }
  function E2(t4, e3, r3, n3, i3) {
    for (var a3, o3 = i3[0], s3 = i3[240], c3 = function(t5, e4) {
      var r4, n4, i4, a4, o4, s4, c4, u4, h4, l3, f3 = 0;
      for (h4 = 0; h4 < 8; ++h4) {
        r4 = t5[f3], n4 = t5[f3 + 1], i4 = t5[f3 + 2], a4 = t5[f3 + 3], o4 = t5[f3 + 4], s4 = t5[f3 + 5], c4 = t5[f3 + 6];
        var p6 = r4 + (u4 = t5[f3 + 7]), g4 = r4 - u4, m4 = n4 + c4, v4 = n4 - c4, b4 = i4 + s4, y4 = i4 - s4, w4 = a4 + o4, N3 = a4 - o4, L3 = p6 + w4, A3 = p6 - w4, x3 = m4 + b4, S3 = m4 - b4;
        t5[f3] = L3 + x3, t5[f3 + 4] = L3 - x3;
        var _3 = 0.707106781 * (S3 + A3);
        t5[f3 + 2] = A3 + _3, t5[f3 + 6] = A3 - _3;
        var P3 = 0.382683433 * ((L3 = N3 + y4) - (S3 = v4 + g4)), k3 = 0.5411961 * L3 + P3, I3 = 1.306562965 * S3 + P3, F3 = 0.707106781 * (x3 = y4 + v4), C3 = g4 + F3, j3 = g4 - F3;
        t5[f3 + 5] = j3 + k3, t5[f3 + 3] = j3 - k3, t5[f3 + 1] = C3 + I3, t5[f3 + 7] = C3 - I3, f3 += 8;
      }
      for (f3 = 0, h4 = 0; h4 < 8; ++h4) {
        r4 = t5[f3], n4 = t5[f3 + 8], i4 = t5[f3 + 16], a4 = t5[f3 + 24], o4 = t5[f3 + 32], s4 = t5[f3 + 40], c4 = t5[f3 + 48];
        var O3 = r4 + (u4 = t5[f3 + 56]), B4 = r4 - u4, M3 = n4 + c4, E3 = n4 - c4, q3 = i4 + s4, D2 = i4 - s4, R2 = a4 + o4, T2 = a4 - o4, z2 = O3 + R2, U2 = O3 - R2, H4 = M3 + q3, W2 = M3 - q3;
        t5[f3] = z2 + H4, t5[f3 + 32] = z2 - H4;
        var V2 = 0.707106781 * (W2 + U2);
        t5[f3 + 16] = U2 + V2, t5[f3 + 48] = U2 - V2;
        var G2 = 0.382683433 * ((z2 = T2 + D2) - (W2 = E3 + B4)), Y2 = 0.5411961 * z2 + G2, J2 = 1.306562965 * W2 + G2, X2 = 0.707106781 * (H4 = D2 + E3), K2 = B4 + X2, Z2 = B4 - X2;
        t5[f3 + 40] = Z2 + Y2, t5[f3 + 24] = Z2 - Y2, t5[f3 + 8] = K2 + J2, t5[f3 + 56] = K2 - J2, f3++;
      }
      for (h4 = 0; h4 < 64; ++h4)
        l3 = t5[h4] * e4[h4], d2[h4] = l3 > 0 ? l3 + 0.5 | 0 : l3 - 0.5 | 0;
      return d2;
    }(t4, e3), u3 = 0; u3 < 64; ++u3)
      p5[A2[u3]] = c3[u3];
    var h3 = p5[0] - r3;
    r3 = p5[0], h3 == 0 ? O2(n3[0]) : (O2(n3[f2[a3 = 32767 + h3]]), O2(l2[a3]));
    for (var g3 = 63; g3 > 0 && p5[g3] == 0; )
      g3--;
    if (g3 == 0)
      return O2(o3), r3;
    for (var m3, v3 = 1; v3 <= g3; ) {
      for (var b3 = v3; p5[v3] == 0 && v3 <= g3; )
        ++v3;
      var y3 = v3 - b3;
      if (y3 >= 16) {
        m3 = y3 >> 4;
        for (var w3 = 1; w3 <= m3; ++w3)
          O2(s3);
        y3 &= 15;
      }
      a3 = 32767 + p5[v3], O2(i3[(y3 << 4) + f2[a3]]), O2(l2[a3]), v3++;
    }
    return g3 != 63 && O2(o3), r3;
  }
  function q2(t4) {
    (t4 = Math.min(Math.max(t4, 1), 100), a2 != t4) && (!function(t5) {
      for (var e3 = [16, 11, 10, 16, 24, 40, 51, 61, 12, 12, 14, 19, 26, 58, 60, 55, 14, 13, 16, 24, 40, 57, 69, 56, 14, 17, 22, 29, 51, 87, 80, 62, 18, 22, 37, 56, 68, 109, 103, 77, 24, 35, 55, 64, 81, 104, 113, 92, 49, 64, 78, 87, 103, 121, 120, 101, 72, 92, 95, 98, 112, 100, 103, 99], r3 = 0; r3 < 64; r3++) {
        var n3 = o2((e3[r3] * t5 + 50) / 100);
        n3 = Math.min(Math.max(n3, 1), 255), s2[A2[r3]] = n3;
      }
      for (var i3 = [17, 18, 24, 47, 99, 99, 99, 99, 18, 21, 26, 66, 99, 99, 99, 99, 24, 26, 56, 99, 99, 99, 99, 99, 47, 66, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99], a3 = 0; a3 < 64; a3++) {
        var l3 = o2((i3[a3] * t5 + 50) / 100);
        l3 = Math.min(Math.max(l3, 1), 255), c2[A2[a3]] = l3;
      }
      for (var f3 = [1, 1.387039845, 1.306562965, 1.175875602, 1, 0.785694958, 0.5411961, 0.275899379], d3 = 0, p6 = 0; p6 < 8; p6++)
        for (var g3 = 0; g3 < 8; g3++)
          u2[d3] = 1 / (s2[A2[d3]] * f3[p6] * f3[g3] * 8), h2[d3] = 1 / (c2[A2[d3]] * f3[p6] * f3[g3] * 8), d3++;
    }(t4 < 50 ? Math.floor(5e3 / t4) : Math.floor(200 - 2 * t4)), a2 = t4);
  }
  this.encode = function(t4, a3) {
    a3 && q2(a3), g2 = new Array(), m2 = 0, v2 = 7, M2(65496), M2(65504), M2(16), B3(74), B3(70), B3(73), B3(70), B3(0), B3(1), B3(1), B3(0), M2(1), M2(1), B3(0), B3(0), function() {
      M2(65499), M2(132), B3(0);
      for (var t5 = 0; t5 < 64; t5++)
        B3(s2[t5]);
      B3(1);
      for (var e3 = 0; e3 < 64; e3++)
        B3(c2[e3]);
    }(), function(t5, e3) {
      M2(65472), M2(17), B3(8), M2(e3), M2(t5), B3(3), B3(1), B3(17), B3(0), B3(2), B3(17), B3(1), B3(3), B3(17), B3(1);
    }(t4.width, t4.height), function() {
      M2(65476), M2(418), B3(0);
      for (var t5 = 0; t5 < 16; t5++)
        B3(x2[t5 + 1]);
      for (var e3 = 0; e3 <= 11; e3++)
        B3(S2[e3]);
      B3(16);
      for (var r3 = 0; r3 < 16; r3++)
        B3(_2[r3 + 1]);
      for (var n3 = 0; n3 <= 161; n3++)
        B3(P2[n3]);
      B3(1);
      for (var i3 = 0; i3 < 16; i3++)
        B3(k2[i3 + 1]);
      for (var a4 = 0; a4 <= 11; a4++)
        B3(I2[a4]);
      B3(17);
      for (var o4 = 0; o4 < 16; o4++)
        B3(F2[o4 + 1]);
      for (var s3 = 0; s3 <= 161; s3++)
        B3(C2[s3]);
    }(), M2(65498), M2(12), B3(3), B3(1), B3(0), B3(2), B3(17), B3(3), B3(17), B3(0), B3(63), B3(0);
    var o3 = 0, l3 = 0, f3 = 0;
    m2 = 0, v2 = 7, this.encode.displayName = "_encode_";
    for (var d3, p6, N3, A3, j3, D2, R2, T2, z2, U2 = t4.data, H4 = t4.width, W2 = t4.height, V2 = 4 * H4, G2 = 0; G2 < W2; ) {
      for (d3 = 0; d3 < V2; ) {
        for (j3 = V2 * G2 + d3, R2 = -1, T2 = 0, z2 = 0; z2 < 64; z2++)
          D2 = j3 + (T2 = z2 >> 3) * V2 + (R2 = 4 * (7 & z2)), G2 + T2 >= W2 && (D2 -= V2 * (G2 + 1 + T2 - W2)), d3 + R2 >= V2 && (D2 -= d3 + R2 - V2 + 4), p6 = U2[D2++], N3 = U2[D2++], A3 = U2[D2++], b2[z2] = (L2[p6] + L2[N3 + 256 >> 0] + L2[A3 + 512 >> 0] >> 16) - 128, y2[z2] = (L2[p6 + 768 >> 0] + L2[N3 + 1024 >> 0] + L2[A3 + 1280 >> 0] >> 16) - 128, w2[z2] = (L2[p6 + 1280 >> 0] + L2[N3 + 1536 >> 0] + L2[A3 + 1792 >> 0] >> 16) - 128;
        o3 = E2(b2, u2, o3, e2, n2), l3 = E2(y2, h2, l3, r2, i2), f3 = E2(w2, h2, f3, r2, i2), d3 += 32;
      }
      G2 += 8;
    }
    if (v2 >= 0) {
      var Y2 = [];
      Y2[1] = v2 + 1, Y2[0] = (1 << v2 + 1) - 1, O2(Y2);
    }
    return M2(65497), new Uint8Array(g2);
  }, t3 = t3 || 50, function() {
    for (var t4 = String.fromCharCode, e3 = 0; e3 < 256; e3++)
      N2[e3] = t4(e3);
  }(), e2 = j2(x2, S2), r2 = j2(k2, I2), n2 = j2(_2, P2), i2 = j2(F2, C2), function() {
    for (var t4 = 1, e3 = 2, r3 = 1; r3 <= 15; r3++) {
      for (var n3 = t4; n3 < e3; n3++)
        f2[32767 + n3] = r3, l2[32767 + n3] = [], l2[32767 + n3][1] = r3, l2[32767 + n3][0] = n3;
      for (var i3 = -(e3 - 1); i3 <= -t4; i3++)
        f2[32767 + i3] = r3, l2[32767 + i3] = [], l2[32767 + i3][1] = r3, l2[32767 + i3][0] = e3 - 1 + i3;
      t4 <<= 1, e3 <<= 1;
    }
  }(), function() {
    for (var t4 = 0; t4 < 256; t4++)
      L2[t4] = 19595 * t4, L2[t4 + 256 >> 0] = 38470 * t4, L2[t4 + 512 >> 0] = 7471 * t4 + 32768, L2[t4 + 768 >> 0] = -11059 * t4, L2[t4 + 1024 >> 0] = -21709 * t4, L2[t4 + 1280 >> 0] = 32768 * t4 + 8421375, L2[t4 + 1536 >> 0] = -27439 * t4, L2[t4 + 1792 >> 0] = -5329 * t4;
  }(), q2(t3);
}
function te(t3, e2) {
  if (this.pos = 0, this.buffer = t3, this.datav = new DataView(t3.buffer), this.is_with_alpha = !!e2, this.bottom_up = true, this.flag = String.fromCharCode(this.buffer[0]) + String.fromCharCode(this.buffer[1]), this.pos += 2, ["BM", "BA", "CI", "CP", "IC", "PT"].indexOf(this.flag) === -1)
    throw new Error("Invalid BMP File");
  this.parseHeader(), this.parseBGR();
}
function ee(t3) {
  function e2(t4) {
    if (!t4)
      throw Error("assert :P");
  }
  function r2(t4, e3, r3) {
    for (var n3 = 0; 4 > n3; n3++)
      if (t4[e3 + n3] != r3.charCodeAt(n3))
        return true;
    return false;
  }
  function n2(t4, e3, r3, n3, i3) {
    for (var a3 = 0; a3 < i3; a3++)
      t4[e3 + a3] = r3[n3 + a3];
  }
  function i2(t4, e3, r3, n3) {
    for (var i3 = 0; i3 < n3; i3++)
      t4[e3 + i3] = r3;
  }
  function a2(t4) {
    return new Int32Array(t4);
  }
  function o2(t4, e3) {
    for (var r3 = [], n3 = 0; n3 < t4; n3++)
      r3.push(new e3());
    return r3;
  }
  function s2(t4, e3) {
    var r3 = [];
    return function t5(r4, n3, i3) {
      for (var a3 = i3[n3], o3 = 0; o3 < a3 && (r4.push(i3.length > n3 + 1 ? [] : new e3()), !(i3.length < n3 + 1)); o3++)
        t5(r4[o3], n3 + 1, i3);
    }(r3, 0, t4), r3;
  }
  var c2 = function() {
    var t4 = this;
    function c3(t5, e3) {
      for (var r3 = 1 << e3 - 1 >>> 0; t5 & r3; )
        r3 >>>= 1;
      return r3 ? (t5 & r3 - 1) + r3 : t5;
    }
    function u3(t5, r3, n3, i3, a3) {
      e2(!(i3 % n3));
      do {
        t5[r3 + (i3 -= n3)] = a3;
      } while (0 < i3);
    }
    function h3(t5, r3, n3, i3, o3) {
      if (e2(2328 >= o3), 512 >= o3)
        var s3 = a2(512);
      else if ((s3 = a2(o3)) == null)
        return 0;
      return function(t6, r4, n4, i4, o4, s4) {
        var h4, f4, d4 = r4, p7 = 1 << n4, g4 = a2(16), m4 = a2(16);
        for (e2(o4 != 0), e2(i4 != null), e2(t6 != null), e2(0 < n4), f4 = 0; f4 < o4; ++f4) {
          if (15 < i4[f4])
            return 0;
          ++g4[i4[f4]];
        }
        if (g4[0] == o4)
          return 0;
        for (m4[1] = 0, h4 = 1; 15 > h4; ++h4) {
          if (g4[h4] > 1 << h4)
            return 0;
          m4[h4 + 1] = m4[h4] + g4[h4];
        }
        for (f4 = 0; f4 < o4; ++f4)
          h4 = i4[f4], 0 < i4[f4] && (s4[m4[h4]++] = f4);
        if (m4[15] == 1)
          return (i4 = new l3()).g = 0, i4.value = s4[0], u3(t6, d4, 1, p7, i4), p7;
        var v4, b4 = -1, y4 = p7 - 1, w4 = 0, N4 = 1, L4 = 1, A4 = 1 << n4;
        for (f4 = 0, h4 = 1, o4 = 2; h4 <= n4; ++h4, o4 <<= 1) {
          if (N4 += L4 <<= 1, 0 > (L4 -= g4[h4]))
            return 0;
          for (; 0 < g4[h4]; --g4[h4])
            (i4 = new l3()).g = h4, i4.value = s4[f4++], u3(t6, d4 + w4, o4, A4, i4), w4 = c3(w4, h4);
        }
        for (h4 = n4 + 1, o4 = 2; 15 >= h4; ++h4, o4 <<= 1) {
          if (N4 += L4 <<= 1, 0 > (L4 -= g4[h4]))
            return 0;
          for (; 0 < g4[h4]; --g4[h4]) {
            if (i4 = new l3(), (w4 & y4) != b4) {
              for (d4 += A4, v4 = 1 << (b4 = h4) - n4; 15 > b4 && !(0 >= (v4 -= g4[b4])); )
                ++b4, v4 <<= 1;
              p7 += A4 = 1 << (v4 = b4 - n4), t6[r4 + (b4 = w4 & y4)].g = v4 + n4, t6[r4 + b4].value = d4 - r4 - b4;
            }
            i4.g = h4 - n4, i4.value = s4[f4++], u3(t6, d4 + (w4 >> n4), o4, A4, i4), w4 = c3(w4, h4);
          }
        }
        return N4 != 2 * m4[15] - 1 ? 0 : p7;
      }(t5, r3, n3, i3, o3, s3);
    }
    function l3() {
      this.value = this.g = 0;
    }
    function f3() {
      this.value = this.g = 0;
    }
    function d3() {
      this.G = o2(5, l3), this.H = a2(5), this.jc = this.Qb = this.qb = this.nd = 0, this.pd = o2(Dr, f3);
    }
    function p6(t5, r3, n3, i3) {
      e2(t5 != null), e2(r3 != null), e2(2147483648 > i3), t5.Ca = 254, t5.I = 0, t5.b = -8, t5.Ka = 0, t5.oa = r3, t5.pa = n3, t5.Jd = r3, t5.Yc = n3 + i3, t5.Zc = 4 <= i3 ? n3 + i3 - 4 + 1 : n3, _2(t5);
    }
    function g3(t5, e3) {
      for (var r3 = 0; 0 < e3--; )
        r3 |= k2(t5, 128) << e3;
      return r3;
    }
    function m3(t5, e3) {
      var r3 = g3(t5, e3);
      return P2(t5) ? -r3 : r3;
    }
    function v3(t5, r3, n3, i3) {
      var a3, o3 = 0;
      for (e2(t5 != null), e2(r3 != null), e2(4294967288 > i3), t5.Sb = i3, t5.Ra = 0, t5.u = 0, t5.h = 0, 4 < i3 && (i3 = 4), a3 = 0; a3 < i3; ++a3)
        o3 += r3[n3 + a3] << 8 * a3;
      t5.Ra = o3, t5.bb = i3, t5.oa = r3, t5.pa = n3;
    }
    function b3(t5) {
      for (; 8 <= t5.u && t5.bb < t5.Sb; )
        t5.Ra >>>= 8, t5.Ra += t5.oa[t5.pa + t5.bb] << zr - 8 >>> 0, ++t5.bb, t5.u -= 8;
      A3(t5) && (t5.h = 1, t5.u = 0);
    }
    function y3(t5, r3) {
      if (e2(0 <= r3), !t5.h && r3 <= Tr) {
        var n3 = L3(t5) & Rr[r3];
        return t5.u += r3, b3(t5), n3;
      }
      return t5.h = 1, t5.u = 0;
    }
    function w3() {
      this.b = this.Ca = this.I = 0, this.oa = [], this.pa = 0, this.Jd = [], this.Yc = 0, this.Zc = [], this.Ka = 0;
    }
    function N3() {
      this.Ra = 0, this.oa = [], this.h = this.u = this.bb = this.Sb = this.pa = 0;
    }
    function L3(t5) {
      return t5.Ra >>> (t5.u & zr - 1) >>> 0;
    }
    function A3(t5) {
      return e2(t5.bb <= t5.Sb), t5.h || t5.bb == t5.Sb && t5.u > zr;
    }
    function x2(t5, e3) {
      t5.u = e3, t5.h = A3(t5);
    }
    function S2(t5) {
      t5.u >= Ur && (e2(t5.u >= Ur), b3(t5));
    }
    function _2(t5) {
      e2(t5 != null && t5.oa != null), t5.pa < t5.Zc ? (t5.I = (t5.oa[t5.pa++] | t5.I << 8) >>> 0, t5.b += 8) : (e2(t5 != null && t5.oa != null), t5.pa < t5.Yc ? (t5.b += 8, t5.I = t5.oa[t5.pa++] | t5.I << 8) : t5.Ka ? t5.b = 0 : (t5.I <<= 8, t5.b += 8, t5.Ka = 1));
    }
    function P2(t5) {
      return g3(t5, 1);
    }
    function k2(t5, e3) {
      var r3 = t5.Ca;
      0 > t5.b && _2(t5);
      var n3 = t5.b, i3 = r3 * e3 >>> 8, a3 = (t5.I >>> n3 > i3) + 0;
      for (a3 ? (r3 -= i3, t5.I -= i3 + 1 << n3 >>> 0) : r3 = i3 + 1, n3 = r3, i3 = 0; 256 <= n3; )
        i3 += 8, n3 >>= 8;
      return n3 = 7 ^ i3 + Hr[n3], t5.b -= n3, t5.Ca = (r3 << n3) - 1, a3;
    }
    function I2(t5, e3, r3) {
      t5[e3 + 0] = r3 >> 24 & 255, t5[e3 + 1] = r3 >> 16 & 255, t5[e3 + 2] = r3 >> 8 & 255, t5[e3 + 3] = r3 >> 0 & 255;
    }
    function F2(t5, e3) {
      return t5[e3 + 0] << 0 | t5[e3 + 1] << 8;
    }
    function C2(t5, e3) {
      return F2(t5, e3) | t5[e3 + 2] << 16;
    }
    function j2(t5, e3) {
      return F2(t5, e3) | F2(t5, e3 + 2) << 16;
    }
    function O2(t5, r3) {
      var n3 = 1 << r3;
      return e2(t5 != null), e2(0 < r3), t5.X = a2(n3), t5.X == null ? 0 : (t5.Mb = 32 - r3, t5.Xa = r3, 1);
    }
    function B3(t5, r3) {
      e2(t5 != null), e2(r3 != null), e2(t5.Xa == r3.Xa), n2(r3.X, 0, t5.X, 0, 1 << r3.Xa);
    }
    function M2() {
      this.X = [], this.Xa = this.Mb = 0;
    }
    function E2(t5, r3, n3, i3) {
      e2(n3 != null), e2(i3 != null);
      var a3 = n3[0], o3 = i3[0];
      return a3 == 0 && (a3 = (t5 * o3 + r3 / 2) / r3), o3 == 0 && (o3 = (r3 * a3 + t5 / 2) / t5), 0 >= a3 || 0 >= o3 ? 0 : (n3[0] = a3, i3[0] = o3, 1);
    }
    function q2(t5, e3) {
      return t5 + (1 << e3) - 1 >>> e3;
    }
    function D2(t5, e3) {
      return ((4278255360 & t5) + (4278255360 & e3) >>> 0 & 4278255360) + ((16711935 & t5) + (16711935 & e3) >>> 0 & 16711935) >>> 0;
    }
    function R2(e3, r3) {
      t4[r3] = function(r4, n3, i3, a3, o3, s3, c4) {
        var u4;
        for (u4 = 0; u4 < o3; ++u4) {
          var h4 = t4[e3](s3[c4 + u4 - 1], i3, a3 + u4);
          s3[c4 + u4] = D2(r4[n3 + u4], h4);
        }
      };
    }
    function T2() {
      this.ud = this.hd = this.jd = 0;
    }
    function z2(t5, e3) {
      return ((4278124286 & (t5 ^ e3)) >>> 1) + (t5 & e3) >>> 0;
    }
    function U2(t5) {
      return 0 <= t5 && 256 > t5 ? t5 : 0 > t5 ? 0 : 255 < t5 ? 255 : void 0;
    }
    function H4(t5, e3) {
      return U2(t5 + (t5 - e3 + 0.5 >> 1));
    }
    function W2(t5, e3, r3) {
      return Math.abs(e3 - r3) - Math.abs(t5 - r3);
    }
    function V2(t5, e3, r3, n3, i3, a3, o3) {
      for (n3 = a3[o3 - 1], r3 = 0; r3 < i3; ++r3)
        a3[o3 + r3] = n3 = D2(t5[e3 + r3], n3);
    }
    function G2(t5, e3, r3, n3, i3) {
      var a3;
      for (a3 = 0; a3 < r3; ++a3) {
        var o3 = t5[e3 + a3], s3 = o3 >> 8 & 255, c4 = 16711935 & (c4 = (c4 = 16711935 & o3) + ((s3 << 16) + s3));
        n3[i3 + a3] = (4278255360 & o3) + c4 >>> 0;
      }
    }
    function Y2(t5, e3) {
      e3.jd = t5 >> 0 & 255, e3.hd = t5 >> 8 & 255, e3.ud = t5 >> 16 & 255;
    }
    function J2(t5, e3, r3, n3, i3, a3) {
      var o3;
      for (o3 = 0; o3 < n3; ++o3) {
        var s3 = e3[r3 + o3], c4 = s3 >>> 8, u4 = s3, h4 = 255 & (h4 = (h4 = s3 >>> 16) + ((t5.jd << 24 >> 24) * (c4 << 24 >> 24) >>> 5));
        u4 = 255 & (u4 = (u4 = u4 + ((t5.hd << 24 >> 24) * (c4 << 24 >> 24) >>> 5)) + ((t5.ud << 24 >> 24) * (h4 << 24 >> 24) >>> 5));
        i3[a3 + o3] = (4278255360 & s3) + (h4 << 16) + u4;
      }
    }
    function X2(e3, r3, n3, i3, a3) {
      t4[r3] = function(t5, e4, r4, n4, o3, s3, c4, u4, h4) {
        for (n4 = c4; n4 < u4; ++n4)
          for (c4 = 0; c4 < h4; ++c4)
            o3[s3++] = a3(r4[i3(t5[e4++])]);
      }, t4[e3] = function(e4, r4, o3, s3, c4, u4, h4) {
        var l4 = 8 >> e4.b, f4 = e4.Ea, d4 = e4.K[0], p7 = e4.w;
        if (8 > l4)
          for (e4 = (1 << e4.b) - 1, p7 = (1 << l4) - 1; r4 < o3; ++r4) {
            var g4, m4 = 0;
            for (g4 = 0; g4 < f4; ++g4)
              g4 & e4 || (m4 = i3(s3[c4++])), u4[h4++] = a3(d4[m4 & p7]), m4 >>= l4;
          }
        else
          t4["VP8LMapColor" + n3](s3, c4, d4, p7, u4, h4, r4, o3, f4);
      };
    }
    function K2(t5, e3, r3, n3, i3) {
      for (r3 = e3 + r3; e3 < r3; ) {
        var a3 = t5[e3++];
        n3[i3++] = a3 >> 16 & 255, n3[i3++] = a3 >> 8 & 255, n3[i3++] = a3 >> 0 & 255;
      }
    }
    function Z2(t5, e3, r3, n3, i3) {
      for (r3 = e3 + r3; e3 < r3; ) {
        var a3 = t5[e3++];
        n3[i3++] = a3 >> 16 & 255, n3[i3++] = a3 >> 8 & 255, n3[i3++] = a3 >> 0 & 255, n3[i3++] = a3 >> 24 & 255;
      }
    }
    function $2(t5, e3, r3, n3, i3) {
      for (r3 = e3 + r3; e3 < r3; ) {
        var a3 = (o3 = t5[e3++]) >> 16 & 240 | o3 >> 12 & 15, o3 = o3 >> 0 & 240 | o3 >> 28 & 15;
        n3[i3++] = a3, n3[i3++] = o3;
      }
    }
    function Q2(t5, e3, r3, n3, i3) {
      for (r3 = e3 + r3; e3 < r3; ) {
        var a3 = (o3 = t5[e3++]) >> 16 & 248 | o3 >> 13 & 7, o3 = o3 >> 5 & 224 | o3 >> 3 & 31;
        n3[i3++] = a3, n3[i3++] = o3;
      }
    }
    function tt2(t5, e3, r3, n3, i3) {
      for (r3 = e3 + r3; e3 < r3; ) {
        var a3 = t5[e3++];
        n3[i3++] = a3 >> 0 & 255, n3[i3++] = a3 >> 8 & 255, n3[i3++] = a3 >> 16 & 255;
      }
    }
    function et2(t5, e3, r3, i3, a3, o3) {
      if (o3 == 0)
        for (r3 = e3 + r3; e3 < r3; )
          I2(i3, ((o3 = t5[e3++])[0] >> 24 | o3[1] >> 8 & 65280 | o3[2] << 8 & 16711680 | o3[3] << 24) >>> 0), a3 += 32;
      else
        n2(i3, a3, t5, e3, r3);
    }
    function rt2(e3, r3) {
      t4[r3][0] = t4[e3 + "0"], t4[r3][1] = t4[e3 + "1"], t4[r3][2] = t4[e3 + "2"], t4[r3][3] = t4[e3 + "3"], t4[r3][4] = t4[e3 + "4"], t4[r3][5] = t4[e3 + "5"], t4[r3][6] = t4[e3 + "6"], t4[r3][7] = t4[e3 + "7"], t4[r3][8] = t4[e3 + "8"], t4[r3][9] = t4[e3 + "9"], t4[r3][10] = t4[e3 + "10"], t4[r3][11] = t4[e3 + "11"], t4[r3][12] = t4[e3 + "12"], t4[r3][13] = t4[e3 + "13"], t4[r3][14] = t4[e3 + "0"], t4[r3][15] = t4[e3 + "0"];
    }
    function nt2(t5) {
      return t5 == Hn || t5 == Wn || t5 == Vn || t5 == Gn;
    }
    function it2() {
      this.eb = [], this.size = this.A = this.fb = 0;
    }
    function at2() {
      this.y = [], this.f = [], this.ea = [], this.F = [], this.Tc = this.Ed = this.Cd = this.Fd = this.lb = this.Db = this.Ab = this.fa = this.J = this.W = this.N = this.O = 0;
    }
    function ot2() {
      this.Rd = this.height = this.width = this.S = 0, this.f = {}, this.f.RGBA = new it2(), this.f.kb = new at2(), this.sd = null;
    }
    function st2() {
      this.width = [0], this.height = [0], this.Pd = [0], this.Qd = [0], this.format = [0];
    }
    function ct2() {
      this.Id = this.fd = this.Md = this.hb = this.ib = this.da = this.bd = this.cd = this.j = this.v = this.Da = this.Sd = this.ob = 0;
    }
    function ut2(t5) {
      return alert("todo:WebPSamplerProcessPlane"), t5.T;
    }
    function ht2(t5, e3) {
      var r3 = t5.T, i3 = e3.ba.f.RGBA, a3 = i3.eb, o3 = i3.fb + t5.ka * i3.A, s3 = vi[e3.ba.S], c4 = t5.y, u4 = t5.O, h4 = t5.f, l4 = t5.N, f4 = t5.ea, d4 = t5.W, p7 = e3.cc, g4 = e3.dc, m4 = e3.Mc, v4 = e3.Nc, b4 = t5.ka, y4 = t5.ka + t5.T, w4 = t5.U, N4 = w4 + 1 >> 1;
      for (b4 == 0 ? s3(c4, u4, null, null, h4, l4, f4, d4, h4, l4, f4, d4, a3, o3, null, null, w4) : (s3(e3.ec, e3.fc, c4, u4, p7, g4, m4, v4, h4, l4, f4, d4, a3, o3 - i3.A, a3, o3, w4), ++r3); b4 + 2 < y4; b4 += 2)
        p7 = h4, g4 = l4, m4 = f4, v4 = d4, l4 += t5.Rc, d4 += t5.Rc, o3 += 2 * i3.A, s3(c4, (u4 += 2 * t5.fa) - t5.fa, c4, u4, p7, g4, m4, v4, h4, l4, f4, d4, a3, o3 - i3.A, a3, o3, w4);
      return u4 += t5.fa, t5.j + y4 < t5.o ? (n2(e3.ec, e3.fc, c4, u4, w4), n2(e3.cc, e3.dc, h4, l4, N4), n2(e3.Mc, e3.Nc, f4, d4, N4), r3--) : 1 & y4 || s3(c4, u4, null, null, h4, l4, f4, d4, h4, l4, f4, d4, a3, o3 + i3.A, null, null, w4), r3;
    }
    function lt2(t5, r3, n3) {
      var i3 = t5.F, a3 = [t5.J];
      if (i3 != null) {
        var o3 = t5.U, s3 = r3.ba.S, c4 = s3 == Tn || s3 == Vn;
        r3 = r3.ba.f.RGBA;
        var u4 = [0], h4 = t5.ka;
        u4[0] = t5.T, t5.Kb && (h4 == 0 ? --u4[0] : (--h4, a3[0] -= t5.width), t5.j + t5.ka + t5.T == t5.o && (u4[0] = t5.o - t5.j - h4));
        var l4 = r3.eb;
        h4 = r3.fb + h4 * r3.A;
        t5 = Sn(i3, a3[0], t5.width, o3, u4, l4, h4 + (c4 ? 0 : 3), r3.A), e2(n3 == u4), t5 && nt2(s3) && An(l4, h4, c4, o3, u4, r3.A);
      }
      return 0;
    }
    function ft2(t5) {
      var e3 = t5.ma, r3 = e3.ba.S, n3 = 11 > r3, i3 = r3 == qn || r3 == Rn || r3 == Tn || r3 == zn || r3 == 12 || nt2(r3);
      if (e3.memory = null, e3.Ib = null, e3.Jb = null, e3.Nd = null, !Mr(e3.Oa, t5, i3 ? 11 : 12))
        return 0;
      if (i3 && nt2(r3) && br(), t5.da)
        alert("todo:use_scaling");
      else {
        if (n3) {
          if (e3.Ib = ut2, t5.Kb) {
            if (r3 = t5.U + 1 >> 1, e3.memory = a2(t5.U + 2 * r3), e3.memory == null)
              return 0;
            e3.ec = e3.memory, e3.fc = 0, e3.cc = e3.ec, e3.dc = e3.fc + t5.U, e3.Mc = e3.cc, e3.Nc = e3.dc + r3, e3.Ib = ht2, br();
          }
        } else
          alert("todo:EmitYUV");
        i3 && (e3.Jb = lt2, n3 && mr());
      }
      if (n3 && !Ci) {
        for (t5 = 0; 256 > t5; ++t5)
          ji[t5] = 89858 * (t5 - 128) + _i >> Si, Mi[t5] = -22014 * (t5 - 128) + _i, Bi[t5] = -45773 * (t5 - 128), Oi[t5] = 113618 * (t5 - 128) + _i >> Si;
        for (t5 = Pi; t5 < ki; ++t5)
          e3 = 76283 * (t5 - 16) + _i >> Si, Ei[t5 - Pi] = Vt2(e3, 255), qi[t5 - Pi] = Vt2(e3 + 8 >> 4, 15);
        Ci = 1;
      }
      return 1;
    }
    function dt2(t5) {
      var r3 = t5.ma, n3 = t5.U, i3 = t5.T;
      return e2(!(1 & t5.ka)), 0 >= n3 || 0 >= i3 ? 0 : (n3 = r3.Ib(t5, r3), r3.Jb != null && r3.Jb(t5, r3, n3), r3.Dc += n3, 1);
    }
    function pt2(t5) {
      t5.ma.memory = null;
    }
    function gt2(t5, e3, r3, n3) {
      return y3(t5, 8) != 47 ? 0 : (e3[0] = y3(t5, 14) + 1, r3[0] = y3(t5, 14) + 1, n3[0] = y3(t5, 1), y3(t5, 3) != 0 ? 0 : !t5.h);
    }
    function mt2(t5, e3) {
      if (4 > t5)
        return t5 + 1;
      var r3 = t5 - 2 >> 1;
      return (2 + (1 & t5) << r3) + y3(e3, r3) + 1;
    }
    function vt2(t5, e3) {
      return 120 < e3 ? e3 - 120 : 1 <= (r3 = ((r3 = $n[e3 - 1]) >> 4) * t5 + (8 - (15 & r3))) ? r3 : 1;
      var r3;
    }
    function bt2(t5, e3, r3) {
      var n3 = L3(r3), i3 = t5[e3 += 255 & n3].g - 8;
      return 0 < i3 && (x2(r3, r3.u + 8), n3 = L3(r3), e3 += t5[e3].value, e3 += n3 & (1 << i3) - 1), x2(r3, r3.u + t5[e3].g), t5[e3].value;
    }
    function yt2(t5, r3, n3) {
      return n3.g += t5.g, n3.value += t5.value << r3 >>> 0, e2(8 >= n3.g), t5.g;
    }
    function wt2(t5, r3, n3) {
      var i3 = t5.xc;
      return e2((r3 = i3 == 0 ? 0 : t5.vc[t5.md * (n3 >> i3) + (r3 >> i3)]) < t5.Wb), t5.Ya[r3];
    }
    function Nt2(t5, r3, i3, a3) {
      var o3 = t5.ab, s3 = t5.c * r3, c4 = t5.C;
      r3 = c4 + r3;
      var u4 = i3, h4 = a3;
      for (a3 = t5.Ta, i3 = t5.Ua; 0 < o3--; ) {
        var l4 = t5.gc[o3], f4 = c4, d4 = r3, p7 = u4, g4 = h4, m4 = (h4 = a3, u4 = i3, l4.Ea);
        switch (e2(f4 < d4), e2(d4 <= l4.nc), l4.hc) {
          case 2:
            Gr(p7, g4, (d4 - f4) * m4, h4, u4);
            break;
          case 0:
            var v4 = f4, b4 = d4, y4 = h4, w4 = u4, N4 = (_3 = l4).Ea;
            v4 == 0 && (Wr(p7, g4, null, null, 1, y4, w4), V2(p7, g4 + 1, 0, 0, N4 - 1, y4, w4 + 1), g4 += N4, w4 += N4, ++v4);
            for (var L4 = 1 << _3.b, A4 = L4 - 1, x3 = q2(N4, _3.b), S3 = _3.K, _3 = _3.w + (v4 >> _3.b) * x3; v4 < b4; ) {
              var P3 = S3, k3 = _3, I3 = 1;
              for (Vr(p7, g4, y4, w4 - N4, 1, y4, w4); I3 < N4; ) {
                var F3 = (I3 & ~A4) + L4;
                F3 > N4 && (F3 = N4), (0, Zr[P3[k3++] >> 8 & 15])(p7, g4 + +I3, y4, w4 + I3 - N4, F3 - I3, y4, w4 + I3), I3 = F3;
              }
              g4 += N4, w4 += N4, ++v4 & A4 || (_3 += x3);
            }
            d4 != l4.nc && n2(h4, u4 - m4, h4, u4 + (d4 - f4 - 1) * m4, m4);
            break;
          case 1:
            for (m4 = p7, b4 = g4, N4 = (p7 = l4.Ea) - (w4 = p7 & ~(y4 = (g4 = 1 << l4.b) - 1)), v4 = q2(p7, l4.b), L4 = l4.K, l4 = l4.w + (f4 >> l4.b) * v4; f4 < d4; ) {
              for (A4 = L4, x3 = l4, S3 = new T2(), _3 = b4 + w4, P3 = b4 + p7; b4 < _3; )
                Y2(A4[x3++], S3), $r(S3, m4, b4, g4, h4, u4), b4 += g4, u4 += g4;
              b4 < P3 && (Y2(A4[x3++], S3), $r(S3, m4, b4, N4, h4, u4), b4 += N4, u4 += N4), ++f4 & y4 || (l4 += v4);
            }
            break;
          case 3:
            if (p7 == h4 && g4 == u4 && 0 < l4.b) {
              for (b4 = h4, p7 = m4 = u4 + (d4 - f4) * m4 - (w4 = (d4 - f4) * q2(l4.Ea, l4.b)), g4 = h4, y4 = u4, v4 = [], w4 = (N4 = w4) - 1; 0 <= w4; --w4)
                v4[w4] = g4[y4 + w4];
              for (w4 = N4 - 1; 0 <= w4; --w4)
                b4[p7 + w4] = v4[w4];
              Yr(l4, f4, d4, h4, m4, h4, u4);
            } else
              Yr(l4, f4, d4, p7, g4, h4, u4);
        }
        u4 = a3, h4 = i3;
      }
      h4 != i3 && n2(a3, i3, u4, h4, s3);
    }
    function Lt2(t5, r3) {
      var n3 = t5.V, i3 = t5.Ba + t5.c * t5.C, a3 = r3 - t5.C;
      if (e2(r3 <= t5.l.o), e2(16 >= a3), 0 < a3) {
        var o3 = t5.l, s3 = t5.Ta, c4 = t5.Ua, u4 = o3.width;
        if (Nt2(t5, a3, n3, i3), a3 = c4 = [c4], e2((n3 = t5.C) < (i3 = r3)), e2(o3.v < o3.va), i3 > o3.o && (i3 = o3.o), n3 < o3.j) {
          var h4 = o3.j - n3;
          n3 = o3.j;
          a3[0] += h4 * u4;
        }
        if (n3 >= i3 ? n3 = 0 : (a3[0] += 4 * o3.v, o3.ka = n3 - o3.j, o3.U = o3.va - o3.v, o3.T = i3 - n3, n3 = 1), n3) {
          if (c4 = c4[0], 11 > (n3 = t5.ca).S) {
            var l4 = n3.f.RGBA, f4 = (i3 = n3.S, a3 = o3.U, o3 = o3.T, h4 = l4.eb, l4.A), d4 = o3;
            for (l4 = l4.fb + t5.Ma * l4.A; 0 < d4--; ) {
              var p7 = s3, g4 = c4, m4 = a3, v4 = h4, b4 = l4;
              switch (i3) {
                case En:
                  Qr(p7, g4, m4, v4, b4);
                  break;
                case qn:
                  tn(p7, g4, m4, v4, b4);
                  break;
                case Hn:
                  tn(p7, g4, m4, v4, b4), An(v4, b4, 0, m4, 1, 0);
                  break;
                case Dn:
                  nn(p7, g4, m4, v4, b4);
                  break;
                case Rn:
                  et2(p7, g4, m4, v4, b4, 1);
                  break;
                case Wn:
                  et2(p7, g4, m4, v4, b4, 1), An(v4, b4, 0, m4, 1, 0);
                  break;
                case Tn:
                  et2(p7, g4, m4, v4, b4, 0);
                  break;
                case Vn:
                  et2(p7, g4, m4, v4, b4, 0), An(v4, b4, 1, m4, 1, 0);
                  break;
                case zn:
                  en(p7, g4, m4, v4, b4);
                  break;
                case Gn:
                  en(p7, g4, m4, v4, b4), xn(v4, b4, m4, 1, 0);
                  break;
                case Un:
                  rn(p7, g4, m4, v4, b4);
                  break;
                default:
                  e2(0);
              }
              c4 += u4, l4 += f4;
            }
            t5.Ma += o3;
          } else
            alert("todo:EmitRescaledRowsYUVA");
          e2(t5.Ma <= n3.height);
        }
      }
      t5.C = r3, e2(t5.C <= t5.i);
    }
    function At2(t5) {
      var e3;
      if (0 < t5.ua)
        return 0;
      for (e3 = 0; e3 < t5.Wb; ++e3) {
        var r3 = t5.Ya[e3].G, n3 = t5.Ya[e3].H;
        if (0 < r3[1][n3[1] + 0].g || 0 < r3[2][n3[2] + 0].g || 0 < r3[3][n3[3] + 0].g)
          return 0;
      }
      return 1;
    }
    function xt2(t5, r3, n3, i3, a3, o3) {
      if (t5.Z != 0) {
        var s3 = t5.qd, c4 = t5.rd;
        for (e2(mi[t5.Z] != null); r3 < n3; ++r3)
          mi[t5.Z](s3, c4, i3, a3, i3, a3, o3), s3 = i3, c4 = a3, a3 += o3;
        t5.qd = s3, t5.rd = c4;
      }
    }
    function St(t5, r3) {
      var n3 = t5.l.ma, i3 = n3.Z == 0 || n3.Z == 1 ? t5.l.j : t5.C;
      i3 = t5.C < i3 ? i3 : t5.C;
      if (e2(r3 <= t5.l.o), r3 > i3) {
        var a3 = t5.l.width, o3 = n3.ca, s3 = n3.tb + a3 * i3, c4 = t5.V, u4 = t5.Ba + t5.c * i3, h4 = t5.gc;
        e2(t5.ab == 1), e2(h4[0].hc == 3), Xr(h4[0], i3, r3, c4, u4, o3, s3), xt2(n3, i3, r3, o3, s3, a3);
      }
      t5.C = t5.Ma = r3;
    }
    function _t2(t5, r3, n3, i3, a3, o3, s3) {
      var c4 = t5.$ / i3, u4 = t5.$ % i3, h4 = t5.m, l4 = t5.s, f4 = n3 + t5.$, d4 = f4;
      a3 = n3 + i3 * a3;
      var p7 = n3 + i3 * o3, g4 = 280 + l4.ua, m4 = t5.Pb ? c4 : 16777216, v4 = 0 < l4.ua ? l4.Wa : null, b4 = l4.wc, y4 = f4 < p7 ? wt2(l4, u4, c4) : null;
      e2(t5.C < o3), e2(p7 <= a3);
      var w4 = false;
      t:
        for (; ; ) {
          for (; w4 || f4 < p7; ) {
            var N4 = 0;
            if (c4 >= m4) {
              var _3 = f4 - n3;
              e2((m4 = t5).Pb), m4.wd = m4.m, m4.xd = _3, 0 < m4.s.ua && B3(m4.s.Wa, m4.s.vb), m4 = c4 + ti;
            }
            if (u4 & b4 || (y4 = wt2(l4, u4, c4)), e2(y4 != null), y4.Qb && (r3[f4] = y4.qb, w4 = true), !w4)
              if (S2(h4), y4.jc) {
                N4 = h4, _3 = r3;
                var P3 = f4, k3 = y4.pd[L3(N4) & Dr - 1];
                e2(y4.jc), 256 > k3.g ? (x2(N4, N4.u + k3.g), _3[P3] = k3.value, N4 = 0) : (x2(N4, N4.u + k3.g - 256), e2(256 <= k3.value), N4 = k3.value), N4 == 0 && (w4 = true);
              } else
                N4 = bt2(y4.G[0], y4.H[0], h4);
            if (h4.h)
              break;
            if (w4 || 256 > N4) {
              if (!w4)
                if (y4.nd)
                  r3[f4] = (y4.qb | N4 << 8) >>> 0;
                else {
                  if (S2(h4), w4 = bt2(y4.G[1], y4.H[1], h4), S2(h4), _3 = bt2(y4.G[2], y4.H[2], h4), P3 = bt2(y4.G[3], y4.H[3], h4), h4.h)
                    break;
                  r3[f4] = (P3 << 24 | w4 << 16 | N4 << 8 | _3) >>> 0;
                }
              if (w4 = false, ++f4, ++u4 >= i3 && (u4 = 0, ++c4, s3 != null && c4 <= o3 && !(c4 % 16) && s3(t5, c4), v4 != null))
                for (; d4 < f4; )
                  N4 = r3[d4++], v4.X[(506832829 * N4 & 4294967295) >>> v4.Mb] = N4;
            } else if (280 > N4) {
              if (N4 = mt2(N4 - 256, h4), _3 = bt2(y4.G[4], y4.H[4], h4), S2(h4), _3 = vt2(i3, _3 = mt2(_3, h4)), h4.h)
                break;
              if (f4 - n3 < _3 || a3 - f4 < N4)
                break t;
              for (P3 = 0; P3 < N4; ++P3)
                r3[f4 + P3] = r3[f4 + P3 - _3];
              for (f4 += N4, u4 += N4; u4 >= i3; )
                u4 -= i3, ++c4, s3 != null && c4 <= o3 && !(c4 % 16) && s3(t5, c4);
              if (e2(f4 <= a3), u4 & b4 && (y4 = wt2(l4, u4, c4)), v4 != null)
                for (; d4 < f4; )
                  N4 = r3[d4++], v4.X[(506832829 * N4 & 4294967295) >>> v4.Mb] = N4;
            } else {
              if (!(N4 < g4))
                break t;
              for (w4 = N4 - 280, e2(v4 != null); d4 < f4; )
                N4 = r3[d4++], v4.X[(506832829 * N4 & 4294967295) >>> v4.Mb] = N4;
              N4 = f4, e2(!(w4 >>> (_3 = v4).Xa)), r3[N4] = _3.X[w4], w4 = true;
            }
            w4 || e2(h4.h == A3(h4));
          }
          if (t5.Pb && h4.h && f4 < a3)
            e2(t5.m.h), t5.a = 5, t5.m = t5.wd, t5.$ = t5.xd, 0 < t5.s.ua && B3(t5.s.vb, t5.s.Wa);
          else {
            if (h4.h)
              break t;
            s3 != null && s3(t5, c4 > o3 ? o3 : c4), t5.a = 0, t5.$ = f4 - n3;
          }
          return 1;
        }
      return t5.a = 3, 0;
    }
    function Pt2(t5) {
      e2(t5 != null), t5.vc = null, t5.yc = null, t5.Ya = null;
      var r3 = t5.Wa;
      r3 != null && (r3.X = null), t5.vb = null, e2(t5 != null);
    }
    function kt2() {
      var e3 = new or();
      return e3 == null ? null : (e3.a = 0, e3.xb = gi, rt2("Predictor", "VP8LPredictors"), rt2("Predictor", "VP8LPredictors_C"), rt2("PredictorAdd", "VP8LPredictorsAdd"), rt2("PredictorAdd", "VP8LPredictorsAdd_C"), Gr = G2, $r = J2, Qr = K2, tn = Z2, en = $2, rn = Q2, nn = tt2, t4.VP8LMapColor32b = Jr, t4.VP8LMapColor8b = Kr, e3);
    }
    function It2(t5, r3, n3, s3, c4) {
      var u4 = 1, f4 = [t5], p7 = [r3], g4 = s3.m, m4 = s3.s, v4 = null, b4 = 0;
      t:
        for (; ; ) {
          if (n3)
            for (; u4 && y3(g4, 1); ) {
              var w4 = f4, N4 = p7, A4 = s3, _3 = 1, P3 = A4.m, k3 = A4.gc[A4.ab], I3 = y3(P3, 2);
              if (A4.Oc & 1 << I3)
                u4 = 0;
              else {
                switch (A4.Oc |= 1 << I3, k3.hc = I3, k3.Ea = w4[0], k3.nc = N4[0], k3.K = [null], ++A4.ab, e2(4 >= A4.ab), I3) {
                  case 0:
                  case 1:
                    k3.b = y3(P3, 3) + 2, _3 = It2(q2(k3.Ea, k3.b), q2(k3.nc, k3.b), 0, A4, k3.K), k3.K = k3.K[0];
                    break;
                  case 3:
                    var F3, C3 = y3(P3, 8) + 1, j3 = 16 < C3 ? 0 : 4 < C3 ? 1 : 2 < C3 ? 2 : 3;
                    if (w4[0] = q2(k3.Ea, j3), k3.b = j3, F3 = _3 = It2(C3, 1, 0, A4, k3.K)) {
                      var B4, M3 = C3, E3 = k3, R3 = 1 << (8 >> E3.b), T3 = a2(R3);
                      if (T3 == null)
                        F3 = 0;
                      else {
                        var z3 = E3.K[0], U3 = E3.w;
                        for (T3[0] = E3.K[0][0], B4 = 1; B4 < 1 * M3; ++B4)
                          T3[B4] = D2(z3[U3 + B4], T3[B4 - 1]);
                        for (; B4 < 4 * R3; ++B4)
                          T3[B4] = 0;
                        E3.K[0] = null, E3.K[0] = T3, F3 = 1;
                      }
                    }
                    _3 = F3;
                    break;
                  case 2:
                    break;
                  default:
                    e2(0);
                }
                u4 = _3;
              }
            }
          if (f4 = f4[0], p7 = p7[0], u4 && y3(g4, 1) && !(u4 = 1 <= (b4 = y3(g4, 4)) && 11 >= b4)) {
            s3.a = 3;
            break t;
          }
          var H5;
          if (H5 = u4)
            e: {
              var W3, V3, G3, Y3 = s3, J3 = f4, X3 = p7, K3 = b4, Z3 = n3, $3 = Y3.m, Q3 = Y3.s, tt3 = [null], et3 = 1, rt3 = 0, nt3 = Qn[K3];
              r:
                for (; ; ) {
                  if (Z3 && y3($3, 1)) {
                    var it3 = y3($3, 3) + 2, at3 = q2(J3, it3), ot3 = q2(X3, it3), st3 = at3 * ot3;
                    if (!It2(at3, ot3, 0, Y3, tt3))
                      break r;
                    for (tt3 = tt3[0], Q3.xc = it3, W3 = 0; W3 < st3; ++W3) {
                      var ct3 = tt3[W3] >> 8 & 65535;
                      tt3[W3] = ct3, ct3 >= et3 && (et3 = ct3 + 1);
                    }
                  }
                  if ($3.h)
                    break r;
                  for (V3 = 0; 5 > V3; ++V3) {
                    var ut3 = Xn[V3];
                    !V3 && 0 < K3 && (ut3 += 1 << K3), rt3 < ut3 && (rt3 = ut3);
                  }
                  var ht3 = o2(et3 * nt3, l3), lt3 = et3, ft3 = o2(lt3, d3);
                  if (ft3 == null)
                    var dt3 = null;
                  else
                    e2(65536 >= lt3), dt3 = ft3;
                  var pt3 = a2(rt3);
                  if (dt3 == null || pt3 == null || ht3 == null) {
                    Y3.a = 1;
                    break r;
                  }
                  var gt3 = ht3;
                  for (W3 = G3 = 0; W3 < et3; ++W3) {
                    var mt3 = dt3[W3], vt3 = mt3.G, bt3 = mt3.H, wt3 = 0, Nt3 = 1, Lt3 = 0;
                    for (V3 = 0; 5 > V3; ++V3) {
                      ut3 = Xn[V3], vt3[V3] = gt3, bt3[V3] = G3, !V3 && 0 < K3 && (ut3 += 1 << K3);
                      n: {
                        var At3, xt3 = ut3, St2 = Y3, kt3 = pt3, Ft3 = gt3, Ct3 = G3, jt3 = 0, Ot3 = St2.m, Bt3 = y3(Ot3, 1);
                        if (i2(kt3, 0, 0, xt3), Bt3) {
                          var Mt3 = y3(Ot3, 1) + 1, Et3 = y3(Ot3, 1), qt3 = y3(Ot3, Et3 == 0 ? 1 : 8);
                          kt3[qt3] = 1, Mt3 == 2 && (kt3[qt3 = y3(Ot3, 8)] = 1);
                          var Dt3 = 1;
                        } else {
                          var Rt3 = a2(19), Tt3 = y3(Ot3, 4) + 4;
                          if (19 < Tt3) {
                            St2.a = 3;
                            var zt3 = 0;
                            break n;
                          }
                          for (At3 = 0; At3 < Tt3; ++At3)
                            Rt3[Zn[At3]] = y3(Ot3, 3);
                          var Ut3 = void 0, Ht3 = void 0, Wt3 = St2, Vt3 = Rt3, Gt3 = xt3, Yt3 = kt3, Jt3 = 0, Xt3 = Wt3.m, Kt3 = 8, Zt3 = o2(128, l3);
                          i:
                            for (; h3(Zt3, 0, 7, Vt3, 19); ) {
                              if (y3(Xt3, 1)) {
                                var $t3 = 2 + 2 * y3(Xt3, 3);
                                if ((Ut3 = 2 + y3(Xt3, $t3)) > Gt3)
                                  break i;
                              } else
                                Ut3 = Gt3;
                              for (Ht3 = 0; Ht3 < Gt3 && Ut3--; ) {
                                S2(Xt3);
                                var Qt3 = Zt3[0 + (127 & L3(Xt3))];
                                x2(Xt3, Xt3.u + Qt3.g);
                                var te3 = Qt3.value;
                                if (16 > te3)
                                  Yt3[Ht3++] = te3, te3 != 0 && (Kt3 = te3);
                                else {
                                  var ee3 = te3 == 16, re3 = te3 - 16, ne3 = Jn[re3], ie3 = y3(Xt3, Yn[re3]) + ne3;
                                  if (Ht3 + ie3 > Gt3)
                                    break i;
                                  for (var ae3 = ee3 ? Kt3 : 0; 0 < ie3--; )
                                    Yt3[Ht3++] = ae3;
                                }
                              }
                              Jt3 = 1;
                              break i;
                            }
                          Jt3 || (Wt3.a = 3), Dt3 = Jt3;
                        }
                        (Dt3 = Dt3 && !Ot3.h) && (jt3 = h3(Ft3, Ct3, 8, kt3, xt3)), Dt3 && jt3 != 0 ? zt3 = jt3 : (St2.a = 3, zt3 = 0);
                      }
                      if (zt3 == 0)
                        break r;
                      if (Nt3 && Kn[V3] == 1 && (Nt3 = gt3[G3].g == 0), wt3 += gt3[G3].g, G3 += zt3, 3 >= V3) {
                        var oe3, se3 = pt3[0];
                        for (oe3 = 1; oe3 < ut3; ++oe3)
                          pt3[oe3] > se3 && (se3 = pt3[oe3]);
                        Lt3 += se3;
                      }
                    }
                    if (mt3.nd = Nt3, mt3.Qb = 0, Nt3 && (mt3.qb = (vt3[3][bt3[3] + 0].value << 24 | vt3[1][bt3[1] + 0].value << 16 | vt3[2][bt3[2] + 0].value) >>> 0, wt3 == 0 && 256 > vt3[0][bt3[0] + 0].value && (mt3.Qb = 1, mt3.qb += vt3[0][bt3[0] + 0].value << 8)), mt3.jc = !mt3.Qb && 6 > Lt3, mt3.jc) {
                      var ce3, ue3 = mt3;
                      for (ce3 = 0; ce3 < Dr; ++ce3) {
                        var he3 = ce3, le3 = ue3.pd[he3], fe3 = ue3.G[0][ue3.H[0] + he3];
                        256 <= fe3.value ? (le3.g = fe3.g + 256, le3.value = fe3.value) : (le3.g = 0, le3.value = 0, he3 >>= yt2(fe3, 8, le3), he3 >>= yt2(ue3.G[1][ue3.H[1] + he3], 16, le3), he3 >>= yt2(ue3.G[2][ue3.H[2] + he3], 0, le3), yt2(ue3.G[3][ue3.H[3] + he3], 24, le3));
                      }
                    }
                  }
                  Q3.vc = tt3, Q3.Wb = et3, Q3.Ya = dt3, Q3.yc = ht3, H5 = 1;
                  break e;
                }
              H5 = 0;
            }
          if (!(u4 = H5)) {
            s3.a = 3;
            break t;
          }
          if (0 < b4) {
            if (m4.ua = 1 << b4, !O2(m4.Wa, b4)) {
              s3.a = 1, u4 = 0;
              break t;
            }
          } else
            m4.ua = 0;
          var de3 = s3, pe3 = f4, ge3 = p7, me3 = de3.s, ve3 = me3.xc;
          if (de3.c = pe3, de3.i = ge3, me3.md = q2(pe3, ve3), me3.wc = ve3 == 0 ? -1 : (1 << ve3) - 1, n3) {
            s3.xb = pi;
            break t;
          }
          if ((v4 = a2(f4 * p7)) == null) {
            s3.a = 1, u4 = 0;
            break t;
          }
          u4 = (u4 = _t2(s3, v4, 0, f4, p7, p7, null)) && !g4.h;
          break t;
        }
      return u4 ? (c4 != null ? c4[0] = v4 : (e2(v4 == null), e2(n3)), s3.$ = 0, n3 || Pt2(m4)) : Pt2(m4), u4;
    }
    function Ft2(t5, r3) {
      var n3 = t5.c * t5.i, i3 = n3 + r3 + 16 * r3;
      return e2(t5.c <= r3), t5.V = a2(i3), t5.V == null ? (t5.Ta = null, t5.Ua = 0, t5.a = 1, 0) : (t5.Ta = t5.V, t5.Ua = t5.Ba + n3 + r3, 1);
    }
    function Ct2(t5, r3) {
      var n3 = t5.C, i3 = r3 - n3, a3 = t5.V, o3 = t5.Ba + t5.c * n3;
      for (e2(r3 <= t5.l.o); 0 < i3; ) {
        var s3 = 16 < i3 ? 16 : i3, c4 = t5.l.ma, u4 = t5.l.width, h4 = u4 * s3, l4 = c4.ca, f4 = c4.tb + u4 * n3, d4 = t5.Ta, p7 = t5.Ua;
        Nt2(t5, s3, a3, o3), _n(d4, p7, l4, f4, h4), xt2(c4, n3, n3 + s3, l4, f4, u4), i3 -= s3, a3 += s3 * t5.c, n3 += s3;
      }
      e2(n3 == r3), t5.C = t5.Ma = r3;
    }
    function jt2() {
      this.ub = this.yd = this.td = this.Rb = 0;
    }
    function Ot2() {
      this.Kd = this.Ld = this.Ud = this.Td = this.i = this.c = 0;
    }
    function Bt2() {
      this.Fb = this.Bb = this.Cb = 0, this.Zb = a2(4), this.Lb = a2(4);
    }
    function Mt2() {
      this.Yb = function() {
        var t5 = [];
        return function t6(e3, r3, n3) {
          for (var i3 = n3[r3], a3 = 0; a3 < i3 && (e3.push(n3.length > r3 + 1 ? [] : 0), !(n3.length < r3 + 1)); a3++)
            t6(e3[a3], r3 + 1, n3);
        }(t5, 0, [3, 11]), t5;
      }();
    }
    function Et2() {
      this.jb = a2(3), this.Wc = s2([4, 8], Mt2), this.Xc = s2([4, 17], Mt2);
    }
    function qt2() {
      this.Pc = this.wb = this.Tb = this.zd = 0, this.vd = new a2(4), this.od = new a2(4);
    }
    function Dt2() {
      this.ld = this.La = this.dd = this.tc = 0;
    }
    function Rt2() {
      this.Na = this.la = 0;
    }
    function Tt2() {
      this.Sc = [0, 0], this.Eb = [0, 0], this.Qc = [0, 0], this.ia = this.lc = 0;
    }
    function zt2() {
      this.ad = a2(384), this.Za = 0, this.Ob = a2(16), this.$b = this.Ad = this.ia = this.Gc = this.Hc = this.Dd = 0;
    }
    function Ut2() {
      this.uc = this.M = this.Nb = 0, this.wa = Array(new Dt2()), this.Y = 0, this.ya = Array(new zt2()), this.aa = 0, this.l = new Gt2();
    }
    function Ht2() {
      this.y = a2(16), this.f = a2(8), this.ea = a2(8);
    }
    function Wt2() {
      this.cb = this.a = 0, this.sc = "", this.m = new w3(), this.Od = new jt2(), this.Kc = new Ot2(), this.ed = new qt2(), this.Qa = new Bt2(), this.Ic = this.$c = this.Aa = 0, this.D = new Ut2(), this.Xb = this.Va = this.Hb = this.zb = this.yb = this.Ub = this.za = 0, this.Jc = o2(8, w3), this.ia = 0, this.pb = o2(4, Tt2), this.Pa = new Et2(), this.Bd = this.kc = 0, this.Ac = [], this.Bc = 0, this.zc = [0, 0, 0, 0], this.Gd = Array(new Ht2()), this.Hd = 0, this.rb = Array(new Rt2()), this.sb = 0, this.wa = Array(new Dt2()), this.Y = 0, this.oc = [], this.pc = 0, this.sa = [], this.ta = 0, this.qa = [], this.ra = 0, this.Ha = [], this.B = this.R = this.Ia = 0, this.Ec = [], this.M = this.ja = this.Vb = this.Fc = 0, this.ya = Array(new zt2()), this.L = this.aa = 0, this.gd = s2([4, 2], Dt2), this.ga = null, this.Fa = [], this.Cc = this.qc = this.P = 0, this.Gb = [], this.Uc = 0, this.mb = [], this.nb = 0, this.rc = [], this.Ga = this.Vc = 0;
    }
    function Vt2(t5, e3) {
      return 0 > t5 ? 0 : t5 > e3 ? e3 : t5;
    }
    function Gt2() {
      this.T = this.U = this.ka = this.height = this.width = 0, this.y = [], this.f = [], this.ea = [], this.Rc = this.fa = this.W = this.N = this.O = 0, this.ma = "void", this.put = "VP8IoPutHook", this.ac = "VP8IoSetupHook", this.bc = "VP8IoTeardownHook", this.ha = this.Kb = 0, this.data = [], this.hb = this.ib = this.da = this.o = this.j = this.va = this.v = this.Da = this.ob = this.w = 0, this.F = [], this.J = 0;
    }
    function Yt2() {
      var t5 = new Wt2();
      return t5 != null && (t5.a = 0, t5.sc = "OK", t5.cb = 0, t5.Xb = 0, ni || (ni = Zt2)), t5;
    }
    function Jt2(t5, e3, r3) {
      return t5.a == 0 && (t5.a = e3, t5.sc = r3, t5.cb = 0), 0;
    }
    function Xt2(t5, e3, r3) {
      return 3 <= r3 && t5[e3 + 0] == 157 && t5[e3 + 1] == 1 && t5[e3 + 2] == 42;
    }
    function Kt2(t5, r3) {
      if (t5 == null)
        return 0;
      if (t5.a = 0, t5.sc = "OK", r3 == null)
        return Jt2(t5, 2, "null VP8Io passed to VP8GetHeaders()");
      var n3 = r3.data, a3 = r3.w, o3 = r3.ha;
      if (4 > o3)
        return Jt2(t5, 7, "Truncated header.");
      var s3 = n3[a3 + 0] | n3[a3 + 1] << 8 | n3[a3 + 2] << 16, c4 = t5.Od;
      if (c4.Rb = !(1 & s3), c4.td = s3 >> 1 & 7, c4.yd = s3 >> 4 & 1, c4.ub = s3 >> 5, 3 < c4.td)
        return Jt2(t5, 3, "Incorrect keyframe parameters.");
      if (!c4.yd)
        return Jt2(t5, 4, "Frame not displayable.");
      a3 += 3, o3 -= 3;
      var u4 = t5.Kc;
      if (c4.Rb) {
        if (7 > o3)
          return Jt2(t5, 7, "cannot parse picture header");
        if (!Xt2(n3, a3, o3))
          return Jt2(t5, 3, "Bad code word");
        u4.c = 16383 & (n3[a3 + 4] << 8 | n3[a3 + 3]), u4.Td = n3[a3 + 4] >> 6, u4.i = 16383 & (n3[a3 + 6] << 8 | n3[a3 + 5]), u4.Ud = n3[a3 + 6] >> 6, a3 += 7, o3 -= 7, t5.za = u4.c + 15 >> 4, t5.Ub = u4.i + 15 >> 4, r3.width = u4.c, r3.height = u4.i, r3.Da = 0, r3.j = 0, r3.v = 0, r3.va = r3.width, r3.o = r3.height, r3.da = 0, r3.ib = r3.width, r3.hb = r3.height, r3.U = r3.width, r3.T = r3.height, i2((s3 = t5.Pa).jb, 0, 255, s3.jb.length), e2((s3 = t5.Qa) != null), s3.Cb = 0, s3.Bb = 0, s3.Fb = 1, i2(s3.Zb, 0, 0, s3.Zb.length), i2(s3.Lb, 0, 0, s3.Lb);
      }
      if (c4.ub > o3)
        return Jt2(t5, 7, "bad partition length");
      p6(s3 = t5.m, n3, a3, c4.ub), a3 += c4.ub, o3 -= c4.ub, c4.Rb && (u4.Ld = P2(s3), u4.Kd = P2(s3)), u4 = t5.Qa;
      var h4, l4 = t5.Pa;
      if (e2(s3 != null), e2(u4 != null), u4.Cb = P2(s3), u4.Cb) {
        if (u4.Bb = P2(s3), P2(s3)) {
          for (u4.Fb = P2(s3), h4 = 0; 4 > h4; ++h4)
            u4.Zb[h4] = P2(s3) ? m3(s3, 7) : 0;
          for (h4 = 0; 4 > h4; ++h4)
            u4.Lb[h4] = P2(s3) ? m3(s3, 6) : 0;
        }
        if (u4.Bb)
          for (h4 = 0; 3 > h4; ++h4)
            l4.jb[h4] = P2(s3) ? g3(s3, 8) : 255;
      } else
        u4.Bb = 0;
      if (s3.Ka)
        return Jt2(t5, 3, "cannot parse segment header");
      if ((u4 = t5.ed).zd = P2(s3), u4.Tb = g3(s3, 6), u4.wb = g3(s3, 3), u4.Pc = P2(s3), u4.Pc && P2(s3)) {
        for (l4 = 0; 4 > l4; ++l4)
          P2(s3) && (u4.vd[l4] = m3(s3, 6));
        for (l4 = 0; 4 > l4; ++l4)
          P2(s3) && (u4.od[l4] = m3(s3, 6));
      }
      if (t5.L = u4.Tb == 0 ? 0 : u4.zd ? 1 : 2, s3.Ka)
        return Jt2(t5, 3, "cannot parse filter header");
      var f4 = o3;
      if (o3 = h4 = a3, a3 = h4 + f4, u4 = f4, t5.Xb = (1 << g3(t5.m, 2)) - 1, f4 < 3 * (l4 = t5.Xb))
        n3 = 7;
      else {
        for (h4 += 3 * l4, u4 -= 3 * l4, f4 = 0; f4 < l4; ++f4) {
          var d4 = n3[o3 + 0] | n3[o3 + 1] << 8 | n3[o3 + 2] << 16;
          d4 > u4 && (d4 = u4), p6(t5.Jc[+f4], n3, h4, d4), h4 += d4, u4 -= d4, o3 += 3;
        }
        p6(t5.Jc[+l4], n3, h4, u4), n3 = h4 < a3 ? 0 : 5;
      }
      if (n3 != 0)
        return Jt2(t5, n3, "cannot parse partitions");
      for (n3 = g3(h4 = t5.m, 7), o3 = P2(h4) ? m3(h4, 4) : 0, a3 = P2(h4) ? m3(h4, 4) : 0, u4 = P2(h4) ? m3(h4, 4) : 0, l4 = P2(h4) ? m3(h4, 4) : 0, h4 = P2(h4) ? m3(h4, 4) : 0, f4 = t5.Qa, d4 = 0; 4 > d4; ++d4) {
        if (f4.Cb) {
          var v4 = f4.Zb[d4];
          f4.Fb || (v4 += n3);
        } else {
          if (0 < d4) {
            t5.pb[d4] = t5.pb[0];
            continue;
          }
          v4 = n3;
        }
        var b4 = t5.pb[d4];
        b4.Sc[0] = ei[Vt2(v4 + o3, 127)], b4.Sc[1] = ri[Vt2(v4 + 0, 127)], b4.Eb[0] = 2 * ei[Vt2(v4 + a3, 127)], b4.Eb[1] = 101581 * ri[Vt2(v4 + u4, 127)] >> 16, 8 > b4.Eb[1] && (b4.Eb[1] = 8), b4.Qc[0] = ei[Vt2(v4 + l4, 117)], b4.Qc[1] = ri[Vt2(v4 + h4, 127)], b4.lc = v4 + h4;
      }
      if (!c4.Rb)
        return Jt2(t5, 4, "Not a key frame.");
      for (P2(s3), c4 = t5.Pa, n3 = 0; 4 > n3; ++n3) {
        for (o3 = 0; 8 > o3; ++o3)
          for (a3 = 0; 3 > a3; ++a3)
            for (u4 = 0; 11 > u4; ++u4)
              l4 = k2(s3, ui[n3][o3][a3][u4]) ? g3(s3, 8) : si[n3][o3][a3][u4], c4.Wc[n3][o3].Yb[a3][u4] = l4;
        for (o3 = 0; 17 > o3; ++o3)
          c4.Xc[n3][o3] = c4.Wc[n3][hi[o3]];
      }
      return t5.kc = P2(s3), t5.kc && (t5.Bd = g3(s3, 8)), t5.cb = 1;
    }
    function Zt2(t5, e3, r3, n3, i3, a3, o3) {
      var s3 = e3[i3].Yb[r3];
      for (r3 = 0; 16 > i3; ++i3) {
        if (!k2(t5, s3[r3 + 0]))
          return i3;
        for (; !k2(t5, s3[r3 + 1]); )
          if (s3 = e3[++i3].Yb[0], r3 = 0, i3 == 16)
            return 16;
        var c4 = e3[i3 + 1].Yb;
        if (k2(t5, s3[r3 + 2])) {
          var u4 = t5, h4 = 0;
          if (k2(u4, (f4 = s3)[(l4 = r3) + 3]))
            if (k2(u4, f4[l4 + 6])) {
              for (s3 = 0, l4 = 2 * (h4 = k2(u4, f4[l4 + 8])) + (f4 = k2(u4, f4[l4 + 9 + h4])), h4 = 0, f4 = ii[l4]; f4[s3]; ++s3)
                h4 += h4 + k2(u4, f4[s3]);
              h4 += 3 + (8 << l4);
            } else
              k2(u4, f4[l4 + 7]) ? (h4 = 7 + 2 * k2(u4, 165), h4 += k2(u4, 145)) : h4 = 5 + k2(u4, 159);
          else
            h4 = k2(u4, f4[l4 + 4]) ? 3 + k2(u4, f4[l4 + 5]) : 2;
          s3 = c4[2];
        } else
          h4 = 1, s3 = c4[1];
        c4 = o3 + ai[i3], 0 > (u4 = t5).b && _2(u4);
        var l4, f4 = u4.b, d4 = (l4 = u4.Ca >> 1) - (u4.I >> f4) >> 31;
        --u4.b, u4.Ca += d4, u4.Ca |= 1, u4.I -= (l4 + 1 & d4) << f4, a3[c4] = ((h4 ^ d4) - d4) * n3[(0 < i3) + 0];
      }
      return 16;
    }
    function $t2(t5) {
      var e3 = t5.rb[t5.sb - 1];
      e3.la = 0, e3.Na = 0, i2(t5.zc, 0, 0, t5.zc.length), t5.ja = 0;
    }
    function Qt2(t5, r3) {
      if (t5 == null)
        return 0;
      if (r3 == null)
        return Jt2(t5, 2, "NULL VP8Io parameter in VP8Decode().");
      if (!t5.cb && !Kt2(t5, r3))
        return 0;
      if (e2(t5.cb), r3.ac == null || r3.ac(r3)) {
        r3.ob && (t5.L = 0);
        var s3 = Ri[t5.L];
        if (t5.L == 2 ? (t5.yb = 0, t5.zb = 0) : (t5.yb = r3.v - s3 >> 4, t5.zb = r3.j - s3 >> 4, 0 > t5.yb && (t5.yb = 0), 0 > t5.zb && (t5.zb = 0)), t5.Va = r3.o + 15 + s3 >> 4, t5.Hb = r3.va + 15 + s3 >> 4, t5.Hb > t5.za && (t5.Hb = t5.za), t5.Va > t5.Ub && (t5.Va = t5.Ub), 0 < t5.L) {
          var c4 = t5.ed;
          for (s3 = 0; 4 > s3; ++s3) {
            var u4;
            if (t5.Qa.Cb) {
              var h4 = t5.Qa.Lb[s3];
              t5.Qa.Fb || (h4 += c4.Tb);
            } else
              h4 = c4.Tb;
            for (u4 = 0; 1 >= u4; ++u4) {
              var l4 = t5.gd[s3][u4], f4 = h4;
              if (c4.Pc && (f4 += c4.vd[0], u4 && (f4 += c4.od[0])), 0 < (f4 = 0 > f4 ? 0 : 63 < f4 ? 63 : f4)) {
                var d4 = f4;
                0 < c4.wb && ((d4 = 4 < c4.wb ? d4 >> 2 : d4 >> 1) > 9 - c4.wb && (d4 = 9 - c4.wb)), 1 > d4 && (d4 = 1), l4.dd = d4, l4.tc = 2 * f4 + d4, l4.ld = 40 <= f4 ? 2 : 15 <= f4 ? 1 : 0;
              } else
                l4.tc = 0;
              l4.La = u4;
            }
          }
        }
        s3 = 0;
      } else
        Jt2(t5, 6, "Frame setup failed"), s3 = t5.a;
      if (s3 = s3 == 0) {
        if (s3) {
          t5.$c = 0, 0 < t5.Aa || (t5.Ic = zi);
          t: {
            s3 = t5.Ic;
            c4 = 4 * (d4 = t5.za);
            var p7 = 32 * d4, g4 = d4 + 1, m4 = 0 < t5.L ? d4 * (0 < t5.Aa ? 2 : 1) : 0, v4 = (t5.Aa == 2 ? 2 : 1) * d4;
            if ((l4 = c4 + 832 + (u4 = 3 * (16 * s3 + Ri[t5.L]) / 2 * p7) + (h4 = t5.Fa != null && 0 < t5.Fa.length ? t5.Kc.c * t5.Kc.i : 0)) != l4)
              s3 = 0;
            else {
              if (l4 > t5.Vb) {
                if (t5.Vb = 0, t5.Ec = a2(l4), t5.Fc = 0, t5.Ec == null) {
                  s3 = Jt2(t5, 1, "no memory during frame initialization.");
                  break t;
                }
                t5.Vb = l4;
              }
              l4 = t5.Ec, f4 = t5.Fc, t5.Ac = l4, t5.Bc = f4, f4 += c4, t5.Gd = o2(p7, Ht2), t5.Hd = 0, t5.rb = o2(g4 + 1, Rt2), t5.sb = 1, t5.wa = m4 ? o2(m4, Dt2) : null, t5.Y = 0, t5.D.Nb = 0, t5.D.wa = t5.wa, t5.D.Y = t5.Y, 0 < t5.Aa && (t5.D.Y += d4), e2(true), t5.oc = l4, t5.pc = f4, f4 += 832, t5.ya = o2(v4, zt2), t5.aa = 0, t5.D.ya = t5.ya, t5.D.aa = t5.aa, t5.Aa == 2 && (t5.D.aa += d4), t5.R = 16 * d4, t5.B = 8 * d4, d4 = (p7 = Ri[t5.L]) * t5.R, p7 = p7 / 2 * t5.B, t5.sa = l4, t5.ta = f4 + d4, t5.qa = t5.sa, t5.ra = t5.ta + 16 * s3 * t5.R + p7, t5.Ha = t5.qa, t5.Ia = t5.ra + 8 * s3 * t5.B + p7, t5.$c = 0, f4 += u4, t5.mb = h4 ? l4 : null, t5.nb = h4 ? f4 : null, e2(f4 + h4 <= t5.Fc + t5.Vb), $t2(t5), i2(t5.Ac, t5.Bc, 0, c4), s3 = 1;
            }
          }
          if (s3) {
            if (r3.ka = 0, r3.y = t5.sa, r3.O = t5.ta, r3.f = t5.qa, r3.N = t5.ra, r3.ea = t5.Ha, r3.Vd = t5.Ia, r3.fa = t5.R, r3.Rc = t5.B, r3.F = null, r3.J = 0, !Cn) {
              for (s3 = -255; 255 >= s3; ++s3)
                Pn[255 + s3] = 0 > s3 ? -s3 : s3;
              for (s3 = -1020; 1020 >= s3; ++s3)
                kn[1020 + s3] = -128 > s3 ? -128 : 127 < s3 ? 127 : s3;
              for (s3 = -112; 112 >= s3; ++s3)
                In[112 + s3] = -16 > s3 ? -16 : 15 < s3 ? 15 : s3;
              for (s3 = -255; 510 >= s3; ++s3)
                Fn[255 + s3] = 0 > s3 ? 0 : 255 < s3 ? 255 : s3;
              Cn = 1;
            }
            an = ue2, on = ae2, cn = oe2, un = se2, hn = ce2, sn = ie2, ln2 = Je, fn = Xe, dn = $e, pn = Qe, gn = Ke, mn = Ze, vn = tr, bn = er, yn = Ue, wn = He, Nn = We, Ln = Ve, fi[0] = xe, fi[1] = le2, fi[2] = Le2, fi[3] = Ae, fi[4] = Se, fi[5] = Pe, fi[6] = _e, fi[7] = ke, fi[8] = Fe, fi[9] = Ie, li[0] = ve2, li[1] = de2, li[2] = pe2, li[3] = ge2, li[4] = be2, li[5] = ye2, li[6] = we2, di[0] = Be, di[1] = fe2, di[2] = Ce, di[3] = je, di[4] = Ee, di[5] = Me, di[6] = qe, s3 = 1;
          } else
            s3 = 0;
        }
        s3 && (s3 = function(t6, r4) {
          for (t6.M = 0; t6.M < t6.Va; ++t6.M) {
            var o3, s4 = t6.Jc[t6.M & t6.Xb], c5 = t6.m, u5 = t6;
            for (o3 = 0; o3 < u5.za; ++o3) {
              var h5 = c5, l5 = u5, f5 = l5.Ac, d5 = l5.Bc + 4 * o3, p8 = l5.zc, g5 = l5.ya[l5.aa + o3];
              if (l5.Qa.Bb ? g5.$b = k2(h5, l5.Pa.jb[0]) ? 2 + k2(h5, l5.Pa.jb[2]) : k2(h5, l5.Pa.jb[1]) : g5.$b = 0, l5.kc && (g5.Ad = k2(h5, l5.Bd)), g5.Za = !k2(h5, 145) + 0, g5.Za) {
                var m5 = g5.Ob, v5 = 0;
                for (l5 = 0; 4 > l5; ++l5) {
                  var b4, y4 = p8[0 + l5];
                  for (b4 = 0; 4 > b4; ++b4) {
                    y4 = ci[f5[d5 + b4]][y4];
                    for (var w4 = oi[k2(h5, y4[0])]; 0 < w4; )
                      w4 = oi[2 * w4 + k2(h5, y4[w4])];
                    y4 = -w4, f5[d5 + b4] = y4;
                  }
                  n2(m5, v5, f5, d5, 4), v5 += 4, p8[0 + l5] = y4;
                }
              } else
                y4 = k2(h5, 156) ? k2(h5, 128) ? 1 : 3 : k2(h5, 163) ? 2 : 0, g5.Ob[0] = y4, i2(f5, d5, y4, 4), i2(p8, 0, y4, 4);
              g5.Dd = k2(h5, 142) ? k2(h5, 114) ? k2(h5, 183) ? 1 : 3 : 2 : 0;
            }
            if (u5.m.Ka)
              return Jt2(t6, 7, "Premature end-of-partition0 encountered.");
            for (; t6.ja < t6.za; ++t6.ja) {
              if (u5 = s4, h5 = (c5 = t6).rb[c5.sb - 1], f5 = c5.rb[c5.sb + c5.ja], o3 = c5.ya[c5.aa + c5.ja], d5 = c5.kc ? o3.Ad : 0)
                h5.la = f5.la = 0, o3.Za || (h5.Na = f5.Na = 0), o3.Hc = 0, o3.Gc = 0, o3.ia = 0;
              else {
                var N4, L4;
                h5 = f5, f5 = u5, d5 = c5.Pa.Xc, p8 = c5.ya[c5.aa + c5.ja], g5 = c5.pb[p8.$b];
                if (l5 = p8.ad, m5 = 0, v5 = c5.rb[c5.sb - 1], y4 = b4 = 0, i2(l5, m5, 0, 384), p8.Za)
                  var A4 = 0, x3 = d5[3];
                else {
                  w4 = a2(16);
                  var S3 = h5.Na + v5.Na;
                  if (S3 = ni(f5, d5[1], S3, g5.Eb, 0, w4, 0), h5.Na = v5.Na = (0 < S3) + 0, 1 < S3)
                    an(w4, 0, l5, m5);
                  else {
                    var _3 = w4[0] + 3 >> 3;
                    for (w4 = 0; 256 > w4; w4 += 16)
                      l5[m5 + w4] = _3;
                  }
                  A4 = 1, x3 = d5[0];
                }
                var P3 = 15 & h5.la, I3 = 15 & v5.la;
                for (w4 = 0; 4 > w4; ++w4) {
                  var F3 = 1 & I3;
                  for (_3 = L4 = 0; 4 > _3; ++_3)
                    P3 = P3 >> 1 | (F3 = (S3 = ni(f5, x3, S3 = F3 + (1 & P3), g5.Sc, A4, l5, m5)) > A4) << 7, L4 = L4 << 2 | (3 < S3 ? 3 : 1 < S3 ? 2 : l5[m5 + 0] != 0), m5 += 16;
                  P3 >>= 4, I3 = I3 >> 1 | F3 << 7, b4 = (b4 << 8 | L4) >>> 0;
                }
                for (x3 = P3, A4 = I3 >> 4, N4 = 0; 4 > N4; N4 += 2) {
                  for (L4 = 0, P3 = h5.la >> 4 + N4, I3 = v5.la >> 4 + N4, w4 = 0; 2 > w4; ++w4) {
                    for (F3 = 1 & I3, _3 = 0; 2 > _3; ++_3)
                      S3 = F3 + (1 & P3), P3 = P3 >> 1 | (F3 = 0 < (S3 = ni(f5, d5[2], S3, g5.Qc, 0, l5, m5))) << 3, L4 = L4 << 2 | (3 < S3 ? 3 : 1 < S3 ? 2 : l5[m5 + 0] != 0), m5 += 16;
                    P3 >>= 2, I3 = I3 >> 1 | F3 << 5;
                  }
                  y4 |= L4 << 4 * N4, x3 |= P3 << 4 << N4, A4 |= (240 & I3) << N4;
                }
                h5.la = x3, v5.la = A4, p8.Hc = b4, p8.Gc = y4, p8.ia = 43690 & y4 ? 0 : g5.ia, d5 = !(b4 | y4);
              }
              if (0 < c5.L && (c5.wa[c5.Y + c5.ja] = c5.gd[o3.$b][o3.Za], c5.wa[c5.Y + c5.ja].La |= !d5), u5.Ka)
                return Jt2(t6, 7, "Premature end-of-file encountered.");
            }
            if ($t2(t6), c5 = r4, u5 = 1, o3 = (s4 = t6).D, h5 = 0 < s4.L && s4.M >= s4.zb && s4.M <= s4.Va, s4.Aa == 0)
              t: {
                if (o3.M = s4.M, o3.uc = h5, Or(s4, o3), u5 = 1, o3 = (L4 = s4.D).Nb, h5 = (y4 = Ri[s4.L]) * s4.R, f5 = y4 / 2 * s4.B, w4 = 16 * o3 * s4.R, _3 = 8 * o3 * s4.B, d5 = s4.sa, p8 = s4.ta - h5 + w4, g5 = s4.qa, l5 = s4.ra - f5 + _3, m5 = s4.Ha, v5 = s4.Ia - f5 + _3, I3 = (P3 = L4.M) == 0, b4 = P3 >= s4.Va - 1, s4.Aa == 2 && Or(s4, L4), L4.uc)
                  for (F3 = (S3 = s4).D.M, e2(S3.D.uc), L4 = S3.yb; L4 < S3.Hb; ++L4) {
                    A4 = L4, x3 = F3;
                    var C3 = (j3 = (z3 = S3).D).Nb;
                    N4 = z3.R;
                    var j3 = j3.wa[j3.Y + A4], O3 = z3.sa, B4 = z3.ta + 16 * C3 * N4 + 16 * A4, M3 = j3.dd, E3 = j3.tc;
                    if (E3 != 0)
                      if (e2(3 <= E3), z3.L == 1)
                        0 < A4 && wn(O3, B4, N4, E3 + 4), j3.La && Ln(O3, B4, N4, E3), 0 < x3 && yn(O3, B4, N4, E3 + 4), j3.La && Nn(O3, B4, N4, E3);
                      else {
                        var q3 = z3.B, D3 = z3.qa, R3 = z3.ra + 8 * C3 * q3 + 8 * A4, T3 = z3.Ha, z3 = z3.Ia + 8 * C3 * q3 + 8 * A4;
                        C3 = j3.ld;
                        0 < A4 && (fn(O3, B4, N4, E3 + 4, M3, C3), pn(D3, R3, T3, z3, q3, E3 + 4, M3, C3)), j3.La && (mn(O3, B4, N4, E3, M3, C3), bn(D3, R3, T3, z3, q3, E3, M3, C3)), 0 < x3 && (ln2(O3, B4, N4, E3 + 4, M3, C3), dn(D3, R3, T3, z3, q3, E3 + 4, M3, C3)), j3.La && (gn(O3, B4, N4, E3, M3, C3), vn(D3, R3, T3, z3, q3, E3, M3, C3));
                      }
                  }
                if (s4.ia && alert("todo:DitherRow"), c5.put != null) {
                  if (L4 = 16 * P3, P3 = 16 * (P3 + 1), I3 ? (c5.y = s4.sa, c5.O = s4.ta + w4, c5.f = s4.qa, c5.N = s4.ra + _3, c5.ea = s4.Ha, c5.W = s4.Ia + _3) : (L4 -= y4, c5.y = d5, c5.O = p8, c5.f = g5, c5.N = l5, c5.ea = m5, c5.W = v5), b4 || (P3 -= y4), P3 > c5.o && (P3 = c5.o), c5.F = null, c5.J = null, s4.Fa != null && 0 < s4.Fa.length && L4 < P3 && (c5.J = lr(s4, c5, L4, P3 - L4), c5.F = s4.mb, c5.F == null && c5.F.length == 0)) {
                    u5 = Jt2(s4, 3, "Could not decode alpha data.");
                    break t;
                  }
                  L4 < c5.j && (y4 = c5.j - L4, L4 = c5.j, e2(!(1 & y4)), c5.O += s4.R * y4, c5.N += s4.B * (y4 >> 1), c5.W += s4.B * (y4 >> 1), c5.F != null && (c5.J += c5.width * y4)), L4 < P3 && (c5.O += c5.v, c5.N += c5.v >> 1, c5.W += c5.v >> 1, c5.F != null && (c5.J += c5.v), c5.ka = L4 - c5.j, c5.U = c5.va - c5.v, c5.T = P3 - L4, u5 = c5.put(c5));
                }
                o3 + 1 != s4.Ic || b4 || (n2(s4.sa, s4.ta - h5, d5, p8 + 16 * s4.R, h5), n2(s4.qa, s4.ra - f5, g5, l5 + 8 * s4.B, f5), n2(s4.Ha, s4.Ia - f5, m5, v5 + 8 * s4.B, f5));
              }
            if (!u5)
              return Jt2(t6, 6, "Output aborted.");
          }
          return 1;
        }(t5, r3)), r3.bc != null && r3.bc(r3), s3 &= 1;
      }
      return s3 ? (t5.cb = 0, s3) : 0;
    }
    function te2(t5, e3, r3, n3, i3) {
      i3 = t5[e3 + r3 + 32 * n3] + (i3 >> 3), t5[e3 + r3 + 32 * n3] = -256 & i3 ? 0 > i3 ? 0 : 255 : i3;
    }
    function ee2(t5, e3, r3, n3, i3, a3) {
      te2(t5, e3, 0, r3, n3 + i3), te2(t5, e3, 1, r3, n3 + a3), te2(t5, e3, 2, r3, n3 - a3), te2(t5, e3, 3, r3, n3 - i3);
    }
    function re2(t5) {
      return (20091 * t5 >> 16) + t5;
    }
    function ne2(t5, e3, r3, n3) {
      var i3, o3 = 0, s3 = a2(16);
      for (i3 = 0; 4 > i3; ++i3) {
        var c4 = t5[e3 + 0] + t5[e3 + 8], u4 = t5[e3 + 0] - t5[e3 + 8], h4 = (35468 * t5[e3 + 4] >> 16) - re2(t5[e3 + 12]), l4 = re2(t5[e3 + 4]) + (35468 * t5[e3 + 12] >> 16);
        s3[o3 + 0] = c4 + l4, s3[o3 + 1] = u4 + h4, s3[o3 + 2] = u4 - h4, s3[o3 + 3] = c4 - l4, o3 += 4, e3++;
      }
      for (i3 = o3 = 0; 4 > i3; ++i3)
        c4 = (t5 = s3[o3 + 0] + 4) + s3[o3 + 8], u4 = t5 - s3[o3 + 8], h4 = (35468 * s3[o3 + 4] >> 16) - re2(s3[o3 + 12]), te2(r3, n3, 0, 0, c4 + (l4 = re2(s3[o3 + 4]) + (35468 * s3[o3 + 12] >> 16))), te2(r3, n3, 1, 0, u4 + h4), te2(r3, n3, 2, 0, u4 - h4), te2(r3, n3, 3, 0, c4 - l4), o3++, n3 += 32;
    }
    function ie2(t5, e3, r3, n3) {
      var i3 = t5[e3 + 0] + 4, a3 = 35468 * t5[e3 + 4] >> 16, o3 = re2(t5[e3 + 4]), s3 = 35468 * t5[e3 + 1] >> 16;
      ee2(r3, n3, 0, i3 + o3, t5 = re2(t5[e3 + 1]), s3), ee2(r3, n3, 1, i3 + a3, t5, s3), ee2(r3, n3, 2, i3 - a3, t5, s3), ee2(r3, n3, 3, i3 - o3, t5, s3);
    }
    function ae2(t5, e3, r3, n3, i3) {
      ne2(t5, e3, r3, n3), i3 && ne2(t5, e3 + 16, r3, n3 + 4);
    }
    function oe2(t5, e3, r3, n3) {
      on(t5, e3 + 0, r3, n3, 1), on(t5, e3 + 32, r3, n3 + 128, 1);
    }
    function se2(t5, e3, r3, n3) {
      var i3;
      for (t5 = t5[e3 + 0] + 4, i3 = 0; 4 > i3; ++i3)
        for (e3 = 0; 4 > e3; ++e3)
          te2(r3, n3, e3, i3, t5);
    }
    function ce2(t5, e3, r3, n3) {
      t5[e3 + 0] && un(t5, e3 + 0, r3, n3), t5[e3 + 16] && un(t5, e3 + 16, r3, n3 + 4), t5[e3 + 32] && un(t5, e3 + 32, r3, n3 + 128), t5[e3 + 48] && un(t5, e3 + 48, r3, n3 + 128 + 4);
    }
    function ue2(t5, e3, r3, n3) {
      var i3, o3 = a2(16);
      for (i3 = 0; 4 > i3; ++i3) {
        var s3 = t5[e3 + 0 + i3] + t5[e3 + 12 + i3], c4 = t5[e3 + 4 + i3] + t5[e3 + 8 + i3], u4 = t5[e3 + 4 + i3] - t5[e3 + 8 + i3], h4 = t5[e3 + 0 + i3] - t5[e3 + 12 + i3];
        o3[0 + i3] = s3 + c4, o3[8 + i3] = s3 - c4, o3[4 + i3] = h4 + u4, o3[12 + i3] = h4 - u4;
      }
      for (i3 = 0; 4 > i3; ++i3)
        s3 = (t5 = o3[0 + 4 * i3] + 3) + o3[3 + 4 * i3], c4 = o3[1 + 4 * i3] + o3[2 + 4 * i3], u4 = o3[1 + 4 * i3] - o3[2 + 4 * i3], h4 = t5 - o3[3 + 4 * i3], r3[n3 + 0] = s3 + c4 >> 3, r3[n3 + 16] = h4 + u4 >> 3, r3[n3 + 32] = s3 - c4 >> 3, r3[n3 + 48] = h4 - u4 >> 3, n3 += 64;
    }
    function he2(t5, e3, r3) {
      var n3, i3 = e3 - 32, a3 = Bn, o3 = 255 - t5[i3 - 1];
      for (n3 = 0; n3 < r3; ++n3) {
        var s3, c4 = a3, u4 = o3 + t5[e3 - 1];
        for (s3 = 0; s3 < r3; ++s3)
          t5[e3 + s3] = c4[u4 + t5[i3 + s3]];
        e3 += 32;
      }
    }
    function le2(t5, e3) {
      he2(t5, e3, 4);
    }
    function fe2(t5, e3) {
      he2(t5, e3, 8);
    }
    function de2(t5, e3) {
      he2(t5, e3, 16);
    }
    function pe2(t5, e3) {
      var r3;
      for (r3 = 0; 16 > r3; ++r3)
        n2(t5, e3 + 32 * r3, t5, e3 - 32, 16);
    }
    function ge2(t5, e3) {
      var r3;
      for (r3 = 16; 0 < r3; --r3)
        i2(t5, e3, t5[e3 - 1], 16), e3 += 32;
    }
    function me2(t5, e3, r3) {
      var n3;
      for (n3 = 0; 16 > n3; ++n3)
        i2(e3, r3 + 32 * n3, t5, 16);
    }
    function ve2(t5, e3) {
      var r3, n3 = 16;
      for (r3 = 0; 16 > r3; ++r3)
        n3 += t5[e3 - 1 + 32 * r3] + t5[e3 + r3 - 32];
      me2(n3 >> 5, t5, e3);
    }
    function be2(t5, e3) {
      var r3, n3 = 8;
      for (r3 = 0; 16 > r3; ++r3)
        n3 += t5[e3 - 1 + 32 * r3];
      me2(n3 >> 4, t5, e3);
    }
    function ye2(t5, e3) {
      var r3, n3 = 8;
      for (r3 = 0; 16 > r3; ++r3)
        n3 += t5[e3 + r3 - 32];
      me2(n3 >> 4, t5, e3);
    }
    function we2(t5, e3) {
      me2(128, t5, e3);
    }
    function Ne2(t5, e3, r3) {
      return t5 + 2 * e3 + r3 + 2 >> 2;
    }
    function Le2(t5, e3) {
      var r3, i3 = e3 - 32;
      i3 = new Uint8Array([Ne2(t5[i3 - 1], t5[i3 + 0], t5[i3 + 1]), Ne2(t5[i3 + 0], t5[i3 + 1], t5[i3 + 2]), Ne2(t5[i3 + 1], t5[i3 + 2], t5[i3 + 3]), Ne2(t5[i3 + 2], t5[i3 + 3], t5[i3 + 4])]);
      for (r3 = 0; 4 > r3; ++r3)
        n2(t5, e3 + 32 * r3, i3, 0, i3.length);
    }
    function Ae(t5, e3) {
      var r3 = t5[e3 - 1], n3 = t5[e3 - 1 + 32], i3 = t5[e3 - 1 + 64], a3 = t5[e3 - 1 + 96];
      I2(t5, e3 + 0, 16843009 * Ne2(t5[e3 - 1 - 32], r3, n3)), I2(t5, e3 + 32, 16843009 * Ne2(r3, n3, i3)), I2(t5, e3 + 64, 16843009 * Ne2(n3, i3, a3)), I2(t5, e3 + 96, 16843009 * Ne2(i3, a3, a3));
    }
    function xe(t5, e3) {
      var r3, n3 = 4;
      for (r3 = 0; 4 > r3; ++r3)
        n3 += t5[e3 + r3 - 32] + t5[e3 - 1 + 32 * r3];
      for (n3 >>= 3, r3 = 0; 4 > r3; ++r3)
        i2(t5, e3 + 32 * r3, n3, 4);
    }
    function Se(t5, e3) {
      var r3 = t5[e3 - 1 + 0], n3 = t5[e3 - 1 + 32], i3 = t5[e3 - 1 + 64], a3 = t5[e3 - 1 - 32], o3 = t5[e3 + 0 - 32], s3 = t5[e3 + 1 - 32], c4 = t5[e3 + 2 - 32], u4 = t5[e3 + 3 - 32];
      t5[e3 + 0 + 96] = Ne2(n3, i3, t5[e3 - 1 + 96]), t5[e3 + 1 + 96] = t5[e3 + 0 + 64] = Ne2(r3, n3, i3), t5[e3 + 2 + 96] = t5[e3 + 1 + 64] = t5[e3 + 0 + 32] = Ne2(a3, r3, n3), t5[e3 + 3 + 96] = t5[e3 + 2 + 64] = t5[e3 + 1 + 32] = t5[e3 + 0 + 0] = Ne2(o3, a3, r3), t5[e3 + 3 + 64] = t5[e3 + 2 + 32] = t5[e3 + 1 + 0] = Ne2(s3, o3, a3), t5[e3 + 3 + 32] = t5[e3 + 2 + 0] = Ne2(c4, s3, o3), t5[e3 + 3 + 0] = Ne2(u4, c4, s3);
    }
    function _e(t5, e3) {
      var r3 = t5[e3 + 1 - 32], n3 = t5[e3 + 2 - 32], i3 = t5[e3 + 3 - 32], a3 = t5[e3 + 4 - 32], o3 = t5[e3 + 5 - 32], s3 = t5[e3 + 6 - 32], c4 = t5[e3 + 7 - 32];
      t5[e3 + 0 + 0] = Ne2(t5[e3 + 0 - 32], r3, n3), t5[e3 + 1 + 0] = t5[e3 + 0 + 32] = Ne2(r3, n3, i3), t5[e3 + 2 + 0] = t5[e3 + 1 + 32] = t5[e3 + 0 + 64] = Ne2(n3, i3, a3), t5[e3 + 3 + 0] = t5[e3 + 2 + 32] = t5[e3 + 1 + 64] = t5[e3 + 0 + 96] = Ne2(i3, a3, o3), t5[e3 + 3 + 32] = t5[e3 + 2 + 64] = t5[e3 + 1 + 96] = Ne2(a3, o3, s3), t5[e3 + 3 + 64] = t5[e3 + 2 + 96] = Ne2(o3, s3, c4), t5[e3 + 3 + 96] = Ne2(s3, c4, c4);
    }
    function Pe(t5, e3) {
      var r3 = t5[e3 - 1 + 0], n3 = t5[e3 - 1 + 32], i3 = t5[e3 - 1 + 64], a3 = t5[e3 - 1 - 32], o3 = t5[e3 + 0 - 32], s3 = t5[e3 + 1 - 32], c4 = t5[e3 + 2 - 32], u4 = t5[e3 + 3 - 32];
      t5[e3 + 0 + 0] = t5[e3 + 1 + 64] = a3 + o3 + 1 >> 1, t5[e3 + 1 + 0] = t5[e3 + 2 + 64] = o3 + s3 + 1 >> 1, t5[e3 + 2 + 0] = t5[e3 + 3 + 64] = s3 + c4 + 1 >> 1, t5[e3 + 3 + 0] = c4 + u4 + 1 >> 1, t5[e3 + 0 + 96] = Ne2(i3, n3, r3), t5[e3 + 0 + 64] = Ne2(n3, r3, a3), t5[e3 + 0 + 32] = t5[e3 + 1 + 96] = Ne2(r3, a3, o3), t5[e3 + 1 + 32] = t5[e3 + 2 + 96] = Ne2(a3, o3, s3), t5[e3 + 2 + 32] = t5[e3 + 3 + 96] = Ne2(o3, s3, c4), t5[e3 + 3 + 32] = Ne2(s3, c4, u4);
    }
    function ke(t5, e3) {
      var r3 = t5[e3 + 0 - 32], n3 = t5[e3 + 1 - 32], i3 = t5[e3 + 2 - 32], a3 = t5[e3 + 3 - 32], o3 = t5[e3 + 4 - 32], s3 = t5[e3 + 5 - 32], c4 = t5[e3 + 6 - 32], u4 = t5[e3 + 7 - 32];
      t5[e3 + 0 + 0] = r3 + n3 + 1 >> 1, t5[e3 + 1 + 0] = t5[e3 + 0 + 64] = n3 + i3 + 1 >> 1, t5[e3 + 2 + 0] = t5[e3 + 1 + 64] = i3 + a3 + 1 >> 1, t5[e3 + 3 + 0] = t5[e3 + 2 + 64] = a3 + o3 + 1 >> 1, t5[e3 + 0 + 32] = Ne2(r3, n3, i3), t5[e3 + 1 + 32] = t5[e3 + 0 + 96] = Ne2(n3, i3, a3), t5[e3 + 2 + 32] = t5[e3 + 1 + 96] = Ne2(i3, a3, o3), t5[e3 + 3 + 32] = t5[e3 + 2 + 96] = Ne2(a3, o3, s3), t5[e3 + 3 + 64] = Ne2(o3, s3, c4), t5[e3 + 3 + 96] = Ne2(s3, c4, u4);
    }
    function Ie(t5, e3) {
      var r3 = t5[e3 - 1 + 0], n3 = t5[e3 - 1 + 32], i3 = t5[e3 - 1 + 64], a3 = t5[e3 - 1 + 96];
      t5[e3 + 0 + 0] = r3 + n3 + 1 >> 1, t5[e3 + 2 + 0] = t5[e3 + 0 + 32] = n3 + i3 + 1 >> 1, t5[e3 + 2 + 32] = t5[e3 + 0 + 64] = i3 + a3 + 1 >> 1, t5[e3 + 1 + 0] = Ne2(r3, n3, i3), t5[e3 + 3 + 0] = t5[e3 + 1 + 32] = Ne2(n3, i3, a3), t5[e3 + 3 + 32] = t5[e3 + 1 + 64] = Ne2(i3, a3, a3), t5[e3 + 3 + 64] = t5[e3 + 2 + 64] = t5[e3 + 0 + 96] = t5[e3 + 1 + 96] = t5[e3 + 2 + 96] = t5[e3 + 3 + 96] = a3;
    }
    function Fe(t5, e3) {
      var r3 = t5[e3 - 1 + 0], n3 = t5[e3 - 1 + 32], i3 = t5[e3 - 1 + 64], a3 = t5[e3 - 1 + 96], o3 = t5[e3 - 1 - 32], s3 = t5[e3 + 0 - 32], c4 = t5[e3 + 1 - 32], u4 = t5[e3 + 2 - 32];
      t5[e3 + 0 + 0] = t5[e3 + 2 + 32] = r3 + o3 + 1 >> 1, t5[e3 + 0 + 32] = t5[e3 + 2 + 64] = n3 + r3 + 1 >> 1, t5[e3 + 0 + 64] = t5[e3 + 2 + 96] = i3 + n3 + 1 >> 1, t5[e3 + 0 + 96] = a3 + i3 + 1 >> 1, t5[e3 + 3 + 0] = Ne2(s3, c4, u4), t5[e3 + 2 + 0] = Ne2(o3, s3, c4), t5[e3 + 1 + 0] = t5[e3 + 3 + 32] = Ne2(r3, o3, s3), t5[e3 + 1 + 32] = t5[e3 + 3 + 64] = Ne2(n3, r3, o3), t5[e3 + 1 + 64] = t5[e3 + 3 + 96] = Ne2(i3, n3, r3), t5[e3 + 1 + 96] = Ne2(a3, i3, n3);
    }
    function Ce(t5, e3) {
      var r3;
      for (r3 = 0; 8 > r3; ++r3)
        n2(t5, e3 + 32 * r3, t5, e3 - 32, 8);
    }
    function je(t5, e3) {
      var r3;
      for (r3 = 0; 8 > r3; ++r3)
        i2(t5, e3, t5[e3 - 1], 8), e3 += 32;
    }
    function Oe(t5, e3, r3) {
      var n3;
      for (n3 = 0; 8 > n3; ++n3)
        i2(e3, r3 + 32 * n3, t5, 8);
    }
    function Be(t5, e3) {
      var r3, n3 = 8;
      for (r3 = 0; 8 > r3; ++r3)
        n3 += t5[e3 + r3 - 32] + t5[e3 - 1 + 32 * r3];
      Oe(n3 >> 4, t5, e3);
    }
    function Me(t5, e3) {
      var r3, n3 = 4;
      for (r3 = 0; 8 > r3; ++r3)
        n3 += t5[e3 + r3 - 32];
      Oe(n3 >> 3, t5, e3);
    }
    function Ee(t5, e3) {
      var r3, n3 = 4;
      for (r3 = 0; 8 > r3; ++r3)
        n3 += t5[e3 - 1 + 32 * r3];
      Oe(n3 >> 3, t5, e3);
    }
    function qe(t5, e3) {
      Oe(128, t5, e3);
    }
    function De(t5, e3, r3) {
      var n3 = t5[e3 - r3], i3 = t5[e3 + 0], a3 = 3 * (i3 - n3) + jn[1020 + t5[e3 - 2 * r3] - t5[e3 + r3]], o3 = On[112 + (a3 + 4 >> 3)];
      t5[e3 - r3] = Bn[255 + n3 + On[112 + (a3 + 3 >> 3)]], t5[e3 + 0] = Bn[255 + i3 - o3];
    }
    function Re(t5, e3, r3, n3) {
      var i3 = t5[e3 + 0], a3 = t5[e3 + r3];
      return Mn[255 + t5[e3 - 2 * r3] - t5[e3 - r3]] > n3 || Mn[255 + a3 - i3] > n3;
    }
    function Te(t5, e3, r3, n3) {
      return 4 * Mn[255 + t5[e3 - r3] - t5[e3 + 0]] + Mn[255 + t5[e3 - 2 * r3] - t5[e3 + r3]] <= n3;
    }
    function ze(t5, e3, r3, n3, i3) {
      var a3 = t5[e3 - 3 * r3], o3 = t5[e3 - 2 * r3], s3 = t5[e3 - r3], c4 = t5[e3 + 0], u4 = t5[e3 + r3], h4 = t5[e3 + 2 * r3], l4 = t5[e3 + 3 * r3];
      return 4 * Mn[255 + s3 - c4] + Mn[255 + o3 - u4] > n3 ? 0 : Mn[255 + t5[e3 - 4 * r3] - a3] <= i3 && Mn[255 + a3 - o3] <= i3 && Mn[255 + o3 - s3] <= i3 && Mn[255 + l4 - h4] <= i3 && Mn[255 + h4 - u4] <= i3 && Mn[255 + u4 - c4] <= i3;
    }
    function Ue(t5, e3, r3, n3) {
      var i3 = 2 * n3 + 1;
      for (n3 = 0; 16 > n3; ++n3)
        Te(t5, e3 + n3, r3, i3) && De(t5, e3 + n3, r3);
    }
    function He(t5, e3, r3, n3) {
      var i3 = 2 * n3 + 1;
      for (n3 = 0; 16 > n3; ++n3)
        Te(t5, e3 + n3 * r3, 1, i3) && De(t5, e3 + n3 * r3, 1);
    }
    function We(t5, e3, r3, n3) {
      var i3;
      for (i3 = 3; 0 < i3; --i3)
        Ue(t5, e3 += 4 * r3, r3, n3);
    }
    function Ve(t5, e3, r3, n3) {
      var i3;
      for (i3 = 3; 0 < i3; --i3)
        He(t5, e3 += 4, r3, n3);
    }
    function Ge(t5, e3, r3, n3, i3, a3, o3, s3) {
      for (a3 = 2 * a3 + 1; 0 < i3--; ) {
        if (ze(t5, e3, r3, a3, o3))
          if (Re(t5, e3, r3, s3))
            De(t5, e3, r3);
          else {
            var c4 = t5, u4 = e3, h4 = r3, l4 = c4[u4 - 2 * h4], f4 = c4[u4 - h4], d4 = c4[u4 + 0], p7 = c4[u4 + h4], g4 = c4[u4 + 2 * h4], m4 = 27 * (b4 = jn[1020 + 3 * (d4 - f4) + jn[1020 + l4 - p7]]) + 63 >> 7, v4 = 18 * b4 + 63 >> 7, b4 = 9 * b4 + 63 >> 7;
            c4[u4 - 3 * h4] = Bn[255 + c4[u4 - 3 * h4] + b4], c4[u4 - 2 * h4] = Bn[255 + l4 + v4], c4[u4 - h4] = Bn[255 + f4 + m4], c4[u4 + 0] = Bn[255 + d4 - m4], c4[u4 + h4] = Bn[255 + p7 - v4], c4[u4 + 2 * h4] = Bn[255 + g4 - b4];
          }
        e3 += n3;
      }
    }
    function Ye(t5, e3, r3, n3, i3, a3, o3, s3) {
      for (a3 = 2 * a3 + 1; 0 < i3--; ) {
        if (ze(t5, e3, r3, a3, o3))
          if (Re(t5, e3, r3, s3))
            De(t5, e3, r3);
          else {
            var c4 = t5, u4 = e3, h4 = r3, l4 = c4[u4 - h4], f4 = c4[u4 + 0], d4 = c4[u4 + h4], p7 = On[112 + ((g4 = 3 * (f4 - l4)) + 4 >> 3)], g4 = On[112 + (g4 + 3 >> 3)], m4 = p7 + 1 >> 1;
            c4[u4 - 2 * h4] = Bn[255 + c4[u4 - 2 * h4] + m4], c4[u4 - h4] = Bn[255 + l4 + g4], c4[u4 + 0] = Bn[255 + f4 - p7], c4[u4 + h4] = Bn[255 + d4 - m4];
          }
        e3 += n3;
      }
    }
    function Je(t5, e3, r3, n3, i3, a3) {
      Ge(t5, e3, r3, 1, 16, n3, i3, a3);
    }
    function Xe(t5, e3, r3, n3, i3, a3) {
      Ge(t5, e3, 1, r3, 16, n3, i3, a3);
    }
    function Ke(t5, e3, r3, n3, i3, a3) {
      var o3;
      for (o3 = 3; 0 < o3; --o3)
        Ye(t5, e3 += 4 * r3, r3, 1, 16, n3, i3, a3);
    }
    function Ze(t5, e3, r3, n3, i3, a3) {
      var o3;
      for (o3 = 3; 0 < o3; --o3)
        Ye(t5, e3 += 4, 1, r3, 16, n3, i3, a3);
    }
    function $e(t5, e3, r3, n3, i3, a3, o3, s3) {
      Ge(t5, e3, i3, 1, 8, a3, o3, s3), Ge(r3, n3, i3, 1, 8, a3, o3, s3);
    }
    function Qe(t5, e3, r3, n3, i3, a3, o3, s3) {
      Ge(t5, e3, 1, i3, 8, a3, o3, s3), Ge(r3, n3, 1, i3, 8, a3, o3, s3);
    }
    function tr(t5, e3, r3, n3, i3, a3, o3, s3) {
      Ye(t5, e3 + 4 * i3, i3, 1, 8, a3, o3, s3), Ye(r3, n3 + 4 * i3, i3, 1, 8, a3, o3, s3);
    }
    function er(t5, e3, r3, n3, i3, a3, o3, s3) {
      Ye(t5, e3 + 4, 1, i3, 8, a3, o3, s3), Ye(r3, n3 + 4, 1, i3, 8, a3, o3, s3);
    }
    function rr() {
      this.ba = new ot2(), this.ec = [], this.cc = [], this.Mc = [], this.Dc = this.Nc = this.dc = this.fc = 0, this.Oa = new ct2(), this.memory = 0, this.Ib = "OutputFunc", this.Jb = "OutputAlphaFunc", this.Nd = "OutputRowFunc";
    }
    function nr() {
      this.data = [], this.offset = this.kd = this.ha = this.w = 0, this.na = [], this.xa = this.gb = this.Ja = this.Sa = this.P = 0;
    }
    function ir() {
      this.nc = this.Ea = this.b = this.hc = 0, this.K = [], this.w = 0;
    }
    function ar() {
      this.ua = 0, this.Wa = new M2(), this.vb = new M2(), this.md = this.xc = this.wc = 0, this.vc = [], this.Wb = 0, this.Ya = new d3(), this.yc = new l3();
    }
    function or() {
      this.xb = this.a = 0, this.l = new Gt2(), this.ca = new ot2(), this.V = [], this.Ba = 0, this.Ta = [], this.Ua = 0, this.m = new N3(), this.Pb = 0, this.wd = new N3(), this.Ma = this.$ = this.C = this.i = this.c = this.xd = 0, this.s = new ar(), this.ab = 0, this.gc = o2(4, ir), this.Oc = 0;
    }
    function sr() {
      this.Lc = this.Z = this.$a = this.i = this.c = 0, this.l = new Gt2(), this.ic = 0, this.ca = [], this.tb = 0, this.qd = null, this.rd = 0;
    }
    function cr(t5, e3, r3, n3, i3, a3, o3) {
      for (t5 = t5 == null ? 0 : t5[e3 + 0], e3 = 0; e3 < o3; ++e3)
        i3[a3 + e3] = t5 + r3[n3 + e3] & 255, t5 = i3[a3 + e3];
    }
    function ur(t5, e3, r3, n3, i3, a3, o3) {
      var s3;
      if (t5 == null)
        cr(null, null, r3, n3, i3, a3, o3);
      else
        for (s3 = 0; s3 < o3; ++s3)
          i3[a3 + s3] = t5[e3 + s3] + r3[n3 + s3] & 255;
    }
    function hr(t5, e3, r3, n3, i3, a3, o3) {
      if (t5 == null)
        cr(null, null, r3, n3, i3, a3, o3);
      else {
        var s3, c4 = t5[e3 + 0], u4 = c4, h4 = c4;
        for (s3 = 0; s3 < o3; ++s3)
          u4 = h4 + (c4 = t5[e3 + s3]) - u4, h4 = r3[n3 + s3] + (-256 & u4 ? 0 > u4 ? 0 : 255 : u4) & 255, u4 = c4, i3[a3 + s3] = h4;
      }
    }
    function lr(t5, r3, i3, o3) {
      var s3 = r3.width, c4 = r3.o;
      if (e2(t5 != null && r3 != null), 0 > i3 || 0 >= o3 || i3 + o3 > c4)
        return null;
      if (!t5.Cc) {
        if (t5.ga == null) {
          var u4;
          if (t5.ga = new sr(), (u4 = t5.ga == null) || (u4 = r3.width * r3.o, e2(t5.Gb.length == 0), t5.Gb = a2(u4), t5.Uc = 0, t5.Gb == null ? u4 = 0 : (t5.mb = t5.Gb, t5.nb = t5.Uc, t5.rc = null, u4 = 1), u4 = !u4), !u4) {
            u4 = t5.ga;
            var h4 = t5.Fa, l4 = t5.P, f4 = t5.qc, d4 = t5.mb, p7 = t5.nb, g4 = l4 + 1, m4 = f4 - 1, b4 = u4.l;
            if (e2(h4 != null && d4 != null && r3 != null), mi[0] = null, mi[1] = cr, mi[2] = ur, mi[3] = hr, u4.ca = d4, u4.tb = p7, u4.c = r3.width, u4.i = r3.height, e2(0 < u4.c && 0 < u4.i), 1 >= f4)
              r3 = 0;
            else if (u4.$a = h4[l4 + 0] >> 0 & 3, u4.Z = h4[l4 + 0] >> 2 & 3, u4.Lc = h4[l4 + 0] >> 4 & 3, l4 = h4[l4 + 0] >> 6 & 3, 0 > u4.$a || 1 < u4.$a || 4 <= u4.Z || 1 < u4.Lc || l4)
              r3 = 0;
            else if (b4.put = dt2, b4.ac = ft2, b4.bc = pt2, b4.ma = u4, b4.width = r3.width, b4.height = r3.height, b4.Da = r3.Da, b4.v = r3.v, b4.va = r3.va, b4.j = r3.j, b4.o = r3.o, u4.$a)
              t: {
                e2(u4.$a == 1), r3 = kt2();
                e:
                  for (; ; ) {
                    if (r3 == null) {
                      r3 = 0;
                      break t;
                    }
                    if (e2(u4 != null), u4.mc = r3, r3.c = u4.c, r3.i = u4.i, r3.l = u4.l, r3.l.ma = u4, r3.l.width = u4.c, r3.l.height = u4.i, r3.a = 0, v3(r3.m, h4, g4, m4), !It2(u4.c, u4.i, 1, r3, null))
                      break e;
                    if (r3.ab == 1 && r3.gc[0].hc == 3 && At2(r3.s) ? (u4.ic = 1, h4 = r3.c * r3.i, r3.Ta = null, r3.Ua = 0, r3.V = a2(h4), r3.Ba = 0, r3.V == null ? (r3.a = 1, r3 = 0) : r3 = 1) : (u4.ic = 0, r3 = Ft2(r3, u4.c)), !r3)
                      break e;
                    r3 = 1;
                    break t;
                  }
                u4.mc = null, r3 = 0;
              }
            else
              r3 = m4 >= u4.c * u4.i;
            u4 = !r3;
          }
          if (u4)
            return null;
          t5.ga.Lc != 1 ? t5.Ga = 0 : o3 = c4 - i3;
        }
        e2(t5.ga != null), e2(i3 + o3 <= c4);
        t: {
          if (r3 = (h4 = t5.ga).c, c4 = h4.l.o, h4.$a == 0) {
            if (g4 = t5.rc, m4 = t5.Vc, b4 = t5.Fa, l4 = t5.P + 1 + i3 * r3, f4 = t5.mb, d4 = t5.nb + i3 * r3, e2(l4 <= t5.P + t5.qc), h4.Z != 0)
              for (e2(mi[h4.Z] != null), u4 = 0; u4 < o3; ++u4)
                mi[h4.Z](g4, m4, b4, l4, f4, d4, r3), g4 = f4, m4 = d4, d4 += r3, l4 += r3;
            else
              for (u4 = 0; u4 < o3; ++u4)
                n2(f4, d4, b4, l4, r3), g4 = f4, m4 = d4, d4 += r3, l4 += r3;
            t5.rc = g4, t5.Vc = m4;
          } else {
            if (e2(h4.mc != null), r3 = i3 + o3, e2((u4 = h4.mc) != null), e2(r3 <= u4.i), u4.C >= r3)
              r3 = 1;
            else if (h4.ic || mr(), h4.ic) {
              h4 = u4.V, g4 = u4.Ba, m4 = u4.c;
              var y4 = u4.i, w4 = (b4 = 1, l4 = u4.$ / m4, f4 = u4.$ % m4, d4 = u4.m, p7 = u4.s, u4.$), N4 = m4 * y4, L4 = m4 * r3, x3 = p7.wc, _3 = w4 < L4 ? wt2(p7, f4, l4) : null;
              e2(w4 <= N4), e2(r3 <= y4), e2(At2(p7));
              e:
                for (; ; ) {
                  for (; !d4.h && w4 < L4; ) {
                    if (f4 & x3 || (_3 = wt2(p7, f4, l4)), e2(_3 != null), S2(d4), 256 > (y4 = bt2(_3.G[0], _3.H[0], d4)))
                      h4[g4 + w4] = y4, ++w4, ++f4 >= m4 && (f4 = 0, ++l4 <= r3 && !(l4 % 16) && St(u4, l4));
                    else {
                      if (!(280 > y4)) {
                        b4 = 0;
                        break e;
                      }
                      y4 = mt2(y4 - 256, d4);
                      var P3, k3 = bt2(_3.G[4], _3.H[4], d4);
                      if (S2(d4), !(w4 >= (k3 = vt2(m4, k3 = mt2(k3, d4))) && N4 - w4 >= y4)) {
                        b4 = 0;
                        break e;
                      }
                      for (P3 = 0; P3 < y4; ++P3)
                        h4[g4 + w4 + P3] = h4[g4 + w4 + P3 - k3];
                      for (w4 += y4, f4 += y4; f4 >= m4; )
                        f4 -= m4, ++l4 <= r3 && !(l4 % 16) && St(u4, l4);
                      w4 < L4 && f4 & x3 && (_3 = wt2(p7, f4, l4));
                    }
                    e2(d4.h == A3(d4));
                  }
                  St(u4, l4 > r3 ? r3 : l4);
                  break e;
                }
              !b4 || d4.h && w4 < N4 ? (b4 = 0, u4.a = d4.h ? 5 : 3) : u4.$ = w4, r3 = b4;
            } else
              r3 = _t2(u4, u4.V, u4.Ba, u4.c, u4.i, r3, Ct2);
            if (!r3) {
              o3 = 0;
              break t;
            }
          }
          i3 + o3 >= c4 && (t5.Cc = 1), o3 = 1;
        }
        if (!o3)
          return null;
        if (t5.Cc && ((o3 = t5.ga) != null && (o3.mc = null), t5.ga = null, 0 < t5.Ga))
          return alert("todo:WebPDequantizeLevels"), null;
      }
      return t5.nb + i3 * s3;
    }
    function fr(t5, e3, r3, n3, i3, a3) {
      for (; 0 < i3--; ) {
        var o3, s3 = t5, c4 = e3 + (r3 ? 1 : 0), u4 = t5, h4 = e3 + (r3 ? 0 : 3);
        for (o3 = 0; o3 < n3; ++o3) {
          var l4 = u4[h4 + 4 * o3];
          l4 != 255 && (l4 *= 32897, s3[c4 + 4 * o3 + 0] = s3[c4 + 4 * o3 + 0] * l4 >> 23, s3[c4 + 4 * o3 + 1] = s3[c4 + 4 * o3 + 1] * l4 >> 23, s3[c4 + 4 * o3 + 2] = s3[c4 + 4 * o3 + 2] * l4 >> 23);
        }
        e3 += a3;
      }
    }
    function dr(t5, e3, r3, n3, i3) {
      for (; 0 < n3--; ) {
        var a3;
        for (a3 = 0; a3 < r3; ++a3) {
          var o3 = t5[e3 + 2 * a3 + 0], s3 = 15 & (u4 = t5[e3 + 2 * a3 + 1]), c4 = 4369 * s3, u4 = (240 & u4 | u4 >> 4) * c4 >> 16;
          t5[e3 + 2 * a3 + 0] = (240 & o3 | o3 >> 4) * c4 >> 16 & 240 | (15 & o3 | o3 << 4) * c4 >> 16 >> 4 & 15, t5[e3 + 2 * a3 + 1] = 240 & u4 | s3;
        }
        e3 += i3;
      }
    }
    function pr(t5, e3, r3, n3, i3, a3, o3, s3) {
      var c4, u4, h4 = 255;
      for (u4 = 0; u4 < i3; ++u4) {
        for (c4 = 0; c4 < n3; ++c4) {
          var l4 = t5[e3 + c4];
          a3[o3 + 4 * c4] = l4, h4 &= l4;
        }
        e3 += r3, o3 += s3;
      }
      return h4 != 255;
    }
    function gr(t5, e3, r3, n3, i3) {
      var a3;
      for (a3 = 0; a3 < i3; ++a3)
        r3[n3 + a3] = t5[e3 + a3] >> 8;
    }
    function mr() {
      An = fr, xn = dr, Sn = pr, _n = gr;
    }
    function vr(r3, n3, i3) {
      t4[r3] = function(t5, r4, a3, o3, s3, c4, u4, h4, l4, f4, d4, p7, g4, m4, v4, b4, y4) {
        var w4, N4 = y4 - 1 >> 1, L4 = s3[c4 + 0] | u4[h4 + 0] << 16, A4 = l4[f4 + 0] | d4[p7 + 0] << 16;
        e2(t5 != null);
        var x3 = 3 * L4 + A4 + 131074 >> 2;
        for (n3(t5[r4 + 0], 255 & x3, x3 >> 16, g4, m4), a3 != null && (x3 = 3 * A4 + L4 + 131074 >> 2, n3(a3[o3 + 0], 255 & x3, x3 >> 16, v4, b4)), w4 = 1; w4 <= N4; ++w4) {
          var S3 = s3[c4 + w4] | u4[h4 + w4] << 16, _3 = l4[f4 + w4] | d4[p7 + w4] << 16, P3 = L4 + S3 + A4 + _3 + 524296, k3 = P3 + 2 * (S3 + A4) >> 3;
          x3 = k3 + L4 >> 1, L4 = (P3 = P3 + 2 * (L4 + _3) >> 3) + S3 >> 1, n3(t5[r4 + 2 * w4 - 1], 255 & x3, x3 >> 16, g4, m4 + (2 * w4 - 1) * i3), n3(t5[r4 + 2 * w4 - 0], 255 & L4, L4 >> 16, g4, m4 + (2 * w4 - 0) * i3), a3 != null && (x3 = P3 + A4 >> 1, L4 = k3 + _3 >> 1, n3(a3[o3 + 2 * w4 - 1], 255 & x3, x3 >> 16, v4, b4 + (2 * w4 - 1) * i3), n3(a3[o3 + 2 * w4 + 0], 255 & L4, L4 >> 16, v4, b4 + (2 * w4 + 0) * i3)), L4 = S3, A4 = _3;
        }
        1 & y4 || (x3 = 3 * L4 + A4 + 131074 >> 2, n3(t5[r4 + y4 - 1], 255 & x3, x3 >> 16, g4, m4 + (y4 - 1) * i3), a3 != null && (x3 = 3 * A4 + L4 + 131074 >> 2, n3(a3[o3 + y4 - 1], 255 & x3, x3 >> 16, v4, b4 + (y4 - 1) * i3)));
      };
    }
    function br() {
      vi[En] = bi, vi[qn] = wi, vi[Dn] = yi, vi[Rn] = Ni, vi[Tn] = Li, vi[zn] = Ai, vi[Un] = xi, vi[Hn] = wi, vi[Wn] = Ni, vi[Vn] = Li, vi[Gn] = Ai;
    }
    function yr(t5) {
      return t5 & ~Fi ? 0 > t5 ? 0 : 255 : t5 >> Ii;
    }
    function wr(t5, e3) {
      return yr((19077 * t5 >> 8) + (26149 * e3 >> 8) - 14234);
    }
    function Nr(t5, e3, r3) {
      return yr((19077 * t5 >> 8) - (6419 * e3 >> 8) - (13320 * r3 >> 8) + 8708);
    }
    function Lr(t5, e3) {
      return yr((19077 * t5 >> 8) + (33050 * e3 >> 8) - 17685);
    }
    function Ar(t5, e3, r3, n3, i3) {
      n3[i3 + 0] = wr(t5, r3), n3[i3 + 1] = Nr(t5, e3, r3), n3[i3 + 2] = Lr(t5, e3);
    }
    function xr(t5, e3, r3, n3, i3) {
      n3[i3 + 0] = Lr(t5, e3), n3[i3 + 1] = Nr(t5, e3, r3), n3[i3 + 2] = wr(t5, r3);
    }
    function Sr(t5, e3, r3, n3, i3) {
      var a3 = Nr(t5, e3, r3);
      e3 = a3 << 3 & 224 | Lr(t5, e3) >> 3, n3[i3 + 0] = 248 & wr(t5, r3) | a3 >> 5, n3[i3 + 1] = e3;
    }
    function _r(t5, e3, r3, n3, i3) {
      var a3 = 240 & Lr(t5, e3) | 15;
      n3[i3 + 0] = 240 & wr(t5, r3) | Nr(t5, e3, r3) >> 4, n3[i3 + 1] = a3;
    }
    function Pr(t5, e3, r3, n3, i3) {
      n3[i3 + 0] = 255, Ar(t5, e3, r3, n3, i3 + 1);
    }
    function kr(t5, e3, r3, n3, i3) {
      xr(t5, e3, r3, n3, i3), n3[i3 + 3] = 255;
    }
    function Ir(t5, e3, r3, n3, i3) {
      Ar(t5, e3, r3, n3, i3), n3[i3 + 3] = 255;
    }
    function Vt2(t5, e3) {
      return 0 > t5 ? 0 : t5 > e3 ? e3 : t5;
    }
    function Fr(e3, r3, n3) {
      t4[e3] = function(t5, e4, i3, a3, o3, s3, c4, u4, h4) {
        for (var l4 = u4 + (-2 & h4) * n3; u4 != l4; )
          r3(t5[e4 + 0], i3[a3 + 0], o3[s3 + 0], c4, u4), r3(t5[e4 + 1], i3[a3 + 0], o3[s3 + 0], c4, u4 + n3), e4 += 2, ++a3, ++s3, u4 += 2 * n3;
        1 & h4 && r3(t5[e4 + 0], i3[a3 + 0], o3[s3 + 0], c4, u4);
      };
    }
    function Cr(t5, e3, r3) {
      return r3 == 0 ? t5 == 0 ? e3 == 0 ? 6 : 5 : e3 == 0 ? 4 : 0 : r3;
    }
    function jr(t5, e3, r3, n3, i3) {
      switch (t5 >>> 30) {
        case 3:
          on(e3, r3, n3, i3, 0);
          break;
        case 2:
          sn(e3, r3, n3, i3);
          break;
        case 1:
          un(e3, r3, n3, i3);
      }
    }
    function Or(t5, e3) {
      var r3, a3, o3 = e3.M, s3 = e3.Nb, c4 = t5.oc, u4 = t5.pc + 40, h4 = t5.oc, l4 = t5.pc + 584, f4 = t5.oc, d4 = t5.pc + 600;
      for (r3 = 0; 16 > r3; ++r3)
        c4[u4 + 32 * r3 - 1] = 129;
      for (r3 = 0; 8 > r3; ++r3)
        h4[l4 + 32 * r3 - 1] = 129, f4[d4 + 32 * r3 - 1] = 129;
      for (0 < o3 ? c4[u4 - 1 - 32] = h4[l4 - 1 - 32] = f4[d4 - 1 - 32] = 129 : (i2(c4, u4 - 32 - 1, 127, 21), i2(h4, l4 - 32 - 1, 127, 9), i2(f4, d4 - 32 - 1, 127, 9)), a3 = 0; a3 < t5.za; ++a3) {
        var p7 = e3.ya[e3.aa + a3];
        if (0 < a3) {
          for (r3 = -1; 16 > r3; ++r3)
            n2(c4, u4 + 32 * r3 - 4, c4, u4 + 32 * r3 + 12, 4);
          for (r3 = -1; 8 > r3; ++r3)
            n2(h4, l4 + 32 * r3 - 4, h4, l4 + 32 * r3 + 4, 4), n2(f4, d4 + 32 * r3 - 4, f4, d4 + 32 * r3 + 4, 4);
        }
        var g4 = t5.Gd, m4 = t5.Hd + a3, v4 = p7.ad, b4 = p7.Hc;
        if (0 < o3 && (n2(c4, u4 - 32, g4[m4].y, 0, 16), n2(h4, l4 - 32, g4[m4].f, 0, 8), n2(f4, d4 - 32, g4[m4].ea, 0, 8)), p7.Za) {
          var y4 = c4, w4 = u4 - 32 + 16;
          for (0 < o3 && (a3 >= t5.za - 1 ? i2(y4, w4, g4[m4].y[15], 4) : n2(y4, w4, g4[m4 + 1].y, 0, 4)), r3 = 0; 4 > r3; r3++)
            y4[w4 + 128 + r3] = y4[w4 + 256 + r3] = y4[w4 + 384 + r3] = y4[w4 + 0 + r3];
          for (r3 = 0; 16 > r3; ++r3, b4 <<= 2)
            y4 = c4, w4 = u4 + Di[r3], fi[p7.Ob[r3]](y4, w4), jr(b4, v4, 16 * +r3, y4, w4);
        } else if (y4 = Cr(a3, o3, p7.Ob[0]), li[y4](c4, u4), b4 != 0)
          for (r3 = 0; 16 > r3; ++r3, b4 <<= 2)
            jr(b4, v4, 16 * +r3, c4, u4 + Di[r3]);
        for (r3 = p7.Gc, y4 = Cr(a3, o3, p7.Dd), di[y4](h4, l4), di[y4](f4, d4), b4 = v4, y4 = h4, w4 = l4, 255 & (p7 = r3 >> 0) && (170 & p7 ? cn(b4, 256, y4, w4) : hn(b4, 256, y4, w4)), p7 = f4, b4 = d4, 255 & (r3 >>= 8) && (170 & r3 ? cn(v4, 320, p7, b4) : hn(v4, 320, p7, b4)), o3 < t5.Ub - 1 && (n2(g4[m4].y, 0, c4, u4 + 480, 16), n2(g4[m4].f, 0, h4, l4 + 224, 8), n2(g4[m4].ea, 0, f4, d4 + 224, 8)), r3 = 8 * s3 * t5.B, g4 = t5.sa, m4 = t5.ta + 16 * a3 + 16 * s3 * t5.R, v4 = t5.qa, p7 = t5.ra + 8 * a3 + r3, b4 = t5.Ha, y4 = t5.Ia + 8 * a3 + r3, r3 = 0; 16 > r3; ++r3)
          n2(g4, m4 + r3 * t5.R, c4, u4 + 32 * r3, 16);
        for (r3 = 0; 8 > r3; ++r3)
          n2(v4, p7 + r3 * t5.B, h4, l4 + 32 * r3, 8), n2(b4, y4 + r3 * t5.B, f4, d4 + 32 * r3, 8);
      }
    }
    function Br(t5, n3, i3, a3, o3, s3, c4, u4, h4) {
      var l4 = [0], f4 = [0], d4 = 0, p7 = h4 != null ? h4.kd : 0, g4 = h4 != null ? h4 : new nr();
      if (t5 == null || 12 > i3)
        return 7;
      g4.data = t5, g4.w = n3, g4.ha = i3, n3 = [n3], i3 = [i3], g4.gb = [g4.gb];
      t: {
        var m4 = n3, b4 = i3, y4 = g4.gb;
        if (e2(t5 != null), e2(b4 != null), e2(y4 != null), y4[0] = 0, 12 <= b4[0] && !r2(t5, m4[0], "RIFF")) {
          if (r2(t5, m4[0] + 8, "WEBP")) {
            y4 = 3;
            break t;
          }
          var w4 = j2(t5, m4[0] + 4);
          if (12 > w4 || 4294967286 < w4) {
            y4 = 3;
            break t;
          }
          if (p7 && w4 > b4[0] - 8) {
            y4 = 7;
            break t;
          }
          y4[0] = w4, m4[0] += 12, b4[0] -= 12;
        }
        y4 = 0;
      }
      if (y4 != 0)
        return y4;
      for (w4 = 0 < g4.gb[0], i3 = i3[0]; ; ) {
        t: {
          var L4 = t5;
          b4 = n3, y4 = i3;
          var A4 = l4, x3 = f4, S3 = m4 = [0];
          if ((k3 = d4 = [d4])[0] = 0, 8 > y4[0])
            y4 = 7;
          else {
            if (!r2(L4, b4[0], "VP8X")) {
              if (j2(L4, b4[0] + 4) != 10) {
                y4 = 3;
                break t;
              }
              if (18 > y4[0]) {
                y4 = 7;
                break t;
              }
              var _3 = j2(L4, b4[0] + 8), P3 = 1 + C2(L4, b4[0] + 12);
              if (2147483648 <= P3 * (L4 = 1 + C2(L4, b4[0] + 15))) {
                y4 = 3;
                break t;
              }
              S3 != null && (S3[0] = _3), A4 != null && (A4[0] = P3), x3 != null && (x3[0] = L4), b4[0] += 18, y4[0] -= 18, k3[0] = 1;
            }
            y4 = 0;
          }
        }
        if (d4 = d4[0], m4 = m4[0], y4 != 0)
          return y4;
        if (b4 = !!(2 & m4), !w4 && d4)
          return 3;
        if (s3 != null && (s3[0] = !!(16 & m4)), c4 != null && (c4[0] = b4), u4 != null && (u4[0] = 0), c4 = l4[0], m4 = f4[0], d4 && b4 && h4 == null) {
          y4 = 0;
          break;
        }
        if (4 > i3) {
          y4 = 7;
          break;
        }
        if (w4 && d4 || !w4 && !d4 && !r2(t5, n3[0], "ALPH")) {
          i3 = [i3], g4.na = [g4.na], g4.P = [g4.P], g4.Sa = [g4.Sa];
          t: {
            _3 = t5, y4 = n3, w4 = i3;
            var k3 = g4.gb;
            A4 = g4.na, x3 = g4.P, S3 = g4.Sa;
            P3 = 22, e2(_3 != null), e2(w4 != null), L4 = y4[0];
            var I3 = w4[0];
            for (e2(A4 != null), e2(S3 != null), A4[0] = null, x3[0] = null, S3[0] = 0; ; ) {
              if (y4[0] = L4, w4[0] = I3, 8 > I3) {
                y4 = 7;
                break t;
              }
              var F3 = j2(_3, L4 + 4);
              if (4294967286 < F3) {
                y4 = 3;
                break t;
              }
              var O3 = 8 + F3 + 1 & -2;
              if (P3 += O3, 0 < k3 && P3 > k3) {
                y4 = 3;
                break t;
              }
              if (!r2(_3, L4, "VP8 ") || !r2(_3, L4, "VP8L")) {
                y4 = 0;
                break t;
              }
              if (I3[0] < O3) {
                y4 = 7;
                break t;
              }
              r2(_3, L4, "ALPH") || (A4[0] = _3, x3[0] = L4 + 8, S3[0] = F3), L4 += O3, I3 -= O3;
            }
          }
          if (i3 = i3[0], g4.na = g4.na[0], g4.P = g4.P[0], g4.Sa = g4.Sa[0], y4 != 0)
            break;
        }
        i3 = [i3], g4.Ja = [g4.Ja], g4.xa = [g4.xa];
        t:
          if (k3 = t5, y4 = n3, w4 = i3, A4 = g4.gb[0], x3 = g4.Ja, S3 = g4.xa, _3 = y4[0], L4 = !r2(k3, _3, "VP8 "), P3 = !r2(k3, _3, "VP8L"), e2(k3 != null), e2(w4 != null), e2(x3 != null), e2(S3 != null), 8 > w4[0])
            y4 = 7;
          else {
            if (L4 || P3) {
              if (k3 = j2(k3, _3 + 4), 12 <= A4 && k3 > A4 - 12) {
                y4 = 3;
                break t;
              }
              if (p7 && k3 > w4[0] - 8) {
                y4 = 7;
                break t;
              }
              x3[0] = k3, y4[0] += 8, w4[0] -= 8, S3[0] = P3;
            } else
              S3[0] = 5 <= w4[0] && k3[_3 + 0] == 47 && !(k3[_3 + 4] >> 5), x3[0] = w4[0];
            y4 = 0;
          }
        if (i3 = i3[0], g4.Ja = g4.Ja[0], g4.xa = g4.xa[0], n3 = n3[0], y4 != 0)
          break;
        if (4294967286 < g4.Ja)
          return 3;
        if (u4 == null || b4 || (u4[0] = g4.xa ? 2 : 1), c4 = [c4], m4 = [m4], g4.xa) {
          if (5 > i3) {
            y4 = 7;
            break;
          }
          u4 = c4, p7 = m4, b4 = s3, t5 == null || 5 > i3 ? t5 = 0 : 5 <= i3 && t5[n3 + 0] == 47 && !(t5[n3 + 4] >> 5) ? (w4 = [0], k3 = [0], A4 = [0], v3(x3 = new N3(), t5, n3, i3), gt2(x3, w4, k3, A4) ? (u4 != null && (u4[0] = w4[0]), p7 != null && (p7[0] = k3[0]), b4 != null && (b4[0] = A4[0]), t5 = 1) : t5 = 0) : t5 = 0;
        } else {
          if (10 > i3) {
            y4 = 7;
            break;
          }
          u4 = m4, t5 == null || 10 > i3 || !Xt2(t5, n3 + 3, i3 - 3) ? t5 = 0 : (p7 = t5[n3 + 0] | t5[n3 + 1] << 8 | t5[n3 + 2] << 16, b4 = 16383 & (t5[n3 + 7] << 8 | t5[n3 + 6]), t5 = 16383 & (t5[n3 + 9] << 8 | t5[n3 + 8]), 1 & p7 || 3 < (p7 >> 1 & 7) || !(p7 >> 4 & 1) || p7 >> 5 >= g4.Ja || !b4 || !t5 ? t5 = 0 : (c4 && (c4[0] = b4), u4 && (u4[0] = t5), t5 = 1));
        }
        if (!t5)
          return 3;
        if (c4 = c4[0], m4 = m4[0], d4 && (l4[0] != c4 || f4[0] != m4))
          return 3;
        h4 != null && (h4[0] = g4, h4.offset = n3 - h4.w, e2(4294967286 > n3 - h4.w), e2(h4.offset == h4.ha - i3));
        break;
      }
      return y4 == 0 || y4 == 7 && d4 && h4 == null ? (s3 != null && (s3[0] |= g4.na != null && 0 < g4.na.length), a3 != null && (a3[0] = c4), o3 != null && (o3[0] = m4), 0) : y4;
    }
    function Mr(t5, e3, r3) {
      var n3 = e3.width, i3 = e3.height, a3 = 0, o3 = 0, s3 = n3, c4 = i3;
      if (e3.Da = t5 != null && 0 < t5.Da, e3.Da && (s3 = t5.cd, c4 = t5.bd, a3 = t5.v, o3 = t5.j, 11 > r3 || (a3 &= -2, o3 &= -2), 0 > a3 || 0 > o3 || 0 >= s3 || 0 >= c4 || a3 + s3 > n3 || o3 + c4 > i3))
        return 0;
      if (e3.v = a3, e3.j = o3, e3.va = a3 + s3, e3.o = o3 + c4, e3.U = s3, e3.T = c4, e3.da = t5 != null && 0 < t5.da, e3.da) {
        if (!E2(s3, c4, r3 = [t5.ib], a3 = [t5.hb]))
          return 0;
        e3.ib = r3[0], e3.hb = a3[0];
      }
      return e3.ob = t5 != null && t5.ob, e3.Kb = t5 == null || !t5.Sd, e3.da && (e3.ob = e3.ib < 3 * n3 / 4 && e3.hb < 3 * i3 / 4, e3.Kb = 0), 1;
    }
    function Er(t5) {
      if (t5 == null)
        return 2;
      if (11 > t5.S) {
        var e3 = t5.f.RGBA;
        e3.fb += (t5.height - 1) * e3.A, e3.A = -e3.A;
      } else
        e3 = t5.f.kb, t5 = t5.height, e3.O += (t5 - 1) * e3.fa, e3.fa = -e3.fa, e3.N += (t5 - 1 >> 1) * e3.Ab, e3.Ab = -e3.Ab, e3.W += (t5 - 1 >> 1) * e3.Db, e3.Db = -e3.Db, e3.F != null && (e3.J += (t5 - 1) * e3.lb, e3.lb = -e3.lb);
      return 0;
    }
    function qr(t5, e3, r3, n3) {
      if (n3 == null || 0 >= t5 || 0 >= e3)
        return 2;
      if (r3 != null) {
        if (r3.Da) {
          var i3 = r3.cd, o3 = r3.bd, s3 = -2 & r3.v, c4 = -2 & r3.j;
          if (0 > s3 || 0 > c4 || 0 >= i3 || 0 >= o3 || s3 + i3 > t5 || c4 + o3 > e3)
            return 2;
          t5 = i3, e3 = o3;
        }
        if (r3.da) {
          if (!E2(t5, e3, i3 = [r3.ib], o3 = [r3.hb]))
            return 2;
          t5 = i3[0], e3 = o3[0];
        }
      }
      n3.width = t5, n3.height = e3;
      t: {
        var u4 = n3.width, h4 = n3.height;
        if (t5 = n3.S, 0 >= u4 || 0 >= h4 || !(t5 >= En && 13 > t5))
          t5 = 2;
        else {
          if (0 >= n3.Rd && n3.sd == null) {
            s3 = o3 = i3 = e3 = 0;
            var l4 = (c4 = u4 * Ui[t5]) * h4;
            if (11 > t5 || (o3 = (h4 + 1) / 2 * (e3 = (u4 + 1) / 2), t5 == 12 && (s3 = (i3 = u4) * h4)), (h4 = a2(l4 + 2 * o3 + s3)) == null) {
              t5 = 1;
              break t;
            }
            n3.sd = h4, 11 > t5 ? ((u4 = n3.f.RGBA).eb = h4, u4.fb = 0, u4.A = c4, u4.size = l4) : ((u4 = n3.f.kb).y = h4, u4.O = 0, u4.fa = c4, u4.Fd = l4, u4.f = h4, u4.N = 0 + l4, u4.Ab = e3, u4.Cd = o3, u4.ea = h4, u4.W = 0 + l4 + o3, u4.Db = e3, u4.Ed = o3, t5 == 12 && (u4.F = h4, u4.J = 0 + l4 + 2 * o3), u4.Tc = s3, u4.lb = i3);
          }
          if (e3 = 1, i3 = n3.S, o3 = n3.width, s3 = n3.height, i3 >= En && 13 > i3)
            if (11 > i3)
              t5 = n3.f.RGBA, e3 &= (c4 = Math.abs(t5.A)) * (s3 - 1) + o3 <= t5.size, e3 &= c4 >= o3 * Ui[i3], e3 &= t5.eb != null;
            else {
              t5 = n3.f.kb, c4 = (o3 + 1) / 2, l4 = (s3 + 1) / 2, u4 = Math.abs(t5.fa);
              h4 = Math.abs(t5.Ab);
              var f4 = Math.abs(t5.Db), d4 = Math.abs(t5.lb), p7 = d4 * (s3 - 1) + o3;
              e3 &= u4 * (s3 - 1) + o3 <= t5.Fd, e3 &= h4 * (l4 - 1) + c4 <= t5.Cd, e3 = (e3 &= f4 * (l4 - 1) + c4 <= t5.Ed) & u4 >= o3 & h4 >= c4 & f4 >= c4, e3 &= t5.y != null, e3 &= t5.f != null, e3 &= t5.ea != null, i3 == 12 && (e3 &= d4 >= o3, e3 &= p7 <= t5.Tc, e3 &= t5.F != null);
            }
          else
            e3 = 0;
          t5 = e3 ? 0 : 2;
        }
      }
      return t5 != 0 || r3 != null && r3.fd && (t5 = Er(n3)), t5;
    }
    var Dr = 64, Rr = [0, 1, 3, 7, 15, 31, 63, 127, 255, 511, 1023, 2047, 4095, 8191, 16383, 32767, 65535, 131071, 262143, 524287, 1048575, 2097151, 4194303, 8388607, 16777215], Tr = 24, zr = 32, Ur = 8, Hr = [0, 0, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7];
    R2("Predictor0", "PredictorAdd0"), t4.Predictor0 = function() {
      return 4278190080;
    }, t4.Predictor1 = function(t5) {
      return t5;
    }, t4.Predictor2 = function(t5, e3, r3) {
      return e3[r3 + 0];
    }, t4.Predictor3 = function(t5, e3, r3) {
      return e3[r3 + 1];
    }, t4.Predictor4 = function(t5, e3, r3) {
      return e3[r3 - 1];
    }, t4.Predictor5 = function(t5, e3, r3) {
      return z2(z2(t5, e3[r3 + 1]), e3[r3 + 0]);
    }, t4.Predictor6 = function(t5, e3, r3) {
      return z2(t5, e3[r3 - 1]);
    }, t4.Predictor7 = function(t5, e3, r3) {
      return z2(t5, e3[r3 + 0]);
    }, t4.Predictor8 = function(t5, e3, r3) {
      return z2(e3[r3 - 1], e3[r3 + 0]);
    }, t4.Predictor9 = function(t5, e3, r3) {
      return z2(e3[r3 + 0], e3[r3 + 1]);
    }, t4.Predictor10 = function(t5, e3, r3) {
      return z2(z2(t5, e3[r3 - 1]), z2(e3[r3 + 0], e3[r3 + 1]));
    }, t4.Predictor11 = function(t5, e3, r3) {
      var n3 = e3[r3 + 0];
      return 0 >= W2(n3 >> 24 & 255, t5 >> 24 & 255, (e3 = e3[r3 - 1]) >> 24 & 255) + W2(n3 >> 16 & 255, t5 >> 16 & 255, e3 >> 16 & 255) + W2(n3 >> 8 & 255, t5 >> 8 & 255, e3 >> 8 & 255) + W2(255 & n3, 255 & t5, 255 & e3) ? n3 : t5;
    }, t4.Predictor12 = function(t5, e3, r3) {
      var n3 = e3[r3 + 0];
      return (U2((t5 >> 24 & 255) + (n3 >> 24 & 255) - ((e3 = e3[r3 - 1]) >> 24 & 255)) << 24 | U2((t5 >> 16 & 255) + (n3 >> 16 & 255) - (e3 >> 16 & 255)) << 16 | U2((t5 >> 8 & 255) + (n3 >> 8 & 255) - (e3 >> 8 & 255)) << 8 | U2((255 & t5) + (255 & n3) - (255 & e3))) >>> 0;
    }, t4.Predictor13 = function(t5, e3, r3) {
      var n3 = e3[r3 - 1];
      return (H4((t5 = z2(t5, e3[r3 + 0])) >> 24 & 255, n3 >> 24 & 255) << 24 | H4(t5 >> 16 & 255, n3 >> 16 & 255) << 16 | H4(t5 >> 8 & 255, n3 >> 8 & 255) << 8 | H4(t5 >> 0 & 255, n3 >> 0 & 255)) >>> 0;
    };
    var Wr = t4.PredictorAdd0;
    t4.PredictorAdd1 = V2, R2("Predictor2", "PredictorAdd2"), R2("Predictor3", "PredictorAdd3"), R2("Predictor4", "PredictorAdd4"), R2("Predictor5", "PredictorAdd5"), R2("Predictor6", "PredictorAdd6"), R2("Predictor7", "PredictorAdd7"), R2("Predictor8", "PredictorAdd8"), R2("Predictor9", "PredictorAdd9"), R2("Predictor10", "PredictorAdd10"), R2("Predictor11", "PredictorAdd11"), R2("Predictor12", "PredictorAdd12"), R2("Predictor13", "PredictorAdd13");
    var Vr = t4.PredictorAdd2;
    X2("ColorIndexInverseTransform", "MapARGB", "32b", function(t5) {
      return t5 >> 8 & 255;
    }, function(t5) {
      return t5;
    }), X2("VP8LColorIndexInverseTransformAlpha", "MapAlpha", "8b", function(t5) {
      return t5;
    }, function(t5) {
      return t5 >> 8 & 255;
    });
    var Gr, Yr = t4.ColorIndexInverseTransform, Jr = t4.MapARGB, Xr = t4.VP8LColorIndexInverseTransformAlpha, Kr = t4.MapAlpha, Zr = t4.VP8LPredictorsAdd = [];
    Zr.length = 16, (t4.VP8LPredictors = []).length = 16, (t4.VP8LPredictorsAdd_C = []).length = 16, (t4.VP8LPredictors_C = []).length = 16;
    var $r, Qr, tn, en, rn, nn, an, on, sn, cn, un, hn, ln2, fn, dn, pn, gn, mn, vn, bn, yn, wn, Nn, Ln, An, xn, Sn, _n, Pn = a2(511), kn = a2(2041), In = a2(225), Fn = a2(767), Cn = 0, jn = kn, On = In, Bn = Fn, Mn = Pn, En = 0, qn = 1, Dn = 2, Rn = 3, Tn = 4, zn = 5, Un = 6, Hn = 7, Wn = 8, Vn = 9, Gn = 10, Yn = [2, 3, 7], Jn = [3, 3, 11], Xn = [280, 256, 256, 256, 40], Kn = [0, 1, 1, 1, 0], Zn = [17, 18, 0, 1, 2, 3, 4, 5, 16, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15], $n = [24, 7, 23, 25, 40, 6, 39, 41, 22, 26, 38, 42, 56, 5, 55, 57, 21, 27, 54, 58, 37, 43, 72, 4, 71, 73, 20, 28, 53, 59, 70, 74, 36, 44, 88, 69, 75, 52, 60, 3, 87, 89, 19, 29, 86, 90, 35, 45, 68, 76, 85, 91, 51, 61, 104, 2, 103, 105, 18, 30, 102, 106, 34, 46, 84, 92, 67, 77, 101, 107, 50, 62, 120, 1, 119, 121, 83, 93, 17, 31, 100, 108, 66, 78, 118, 122, 33, 47, 117, 123, 49, 63, 99, 109, 82, 94, 0, 116, 124, 65, 79, 16, 32, 98, 110, 48, 115, 125, 81, 95, 64, 114, 126, 97, 111, 80, 113, 127, 96, 112], Qn = [2954, 2956, 2958, 2962, 2970, 2986, 3018, 3082, 3212, 3468, 3980, 5004], ti = 8, ei = [4, 5, 6, 7, 8, 9, 10, 10, 11, 12, 13, 14, 15, 16, 17, 17, 18, 19, 20, 20, 21, 21, 22, 22, 23, 23, 24, 25, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 91, 93, 95, 96, 98, 100, 101, 102, 104, 106, 108, 110, 112, 114, 116, 118, 122, 124, 126, 128, 130, 132, 134, 136, 138, 140, 143, 145, 148, 151, 154, 157], ri = [4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 60, 62, 64, 66, 68, 70, 72, 74, 76, 78, 80, 82, 84, 86, 88, 90, 92, 94, 96, 98, 100, 102, 104, 106, 108, 110, 112, 114, 116, 119, 122, 125, 128, 131, 134, 137, 140, 143, 146, 149, 152, 155, 158, 161, 164, 167, 170, 173, 177, 181, 185, 189, 193, 197, 201, 205, 209, 213, 217, 221, 225, 229, 234, 239, 245, 249, 254, 259, 264, 269, 274, 279, 284], ni = null, ii = [[173, 148, 140, 0], [176, 155, 140, 135, 0], [180, 157, 141, 134, 130, 0], [254, 254, 243, 230, 196, 177, 153, 140, 133, 130, 129, 0]], ai = [0, 1, 4, 8, 5, 2, 3, 6, 9, 12, 13, 10, 7, 11, 14, 15], oi = [-0, 1, -1, 2, -2, 3, 4, 6, -3, 5, -4, -5, -6, 7, -7, 8, -8, -9], si = [[[[128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128], [128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128], [128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128]], [[253, 136, 254, 255, 228, 219, 128, 128, 128, 128, 128], [189, 129, 242, 255, 227, 213, 255, 219, 128, 128, 128], [106, 126, 227, 252, 214, 209, 255, 255, 128, 128, 128]], [[1, 98, 248, 255, 236, 226, 255, 255, 128, 128, 128], [181, 133, 238, 254, 221, 234, 255, 154, 128, 128, 128], [78, 134, 202, 247, 198, 180, 255, 219, 128, 128, 128]], [[1, 185, 249, 255, 243, 255, 128, 128, 128, 128, 128], [184, 150, 247, 255, 236, 224, 128, 128, 128, 128, 128], [77, 110, 216, 255, 236, 230, 128, 128, 128, 128, 128]], [[1, 101, 251, 255, 241, 255, 128, 128, 128, 128, 128], [170, 139, 241, 252, 236, 209, 255, 255, 128, 128, 128], [37, 116, 196, 243, 228, 255, 255, 255, 128, 128, 128]], [[1, 204, 254, 255, 245, 255, 128, 128, 128, 128, 128], [207, 160, 250, 255, 238, 128, 128, 128, 128, 128, 128], [102, 103, 231, 255, 211, 171, 128, 128, 128, 128, 128]], [[1, 152, 252, 255, 240, 255, 128, 128, 128, 128, 128], [177, 135, 243, 255, 234, 225, 128, 128, 128, 128, 128], [80, 129, 211, 255, 194, 224, 128, 128, 128, 128, 128]], [[1, 1, 255, 128, 128, 128, 128, 128, 128, 128, 128], [246, 1, 255, 128, 128, 128, 128, 128, 128, 128, 128], [255, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128]]], [[[198, 35, 237, 223, 193, 187, 162, 160, 145, 155, 62], [131, 45, 198, 221, 172, 176, 220, 157, 252, 221, 1], [68, 47, 146, 208, 149, 167, 221, 162, 255, 223, 128]], [[1, 149, 241, 255, 221, 224, 255, 255, 128, 128, 128], [184, 141, 234, 253, 222, 220, 255, 199, 128, 128, 128], [81, 99, 181, 242, 176, 190, 249, 202, 255, 255, 128]], [[1, 129, 232, 253, 214, 197, 242, 196, 255, 255, 128], [99, 121, 210, 250, 201, 198, 255, 202, 128, 128, 128], [23, 91, 163, 242, 170, 187, 247, 210, 255, 255, 128]], [[1, 200, 246, 255, 234, 255, 128, 128, 128, 128, 128], [109, 178, 241, 255, 231, 245, 255, 255, 128, 128, 128], [44, 130, 201, 253, 205, 192, 255, 255, 128, 128, 128]], [[1, 132, 239, 251, 219, 209, 255, 165, 128, 128, 128], [94, 136, 225, 251, 218, 190, 255, 255, 128, 128, 128], [22, 100, 174, 245, 186, 161, 255, 199, 128, 128, 128]], [[1, 182, 249, 255, 232, 235, 128, 128, 128, 128, 128], [124, 143, 241, 255, 227, 234, 128, 128, 128, 128, 128], [35, 77, 181, 251, 193, 211, 255, 205, 128, 128, 128]], [[1, 157, 247, 255, 236, 231, 255, 255, 128, 128, 128], [121, 141, 235, 255, 225, 227, 255, 255, 128, 128, 128], [45, 99, 188, 251, 195, 217, 255, 224, 128, 128, 128]], [[1, 1, 251, 255, 213, 255, 128, 128, 128, 128, 128], [203, 1, 248, 255, 255, 128, 128, 128, 128, 128, 128], [137, 1, 177, 255, 224, 255, 128, 128, 128, 128, 128]]], [[[253, 9, 248, 251, 207, 208, 255, 192, 128, 128, 128], [175, 13, 224, 243, 193, 185, 249, 198, 255, 255, 128], [73, 17, 171, 221, 161, 179, 236, 167, 255, 234, 128]], [[1, 95, 247, 253, 212, 183, 255, 255, 128, 128, 128], [239, 90, 244, 250, 211, 209, 255, 255, 128, 128, 128], [155, 77, 195, 248, 188, 195, 255, 255, 128, 128, 128]], [[1, 24, 239, 251, 218, 219, 255, 205, 128, 128, 128], [201, 51, 219, 255, 196, 186, 128, 128, 128, 128, 128], [69, 46, 190, 239, 201, 218, 255, 228, 128, 128, 128]], [[1, 191, 251, 255, 255, 128, 128, 128, 128, 128, 128], [223, 165, 249, 255, 213, 255, 128, 128, 128, 128, 128], [141, 124, 248, 255, 255, 128, 128, 128, 128, 128, 128]], [[1, 16, 248, 255, 255, 128, 128, 128, 128, 128, 128], [190, 36, 230, 255, 236, 255, 128, 128, 128, 128, 128], [149, 1, 255, 128, 128, 128, 128, 128, 128, 128, 128]], [[1, 226, 255, 128, 128, 128, 128, 128, 128, 128, 128], [247, 192, 255, 128, 128, 128, 128, 128, 128, 128, 128], [240, 128, 255, 128, 128, 128, 128, 128, 128, 128, 128]], [[1, 134, 252, 255, 255, 128, 128, 128, 128, 128, 128], [213, 62, 250, 255, 255, 128, 128, 128, 128, 128, 128], [55, 93, 255, 128, 128, 128, 128, 128, 128, 128, 128]], [[128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128], [128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128], [128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128]]], [[[202, 24, 213, 235, 186, 191, 220, 160, 240, 175, 255], [126, 38, 182, 232, 169, 184, 228, 174, 255, 187, 128], [61, 46, 138, 219, 151, 178, 240, 170, 255, 216, 128]], [[1, 112, 230, 250, 199, 191, 247, 159, 255, 255, 128], [166, 109, 228, 252, 211, 215, 255, 174, 128, 128, 128], [39, 77, 162, 232, 172, 180, 245, 178, 255, 255, 128]], [[1, 52, 220, 246, 198, 199, 249, 220, 255, 255, 128], [124, 74, 191, 243, 183, 193, 250, 221, 255, 255, 128], [24, 71, 130, 219, 154, 170, 243, 182, 255, 255, 128]], [[1, 182, 225, 249, 219, 240, 255, 224, 128, 128, 128], [149, 150, 226, 252, 216, 205, 255, 171, 128, 128, 128], [28, 108, 170, 242, 183, 194, 254, 223, 255, 255, 128]], [[1, 81, 230, 252, 204, 203, 255, 192, 128, 128, 128], [123, 102, 209, 247, 188, 196, 255, 233, 128, 128, 128], [20, 95, 153, 243, 164, 173, 255, 203, 128, 128, 128]], [[1, 222, 248, 255, 216, 213, 128, 128, 128, 128, 128], [168, 175, 246, 252, 235, 205, 255, 255, 128, 128, 128], [47, 116, 215, 255, 211, 212, 255, 255, 128, 128, 128]], [[1, 121, 236, 253, 212, 214, 255, 255, 128, 128, 128], [141, 84, 213, 252, 201, 202, 255, 219, 128, 128, 128], [42, 80, 160, 240, 162, 185, 255, 205, 128, 128, 128]], [[1, 1, 255, 128, 128, 128, 128, 128, 128, 128, 128], [244, 1, 255, 128, 128, 128, 128, 128, 128, 128, 128], [238, 1, 255, 128, 128, 128, 128, 128, 128, 128, 128]]]], ci = [[[231, 120, 48, 89, 115, 113, 120, 152, 112], [152, 179, 64, 126, 170, 118, 46, 70, 95], [175, 69, 143, 80, 85, 82, 72, 155, 103], [56, 58, 10, 171, 218, 189, 17, 13, 152], [114, 26, 17, 163, 44, 195, 21, 10, 173], [121, 24, 80, 195, 26, 62, 44, 64, 85], [144, 71, 10, 38, 171, 213, 144, 34, 26], [170, 46, 55, 19, 136, 160, 33, 206, 71], [63, 20, 8, 114, 114, 208, 12, 9, 226], [81, 40, 11, 96, 182, 84, 29, 16, 36]], [[134, 183, 89, 137, 98, 101, 106, 165, 148], [72, 187, 100, 130, 157, 111, 32, 75, 80], [66, 102, 167, 99, 74, 62, 40, 234, 128], [41, 53, 9, 178, 241, 141, 26, 8, 107], [74, 43, 26, 146, 73, 166, 49, 23, 157], [65, 38, 105, 160, 51, 52, 31, 115, 128], [104, 79, 12, 27, 217, 255, 87, 17, 7], [87, 68, 71, 44, 114, 51, 15, 186, 23], [47, 41, 14, 110, 182, 183, 21, 17, 194], [66, 45, 25, 102, 197, 189, 23, 18, 22]], [[88, 88, 147, 150, 42, 46, 45, 196, 205], [43, 97, 183, 117, 85, 38, 35, 179, 61], [39, 53, 200, 87, 26, 21, 43, 232, 171], [56, 34, 51, 104, 114, 102, 29, 93, 77], [39, 28, 85, 171, 58, 165, 90, 98, 64], [34, 22, 116, 206, 23, 34, 43, 166, 73], [107, 54, 32, 26, 51, 1, 81, 43, 31], [68, 25, 106, 22, 64, 171, 36, 225, 114], [34, 19, 21, 102, 132, 188, 16, 76, 124], [62, 18, 78, 95, 85, 57, 50, 48, 51]], [[193, 101, 35, 159, 215, 111, 89, 46, 111], [60, 148, 31, 172, 219, 228, 21, 18, 111], [112, 113, 77, 85, 179, 255, 38, 120, 114], [40, 42, 1, 196, 245, 209, 10, 25, 109], [88, 43, 29, 140, 166, 213, 37, 43, 154], [61, 63, 30, 155, 67, 45, 68, 1, 209], [100, 80, 8, 43, 154, 1, 51, 26, 71], [142, 78, 78, 16, 255, 128, 34, 197, 171], [41, 40, 5, 102, 211, 183, 4, 1, 221], [51, 50, 17, 168, 209, 192, 23, 25, 82]], [[138, 31, 36, 171, 27, 166, 38, 44, 229], [67, 87, 58, 169, 82, 115, 26, 59, 179], [63, 59, 90, 180, 59, 166, 93, 73, 154], [40, 40, 21, 116, 143, 209, 34, 39, 175], [47, 15, 16, 183, 34, 223, 49, 45, 183], [46, 17, 33, 183, 6, 98, 15, 32, 183], [57, 46, 22, 24, 128, 1, 54, 17, 37], [65, 32, 73, 115, 28, 128, 23, 128, 205], [40, 3, 9, 115, 51, 192, 18, 6, 223], [87, 37, 9, 115, 59, 77, 64, 21, 47]], [[104, 55, 44, 218, 9, 54, 53, 130, 226], [64, 90, 70, 205, 40, 41, 23, 26, 57], [54, 57, 112, 184, 5, 41, 38, 166, 213], [30, 34, 26, 133, 152, 116, 10, 32, 134], [39, 19, 53, 221, 26, 114, 32, 73, 255], [31, 9, 65, 234, 2, 15, 1, 118, 73], [75, 32, 12, 51, 192, 255, 160, 43, 51], [88, 31, 35, 67, 102, 85, 55, 186, 85], [56, 21, 23, 111, 59, 205, 45, 37, 192], [55, 38, 70, 124, 73, 102, 1, 34, 98]], [[125, 98, 42, 88, 104, 85, 117, 175, 82], [95, 84, 53, 89, 128, 100, 113, 101, 45], [75, 79, 123, 47, 51, 128, 81, 171, 1], [57, 17, 5, 71, 102, 57, 53, 41, 49], [38, 33, 13, 121, 57, 73, 26, 1, 85], [41, 10, 67, 138, 77, 110, 90, 47, 114], [115, 21, 2, 10, 102, 255, 166, 23, 6], [101, 29, 16, 10, 85, 128, 101, 196, 26], [57, 18, 10, 102, 102, 213, 34, 20, 43], [117, 20, 15, 36, 163, 128, 68, 1, 26]], [[102, 61, 71, 37, 34, 53, 31, 243, 192], [69, 60, 71, 38, 73, 119, 28, 222, 37], [68, 45, 128, 34, 1, 47, 11, 245, 171], [62, 17, 19, 70, 146, 85, 55, 62, 70], [37, 43, 37, 154, 100, 163, 85, 160, 1], [63, 9, 92, 136, 28, 64, 32, 201, 85], [75, 15, 9, 9, 64, 255, 184, 119, 16], [86, 6, 28, 5, 64, 255, 25, 248, 1], [56, 8, 17, 132, 137, 255, 55, 116, 128], [58, 15, 20, 82, 135, 57, 26, 121, 40]], [[164, 50, 31, 137, 154, 133, 25, 35, 218], [51, 103, 44, 131, 131, 123, 31, 6, 158], [86, 40, 64, 135, 148, 224, 45, 183, 128], [22, 26, 17, 131, 240, 154, 14, 1, 209], [45, 16, 21, 91, 64, 222, 7, 1, 197], [56, 21, 39, 155, 60, 138, 23, 102, 213], [83, 12, 13, 54, 192, 255, 68, 47, 28], [85, 26, 85, 85, 128, 128, 32, 146, 171], [18, 11, 7, 63, 144, 171, 4, 4, 246], [35, 27, 10, 146, 174, 171, 12, 26, 128]], [[190, 80, 35, 99, 180, 80, 126, 54, 45], [85, 126, 47, 87, 176, 51, 41, 20, 32], [101, 75, 128, 139, 118, 146, 116, 128, 85], [56, 41, 15, 176, 236, 85, 37, 9, 62], [71, 30, 17, 119, 118, 255, 17, 18, 138], [101, 38, 60, 138, 55, 70, 43, 26, 142], [146, 36, 19, 30, 171, 255, 97, 27, 20], [138, 45, 61, 62, 219, 1, 81, 188, 64], [32, 41, 20, 117, 151, 142, 20, 21, 163], [112, 19, 12, 61, 195, 128, 48, 4, 24]]], ui = [[[[255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[176, 246, 255, 255, 255, 255, 255, 255, 255, 255, 255], [223, 241, 252, 255, 255, 255, 255, 255, 255, 255, 255], [249, 253, 253, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 244, 252, 255, 255, 255, 255, 255, 255, 255, 255], [234, 254, 254, 255, 255, 255, 255, 255, 255, 255, 255], [253, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 246, 254, 255, 255, 255, 255, 255, 255, 255, 255], [239, 253, 254, 255, 255, 255, 255, 255, 255, 255, 255], [254, 255, 254, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 248, 254, 255, 255, 255, 255, 255, 255, 255, 255], [251, 255, 254, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 253, 254, 255, 255, 255, 255, 255, 255, 255, 255], [251, 254, 254, 255, 255, 255, 255, 255, 255, 255, 255], [254, 255, 254, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 254, 253, 255, 254, 255, 255, 255, 255, 255, 255], [250, 255, 254, 255, 254, 255, 255, 255, 255, 255, 255], [254, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]]], [[[217, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [225, 252, 241, 253, 255, 255, 254, 255, 255, 255, 255], [234, 250, 241, 250, 253, 255, 253, 254, 255, 255, 255]], [[255, 254, 255, 255, 255, 255, 255, 255, 255, 255, 255], [223, 254, 254, 255, 255, 255, 255, 255, 255, 255, 255], [238, 253, 254, 254, 255, 255, 255, 255, 255, 255, 255]], [[255, 248, 254, 255, 255, 255, 255, 255, 255, 255, 255], [249, 254, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 253, 255, 255, 255, 255, 255, 255, 255, 255, 255], [247, 254, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 253, 254, 255, 255, 255, 255, 255, 255, 255, 255], [252, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 254, 254, 255, 255, 255, 255, 255, 255, 255, 255], [253, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 254, 253, 255, 255, 255, 255, 255, 255, 255, 255], [250, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [254, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]]], [[[186, 251, 250, 255, 255, 255, 255, 255, 255, 255, 255], [234, 251, 244, 254, 255, 255, 255, 255, 255, 255, 255], [251, 251, 243, 253, 254, 255, 254, 255, 255, 255, 255]], [[255, 253, 254, 255, 255, 255, 255, 255, 255, 255, 255], [236, 253, 254, 255, 255, 255, 255, 255, 255, 255, 255], [251, 253, 253, 254, 254, 255, 255, 255, 255, 255, 255]], [[255, 254, 254, 255, 255, 255, 255, 255, 255, 255, 255], [254, 254, 254, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 254, 255, 255, 255, 255, 255, 255, 255, 255, 255], [254, 254, 255, 255, 255, 255, 255, 255, 255, 255, 255], [254, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [254, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]]], [[[248, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [250, 254, 252, 254, 255, 255, 255, 255, 255, 255, 255], [248, 254, 249, 253, 255, 255, 255, 255, 255, 255, 255]], [[255, 253, 253, 255, 255, 255, 255, 255, 255, 255, 255], [246, 253, 253, 255, 255, 255, 255, 255, 255, 255, 255], [252, 254, 251, 254, 254, 255, 255, 255, 255, 255, 255]], [[255, 254, 252, 255, 255, 255, 255, 255, 255, 255, 255], [248, 254, 253, 255, 255, 255, 255, 255, 255, 255, 255], [253, 255, 254, 254, 255, 255, 255, 255, 255, 255, 255]], [[255, 251, 254, 255, 255, 255, 255, 255, 255, 255, 255], [245, 251, 254, 255, 255, 255, 255, 255, 255, 255, 255], [253, 253, 254, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 251, 253, 255, 255, 255, 255, 255, 255, 255, 255], [252, 253, 254, 255, 255, 255, 255, 255, 255, 255, 255], [255, 254, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 252, 255, 255, 255, 255, 255, 255, 255, 255, 255], [249, 255, 254, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 254, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 255, 253, 255, 255, 255, 255, 255, 255, 255, 255], [250, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [254, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]]]], hi = [0, 1, 2, 3, 6, 4, 5, 6, 6, 6, 6, 6, 6, 6, 6, 7, 0], li = [], fi = [], di = [], pi = 1, gi = 2, mi = [], vi = [];
    vr("UpsampleRgbLinePair", Ar, 3), vr("UpsampleBgrLinePair", xr, 3), vr("UpsampleRgbaLinePair", Ir, 4), vr("UpsampleBgraLinePair", kr, 4), vr("UpsampleArgbLinePair", Pr, 4), vr("UpsampleRgba4444LinePair", _r, 2), vr("UpsampleRgb565LinePair", Sr, 2);
    var bi = t4.UpsampleRgbLinePair, yi = t4.UpsampleBgrLinePair, wi = t4.UpsampleRgbaLinePair, Ni = t4.UpsampleBgraLinePair, Li = t4.UpsampleArgbLinePair, Ai = t4.UpsampleRgba4444LinePair, xi = t4.UpsampleRgb565LinePair, Si = 16, _i = 1 << Si - 1, Pi = -227, ki = 482, Ii = 6, Fi = (256 << Ii) - 1, Ci = 0, ji = a2(256), Oi = a2(256), Bi = a2(256), Mi = a2(256), Ei = a2(ki - Pi), qi = a2(ki - Pi);
    Fr("YuvToRgbRow", Ar, 3), Fr("YuvToBgrRow", xr, 3), Fr("YuvToRgbaRow", Ir, 4), Fr("YuvToBgraRow", kr, 4), Fr("YuvToArgbRow", Pr, 4), Fr("YuvToRgba4444Row", _r, 2), Fr("YuvToRgb565Row", Sr, 2);
    var Di = [0, 4, 8, 12, 128, 132, 136, 140, 256, 260, 264, 268, 384, 388, 392, 396], Ri = [0, 2, 8], Ti = [8, 7, 6, 4, 4, 2, 2, 2, 1, 1, 1, 1], zi = 1;
    this.WebPDecodeRGBA = function(t5, r3, n3, i3, a3) {
      var o3 = qn, s3 = new rr(), c4 = new ot2();
      s3.ba = c4, c4.S = o3, c4.width = [c4.width], c4.height = [c4.height];
      var u4 = c4.width, h4 = c4.height, l4 = new st2();
      if (l4 == null || t5 == null)
        var f4 = 2;
      else
        e2(l4 != null), f4 = Br(t5, r3, n3, l4.width, l4.height, l4.Pd, l4.Qd, l4.format, null);
      if (f4 != 0 ? u4 = 0 : (u4 != null && (u4[0] = l4.width[0]), h4 != null && (h4[0] = l4.height[0]), u4 = 1), u4) {
        c4.width = c4.width[0], c4.height = c4.height[0], i3 != null && (i3[0] = c4.width), a3 != null && (a3[0] = c4.height);
        t: {
          if (i3 = new Gt2(), (a3 = new nr()).data = t5, a3.w = r3, a3.ha = n3, a3.kd = 1, r3 = [0], e2(a3 != null), ((t5 = Br(a3.data, a3.w, a3.ha, null, null, null, r3, null, a3)) == 0 || t5 == 7) && r3[0] && (t5 = 4), (r3 = t5) == 0) {
            if (e2(s3 != null), i3.data = a3.data, i3.w = a3.w + a3.offset, i3.ha = a3.ha - a3.offset, i3.put = dt2, i3.ac = ft2, i3.bc = pt2, i3.ma = s3, a3.xa) {
              if ((t5 = kt2()) == null) {
                s3 = 1;
                break t;
              }
              if (function(t6, r4) {
                var n4 = [0], i4 = [0], a4 = [0];
                e:
                  for (; ; ) {
                    if (t6 == null)
                      return 0;
                    if (r4 == null)
                      return t6.a = 2, 0;
                    if (t6.l = r4, t6.a = 0, v3(t6.m, r4.data, r4.w, r4.ha), !gt2(t6.m, n4, i4, a4)) {
                      t6.a = 3;
                      break e;
                    }
                    if (t6.xb = gi, r4.width = n4[0], r4.height = i4[0], !It2(n4[0], i4[0], 1, t6, null))
                      break e;
                    return 1;
                  }
                return e2(t6.a != 0), 0;
              }(t5, i3)) {
                if (i3 = (r3 = qr(i3.width, i3.height, s3.Oa, s3.ba)) == 0) {
                  e: {
                    i3 = t5;
                    r:
                      for (; ; ) {
                        if (i3 == null) {
                          i3 = 0;
                          break e;
                        }
                        if (e2(i3.s.yc != null), e2(i3.s.Ya != null), e2(0 < i3.s.Wb), e2((n3 = i3.l) != null), e2((a3 = n3.ma) != null), i3.xb != 0) {
                          if (i3.ca = a3.ba, i3.tb = a3.tb, e2(i3.ca != null), !Mr(a3.Oa, n3, Rn)) {
                            i3.a = 2;
                            break r;
                          }
                          if (!Ft2(i3, n3.width))
                            break r;
                          if (n3.da)
                            break r;
                          if ((n3.da || nt2(i3.ca.S)) && mr(), 11 > i3.ca.S || (alert("todo:WebPInitConvertARGBToYUV"), i3.ca.f.kb.F != null && mr()), i3.Pb && 0 < i3.s.ua && i3.s.vb.X == null && !O2(i3.s.vb, i3.s.Wa.Xa)) {
                            i3.a = 1;
                            break r;
                          }
                          i3.xb = 0;
                        }
                        if (!_t2(i3, i3.V, i3.Ba, i3.c, i3.i, n3.o, Lt2))
                          break r;
                        a3.Dc = i3.Ma, i3 = 1;
                        break e;
                      }
                    e2(i3.a != 0), i3 = 0;
                  }
                  i3 = !i3;
                }
                i3 && (r3 = t5.a);
              } else
                r3 = t5.a;
            } else {
              if ((t5 = new Yt2()) == null) {
                s3 = 1;
                break t;
              }
              if (t5.Fa = a3.na, t5.P = a3.P, t5.qc = a3.Sa, Kt2(t5, i3)) {
                if ((r3 = qr(i3.width, i3.height, s3.Oa, s3.ba)) == 0) {
                  if (t5.Aa = 0, n3 = s3.Oa, e2((a3 = t5) != null), n3 != null) {
                    if (0 < (u4 = 0 > (u4 = n3.Md) ? 0 : 100 < u4 ? 255 : 255 * u4 / 100)) {
                      for (h4 = l4 = 0; 4 > h4; ++h4)
                        12 > (f4 = a3.pb[h4]).lc && (f4.ia = u4 * Ti[0 > f4.lc ? 0 : f4.lc] >> 3), l4 |= f4.ia;
                      l4 && (alert("todo:VP8InitRandom"), a3.ia = 1);
                    }
                    a3.Ga = n3.Id, 100 < a3.Ga ? a3.Ga = 100 : 0 > a3.Ga && (a3.Ga = 0);
                  }
                  Qt2(t5, i3) || (r3 = t5.a);
                }
              } else
                r3 = t5.a;
            }
            r3 == 0 && s3.Oa != null && s3.Oa.fd && (r3 = Er(s3.ba));
          }
          s3 = r3;
        }
        o3 = s3 != 0 ? null : 11 > o3 ? c4.f.RGBA.eb : c4.f.kb.y;
      } else
        o3 = null;
      return o3;
    };
    var Ui = [3, 4, 3, 4, 4, 2, 2, 4, 4, 4, 2, 1, 1];
  };
  function u2(t4, e3) {
    for (var r3 = "", n3 = 0; n3 < 4; n3++)
      r3 += String.fromCharCode(t4[e3++]);
    return r3;
  }
  function h2(t4, e3) {
    return (t4[e3 + 0] << 0 | t4[e3 + 1] << 8 | t4[e3 + 2] << 16) >>> 0;
  }
  function l2(t4, e3) {
    return (t4[e3 + 0] << 0 | t4[e3 + 1] << 8 | t4[e3 + 2] << 16 | t4[e3 + 3] << 24) >>> 0;
  }
  new c2();
  var f2 = [0], d2 = [0], p5 = [], g2 = new c2(), m2 = t3, v2 = function(t4, e3) {
    var r3 = {}, n3 = 0, i3 = false, a3 = 0, o3 = 0;
    if (r3.frames = [], !function(t5, e4, r4, n4) {
      for (var i4 = 0; i4 < n4; i4++)
        if (t5[e4 + i4] != r4.charCodeAt(i4))
          return true;
      return false;
    }(t4, e3, "RIFF", 4)) {
      var s3, c3;
      l2(t4, e3 += 4);
      for (e3 += 8; e3 < t4.length; ) {
        var f3 = u2(t4, e3), d3 = l2(t4, e3 += 4);
        e3 += 4;
        var p6 = d3 + (1 & d3);
        switch (f3) {
          case "VP8 ":
          case "VP8L":
            r3.frames[n3] === void 0 && (r3.frames[n3] = {});
            (v3 = r3.frames[n3]).src_off = i3 ? o3 : e3 - 8, v3.src_size = a3 + d3 + 8, n3++, i3 && (i3 = false, a3 = 0, o3 = 0);
            break;
          case "VP8X":
            (v3 = r3.header = {}).feature_flags = t4[e3];
            var g3 = e3 + 4;
            v3.canvas_width = 1 + h2(t4, g3);
            g3 += 3;
            v3.canvas_height = 1 + h2(t4, g3);
            g3 += 3;
            break;
          case "ALPH":
            i3 = true, a3 = p6 + 8, o3 = e3 - 8;
            break;
          case "ANIM":
            (v3 = r3.header).bgcolor = l2(t4, e3);
            g3 = e3 + 4;
            v3.loop_count = (s3 = t4)[(c3 = g3) + 0] << 0 | s3[c3 + 1] << 8;
            g3 += 2;
            break;
          case "ANMF":
            var m3, v3;
            (v3 = r3.frames[n3] = {}).offset_x = 2 * h2(t4, e3), e3 += 3, v3.offset_y = 2 * h2(t4, e3), e3 += 3, v3.width = 1 + h2(t4, e3), e3 += 3, v3.height = 1 + h2(t4, e3), e3 += 3, v3.duration = h2(t4, e3), e3 += 3, m3 = t4[e3++], v3.dispose = 1 & m3, v3.blend = m3 >> 1 & 1;
        }
        f3 != "ANMF" && (e3 += p6);
      }
      return r3;
    }
  }(m2, 0);
  v2.response = m2, v2.rgbaoutput = true, v2.dataurl = false;
  var b2 = v2.header ? v2.header : null, y2 = v2.frames ? v2.frames : null;
  if (b2) {
    b2.loop_counter = b2.loop_count, f2 = [b2.canvas_height], d2 = [b2.canvas_width];
    for (var w2 = 0; w2 < y2.length && y2[w2].blend != 0; w2++)
      ;
  }
  var N2 = y2[0], L2 = g2.WebPDecodeRGBA(m2, N2.src_off, N2.src_size, d2, f2);
  N2.rgba = L2, N2.imgwidth = d2[0], N2.imgheight = f2[0];
  for (var A2 = 0; A2 < d2[0] * f2[0] * 4; A2++)
    p5[A2] = L2[A2];
  return this.width = d2, this.height = f2, this.data = p5, this;
}
!function(t3) {
  var r2 = function() {
    return typeof zlibSync == "function";
  }, n2 = function(r3, n3, a3, h3) {
    var l3 = 4, f3 = s2;
    switch (h3) {
      case t3.image_compression.FAST:
        l3 = 1, f3 = o2;
        break;
      case t3.image_compression.MEDIUM:
        l3 = 6, f3 = c2;
        break;
      case t3.image_compression.SLOW:
        l3 = 9, f3 = u2;
    }
    r3 = i2(r3, n3, a3, f3);
    var d2 = zlibSync(r3, { level: l3 });
    return t3.__addimage__.arrayBufferToBinaryString(d2);
  }, i2 = function(t4, e2, r3, n3) {
    for (var i3, a3, o3, s3 = t4.length / e2, c3 = new Uint8Array(t4.length + s3), u3 = l2(), h3 = 0; h3 < s3; h3 += 1) {
      if (o3 = h3 * e2, i3 = t4.subarray(o3, o3 + e2), n3)
        c3.set(n3(i3, r3, a3), o3 + h3);
      else {
        for (var d2, p5 = u3.length, g2 = []; d2 < p5; d2 += 1)
          g2[d2] = u3[d2](i3, r3, a3);
        var m2 = f2(g2.concat());
        c3.set(g2[m2], o3 + h3);
      }
      a3 = i3;
    }
    return c3;
  }, a2 = function(t4) {
    var e2 = Array.apply([], t4);
    return e2.unshift(0), e2;
  }, o2 = function(t4, e2) {
    var r3, n3 = [], i3 = t4.length;
    n3[0] = 1;
    for (var a3 = 0; a3 < i3; a3 += 1)
      r3 = t4[a3 - e2] || 0, n3[a3 + 1] = t4[a3] - r3 + 256 & 255;
    return n3;
  }, s2 = function(t4, e2, r3) {
    var n3, i3 = [], a3 = t4.length;
    i3[0] = 2;
    for (var o3 = 0; o3 < a3; o3 += 1)
      n3 = r3 && r3[o3] || 0, i3[o3 + 1] = t4[o3] - n3 + 256 & 255;
    return i3;
  }, c2 = function(t4, e2, r3) {
    var n3, i3, a3 = [], o3 = t4.length;
    a3[0] = 3;
    for (var s3 = 0; s3 < o3; s3 += 1)
      n3 = t4[s3 - e2] || 0, i3 = r3 && r3[s3] || 0, a3[s3 + 1] = t4[s3] + 256 - (n3 + i3 >>> 1) & 255;
    return a3;
  }, u2 = function(t4, e2, r3) {
    var n3, i3, a3, o3, s3 = [], c3 = t4.length;
    s3[0] = 4;
    for (var u3 = 0; u3 < c3; u3 += 1)
      n3 = t4[u3 - e2] || 0, i3 = r3 && r3[u3] || 0, a3 = r3 && r3[u3 - e2] || 0, o3 = h2(n3, i3, a3), s3[u3 + 1] = t4[u3] - o3 + 256 & 255;
    return s3;
  }, h2 = function(t4, e2, r3) {
    if (t4 === e2 && e2 === r3)
      return t4;
    var n3 = Math.abs(e2 - r3), i3 = Math.abs(t4 - r3), a3 = Math.abs(t4 + e2 - r3 - r3);
    return n3 <= i3 && n3 <= a3 ? t4 : i3 <= a3 ? e2 : r3;
  }, l2 = function() {
    return [a2, o2, s2, c2, u2];
  }, f2 = function(t4) {
    var e2 = t4.map(function(t5) {
      return t5.reduce(function(t6, e3) {
        return t6 + Math.abs(e3);
      }, 0);
    });
    return e2.indexOf(Math.min.apply(null, e2));
  };
  t3.processPNG = function(e2, i3, a3, o3) {
    var s3, c3, u3, h3, l3, f3, d2, p5, g2, m2, v2, b2, y2, w2, N2, L2 = this.decode.FLATE_DECODE, A2 = "";
    if (this.__addimage__.isArrayBuffer(e2) && (e2 = new Uint8Array(e2)), this.__addimage__.isArrayBufferView(e2)) {
      if (e2 = (u3 = new Kt(e2)).imgData, c3 = u3.bits, s3 = u3.colorSpace, l3 = u3.colors, [4, 6].indexOf(u3.colorType) !== -1) {
        if (u3.bits === 8) {
          g2 = (p5 = u3.pixelBitlength == 32 ? new Uint32Array(u3.decodePixels().buffer) : u3.pixelBitlength == 16 ? new Uint16Array(u3.decodePixels().buffer) : new Uint8Array(u3.decodePixels().buffer)).length, v2 = new Uint8Array(g2 * u3.colors), m2 = new Uint8Array(g2);
          var x2, S2 = u3.pixelBitlength - u3.bits;
          for (w2 = 0, N2 = 0; w2 < g2; w2++) {
            for (y2 = p5[w2], x2 = 0; x2 < S2; )
              v2[N2++] = y2 >>> x2 & 255, x2 += u3.bits;
            m2[w2] = y2 >>> x2 & 255;
          }
        }
        if (u3.bits === 16) {
          g2 = (p5 = new Uint32Array(u3.decodePixels().buffer)).length, v2 = new Uint8Array(g2 * (32 / u3.pixelBitlength) * u3.colors), m2 = new Uint8Array(g2 * (32 / u3.pixelBitlength)), b2 = u3.colors > 1, w2 = 0, N2 = 0;
          for (var _2 = 0; w2 < g2; )
            y2 = p5[w2++], v2[N2++] = y2 >>> 0 & 255, b2 && (v2[N2++] = y2 >>> 16 & 255, y2 = p5[w2++], v2[N2++] = y2 >>> 0 & 255), m2[_2++] = y2 >>> 16 & 255;
          c3 = 8;
        }
        o3 !== t3.image_compression.NONE && r2() ? (e2 = n2(v2, u3.width * u3.colors, u3.colors, o3), d2 = n2(m2, u3.width, 1, o3)) : (e2 = v2, d2 = m2, L2 = void 0);
      }
      if (u3.colorType === 3 && (s3 = this.color_spaces.INDEXED, f3 = u3.palette, u3.transparency.indexed)) {
        var P2 = u3.transparency.indexed, k2 = 0;
        for (w2 = 0, g2 = P2.length; w2 < g2; ++w2)
          k2 += P2[w2];
        if ((k2 /= 255) === g2 - 1 && P2.indexOf(0) !== -1)
          h3 = [P2.indexOf(0)];
        else if (k2 !== g2) {
          for (p5 = u3.decodePixels(), m2 = new Uint8Array(p5.length), w2 = 0, g2 = p5.length; w2 < g2; w2++)
            m2[w2] = P2[p5[w2]];
          d2 = n2(m2, u3.width, 1);
        }
      }
      var I2 = function(e3) {
        var r3;
        switch (e3) {
          case t3.image_compression.FAST:
            r3 = 11;
            break;
          case t3.image_compression.MEDIUM:
            r3 = 13;
            break;
          case t3.image_compression.SLOW:
            r3 = 14;
            break;
          default:
            r3 = 12;
        }
        return r3;
      }(o3);
      return L2 === this.decode.FLATE_DECODE && (A2 = "/Predictor " + I2 + " "), A2 += "/Colors " + l3 + " /BitsPerComponent " + c3 + " /Columns " + u3.width, (this.__addimage__.isArrayBuffer(e2) || this.__addimage__.isArrayBufferView(e2)) && (e2 = this.__addimage__.arrayBufferToBinaryString(e2)), (d2 && this.__addimage__.isArrayBuffer(d2) || this.__addimage__.isArrayBufferView(d2)) && (d2 = this.__addimage__.arrayBufferToBinaryString(d2)), { alias: a3, data: e2, index: i3, filter: L2, decodeParameters: A2, transparency: h3, palette: f3, sMask: d2, predictor: I2, width: u3.width, height: u3.height, bitsPerComponent: c3, colorSpace: s3 };
    }
  };
}(E$1.API), function(t3) {
  t3.processGIF89A = function(e2, r2, n2, i2) {
    var a2 = new Zt(e2), o2 = a2.width, s2 = a2.height, c2 = [];
    a2.decodeAndBlitFrameRGBA(0, c2);
    var u2 = { data: c2, width: o2, height: s2 }, h2 = new Qt(100).encode(u2, 100);
    return t3.processJPEG.call(this, h2, r2, n2, i2);
  }, t3.processGIF87A = t3.processGIF89A;
}(E$1.API), te.prototype.parseHeader = function() {
  if (this.fileSize = this.datav.getUint32(this.pos, true), this.pos += 4, this.reserved = this.datav.getUint32(this.pos, true), this.pos += 4, this.offset = this.datav.getUint32(this.pos, true), this.pos += 4, this.headerSize = this.datav.getUint32(this.pos, true), this.pos += 4, this.width = this.datav.getUint32(this.pos, true), this.pos += 4, this.height = this.datav.getInt32(this.pos, true), this.pos += 4, this.planes = this.datav.getUint16(this.pos, true), this.pos += 2, this.bitPP = this.datav.getUint16(this.pos, true), this.pos += 2, this.compress = this.datav.getUint32(this.pos, true), this.pos += 4, this.rawSize = this.datav.getUint32(this.pos, true), this.pos += 4, this.hr = this.datav.getUint32(this.pos, true), this.pos += 4, this.vr = this.datav.getUint32(this.pos, true), this.pos += 4, this.colors = this.datav.getUint32(this.pos, true), this.pos += 4, this.importantColors = this.datav.getUint32(this.pos, true), this.pos += 4, this.bitPP === 16 && this.is_with_alpha && (this.bitPP = 15), this.bitPP < 15) {
    var t3 = this.colors === 0 ? 1 << this.bitPP : this.colors;
    this.palette = new Array(t3);
    for (var e2 = 0; e2 < t3; e2++) {
      var r2 = this.datav.getUint8(this.pos++, true), n2 = this.datav.getUint8(this.pos++, true), i2 = this.datav.getUint8(this.pos++, true), a2 = this.datav.getUint8(this.pos++, true);
      this.palette[e2] = { red: i2, green: n2, blue: r2, quad: a2 };
    }
  }
  this.height < 0 && (this.height *= -1, this.bottom_up = false);
}, te.prototype.parseBGR = function() {
  this.pos = this.offset;
  try {
    var t3 = "bit" + this.bitPP, e2 = this.width * this.height * 4;
    this.data = new Uint8Array(e2), this[t3]();
  } catch (t4) {
    a$2.log("bit decode error:" + t4);
  }
}, te.prototype.bit1 = function() {
  var t3, e2 = Math.ceil(this.width / 8), r2 = e2 % 4;
  for (t3 = this.height - 1; t3 >= 0; t3--) {
    for (var n2 = this.bottom_up ? t3 : this.height - 1 - t3, i2 = 0; i2 < e2; i2++)
      for (var a2 = this.datav.getUint8(this.pos++, true), o2 = n2 * this.width * 4 + 8 * i2 * 4, s2 = 0; s2 < 8 && 8 * i2 + s2 < this.width; s2++) {
        var c2 = this.palette[a2 >> 7 - s2 & 1];
        this.data[o2 + 4 * s2] = c2.blue, this.data[o2 + 4 * s2 + 1] = c2.green, this.data[o2 + 4 * s2 + 2] = c2.red, this.data[o2 + 4 * s2 + 3] = 255;
      }
    r2 !== 0 && (this.pos += 4 - r2);
  }
}, te.prototype.bit4 = function() {
  for (var t3 = Math.ceil(this.width / 2), e2 = t3 % 4, r2 = this.height - 1; r2 >= 0; r2--) {
    for (var n2 = this.bottom_up ? r2 : this.height - 1 - r2, i2 = 0; i2 < t3; i2++) {
      var a2 = this.datav.getUint8(this.pos++, true), o2 = n2 * this.width * 4 + 2 * i2 * 4, s2 = a2 >> 4, c2 = 15 & a2, u2 = this.palette[s2];
      if (this.data[o2] = u2.blue, this.data[o2 + 1] = u2.green, this.data[o2 + 2] = u2.red, this.data[o2 + 3] = 255, 2 * i2 + 1 >= this.width)
        break;
      u2 = this.palette[c2], this.data[o2 + 4] = u2.blue, this.data[o2 + 4 + 1] = u2.green, this.data[o2 + 4 + 2] = u2.red, this.data[o2 + 4 + 3] = 255;
    }
    e2 !== 0 && (this.pos += 4 - e2);
  }
}, te.prototype.bit8 = function() {
  for (var t3 = this.width % 4, e2 = this.height - 1; e2 >= 0; e2--) {
    for (var r2 = this.bottom_up ? e2 : this.height - 1 - e2, n2 = 0; n2 < this.width; n2++) {
      var i2 = this.datav.getUint8(this.pos++, true), a2 = r2 * this.width * 4 + 4 * n2;
      if (i2 < this.palette.length) {
        var o2 = this.palette[i2];
        this.data[a2] = o2.red, this.data[a2 + 1] = o2.green, this.data[a2 + 2] = o2.blue, this.data[a2 + 3] = 255;
      } else
        this.data[a2] = 255, this.data[a2 + 1] = 255, this.data[a2 + 2] = 255, this.data[a2 + 3] = 255;
    }
    t3 !== 0 && (this.pos += 4 - t3);
  }
}, te.prototype.bit15 = function() {
  for (var t3 = this.width % 3, e2 = parseInt("11111", 2), r2 = this.height - 1; r2 >= 0; r2--) {
    for (var n2 = this.bottom_up ? r2 : this.height - 1 - r2, i2 = 0; i2 < this.width; i2++) {
      var a2 = this.datav.getUint16(this.pos, true);
      this.pos += 2;
      var o2 = (a2 & e2) / e2 * 255 | 0, s2 = (a2 >> 5 & e2) / e2 * 255 | 0, c2 = (a2 >> 10 & e2) / e2 * 255 | 0, u2 = a2 >> 15 ? 255 : 0, h2 = n2 * this.width * 4 + 4 * i2;
      this.data[h2] = c2, this.data[h2 + 1] = s2, this.data[h2 + 2] = o2, this.data[h2 + 3] = u2;
    }
    this.pos += t3;
  }
}, te.prototype.bit16 = function() {
  for (var t3 = this.width % 3, e2 = parseInt("11111", 2), r2 = parseInt("111111", 2), n2 = this.height - 1; n2 >= 0; n2--) {
    for (var i2 = this.bottom_up ? n2 : this.height - 1 - n2, a2 = 0; a2 < this.width; a2++) {
      var o2 = this.datav.getUint16(this.pos, true);
      this.pos += 2;
      var s2 = (o2 & e2) / e2 * 255 | 0, c2 = (o2 >> 5 & r2) / r2 * 255 | 0, u2 = (o2 >> 11) / e2 * 255 | 0, h2 = i2 * this.width * 4 + 4 * a2;
      this.data[h2] = u2, this.data[h2 + 1] = c2, this.data[h2 + 2] = s2, this.data[h2 + 3] = 255;
    }
    this.pos += t3;
  }
}, te.prototype.bit24 = function() {
  for (var t3 = this.height - 1; t3 >= 0; t3--) {
    for (var e2 = this.bottom_up ? t3 : this.height - 1 - t3, r2 = 0; r2 < this.width; r2++) {
      var n2 = this.datav.getUint8(this.pos++, true), i2 = this.datav.getUint8(this.pos++, true), a2 = this.datav.getUint8(this.pos++, true), o2 = e2 * this.width * 4 + 4 * r2;
      this.data[o2] = a2, this.data[o2 + 1] = i2, this.data[o2 + 2] = n2, this.data[o2 + 3] = 255;
    }
    this.pos += this.width % 4;
  }
}, te.prototype.bit32 = function() {
  for (var t3 = this.height - 1; t3 >= 0; t3--)
    for (var e2 = this.bottom_up ? t3 : this.height - 1 - t3, r2 = 0; r2 < this.width; r2++) {
      var n2 = this.datav.getUint8(this.pos++, true), i2 = this.datav.getUint8(this.pos++, true), a2 = this.datav.getUint8(this.pos++, true), o2 = this.datav.getUint8(this.pos++, true), s2 = e2 * this.width * 4 + 4 * r2;
      this.data[s2] = a2, this.data[s2 + 1] = i2, this.data[s2 + 2] = n2, this.data[s2 + 3] = o2;
    }
}, te.prototype.getData = function() {
  return this.data;
}, function(t3) {
  t3.processBMP = function(e2, r2, n2, i2) {
    var a2 = new te(e2, false), o2 = a2.width, s2 = a2.height, c2 = { data: a2.getData(), width: o2, height: s2 }, u2 = new Qt(100).encode(c2, 100);
    return t3.processJPEG.call(this, u2, r2, n2, i2);
  };
}(E$1.API), ee.prototype.getData = function() {
  return this.data;
}, function(t3) {
  t3.processWEBP = function(e2, r2, n2, i2) {
    var a2 = new ee(e2, false), o2 = a2.width, s2 = a2.height, c2 = { data: a2.getData(), width: o2, height: s2 }, u2 = new Qt(100).encode(c2, 100);
    return t3.processJPEG.call(this, u2, r2, n2, i2);
  };
}(E$1.API), E$1.API.processRGBA = function(t3, e2, r2) {
  for (var n2 = t3.data, i2 = n2.length, a2 = new Uint8Array(i2 / 4 * 3), o2 = new Uint8Array(i2 / 4), s2 = 0, c2 = 0, u2 = 0; u2 < i2; u2 += 4) {
    var h2 = n2[u2], l2 = n2[u2 + 1], f2 = n2[u2 + 2], d2 = n2[u2 + 3];
    a2[s2++] = h2, a2[s2++] = l2, a2[s2++] = f2, o2[c2++] = d2;
  }
  var p5 = this.__addimage__.arrayBufferToBinaryString(a2);
  return { alpha: this.__addimage__.arrayBufferToBinaryString(o2), data: p5, index: e2, alias: r2, colorSpace: "DeviceRGB", bitsPerComponent: 8, width: t3.width, height: t3.height };
}, E$1.API.setLanguage = function(t3) {
  return this.internal.languageSettings === void 0 && (this.internal.languageSettings = {}, this.internal.languageSettings.isSubscribed = false), { af: "Afrikaans", sq: "Albanian", ar: "Arabic (Standard)", "ar-DZ": "Arabic (Algeria)", "ar-BH": "Arabic (Bahrain)", "ar-EG": "Arabic (Egypt)", "ar-IQ": "Arabic (Iraq)", "ar-JO": "Arabic (Jordan)", "ar-KW": "Arabic (Kuwait)", "ar-LB": "Arabic (Lebanon)", "ar-LY": "Arabic (Libya)", "ar-MA": "Arabic (Morocco)", "ar-OM": "Arabic (Oman)", "ar-QA": "Arabic (Qatar)", "ar-SA": "Arabic (Saudi Arabia)", "ar-SY": "Arabic (Syria)", "ar-TN": "Arabic (Tunisia)", "ar-AE": "Arabic (U.A.E.)", "ar-YE": "Arabic (Yemen)", an: "Aragonese", hy: "Armenian", as: "Assamese", ast: "Asturian", az: "Azerbaijani", eu: "Basque", be: "Belarusian", bn: "Bengali", bs: "Bosnian", br: "Breton", bg: "Bulgarian", my: "Burmese", ca: "Catalan", ch: "Chamorro", ce: "Chechen", zh: "Chinese", "zh-HK": "Chinese (Hong Kong)", "zh-CN": "Chinese (PRC)", "zh-SG": "Chinese (Singapore)", "zh-TW": "Chinese (Taiwan)", cv: "Chuvash", co: "Corsican", cr: "Cree", hr: "Croatian", cs: "Czech", da: "Danish", nl: "Dutch (Standard)", "nl-BE": "Dutch (Belgian)", en: "English", "en-AU": "English (Australia)", "en-BZ": "English (Belize)", "en-CA": "English (Canada)", "en-IE": "English (Ireland)", "en-JM": "English (Jamaica)", "en-NZ": "English (New Zealand)", "en-PH": "English (Philippines)", "en-ZA": "English (South Africa)", "en-TT": "English (Trinidad & Tobago)", "en-GB": "English (United Kingdom)", "en-US": "English (United States)", "en-ZW": "English (Zimbabwe)", eo: "Esperanto", et: "Estonian", fo: "Faeroese", fj: "Fijian", fi: "Finnish", fr: "French (Standard)", "fr-BE": "French (Belgium)", "fr-CA": "French (Canada)", "fr-FR": "French (France)", "fr-LU": "French (Luxembourg)", "fr-MC": "French (Monaco)", "fr-CH": "French (Switzerland)", fy: "Frisian", fur: "Friulian", gd: "Gaelic (Scots)", "gd-IE": "Gaelic (Irish)", gl: "Galacian", ka: "Georgian", de: "German (Standard)", "de-AT": "German (Austria)", "de-DE": "German (Germany)", "de-LI": "German (Liechtenstein)", "de-LU": "German (Luxembourg)", "de-CH": "German (Switzerland)", el: "Greek", gu: "Gujurati", ht: "Haitian", he: "Hebrew", hi: "Hindi", hu: "Hungarian", is: "Icelandic", id: "Indonesian", iu: "Inuktitut", ga: "Irish", it: "Italian (Standard)", "it-CH": "Italian (Switzerland)", ja: "Japanese", kn: "Kannada", ks: "Kashmiri", kk: "Kazakh", km: "Khmer", ky: "Kirghiz", tlh: "Klingon", ko: "Korean", "ko-KP": "Korean (North Korea)", "ko-KR": "Korean (South Korea)", la: "Latin", lv: "Latvian", lt: "Lithuanian", lb: "Luxembourgish", mk: "North Macedonia", ms: "Malay", ml: "Malayalam", mt: "Maltese", mi: "Maori", mr: "Marathi", mo: "Moldavian", nv: "Navajo", ng: "Ndonga", ne: "Nepali", no: "Norwegian", nb: "Norwegian (Bokmal)", nn: "Norwegian (Nynorsk)", oc: "Occitan", or: "Oriya", om: "Oromo", fa: "Persian", "fa-IR": "Persian/Iran", pl: "Polish", pt: "Portuguese", "pt-BR": "Portuguese (Brazil)", pa: "Punjabi", "pa-IN": "Punjabi (India)", "pa-PK": "Punjabi (Pakistan)", qu: "Quechua", rm: "Rhaeto-Romanic", ro: "Romanian", "ro-MO": "Romanian (Moldavia)", ru: "Russian", "ru-MO": "Russian (Moldavia)", sz: "Sami (Lappish)", sg: "Sango", sa: "Sanskrit", sc: "Sardinian", sd: "Sindhi", si: "Singhalese", sr: "Serbian", sk: "Slovak", sl: "Slovenian", so: "Somani", sb: "Sorbian", es: "Spanish", "es-AR": "Spanish (Argentina)", "es-BO": "Spanish (Bolivia)", "es-CL": "Spanish (Chile)", "es-CO": "Spanish (Colombia)", "es-CR": "Spanish (Costa Rica)", "es-DO": "Spanish (Dominican Republic)", "es-EC": "Spanish (Ecuador)", "es-SV": "Spanish (El Salvador)", "es-GT": "Spanish (Guatemala)", "es-HN": "Spanish (Honduras)", "es-MX": "Spanish (Mexico)", "es-NI": "Spanish (Nicaragua)", "es-PA": "Spanish (Panama)", "es-PY": "Spanish (Paraguay)", "es-PE": "Spanish (Peru)", "es-PR": "Spanish (Puerto Rico)", "es-ES": "Spanish (Spain)", "es-UY": "Spanish (Uruguay)", "es-VE": "Spanish (Venezuela)", sx: "Sutu", sw: "Swahili", sv: "Swedish", "sv-FI": "Swedish (Finland)", "sv-SV": "Swedish (Sweden)", ta: "Tamil", tt: "Tatar", te: "Teluga", th: "Thai", tig: "Tigre", ts: "Tsonga", tn: "Tswana", tr: "Turkish", tk: "Turkmen", uk: "Ukrainian", hsb: "Upper Sorbian", ur: "Urdu", ve: "Venda", vi: "Vietnamese", vo: "Volapuk", wa: "Walloon", cy: "Welsh", xh: "Xhosa", ji: "Yiddish", zu: "Zulu" }[t3] !== void 0 && (this.internal.languageSettings.languageCode = t3, this.internal.languageSettings.isSubscribed === false && (this.internal.events.subscribe("putCatalog", function() {
    this.internal.write("/Lang (" + this.internal.languageSettings.languageCode + ")");
  }), this.internal.languageSettings.isSubscribed = true)), this;
}, Vt = E$1.API, Gt = Vt.getCharWidthsArray = function(e2, r2) {
  var n2, i2, a2 = (r2 = r2 || {}).font || this.internal.getFont(), o2 = r2.fontSize || this.internal.getFontSize(), s2 = r2.charSpace || this.internal.getCharSpace(), c2 = r2.widths ? r2.widths : a2.metadata.Unicode.widths, u2 = c2.fof ? c2.fof : 1, h2 = r2.kerning ? r2.kerning : a2.metadata.Unicode.kerning, l2 = h2.fof ? h2.fof : 1, f2 = r2.doKerning !== false, d2 = 0, p5 = e2.length, g2 = 0, m2 = c2[0] || u2, v2 = [];
  for (n2 = 0; n2 < p5; n2++)
    i2 = e2.charCodeAt(n2), typeof a2.metadata.widthOfString == "function" ? v2.push((a2.metadata.widthOfGlyph(a2.metadata.characterToGlyph(i2)) + s2 * (1e3 / o2) || 0) / 1e3) : (d2 = f2 && _typeof$2(h2[i2]) === "object" && !isNaN(parseInt(h2[i2][g2], 10)) ? h2[i2][g2] / l2 : 0, v2.push((c2[i2] || m2) / u2 + d2)), g2 = i2;
  return v2;
}, Yt = Vt.getStringUnitWidth = function(t3, e2) {
  var r2 = (e2 = e2 || {}).fontSize || this.internal.getFontSize(), n2 = e2.font || this.internal.getFont(), i2 = e2.charSpace || this.internal.getCharSpace();
  return Vt.processArabic && (t3 = Vt.processArabic(t3)), typeof n2.metadata.widthOfString == "function" ? n2.metadata.widthOfString(t3, r2, i2) / r2 : Gt.apply(this, arguments).reduce(function(t4, e3) {
    return t4 + e3;
  }, 0);
}, Jt = function(t3, e2, r2, n2) {
  for (var i2 = [], a2 = 0, o2 = t3.length, s2 = 0; a2 !== o2 && s2 + e2[a2] < r2; )
    s2 += e2[a2], a2++;
  i2.push(t3.slice(0, a2));
  var c2 = a2;
  for (s2 = 0; a2 !== o2; )
    s2 + e2[a2] > n2 && (i2.push(t3.slice(c2, a2)), s2 = 0, c2 = a2), s2 += e2[a2], a2++;
  return c2 !== a2 && i2.push(t3.slice(c2, a2)), i2;
}, Xt = function(t3, e2, r2) {
  r2 || (r2 = {});
  var n2, i2, a2, o2, s2, c2, u2, h2 = [], l2 = [h2], f2 = r2.textIndent || 0, d2 = 0, p5 = 0, g2 = t3.split(" "), m2 = Gt.apply(this, [" ", r2])[0];
  if (c2 = r2.lineIndent === -1 ? g2[0].length + 2 : r2.lineIndent || 0) {
    var v2 = Array(c2).join(" "), b2 = [];
    g2.map(function(t4) {
      (t4 = t4.split(/\s*\n/)).length > 1 ? b2 = b2.concat(t4.map(function(t5, e3) {
        return (e3 && t5.length ? "\n" : "") + t5;
      })) : b2.push(t4[0]);
    }), g2 = b2, c2 = Yt.apply(this, [v2, r2]);
  }
  for (a2 = 0, o2 = g2.length; a2 < o2; a2++) {
    var y2 = 0;
    if (n2 = g2[a2], c2 && n2[0] == "\n" && (n2 = n2.substr(1), y2 = 1), f2 + d2 + (p5 = (i2 = Gt.apply(this, [n2, r2])).reduce(function(t4, e3) {
      return t4 + e3;
    }, 0)) > e2 || y2) {
      if (p5 > e2) {
        for (s2 = Jt.apply(this, [n2, i2, e2 - (f2 + d2), e2]), h2.push(s2.shift()), h2 = [s2.pop()]; s2.length; )
          l2.push([s2.shift()]);
        p5 = i2.slice(n2.length - (h2[0] ? h2[0].length : 0)).reduce(function(t4, e3) {
          return t4 + e3;
        }, 0);
      } else
        h2 = [n2];
      l2.push(h2), f2 = p5 + c2, d2 = m2;
    } else
      h2.push(n2), f2 += d2 + p5, d2 = m2;
  }
  return u2 = c2 ? function(t4, e3) {
    return (e3 ? v2 : "") + t4.join(" ");
  } : function(t4) {
    return t4.join(" ");
  }, l2.map(u2);
}, Vt.splitTextToSize = function(t3, e2, r2) {
  var n2, i2 = (r2 = r2 || {}).fontSize || this.internal.getFontSize(), a2 = function(t4) {
    if (t4.widths && t4.kerning)
      return { widths: t4.widths, kerning: t4.kerning };
    var e3 = this.internal.getFont(t4.fontName, t4.fontStyle);
    return e3.metadata.Unicode ? { widths: e3.metadata.Unicode.widths || { 0: 1 }, kerning: e3.metadata.Unicode.kerning || {} } : { font: e3.metadata, fontSize: this.internal.getFontSize(), charSpace: this.internal.getCharSpace() };
  }.call(this, r2);
  n2 = Array.isArray(t3) ? t3 : String(t3).split(/\r?\n/);
  var o2 = 1 * this.internal.scaleFactor * e2 / i2;
  a2.textIndent = r2.textIndent ? 1 * r2.textIndent * this.internal.scaleFactor / i2 : 0, a2.lineIndent = r2.lineIndent;
  var s2, c2, u2 = [];
  for (s2 = 0, c2 = n2.length; s2 < c2; s2++)
    u2 = u2.concat(Xt.apply(this, [n2[s2], o2, a2]));
  return u2;
}, function(e2) {
  e2.__fontmetrics__ = e2.__fontmetrics__ || {};
  for (var r2 = "klmnopqrstuvwxyz", n2 = {}, i2 = {}, a2 = 0; a2 < r2.length; a2++)
    n2[r2[a2]] = "0123456789abcdef"[a2], i2["0123456789abcdef"[a2]] = r2[a2];
  var o2 = function(t3) {
    return "0x" + parseInt(t3, 10).toString(16);
  }, s2 = e2.__fontmetrics__.compress = function(e3) {
    var r3, n3, a3, c3, u3 = ["{"];
    for (var h3 in e3) {
      if (r3 = e3[h3], isNaN(parseInt(h3, 10)) ? n3 = "'" + h3 + "'" : (h3 = parseInt(h3, 10), n3 = (n3 = o2(h3).slice(2)).slice(0, -1) + i2[n3.slice(-1)]), typeof r3 == "number")
        r3 < 0 ? (a3 = o2(r3).slice(3), c3 = "-") : (a3 = o2(r3).slice(2), c3 = ""), a3 = c3 + a3.slice(0, -1) + i2[a3.slice(-1)];
      else {
        if (_typeof$2(r3) !== "object")
          throw new Error("Don't know what to do with value type " + _typeof$2(r3) + ".");
        a3 = s2(r3);
      }
      u3.push(n3 + a3);
    }
    return u3.push("}"), u3.join("");
  }, c2 = e2.__fontmetrics__.uncompress = function(t3) {
    if (typeof t3 != "string")
      throw new Error("Invalid argument passed to uncompress.");
    for (var e3, r3, i3, a3, o3 = {}, s3 = 1, c3 = o3, u3 = [], h3 = "", l3 = "", f2 = t3.length - 1, d2 = 1; d2 < f2; d2 += 1)
      (a3 = t3[d2]) == "'" ? e3 ? (i3 = e3.join(""), e3 = void 0) : e3 = [] : e3 ? e3.push(a3) : a3 == "{" ? (u3.push([c3, i3]), c3 = {}, i3 = void 0) : a3 == "}" ? ((r3 = u3.pop())[0][r3[1]] = c3, i3 = void 0, c3 = r3[0]) : a3 == "-" ? s3 = -1 : i3 === void 0 ? n2.hasOwnProperty(a3) ? (h3 += n2[a3], i3 = parseInt(h3, 16) * s3, s3 = 1, h3 = "") : h3 += a3 : n2.hasOwnProperty(a3) ? (l3 += n2[a3], c3[i3] = parseInt(l3, 16) * s3, s3 = 1, i3 = void 0, l3 = "") : l3 += a3;
    return o3;
  }, u2 = { codePages: ["WinAnsiEncoding"], WinAnsiEncoding: c2("{19m8n201n9q201o9r201s9l201t9m201u8m201w9n201x9o201y8o202k8q202l8r202m9p202q8p20aw8k203k8t203t8v203u9v2cq8s212m9t15m8w15n9w2dw9s16k8u16l9u17s9z17x8y17y9y}") }, h2 = { Unicode: { Courier: u2, "Courier-Bold": u2, "Courier-BoldOblique": u2, "Courier-Oblique": u2, Helvetica: u2, "Helvetica-Bold": u2, "Helvetica-BoldOblique": u2, "Helvetica-Oblique": u2, "Times-Roman": u2, "Times-Bold": u2, "Times-BoldItalic": u2, "Times-Italic": u2 } }, l2 = { Unicode: { "Courier-Oblique": c2("{'widths'{k3w'fof'6o}'kerning'{'fof'-6o}}"), "Times-BoldItalic": c2("{'widths'{k3o2q4ycx2r201n3m201o6o201s2l201t2l201u2l201w3m201x3m201y3m2k1t2l2r202m2n2n3m2o3m2p5n202q6o2r1w2s2l2t2l2u3m2v3t2w1t2x2l2y1t2z1w3k3m3l3m3m3m3n3m3o3m3p3m3q3m3r3m3s3m203t2l203u2l3v2l3w3t3x3t3y3t3z3m4k5n4l4m4m4m4n4m4o4s4p4m4q4m4r4s4s4y4t2r4u3m4v4m4w3x4x5t4y4s4z4s5k3x5l4s5m4m5n3r5o3x5p4s5q4m5r5t5s4m5t3x5u3x5v2l5w1w5x2l5y3t5z3m6k2l6l3m6m3m6n2w6o3m6p2w6q2l6r3m6s3r6t1w6u1w6v3m6w1w6x4y6y3r6z3m7k3m7l3m7m2r7n2r7o1w7p3r7q2w7r4m7s3m7t2w7u2r7v2n7w1q7x2n7y3t202l3mcl4mal2ram3man3mao3map3mar3mas2lat4uau1uav3maw3way4uaz2lbk2sbl3t'fof'6obo2lbp3tbq3mbr1tbs2lbu1ybv3mbz3mck4m202k3mcm4mcn4mco4mcp4mcq5ycr4mcs4mct4mcu4mcv4mcw2r2m3rcy2rcz2rdl4sdm4sdn4sdo4sdp4sdq4sds4sdt4sdu4sdv4sdw4sdz3mek3mel3mem3men3meo3mep3meq4ser2wes2wet2weu2wev2wew1wex1wey1wez1wfl3rfm3mfn3mfo3mfp3mfq3mfr3tfs3mft3rfu3rfv3rfw3rfz2w203k6o212m6o2dw2l2cq2l3t3m3u2l17s3x19m3m}'kerning'{cl{4qu5kt5qt5rs17ss5ts}201s{201ss}201t{cks4lscmscnscoscpscls2wu2yu201ts}201x{2wu2yu}2k{201ts}2w{4qx5kx5ou5qx5rs17su5tu}2x{17su5tu5ou}2y{4qx5kx5ou5qx5rs17ss5ts}'fof'-6ofn{17sw5tw5ou5qw5rs}7t{cksclscmscnscoscps4ls}3u{17su5tu5os5qs}3v{17su5tu5os5qs}7p{17su5tu}ck{4qu5kt5qt5rs17ss5ts}4l{4qu5kt5qt5rs17ss5ts}cm{4qu5kt5qt5rs17ss5ts}cn{4qu5kt5qt5rs17ss5ts}co{4qu5kt5qt5rs17ss5ts}cp{4qu5kt5qt5rs17ss5ts}6l{4qu5ou5qw5rt17su5tu}5q{ckuclucmucnucoucpu4lu}5r{ckuclucmucnucoucpu4lu}7q{cksclscmscnscoscps4ls}6p{4qu5ou5qw5rt17sw5tw}ek{4qu5ou5qw5rt17su5tu}el{4qu5ou5qw5rt17su5tu}em{4qu5ou5qw5rt17su5tu}en{4qu5ou5qw5rt17su5tu}eo{4qu5ou5qw5rt17su5tu}ep{4qu5ou5qw5rt17su5tu}es{17ss5ts5qs4qu}et{4qu5ou5qw5rt17sw5tw}eu{4qu5ou5qw5rt17ss5ts}ev{17ss5ts5qs4qu}6z{17sw5tw5ou5qw5rs}fm{17sw5tw5ou5qw5rs}7n{201ts}fo{17sw5tw5ou5qw5rs}fp{17sw5tw5ou5qw5rs}fq{17sw5tw5ou5qw5rs}7r{cksclscmscnscoscps4ls}fs{17sw5tw5ou5qw5rs}ft{17su5tu}fu{17su5tu}fv{17su5tu}fw{17su5tu}fz{cksclscmscnscoscps4ls}}}"), "Helvetica-Bold": c2("{'widths'{k3s2q4scx1w201n3r201o6o201s1w201t1w201u1w201w3m201x3m201y3m2k1w2l2l202m2n2n3r2o3r2p5t202q6o2r1s2s2l2t2l2u2r2v3u2w1w2x2l2y1w2z1w3k3r3l3r3m3r3n3r3o3r3p3r3q3r3r3r3s3r203t2l203u2l3v2l3w3u3x3u3y3u3z3x4k6l4l4s4m4s4n4s4o4s4p4m4q3x4r4y4s4s4t1w4u3r4v4s4w3x4x5n4y4s4z4y5k4m5l4y5m4s5n4m5o3x5p4s5q4m5r5y5s4m5t4m5u3x5v2l5w1w5x2l5y3u5z3r6k2l6l3r6m3x6n3r6o3x6p3r6q2l6r3x6s3x6t1w6u1w6v3r6w1w6x5t6y3x6z3x7k3x7l3x7m2r7n3r7o2l7p3x7q3r7r4y7s3r7t3r7u3m7v2r7w1w7x2r7y3u202l3rcl4sal2lam3ran3rao3rap3rar3ras2lat4tau2pav3raw3uay4taz2lbk2sbl3u'fof'6obo2lbp3xbq3rbr1wbs2lbu2obv3rbz3xck4s202k3rcm4scn4sco4scp4scq6ocr4scs4mct4mcu4mcv4mcw1w2m2zcy1wcz1wdl4sdm4ydn4ydo4ydp4ydq4yds4ydt4sdu4sdv4sdw4sdz3xek3rel3rem3ren3reo3rep3req5ter3res3ret3reu3rev3rew1wex1wey1wez1wfl3xfm3xfn3xfo3xfp3xfq3xfr3ufs3xft3xfu3xfv3xfw3xfz3r203k6o212m6o2dw2l2cq2l3t3r3u2l17s4m19m3r}'kerning'{cl{4qs5ku5ot5qs17sv5tv}201t{2ww4wy2yw}201w{2ks}201x{2ww4wy2yw}2k{201ts201xs}2w{7qs4qu5kw5os5qw5rs17su5tu7tsfzs}2x{5ow5qs}2y{7qs4qu5kw5os5qw5rs17su5tu7tsfzs}'fof'-6o7p{17su5tu5ot}ck{4qs5ku5ot5qs17sv5tv}4l{4qs5ku5ot5qs17sv5tv}cm{4qs5ku5ot5qs17sv5tv}cn{4qs5ku5ot5qs17sv5tv}co{4qs5ku5ot5qs17sv5tv}cp{4qs5ku5ot5qs17sv5tv}6l{17st5tt5os}17s{2kwclvcmvcnvcovcpv4lv4wwckv}5o{2kucltcmtcntcotcpt4lt4wtckt}5q{2ksclscmscnscoscps4ls4wvcks}5r{2ks4ws}5t{2kwclvcmvcnvcovcpv4lv4wwckv}eo{17st5tt5os}fu{17su5tu5ot}6p{17ss5ts}ek{17st5tt5os}el{17st5tt5os}em{17st5tt5os}en{17st5tt5os}6o{201ts}ep{17st5tt5os}es{17ss5ts}et{17ss5ts}eu{17ss5ts}ev{17ss5ts}6z{17su5tu5os5qt}fm{17su5tu5os5qt}fn{17su5tu5os5qt}fo{17su5tu5os5qt}fp{17su5tu5os5qt}fq{17su5tu5os5qt}fs{17su5tu5os5qt}ft{17su5tu5ot}7m{5os}fv{17su5tu5ot}fw{17su5tu5ot}}}"), Courier: c2("{'widths'{k3w'fof'6o}'kerning'{'fof'-6o}}"), "Courier-BoldOblique": c2("{'widths'{k3w'fof'6o}'kerning'{'fof'-6o}}"), "Times-Bold": c2("{'widths'{k3q2q5ncx2r201n3m201o6o201s2l201t2l201u2l201w3m201x3m201y3m2k1t2l2l202m2n2n3m2o3m2p6o202q6o2r1w2s2l2t2l2u3m2v3t2w1t2x2l2y1t2z1w3k3m3l3m3m3m3n3m3o3m3p3m3q3m3r3m3s3m203t2l203u2l3v2l3w3t3x3t3y3t3z3m4k5x4l4s4m4m4n4s4o4s4p4m4q3x4r4y4s4y4t2r4u3m4v4y4w4m4x5y4y4s4z4y5k3x5l4y5m4s5n3r5o4m5p4s5q4s5r6o5s4s5t4s5u4m5v2l5w1w5x2l5y3u5z3m6k2l6l3m6m3r6n2w6o3r6p2w6q2l6r3m6s3r6t1w6u2l6v3r6w1w6x5n6y3r6z3m7k3r7l3r7m2w7n2r7o2l7p3r7q3m7r4s7s3m7t3m7u2w7v2r7w1q7x2r7y3o202l3mcl4sal2lam3man3mao3map3mar3mas2lat4uau1yav3maw3tay4uaz2lbk2sbl3t'fof'6obo2lbp3rbr1tbs2lbu2lbv3mbz3mck4s202k3mcm4scn4sco4scp4scq6ocr4scs4mct4mcu4mcv4mcw2r2m3rcy2rcz2rdl4sdm4ydn4ydo4ydp4ydq4yds4ydt4sdu4sdv4sdw4sdz3rek3mel3mem3men3meo3mep3meq4ser2wes2wet2weu2wev2wew1wex1wey1wez1wfl3rfm3mfn3mfo3mfp3mfq3mfr3tfs3mft3rfu3rfv3rfw3rfz3m203k6o212m6o2dw2l2cq2l3t3m3u2l17s4s19m3m}'kerning'{cl{4qt5ks5ot5qy5rw17sv5tv}201t{cks4lscmscnscoscpscls4wv}2k{201ts}2w{4qu5ku7mu5os5qx5ru17su5tu}2x{17su5tu5ou5qs}2y{4qv5kv7mu5ot5qz5ru17su5tu}'fof'-6o7t{cksclscmscnscoscps4ls}3u{17su5tu5os5qu}3v{17su5tu5os5qu}fu{17su5tu5ou5qu}7p{17su5tu5ou5qu}ck{4qt5ks5ot5qy5rw17sv5tv}4l{4qt5ks5ot5qy5rw17sv5tv}cm{4qt5ks5ot5qy5rw17sv5tv}cn{4qt5ks5ot5qy5rw17sv5tv}co{4qt5ks5ot5qy5rw17sv5tv}cp{4qt5ks5ot5qy5rw17sv5tv}6l{17st5tt5ou5qu}17s{ckuclucmucnucoucpu4lu4wu}5o{ckuclucmucnucoucpu4lu4wu}5q{ckzclzcmzcnzcozcpz4lz4wu}5r{ckxclxcmxcnxcoxcpx4lx4wu}5t{ckuclucmucnucoucpu4lu4wu}7q{ckuclucmucnucoucpu4lu}6p{17sw5tw5ou5qu}ek{17st5tt5qu}el{17st5tt5ou5qu}em{17st5tt5qu}en{17st5tt5qu}eo{17st5tt5qu}ep{17st5tt5ou5qu}es{17ss5ts5qu}et{17sw5tw5ou5qu}eu{17sw5tw5ou5qu}ev{17ss5ts5qu}6z{17sw5tw5ou5qu5rs}fm{17sw5tw5ou5qu5rs}fn{17sw5tw5ou5qu5rs}fo{17sw5tw5ou5qu5rs}fp{17sw5tw5ou5qu5rs}fq{17sw5tw5ou5qu5rs}7r{cktcltcmtcntcotcpt4lt5os}fs{17sw5tw5ou5qu5rs}ft{17su5tu5ou5qu}7m{5os}fv{17su5tu5ou5qu}fw{17su5tu5ou5qu}fz{cksclscmscnscoscps4ls}}}"), Symbol: c2("{'widths'{k3uaw4r19m3m2k1t2l2l202m2y2n3m2p5n202q6o3k3m2s2l2t2l2v3r2w1t3m3m2y1t2z1wbk2sbl3r'fof'6o3n3m3o3m3p3m3q3m3r3m3s3m3t3m3u1w3v1w3w3r3x3r3y3r3z2wbp3t3l3m5v2l5x2l5z3m2q4yfr3r7v3k7w1o7x3k}'kerning'{'fof'-6o}}"), Helvetica: c2("{'widths'{k3p2q4mcx1w201n3r201o6o201s1q201t1q201u1q201w2l201x2l201y2l2k1w2l1w202m2n2n3r2o3r2p5t202q6o2r1n2s2l2t2l2u2r2v3u2w1w2x2l2y1w2z1w3k3r3l3r3m3r3n3r3o3r3p3r3q3r3r3r3s3r203t2l203u2l3v1w3w3u3x3u3y3u3z3r4k6p4l4m4m4m4n4s4o4s4p4m4q3x4r4y4s4s4t1w4u3m4v4m4w3r4x5n4y4s4z4y5k4m5l4y5m4s5n4m5o3x5p4s5q4m5r5y5s4m5t4m5u3x5v1w5w1w5x1w5y2z5z3r6k2l6l3r6m3r6n3m6o3r6p3r6q1w6r3r6s3r6t1q6u1q6v3m6w1q6x5n6y3r6z3r7k3r7l3r7m2l7n3m7o1w7p3r7q3m7r4s7s3m7t3m7u3m7v2l7w1u7x2l7y3u202l3rcl4mal2lam3ran3rao3rap3rar3ras2lat4tau2pav3raw3uay4taz2lbk2sbl3u'fof'6obo2lbp3rbr1wbs2lbu2obv3rbz3xck4m202k3rcm4mcn4mco4mcp4mcq6ocr4scs4mct4mcu4mcv4mcw1w2m2ncy1wcz1wdl4sdm4ydn4ydo4ydp4ydq4yds4ydt4sdu4sdv4sdw4sdz3xek3rel3rem3ren3reo3rep3req5ter3mes3ret3reu3rev3rew1wex1wey1wez1wfl3rfm3rfn3rfo3rfp3rfq3rfr3ufs3xft3rfu3rfv3rfw3rfz3m203k6o212m6o2dw2l2cq2l3t3r3u1w17s4m19m3r}'kerning'{5q{4wv}cl{4qs5kw5ow5qs17sv5tv}201t{2wu4w1k2yu}201x{2wu4wy2yu}17s{2ktclucmucnu4otcpu4lu4wycoucku}2w{7qs4qz5k1m17sy5ow5qx5rsfsu5ty7tufzu}2x{17sy5ty5oy5qs}2y{7qs4qz5k1m17sy5ow5qx5rsfsu5ty7tufzu}'fof'-6o7p{17sv5tv5ow}ck{4qs5kw5ow5qs17sv5tv}4l{4qs5kw5ow5qs17sv5tv}cm{4qs5kw5ow5qs17sv5tv}cn{4qs5kw5ow5qs17sv5tv}co{4qs5kw5ow5qs17sv5tv}cp{4qs5kw5ow5qs17sv5tv}6l{17sy5ty5ow}do{17st5tt}4z{17st5tt}7s{fst}dm{17st5tt}dn{17st5tt}5o{ckwclwcmwcnwcowcpw4lw4wv}dp{17st5tt}dq{17st5tt}7t{5ow}ds{17st5tt}5t{2ktclucmucnu4otcpu4lu4wycoucku}fu{17sv5tv5ow}6p{17sy5ty5ow5qs}ek{17sy5ty5ow}el{17sy5ty5ow}em{17sy5ty5ow}en{5ty}eo{17sy5ty5ow}ep{17sy5ty5ow}es{17sy5ty5qs}et{17sy5ty5ow5qs}eu{17sy5ty5ow5qs}ev{17sy5ty5ow5qs}6z{17sy5ty5ow5qs}fm{17sy5ty5ow5qs}fn{17sy5ty5ow5qs}fo{17sy5ty5ow5qs}fp{17sy5ty5qs}fq{17sy5ty5ow5qs}7r{5ow}fs{17sy5ty5ow5qs}ft{17sv5tv5ow}7m{5ow}fv{17sv5tv5ow}fw{17sv5tv5ow}}}"), "Helvetica-BoldOblique": c2("{'widths'{k3s2q4scx1w201n3r201o6o201s1w201t1w201u1w201w3m201x3m201y3m2k1w2l2l202m2n2n3r2o3r2p5t202q6o2r1s2s2l2t2l2u2r2v3u2w1w2x2l2y1w2z1w3k3r3l3r3m3r3n3r3o3r3p3r3q3r3r3r3s3r203t2l203u2l3v2l3w3u3x3u3y3u3z3x4k6l4l4s4m4s4n4s4o4s4p4m4q3x4r4y4s4s4t1w4u3r4v4s4w3x4x5n4y4s4z4y5k4m5l4y5m4s5n4m5o3x5p4s5q4m5r5y5s4m5t4m5u3x5v2l5w1w5x2l5y3u5z3r6k2l6l3r6m3x6n3r6o3x6p3r6q2l6r3x6s3x6t1w6u1w6v3r6w1w6x5t6y3x6z3x7k3x7l3x7m2r7n3r7o2l7p3x7q3r7r4y7s3r7t3r7u3m7v2r7w1w7x2r7y3u202l3rcl4sal2lam3ran3rao3rap3rar3ras2lat4tau2pav3raw3uay4taz2lbk2sbl3u'fof'6obo2lbp3xbq3rbr1wbs2lbu2obv3rbz3xck4s202k3rcm4scn4sco4scp4scq6ocr4scs4mct4mcu4mcv4mcw1w2m2zcy1wcz1wdl4sdm4ydn4ydo4ydp4ydq4yds4ydt4sdu4sdv4sdw4sdz3xek3rel3rem3ren3reo3rep3req5ter3res3ret3reu3rev3rew1wex1wey1wez1wfl3xfm3xfn3xfo3xfp3xfq3xfr3ufs3xft3xfu3xfv3xfw3xfz3r203k6o212m6o2dw2l2cq2l3t3r3u2l17s4m19m3r}'kerning'{cl{4qs5ku5ot5qs17sv5tv}201t{2ww4wy2yw}201w{2ks}201x{2ww4wy2yw}2k{201ts201xs}2w{7qs4qu5kw5os5qw5rs17su5tu7tsfzs}2x{5ow5qs}2y{7qs4qu5kw5os5qw5rs17su5tu7tsfzs}'fof'-6o7p{17su5tu5ot}ck{4qs5ku5ot5qs17sv5tv}4l{4qs5ku5ot5qs17sv5tv}cm{4qs5ku5ot5qs17sv5tv}cn{4qs5ku5ot5qs17sv5tv}co{4qs5ku5ot5qs17sv5tv}cp{4qs5ku5ot5qs17sv5tv}6l{17st5tt5os}17s{2kwclvcmvcnvcovcpv4lv4wwckv}5o{2kucltcmtcntcotcpt4lt4wtckt}5q{2ksclscmscnscoscps4ls4wvcks}5r{2ks4ws}5t{2kwclvcmvcnvcovcpv4lv4wwckv}eo{17st5tt5os}fu{17su5tu5ot}6p{17ss5ts}ek{17st5tt5os}el{17st5tt5os}em{17st5tt5os}en{17st5tt5os}6o{201ts}ep{17st5tt5os}es{17ss5ts}et{17ss5ts}eu{17ss5ts}ev{17ss5ts}6z{17su5tu5os5qt}fm{17su5tu5os5qt}fn{17su5tu5os5qt}fo{17su5tu5os5qt}fp{17su5tu5os5qt}fq{17su5tu5os5qt}fs{17su5tu5os5qt}ft{17su5tu5ot}7m{5os}fv{17su5tu5ot}fw{17su5tu5ot}}}"), ZapfDingbats: c2("{'widths'{k4u2k1w'fof'6o}'kerning'{'fof'-6o}}"), "Courier-Bold": c2("{'widths'{k3w'fof'6o}'kerning'{'fof'-6o}}"), "Times-Italic": c2("{'widths'{k3n2q4ycx2l201n3m201o5t201s2l201t2l201u2l201w3r201x3r201y3r2k1t2l2l202m2n2n3m2o3m2p5n202q5t2r1p2s2l2t2l2u3m2v4n2w1t2x2l2y1t2z1w3k3m3l3m3m3m3n3m3o3m3p3m3q3m3r3m3s3m203t2l203u2l3v2l3w4n3x4n3y4n3z3m4k5w4l3x4m3x4n4m4o4s4p3x4q3x4r4s4s4s4t2l4u2w4v4m4w3r4x5n4y4m4z4s5k3x5l4s5m3x5n3m5o3r5p4s5q3x5r5n5s3x5t3r5u3r5v2r5w1w5x2r5y2u5z3m6k2l6l3m6m3m6n2w6o3m6p2w6q1w6r3m6s3m6t1w6u1w6v2w6w1w6x4s6y3m6z3m7k3m7l3m7m2r7n2r7o1w7p3m7q2w7r4m7s2w7t2w7u2r7v2s7w1v7x2s7y3q202l3mcl3xal2ram3man3mao3map3mar3mas2lat4wau1vav3maw4nay4waz2lbk2sbl4n'fof'6obo2lbp3mbq3obr1tbs2lbu1zbv3mbz3mck3x202k3mcm3xcn3xco3xcp3xcq5tcr4mcs3xct3xcu3xcv3xcw2l2m2ucy2lcz2ldl4mdm4sdn4sdo4sdp4sdq4sds4sdt4sdu4sdv4sdw4sdz3mek3mel3mem3men3meo3mep3meq4mer2wes2wet2weu2wev2wew1wex1wey1wez1wfl3mfm3mfn3mfo3mfp3mfq3mfr4nfs3mft3mfu3mfv3mfw3mfz2w203k6o212m6m2dw2l2cq2l3t3m3u2l17s3r19m3m}'kerning'{cl{5kt4qw}201s{201sw}201t{201tw2wy2yy6q-t}201x{2wy2yy}2k{201tw}2w{7qs4qy7rs5ky7mw5os5qx5ru17su5tu}2x{17ss5ts5os}2y{7qs4qy7rs5ky7mw5os5qx5ru17su5tu}'fof'-6o6t{17ss5ts5qs}7t{5os}3v{5qs}7p{17su5tu5qs}ck{5kt4qw}4l{5kt4qw}cm{5kt4qw}cn{5kt4qw}co{5kt4qw}cp{5kt4qw}6l{4qs5ks5ou5qw5ru17su5tu}17s{2ks}5q{ckvclvcmvcnvcovcpv4lv}5r{ckuclucmucnucoucpu4lu}5t{2ks}6p{4qs5ks5ou5qw5ru17su5tu}ek{4qs5ks5ou5qw5ru17su5tu}el{4qs5ks5ou5qw5ru17su5tu}em{4qs5ks5ou5qw5ru17su5tu}en{4qs5ks5ou5qw5ru17su5tu}eo{4qs5ks5ou5qw5ru17su5tu}ep{4qs5ks5ou5qw5ru17su5tu}es{5ks5qs4qs}et{4qs5ks5ou5qw5ru17su5tu}eu{4qs5ks5qw5ru17su5tu}ev{5ks5qs4qs}ex{17ss5ts5qs}6z{4qv5ks5ou5qw5ru17su5tu}fm{4qv5ks5ou5qw5ru17su5tu}fn{4qv5ks5ou5qw5ru17su5tu}fo{4qv5ks5ou5qw5ru17su5tu}fp{4qv5ks5ou5qw5ru17su5tu}fq{4qv5ks5ou5qw5ru17su5tu}7r{5os}fs{4qv5ks5ou5qw5ru17su5tu}ft{17su5tu5qs}fu{17su5tu5qs}fv{17su5tu5qs}fw{17su5tu5qs}}}"), "Times-Roman": c2("{'widths'{k3n2q4ycx2l201n3m201o6o201s2l201t2l201u2l201w2w201x2w201y2w2k1t2l2l202m2n2n3m2o3m2p5n202q6o2r1m2s2l2t2l2u3m2v3s2w1t2x2l2y1t2z1w3k3m3l3m3m3m3n3m3o3m3p3m3q3m3r3m3s3m203t2l203u2l3v1w3w3s3x3s3y3s3z2w4k5w4l4s4m4m4n4m4o4s4p3x4q3r4r4s4s4s4t2l4u2r4v4s4w3x4x5t4y4s4z4s5k3r5l4s5m4m5n3r5o3x5p4s5q4s5r5y5s4s5t4s5u3x5v2l5w1w5x2l5y2z5z3m6k2l6l2w6m3m6n2w6o3m6p2w6q2l6r3m6s3m6t1w6u1w6v3m6w1w6x4y6y3m6z3m7k3m7l3m7m2l7n2r7o1w7p3m7q3m7r4s7s3m7t3m7u2w7v3k7w1o7x3k7y3q202l3mcl4sal2lam3man3mao3map3mar3mas2lat4wau1vav3maw3say4waz2lbk2sbl3s'fof'6obo2lbp3mbq2xbr1tbs2lbu1zbv3mbz2wck4s202k3mcm4scn4sco4scp4scq5tcr4mcs3xct3xcu3xcv3xcw2l2m2tcy2lcz2ldl4sdm4sdn4sdo4sdp4sdq4sds4sdt4sdu4sdv4sdw4sdz3mek2wel2wem2wen2weo2wep2weq4mer2wes2wet2weu2wev2wew1wex1wey1wez1wfl3mfm3mfn3mfo3mfp3mfq3mfr3sfs3mft3mfu3mfv3mfw3mfz3m203k6o212m6m2dw2l2cq2l3t3m3u1w17s4s19m3m}'kerning'{cl{4qs5ku17sw5ou5qy5rw201ss5tw201ws}201s{201ss}201t{ckw4lwcmwcnwcowcpwclw4wu201ts}2k{201ts}2w{4qs5kw5os5qx5ru17sx5tx}2x{17sw5tw5ou5qu}2y{4qs5kw5os5qx5ru17sx5tx}'fof'-6o7t{ckuclucmucnucoucpu4lu5os5rs}3u{17su5tu5qs}3v{17su5tu5qs}7p{17sw5tw5qs}ck{4qs5ku17sw5ou5qy5rw201ss5tw201ws}4l{4qs5ku17sw5ou5qy5rw201ss5tw201ws}cm{4qs5ku17sw5ou5qy5rw201ss5tw201ws}cn{4qs5ku17sw5ou5qy5rw201ss5tw201ws}co{4qs5ku17sw5ou5qy5rw201ss5tw201ws}cp{4qs5ku17sw5ou5qy5rw201ss5tw201ws}6l{17su5tu5os5qw5rs}17s{2ktclvcmvcnvcovcpv4lv4wuckv}5o{ckwclwcmwcnwcowcpw4lw4wu}5q{ckyclycmycnycoycpy4ly4wu5ms}5r{cktcltcmtcntcotcpt4lt4ws}5t{2ktclvcmvcnvcovcpv4lv4wuckv}7q{cksclscmscnscoscps4ls}6p{17su5tu5qw5rs}ek{5qs5rs}el{17su5tu5os5qw5rs}em{17su5tu5os5qs5rs}en{17su5qs5rs}eo{5qs5rs}ep{17su5tu5os5qw5rs}es{5qs}et{17su5tu5qw5rs}eu{17su5tu5qs5rs}ev{5qs}6z{17sv5tv5os5qx5rs}fm{5os5qt5rs}fn{17sv5tv5os5qx5rs}fo{17sv5tv5os5qx5rs}fp{5os5qt5rs}fq{5os5qt5rs}7r{ckuclucmucnucoucpu4lu5os}fs{17sv5tv5os5qx5rs}ft{17ss5ts5qs}fu{17sw5tw5qs}fv{17sw5tw5qs}fw{17ss5ts5qs}fz{ckuclucmucnucoucpu4lu5os5rs}}}"), "Helvetica-Oblique": c2("{'widths'{k3p2q4mcx1w201n3r201o6o201s1q201t1q201u1q201w2l201x2l201y2l2k1w2l1w202m2n2n3r2o3r2p5t202q6o2r1n2s2l2t2l2u2r2v3u2w1w2x2l2y1w2z1w3k3r3l3r3m3r3n3r3o3r3p3r3q3r3r3r3s3r203t2l203u2l3v1w3w3u3x3u3y3u3z3r4k6p4l4m4m4m4n4s4o4s4p4m4q3x4r4y4s4s4t1w4u3m4v4m4w3r4x5n4y4s4z4y5k4m5l4y5m4s5n4m5o3x5p4s5q4m5r5y5s4m5t4m5u3x5v1w5w1w5x1w5y2z5z3r6k2l6l3r6m3r6n3m6o3r6p3r6q1w6r3r6s3r6t1q6u1q6v3m6w1q6x5n6y3r6z3r7k3r7l3r7m2l7n3m7o1w7p3r7q3m7r4s7s3m7t3m7u3m7v2l7w1u7x2l7y3u202l3rcl4mal2lam3ran3rao3rap3rar3ras2lat4tau2pav3raw3uay4taz2lbk2sbl3u'fof'6obo2lbp3rbr1wbs2lbu2obv3rbz3xck4m202k3rcm4mcn4mco4mcp4mcq6ocr4scs4mct4mcu4mcv4mcw1w2m2ncy1wcz1wdl4sdm4ydn4ydo4ydp4ydq4yds4ydt4sdu4sdv4sdw4sdz3xek3rel3rem3ren3reo3rep3req5ter3mes3ret3reu3rev3rew1wex1wey1wez1wfl3rfm3rfn3rfo3rfp3rfq3rfr3ufs3xft3rfu3rfv3rfw3rfz3m203k6o212m6o2dw2l2cq2l3t3r3u1w17s4m19m3r}'kerning'{5q{4wv}cl{4qs5kw5ow5qs17sv5tv}201t{2wu4w1k2yu}201x{2wu4wy2yu}17s{2ktclucmucnu4otcpu4lu4wycoucku}2w{7qs4qz5k1m17sy5ow5qx5rsfsu5ty7tufzu}2x{17sy5ty5oy5qs}2y{7qs4qz5k1m17sy5ow5qx5rsfsu5ty7tufzu}'fof'-6o7p{17sv5tv5ow}ck{4qs5kw5ow5qs17sv5tv}4l{4qs5kw5ow5qs17sv5tv}cm{4qs5kw5ow5qs17sv5tv}cn{4qs5kw5ow5qs17sv5tv}co{4qs5kw5ow5qs17sv5tv}cp{4qs5kw5ow5qs17sv5tv}6l{17sy5ty5ow}do{17st5tt}4z{17st5tt}7s{fst}dm{17st5tt}dn{17st5tt}5o{ckwclwcmwcnwcowcpw4lw4wv}dp{17st5tt}dq{17st5tt}7t{5ow}ds{17st5tt}5t{2ktclucmucnu4otcpu4lu4wycoucku}fu{17sv5tv5ow}6p{17sy5ty5ow5qs}ek{17sy5ty5ow}el{17sy5ty5ow}em{17sy5ty5ow}en{5ty}eo{17sy5ty5ow}ep{17sy5ty5ow}es{17sy5ty5qs}et{17sy5ty5ow5qs}eu{17sy5ty5ow5qs}ev{17sy5ty5ow5qs}6z{17sy5ty5ow5qs}fm{17sy5ty5ow5qs}fn{17sy5ty5ow5qs}fo{17sy5ty5ow5qs}fp{17sy5ty5qs}fq{17sy5ty5ow5qs}7r{5ow}fs{17sy5ty5ow5qs}ft{17sv5tv5ow}7m{5ow}fv{17sv5tv5ow}fw{17sv5tv5ow}}}") } };
  e2.events.push(["addFont", function(t3) {
    var e3 = t3.font, r3 = l2.Unicode[e3.postScriptName];
    r3 && (e3.metadata.Unicode = {}, e3.metadata.Unicode.widths = r3.widths, e3.metadata.Unicode.kerning = r3.kerning);
    var n3 = h2.Unicode[e3.postScriptName];
    n3 && (e3.metadata.Unicode.encoding = n3, e3.encoding = n3.codePages[0]);
  }]);
}(E$1.API), function(t3) {
  var e2 = function(t4) {
    for (var e3 = t4.length, r2 = new Uint8Array(e3), n2 = 0; n2 < e3; n2++)
      r2[n2] = t4.charCodeAt(n2);
    return r2;
  };
  t3.API.events.push(["addFont", function(r2) {
    var n2 = void 0, i2 = r2.font, a2 = r2.instance;
    if (!i2.isStandardFont) {
      if (a2 === void 0)
        throw new Error("Font does not exist in vFS, import fonts or remove declaration doc.addFont('" + i2.postScriptName + "').");
      if (typeof (n2 = a2.existsFileInVFS(i2.postScriptName) === false ? a2.loadFile(i2.postScriptName) : a2.getFileFromVFS(i2.postScriptName)) != "string")
        throw new Error("Font is not stored as string-data in vFS, import fonts or remove declaration doc.addFont('" + i2.postScriptName + "').");
      !function(r3, n3) {
        n3 = /^\x00\x01\x00\x00/.test(n3) ? e2(n3) : e2(u$2(n3)), r3.metadata = t3.API.TTFFont.open(n3), r3.metadata.Unicode = r3.metadata.Unicode || { encoding: {}, kerning: {}, widths: [] }, r3.metadata.glyIdsUsed = [0];
      }(i2, n2);
    }
  }]);
}(E$1), function(t3) {
  function e2() {
    return (n$1.canvg ? Promise.resolve(n$1.canvg) : Promise.resolve().then(function() {
      return index_es;
    })).catch(function(t4) {
      return Promise.reject(new Error("Could not load canvg: " + t4));
    }).then(function(t4) {
      return t4.default ? t4.default : t4;
    });
  }
  E$1.API.addSvgAsImage = function(t4, r2, n2, i2, o2, s2, c2, u2) {
    if (isNaN(r2) || isNaN(n2))
      throw a$2.error("jsPDF.addSvgAsImage: Invalid coordinates", arguments), new Error("Invalid coordinates passed to jsPDF.addSvgAsImage");
    if (isNaN(i2) || isNaN(o2))
      throw a$2.error("jsPDF.addSvgAsImage: Invalid measurements", arguments), new Error("Invalid measurements (width and/or height) passed to jsPDF.addSvgAsImage");
    var h2 = document.createElement("canvas");
    h2.width = i2, h2.height = o2;
    var l2 = h2.getContext("2d");
    l2.fillStyle = "#fff", l2.fillRect(0, 0, h2.width, h2.height);
    var f2 = { ignoreMouse: true, ignoreAnimation: true, ignoreDimensions: true }, d2 = this;
    return e2().then(function(e3) {
      return e3.fromString(l2, t4, f2);
    }, function() {
      return Promise.reject(new Error("Could not load canvg."));
    }).then(function(t5) {
      return t5.render(f2);
    }).then(function() {
      d2.addImage(h2.toDataURL("image/jpeg", 1), r2, n2, i2, o2, c2, u2);
    });
  };
}(), E$1.API.putTotalPages = function(t3) {
  var e2, r2 = 0;
  parseInt(this.internal.getFont().id.substr(1), 10) < 15 ? (e2 = new RegExp(t3, "g"), r2 = this.internal.getNumberOfPages()) : (e2 = new RegExp(this.pdfEscape16(t3, this.internal.getFont()), "g"), r2 = this.pdfEscape16(this.internal.getNumberOfPages() + "", this.internal.getFont()));
  for (var n2 = 1; n2 <= this.internal.getNumberOfPages(); n2++)
    for (var i2 = 0; i2 < this.internal.pages[n2].length; i2++)
      this.internal.pages[n2][i2] = this.internal.pages[n2][i2].replace(e2, r2);
  return this;
}, E$1.API.viewerPreferences = function(e2, r2) {
  var n2;
  e2 = e2 || {}, r2 = r2 || false;
  var i2, a2, o2, s2 = { HideToolbar: { defaultValue: false, value: false, type: "boolean", explicitSet: false, valueSet: [true, false], pdfVersion: 1.3 }, HideMenubar: { defaultValue: false, value: false, type: "boolean", explicitSet: false, valueSet: [true, false], pdfVersion: 1.3 }, HideWindowUI: { defaultValue: false, value: false, type: "boolean", explicitSet: false, valueSet: [true, false], pdfVersion: 1.3 }, FitWindow: { defaultValue: false, value: false, type: "boolean", explicitSet: false, valueSet: [true, false], pdfVersion: 1.3 }, CenterWindow: { defaultValue: false, value: false, type: "boolean", explicitSet: false, valueSet: [true, false], pdfVersion: 1.3 }, DisplayDocTitle: { defaultValue: false, value: false, type: "boolean", explicitSet: false, valueSet: [true, false], pdfVersion: 1.4 }, NonFullScreenPageMode: { defaultValue: "UseNone", value: "UseNone", type: "name", explicitSet: false, valueSet: ["UseNone", "UseOutlines", "UseThumbs", "UseOC"], pdfVersion: 1.3 }, Direction: { defaultValue: "L2R", value: "L2R", type: "name", explicitSet: false, valueSet: ["L2R", "R2L"], pdfVersion: 1.3 }, ViewArea: { defaultValue: "CropBox", value: "CropBox", type: "name", explicitSet: false, valueSet: ["MediaBox", "CropBox", "TrimBox", "BleedBox", "ArtBox"], pdfVersion: 1.4 }, ViewClip: { defaultValue: "CropBox", value: "CropBox", type: "name", explicitSet: false, valueSet: ["MediaBox", "CropBox", "TrimBox", "BleedBox", "ArtBox"], pdfVersion: 1.4 }, PrintArea: { defaultValue: "CropBox", value: "CropBox", type: "name", explicitSet: false, valueSet: ["MediaBox", "CropBox", "TrimBox", "BleedBox", "ArtBox"], pdfVersion: 1.4 }, PrintClip: { defaultValue: "CropBox", value: "CropBox", type: "name", explicitSet: false, valueSet: ["MediaBox", "CropBox", "TrimBox", "BleedBox", "ArtBox"], pdfVersion: 1.4 }, PrintScaling: { defaultValue: "AppDefault", value: "AppDefault", type: "name", explicitSet: false, valueSet: ["AppDefault", "None"], pdfVersion: 1.6 }, Duplex: { defaultValue: "", value: "none", type: "name", explicitSet: false, valueSet: ["Simplex", "DuplexFlipShortEdge", "DuplexFlipLongEdge", "none"], pdfVersion: 1.7 }, PickTrayByPDFSize: { defaultValue: false, value: false, type: "boolean", explicitSet: false, valueSet: [true, false], pdfVersion: 1.7 }, PrintPageRange: { defaultValue: "", value: "", type: "array", explicitSet: false, valueSet: null, pdfVersion: 1.7 }, NumCopies: { defaultValue: 1, value: 1, type: "integer", explicitSet: false, valueSet: null, pdfVersion: 1.7 } }, c2 = Object.keys(s2), u2 = [], h2 = 0, l2 = 0, f2 = 0;
  function d2(t3, e3) {
    var r3, n3 = false;
    for (r3 = 0; r3 < t3.length; r3 += 1)
      t3[r3] === e3 && (n3 = true);
    return n3;
  }
  if (this.internal.viewerpreferences === void 0 && (this.internal.viewerpreferences = {}, this.internal.viewerpreferences.configuration = JSON.parse(JSON.stringify(s2)), this.internal.viewerpreferences.isSubscribed = false), n2 = this.internal.viewerpreferences.configuration, e2 === "reset" || r2 === true) {
    var p5 = c2.length;
    for (f2 = 0; f2 < p5; f2 += 1)
      n2[c2[f2]].value = n2[c2[f2]].defaultValue, n2[c2[f2]].explicitSet = false;
  }
  if (_typeof$2(e2) === "object") {
    for (a2 in e2)
      if (o2 = e2[a2], d2(c2, a2) && o2 !== void 0) {
        if (n2[a2].type === "boolean" && typeof o2 == "boolean")
          n2[a2].value = o2;
        else if (n2[a2].type === "name" && d2(n2[a2].valueSet, o2))
          n2[a2].value = o2;
        else if (n2[a2].type === "integer" && Number.isInteger(o2))
          n2[a2].value = o2;
        else if (n2[a2].type === "array") {
          for (h2 = 0; h2 < o2.length; h2 += 1)
            if (i2 = true, o2[h2].length === 1 && typeof o2[h2][0] == "number")
              u2.push(String(o2[h2] - 1));
            else if (o2[h2].length > 1) {
              for (l2 = 0; l2 < o2[h2].length; l2 += 1)
                typeof o2[h2][l2] != "number" && (i2 = false);
              i2 === true && u2.push([o2[h2][0] - 1, o2[h2][1] - 1].join(" "));
            }
          n2[a2].value = "[" + u2.join(" ") + "]";
        } else
          n2[a2].value = n2[a2].defaultValue;
        n2[a2].explicitSet = true;
      }
  }
  return this.internal.viewerpreferences.isSubscribed === false && (this.internal.events.subscribe("putCatalog", function() {
    var t3, e3 = [];
    for (t3 in n2)
      n2[t3].explicitSet === true && (n2[t3].type === "name" ? e3.push("/" + t3 + " /" + n2[t3].value) : e3.push("/" + t3 + " " + n2[t3].value));
    e3.length !== 0 && this.internal.write("/ViewerPreferences\n<<\n" + e3.join("\n") + "\n>>");
  }), this.internal.viewerpreferences.isSubscribed = true), this.internal.viewerpreferences.configuration = n2, this;
}, function(t3) {
  var e2 = function() {
    var t4 = '<rdf:RDF xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"><rdf:Description rdf:about="" xmlns:jspdf="' + this.internal.__metadata__.namespaceuri + '"><jspdf:metadata>', e3 = unescape(encodeURIComponent('<x:xmpmeta xmlns:x="adobe:ns:meta/">')), r3 = unescape(encodeURIComponent(t4)), n2 = unescape(encodeURIComponent(this.internal.__metadata__.metadata)), i2 = unescape(encodeURIComponent("</jspdf:metadata></rdf:Description></rdf:RDF>")), a2 = unescape(encodeURIComponent("</x:xmpmeta>")), o2 = r3.length + n2.length + i2.length + e3.length + a2.length;
    this.internal.__metadata__.metadata_object_number = this.internal.newObject(), this.internal.write("<< /Type /Metadata /Subtype /XML /Length " + o2 + " >>"), this.internal.write("stream"), this.internal.write(e3 + r3 + n2 + i2 + a2), this.internal.write("endstream"), this.internal.write("endobj");
  }, r2 = function() {
    this.internal.__metadata__.metadata_object_number && this.internal.write("/Metadata " + this.internal.__metadata__.metadata_object_number + " 0 R");
  };
  t3.addMetadata = function(t4, n2) {
    return this.internal.__metadata__ === void 0 && (this.internal.__metadata__ = { metadata: t4, namespaceuri: n2 || "http://jspdf.default.namespaceuri/" }, this.internal.events.subscribe("putCatalog", r2), this.internal.events.subscribe("postPutResources", e2)), this;
  };
}(E$1.API), function(t3) {
  var e2 = t3.API, r2 = e2.pdfEscape16 = function(t4, e3) {
    for (var r3, n3 = e3.metadata.Unicode.widths, i3 = ["", "0", "00", "000", "0000"], a2 = [""], o2 = 0, s2 = t4.length; o2 < s2; ++o2) {
      if (r3 = e3.metadata.characterToGlyph(t4.charCodeAt(o2)), e3.metadata.glyIdsUsed.push(r3), e3.metadata.toUnicode[r3] = t4.charCodeAt(o2), n3.indexOf(r3) == -1 && (n3.push(r3), n3.push([parseInt(e3.metadata.widthOfGlyph(r3), 10)])), r3 == "0")
        return a2.join("");
      r3 = r3.toString(16), a2.push(i3[4 - r3.length], r3);
    }
    return a2.join("");
  }, n2 = function(t4) {
    var e3, r3, n3, i3, a2, o2, s2;
    for (a2 = "/CIDInit /ProcSet findresource begin\n12 dict begin\nbegincmap\n/CIDSystemInfo <<\n  /Registry (Adobe)\n  /Ordering (UCS)\n  /Supplement 0\n>> def\n/CMapName /Adobe-Identity-UCS def\n/CMapType 2 def\n1 begincodespacerange\n<0000><ffff>\nendcodespacerange", n3 = [], o2 = 0, s2 = (r3 = Object.keys(t4).sort(function(t5, e4) {
      return t5 - e4;
    })).length; o2 < s2; o2++)
      e3 = r3[o2], n3.length >= 100 && (a2 += "\n" + n3.length + " beginbfchar\n" + n3.join("\n") + "\nendbfchar", n3 = []), t4[e3] !== void 0 && t4[e3] !== null && typeof t4[e3].toString == "function" && (i3 = ("0000" + t4[e3].toString(16)).slice(-4), e3 = ("0000" + (+e3).toString(16)).slice(-4), n3.push("<" + e3 + "><" + i3 + ">"));
    return n3.length && (a2 += "\n" + n3.length + " beginbfchar\n" + n3.join("\n") + "\nendbfchar\n"), a2 += "endcmap\nCMapName currentdict /CMap defineresource pop\nend\nend";
  };
  e2.events.push(["putFont", function(e3) {
    !function(e4) {
      var r3 = e4.font, i3 = e4.out, a2 = e4.newObject, o2 = e4.putStream;
      if (r3.metadata instanceof t3.API.TTFFont && r3.encoding === "Identity-H") {
        for (var s2 = r3.metadata.Unicode.widths, c2 = r3.metadata.subset.encode(r3.metadata.glyIdsUsed, 1), u2 = "", h2 = 0; h2 < c2.length; h2++)
          u2 += String.fromCharCode(c2[h2]);
        var l2 = a2();
        o2({ data: u2, addLength1: true, objectId: l2 }), i3("endobj");
        var f2 = a2();
        o2({ data: n2(r3.metadata.toUnicode), addLength1: true, objectId: f2 }), i3("endobj");
        var d2 = a2();
        i3("<<"), i3("/Type /FontDescriptor"), i3("/FontName /" + F$1(r3.fontName)), i3("/FontFile2 " + l2 + " 0 R"), i3("/FontBBox " + t3.API.PDFObject.convert(r3.metadata.bbox)), i3("/Flags " + r3.metadata.flags), i3("/StemV " + r3.metadata.stemV), i3("/ItalicAngle " + r3.metadata.italicAngle), i3("/Ascent " + r3.metadata.ascender), i3("/Descent " + r3.metadata.decender), i3("/CapHeight " + r3.metadata.capHeight), i3(">>"), i3("endobj");
        var p5 = a2();
        i3("<<"), i3("/Type /Font"), i3("/BaseFont /" + F$1(r3.fontName)), i3("/FontDescriptor " + d2 + " 0 R"), i3("/W " + t3.API.PDFObject.convert(s2)), i3("/CIDToGIDMap /Identity"), i3("/DW 1000"), i3("/Subtype /CIDFontType2"), i3("/CIDSystemInfo"), i3("<<"), i3("/Supplement 0"), i3("/Registry (Adobe)"), i3("/Ordering (" + r3.encoding + ")"), i3(">>"), i3(">>"), i3("endobj"), r3.objectNumber = a2(), i3("<<"), i3("/Type /Font"), i3("/Subtype /Type0"), i3("/ToUnicode " + f2 + " 0 R"), i3("/BaseFont /" + F$1(r3.fontName)), i3("/Encoding /" + r3.encoding), i3("/DescendantFonts [" + p5 + " 0 R]"), i3(">>"), i3("endobj"), r3.isAlreadyPutted = true;
      }
    }(e3);
  }]);
  e2.events.push(["putFont", function(e3) {
    !function(e4) {
      var r3 = e4.font, i3 = e4.out, a2 = e4.newObject, o2 = e4.putStream;
      if (r3.metadata instanceof t3.API.TTFFont && r3.encoding === "WinAnsiEncoding") {
        for (var s2 = r3.metadata.rawData, c2 = "", u2 = 0; u2 < s2.length; u2++)
          c2 += String.fromCharCode(s2[u2]);
        var h2 = a2();
        o2({ data: c2, addLength1: true, objectId: h2 }), i3("endobj");
        var l2 = a2();
        o2({ data: n2(r3.metadata.toUnicode), addLength1: true, objectId: l2 }), i3("endobj");
        var f2 = a2();
        i3("<<"), i3("/Descent " + r3.metadata.decender), i3("/CapHeight " + r3.metadata.capHeight), i3("/StemV " + r3.metadata.stemV), i3("/Type /FontDescriptor"), i3("/FontFile2 " + h2 + " 0 R"), i3("/Flags 96"), i3("/FontBBox " + t3.API.PDFObject.convert(r3.metadata.bbox)), i3("/FontName /" + F$1(r3.fontName)), i3("/ItalicAngle " + r3.metadata.italicAngle), i3("/Ascent " + r3.metadata.ascender), i3(">>"), i3("endobj"), r3.objectNumber = a2();
        for (var d2 = 0; d2 < r3.metadata.hmtx.widths.length; d2++)
          r3.metadata.hmtx.widths[d2] = parseInt(r3.metadata.hmtx.widths[d2] * (1e3 / r3.metadata.head.unitsPerEm));
        i3("<</Subtype/TrueType/Type/Font/ToUnicode " + l2 + " 0 R/BaseFont/" + F$1(r3.fontName) + "/FontDescriptor " + f2 + " 0 R/Encoding/" + r3.encoding + " /FirstChar 29 /LastChar 255 /Widths " + t3.API.PDFObject.convert(r3.metadata.hmtx.widths) + ">>"), i3("endobj"), r3.isAlreadyPutted = true;
      }
    }(e3);
  }]);
  var i2 = function(t4) {
    var e3, n3 = t4.text || "", i3 = t4.x, a2 = t4.y, o2 = t4.options || {}, s2 = t4.mutex || {}, c2 = s2.pdfEscape, u2 = s2.activeFontKey, h2 = s2.fonts, l2 = u2, f2 = "", d2 = 0, p5 = "", g2 = h2[l2].encoding;
    if (h2[l2].encoding !== "Identity-H")
      return { text: n3, x: i3, y: a2, options: o2, mutex: s2 };
    for (p5 = n3, l2 = u2, Array.isArray(n3) && (p5 = n3[0]), d2 = 0; d2 < p5.length; d2 += 1)
      h2[l2].metadata.hasOwnProperty("cmap") && (e3 = h2[l2].metadata.cmap.unicode.codeMap[p5[d2].charCodeAt(0)]), e3 || p5[d2].charCodeAt(0) < 256 && h2[l2].metadata.hasOwnProperty("Unicode") ? f2 += p5[d2] : f2 += "";
    var m2 = "";
    return parseInt(l2.slice(1)) < 14 || g2 === "WinAnsiEncoding" ? m2 = c2(f2, l2).split("").map(function(t5) {
      return t5.charCodeAt(0).toString(16);
    }).join("") : g2 === "Identity-H" && (m2 = r2(f2, h2[l2])), s2.isHex = true, { text: m2, x: i3, y: a2, options: o2, mutex: s2 };
  };
  e2.events.push(["postProcessText", function(t4) {
    var e3 = t4.text || "", r3 = [], n3 = { text: e3, x: t4.x, y: t4.y, options: t4.options, mutex: t4.mutex };
    if (Array.isArray(e3)) {
      var a2 = 0;
      for (a2 = 0; a2 < e3.length; a2 += 1)
        Array.isArray(e3[a2]) && e3[a2].length === 3 ? r3.push([i2(Object.assign({}, n3, { text: e3[a2][0] })).text, e3[a2][1], e3[a2][2]]) : r3.push(i2(Object.assign({}, n3, { text: e3[a2] })).text);
      t4.text = r3;
    } else
      t4.text = i2(Object.assign({}, n3, { text: e3 })).text;
  }]);
}(E$1), function(t3) {
  var e2 = function() {
    return this.internal.vFS === void 0 && (this.internal.vFS = {}), true;
  };
  t3.existsFileInVFS = function(t4) {
    return e2.call(this), this.internal.vFS[t4] !== void 0;
  }, t3.addFileToVFS = function(t4, r2) {
    return e2.call(this), this.internal.vFS[t4] = r2, this;
  }, t3.getFileFromVFS = function(t4) {
    return e2.call(this), this.internal.vFS[t4] !== void 0 ? this.internal.vFS[t4] : null;
  };
}(E$1.API), function(t3) {
  t3.__bidiEngine__ = t3.prototype.__bidiEngine__ = function(t4) {
    var r3, n2, i2, a2, o2, s2, c2, u2 = e2, h2 = [[0, 3, 0, 1, 0, 0, 0], [0, 3, 0, 1, 2, 2, 0], [0, 3, 0, 17, 2, 0, 1], [0, 3, 5, 5, 4, 1, 0], [0, 3, 21, 21, 4, 0, 1], [0, 3, 5, 5, 4, 2, 0]], l2 = [[2, 0, 1, 1, 0, 1, 0], [2, 0, 1, 1, 0, 2, 0], [2, 0, 2, 1, 3, 2, 0], [2, 0, 2, 33, 3, 1, 1]], f2 = { L: 0, R: 1, EN: 2, AN: 3, N: 4, B: 5, S: 6 }, d2 = { 0: 0, 5: 1, 6: 2, 7: 3, 32: 4, 251: 5, 254: 6, 255: 7 }, p5 = ["(", ")", "(", "<", ">", "<", "[", "]", "[", "{", "}", "{", "\xAB", "\xBB", "\xAB", "\u2039", "\u203A", "\u2039", "\u2045", "\u2046", "\u2045", "\u207D", "\u207E", "\u207D", "\u208D", "\u208E", "\u208D", "\u2264", "\u2265", "\u2264", "\u2329", "\u232A", "\u2329", "\uFE59", "\uFE5A", "\uFE59", "\uFE5B", "\uFE5C", "\uFE5B", "\uFE5D", "\uFE5E", "\uFE5D", "\uFE64", "\uFE65", "\uFE64"], g2 = new RegExp(/^([1-4|9]|1[0-9]|2[0-9]|3[0168]|4[04589]|5[012]|7[78]|159|16[0-9]|17[0-2]|21[569]|22[03489]|250)$/), m2 = false, v2 = 0;
    this.__bidiEngine__ = {};
    var b2 = function(t5) {
      var e3 = t5.charCodeAt(), r4 = e3 >> 8, n3 = d2[r4];
      return n3 !== void 0 ? u2[256 * n3 + (255 & e3)] : r4 === 252 || r4 === 253 ? "AL" : g2.test(r4) ? "L" : r4 === 8 ? "R" : "N";
    }, y2 = function(t5) {
      for (var e3, r4 = 0; r4 < t5.length; r4++) {
        if ((e3 = b2(t5.charAt(r4))) === "L")
          return false;
        if (e3 === "R")
          return true;
      }
      return false;
    }, w2 = function(t5, e3, o3, s3) {
      var c3, u3, h3, l3, f3 = e3[s3];
      switch (f3) {
        case "L":
        case "R":
          m2 = false;
          break;
        case "N":
        case "AN":
          break;
        case "EN":
          m2 && (f3 = "AN");
          break;
        case "AL":
          m2 = true, f3 = "R";
          break;
        case "WS":
          f3 = "N";
          break;
        case "CS":
          s3 < 1 || s3 + 1 >= e3.length || (c3 = o3[s3 - 1]) !== "EN" && c3 !== "AN" || (u3 = e3[s3 + 1]) !== "EN" && u3 !== "AN" ? f3 = "N" : m2 && (u3 = "AN"), f3 = u3 === c3 ? u3 : "N";
          break;
        case "ES":
          f3 = (c3 = s3 > 0 ? o3[s3 - 1] : "B") === "EN" && s3 + 1 < e3.length && e3[s3 + 1] === "EN" ? "EN" : "N";
          break;
        case "ET":
          if (s3 > 0 && o3[s3 - 1] === "EN") {
            f3 = "EN";
            break;
          }
          if (m2) {
            f3 = "N";
            break;
          }
          for (h3 = s3 + 1, l3 = e3.length; h3 < l3 && e3[h3] === "ET"; )
            h3++;
          f3 = h3 < l3 && e3[h3] === "EN" ? "EN" : "N";
          break;
        case "NSM":
          if (i2 && !a2) {
            for (l3 = e3.length, h3 = s3 + 1; h3 < l3 && e3[h3] === "NSM"; )
              h3++;
            if (h3 < l3) {
              var d3 = t5[s3], p6 = d3 >= 1425 && d3 <= 2303 || d3 === 64286;
              if (c3 = e3[h3], p6 && (c3 === "R" || c3 === "AL")) {
                f3 = "R";
                break;
              }
            }
          }
          f3 = s3 < 1 || (c3 = e3[s3 - 1]) === "B" ? "N" : o3[s3 - 1];
          break;
        case "B":
          m2 = false, r3 = true, f3 = v2;
          break;
        case "S":
          n2 = true, f3 = "N";
          break;
        case "LRE":
        case "RLE":
        case "LRO":
        case "RLO":
        case "PDF":
          m2 = false;
          break;
        case "BN":
          f3 = "N";
      }
      return f3;
    }, N2 = function(t5, e3, r4) {
      var n3 = t5.split("");
      return r4 && L2(n3, r4, { hiLevel: v2 }), n3.reverse(), e3 && e3.reverse(), n3.join("");
    }, L2 = function(t5, e3, i3) {
      var a3, o3, s3, c3, u3, d3 = -1, p6 = t5.length, g3 = 0, y3 = [], N3 = v2 ? l2 : h2, L3 = [];
      for (m2 = false, r3 = false, n2 = false, o3 = 0; o3 < p6; o3++)
        L3[o3] = b2(t5[o3]);
      for (s3 = 0; s3 < p6; s3++) {
        if (u3 = g3, y3[s3] = w2(t5, L3, y3, s3), a3 = 240 & (g3 = N3[u3][f2[y3[s3]]]), g3 &= 15, e3[s3] = c3 = N3[g3][5], a3 > 0)
          if (a3 === 16) {
            for (o3 = d3; o3 < s3; o3++)
              e3[o3] = 1;
            d3 = -1;
          } else
            d3 = -1;
        if (N3[g3][6])
          d3 === -1 && (d3 = s3);
        else if (d3 > -1) {
          for (o3 = d3; o3 < s3; o3++)
            e3[o3] = c3;
          d3 = -1;
        }
        L3[s3] === "B" && (e3[s3] = 0), i3.hiLevel |= c3;
      }
      n2 && function(t6, e4, r4) {
        for (var n3 = 0; n3 < r4; n3++)
          if (t6[n3] === "S") {
            e4[n3] = v2;
            for (var i4 = n3 - 1; i4 >= 0 && t6[i4] === "WS"; i4--)
              e4[i4] = v2;
          }
      }(L3, e3, p6);
    }, A2 = function(t5, e3, n3, i3, a3) {
      if (!(a3.hiLevel < t5)) {
        if (t5 === 1 && v2 === 1 && !r3)
          return e3.reverse(), void (n3 && n3.reverse());
        for (var o3, s3, c3, u3, h3 = e3.length, l3 = 0; l3 < h3; ) {
          if (i3[l3] >= t5) {
            for (c3 = l3 + 1; c3 < h3 && i3[c3] >= t5; )
              c3++;
            for (u3 = l3, s3 = c3 - 1; u3 < s3; u3++, s3--)
              o3 = e3[u3], e3[u3] = e3[s3], e3[s3] = o3, n3 && (o3 = n3[u3], n3[u3] = n3[s3], n3[s3] = o3);
            l3 = c3;
          }
          l3++;
        }
      }
    }, x2 = function(t5, e3, r4) {
      var n3 = t5.split(""), i3 = { hiLevel: v2 };
      return r4 || (r4 = []), L2(n3, r4, i3), function(t6, e4, r5) {
        if (r5.hiLevel !== 0 && c2)
          for (var n4, i4 = 0; i4 < t6.length; i4++)
            e4[i4] === 1 && (n4 = p5.indexOf(t6[i4])) >= 0 && (t6[i4] = p5[n4 + 1]);
      }(n3, r4, i3), A2(2, n3, e3, r4, i3), A2(1, n3, e3, r4, i3), n3.join("");
    };
    return this.__bidiEngine__.doBidiReorder = function(t5, e3, r4) {
      if (function(t6, e4) {
        if (e4)
          for (var r5 = 0; r5 < t6.length; r5++)
            e4[r5] = r5;
        a2 === void 0 && (a2 = y2(t6)), s2 === void 0 && (s2 = y2(t6));
      }(t5, e3), i2 || !o2 || s2)
        if (i2 && o2 && a2 ^ s2)
          v2 = a2 ? 1 : 0, t5 = N2(t5, e3, r4);
        else if (!i2 && o2 && s2)
          v2 = a2 ? 1 : 0, t5 = x2(t5, e3, r4), t5 = N2(t5, e3);
        else if (!i2 || a2 || o2 || s2) {
          if (i2 && !o2 && a2 ^ s2)
            t5 = N2(t5, e3), a2 ? (v2 = 0, t5 = x2(t5, e3, r4)) : (v2 = 1, t5 = x2(t5, e3, r4), t5 = N2(t5, e3));
          else if (i2 && a2 && !o2 && s2)
            v2 = 1, t5 = x2(t5, e3, r4), t5 = N2(t5, e3);
          else if (!i2 && !o2 && a2 ^ s2) {
            var n3 = c2;
            a2 ? (v2 = 1, t5 = x2(t5, e3, r4), v2 = 0, c2 = false, t5 = x2(t5, e3, r4), c2 = n3) : (v2 = 0, t5 = x2(t5, e3, r4), t5 = N2(t5, e3), v2 = 1, c2 = false, t5 = x2(t5, e3, r4), c2 = n3, t5 = N2(t5, e3));
          }
        } else
          v2 = 0, t5 = x2(t5, e3, r4);
      else
        v2 = a2 ? 1 : 0, t5 = x2(t5, e3, r4);
      return t5;
    }, this.__bidiEngine__.setOptions = function(t5) {
      t5 && (i2 = t5.isInputVisual, o2 = t5.isOutputVisual, a2 = t5.isInputRtl, s2 = t5.isOutputRtl, c2 = t5.isSymmetricSwapping);
    }, this.__bidiEngine__.setOptions(t4), this.__bidiEngine__;
  };
  var e2 = ["BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "S", "B", "S", "WS", "B", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "B", "B", "B", "S", "WS", "N", "N", "ET", "ET", "ET", "N", "N", "N", "N", "N", "ES", "CS", "ES", "CS", "CS", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "CS", "N", "N", "N", "N", "N", "N", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "N", "N", "N", "N", "N", "N", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "N", "N", "N", "N", "BN", "BN", "BN", "BN", "BN", "BN", "B", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "CS", "N", "ET", "ET", "ET", "ET", "N", "N", "N", "N", "L", "N", "N", "BN", "N", "N", "ET", "ET", "EN", "EN", "N", "L", "N", "N", "N", "EN", "L", "N", "N", "N", "N", "N", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "N", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "N", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "N", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "N", "N", "L", "L", "L", "L", "L", "L", "L", "N", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "N", "L", "N", "N", "N", "N", "N", "ET", "N", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "R", "NSM", "R", "NSM", "NSM", "R", "NSM", "NSM", "R", "NSM", "N", "N", "N", "N", "N", "N", "N", "N", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "N", "N", "N", "N", "N", "R", "R", "R", "R", "R", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "AN", "AN", "AN", "AN", "AN", "AN", "N", "N", "AL", "ET", "ET", "AL", "CS", "AL", "N", "N", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "AL", "AL", "N", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "AN", "AN", "AN", "AN", "AN", "AN", "AN", "AN", "AN", "AN", "ET", "AN", "AN", "AL", "AL", "AL", "NSM", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "AN", "N", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "AL", "AL", "NSM", "NSM", "N", "NSM", "NSM", "NSM", "NSM", "AL", "AL", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "N", "AL", "AL", "NSM", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "N", "N", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "AL", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "R", "R", "N", "N", "N", "N", "R", "N", "N", "N", "N", "N", "WS", "WS", "WS", "WS", "WS", "WS", "WS", "WS", "WS", "WS", "WS", "BN", "BN", "BN", "L", "R", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "WS", "B", "LRE", "RLE", "PDF", "LRO", "RLO", "CS", "ET", "ET", "ET", "ET", "ET", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "CS", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "WS", "BN", "BN", "BN", "BN", "BN", "N", "LRI", "RLI", "FSI", "PDI", "BN", "BN", "BN", "BN", "BN", "BN", "EN", "L", "N", "N", "EN", "EN", "EN", "EN", "EN", "EN", "ES", "ES", "N", "N", "N", "L", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "ES", "ES", "N", "N", "N", "N", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "N", "N", "N", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "L", "L", "L", "L", "L", "L", "L", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "L", "L", "L", "L", "L", "N", "N", "N", "N", "N", "R", "NSM", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "ES", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "N", "R", "R", "R", "R", "R", "N", "R", "N", "R", "R", "N", "R", "R", "N", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "CS", "N", "CS", "N", "N", "CS", "N", "N", "N", "N", "N", "N", "N", "N", "N", "ET", "N", "N", "ES", "ES", "N", "N", "N", "N", "N", "ET", "ET", "N", "N", "N", "N", "N", "AL", "AL", "AL", "AL", "AL", "N", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "N", "N", "BN", "N", "N", "N", "ET", "ET", "ET", "N", "N", "N", "N", "N", "ES", "CS", "ES", "CS", "CS", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "CS", "N", "N", "N", "N", "N", "N", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "N", "N", "N", "N", "N", "N", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "N", "N", "N", "L", "L", "L", "L", "L", "L", "N", "N", "L", "L", "L", "L", "L", "L", "N", "N", "L", "L", "L", "L", "L", "L", "N", "N", "L", "L", "L", "N", "N", "N", "ET", "ET", "N", "N", "N", "ET", "ET", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N"], r2 = new t3.__bidiEngine__({ isInputVisual: true });
  t3.API.events.push(["postProcessText", function(t4) {
    var e3 = t4.text, n2 = (t4.x, t4.y, t4.options || {}), i2 = (t4.mutex, n2.lang, []);
    if (n2.isInputVisual = typeof n2.isInputVisual != "boolean" || n2.isInputVisual, r2.setOptions(n2), Object.prototype.toString.call(e3) === "[object Array]") {
      var a2 = 0;
      for (i2 = [], a2 = 0; a2 < e3.length; a2 += 1)
        Object.prototype.toString.call(e3[a2]) === "[object Array]" ? i2.push([r2.doBidiReorder(e3[a2][0]), e3[a2][1], e3[a2][2]]) : i2.push([r2.doBidiReorder(e3[a2])]);
      t4.text = i2;
    } else
      t4.text = r2.doBidiReorder(e3);
    r2.setOptions({ isInputVisual: true });
  }]);
}(E$1), E$1.API.TTFFont = function() {
  function t3(t4) {
    var e2;
    if (this.rawData = t4, e2 = this.contents = new ne(t4), this.contents.pos = 4, e2.readString(4) === "ttcf")
      throw new Error("TTCF not supported.");
    e2.pos = 0, this.parse(), this.subset = new Le(this), this.registerTTF();
  }
  return t3.open = function(e2) {
    return new t3(e2);
  }, t3.prototype.parse = function() {
    return this.directory = new ie(this.contents), this.head = new se(this), this.name = new pe(this), this.cmap = new ue(this), this.toUnicode = {}, this.hhea = new he(this), this.maxp = new ge(this), this.hmtx = new me(this), this.post = new fe(this), this.os2 = new le(this), this.loca = new Ne(this), this.glyf = new be(this), this.ascender = this.os2.exists && this.os2.ascender || this.hhea.ascender, this.decender = this.os2.exists && this.os2.decender || this.hhea.decender, this.lineGap = this.os2.exists && this.os2.lineGap || this.hhea.lineGap, this.bbox = [this.head.xMin, this.head.yMin, this.head.xMax, this.head.yMax];
  }, t3.prototype.registerTTF = function() {
    var t4, e2, r2, n2, i2;
    if (this.scaleFactor = 1e3 / this.head.unitsPerEm, this.bbox = function() {
      var e3, r3, n3, i3;
      for (i3 = [], e3 = 0, r3 = (n3 = this.bbox).length; e3 < r3; e3++)
        t4 = n3[e3], i3.push(Math.round(t4 * this.scaleFactor));
      return i3;
    }.call(this), this.stemV = 0, this.post.exists ? (r2 = 255 & (n2 = this.post.italic_angle), (32768 & (e2 = n2 >> 16)) != 0 && (e2 = -(1 + (65535 ^ e2))), this.italicAngle = +(e2 + "." + r2)) : this.italicAngle = 0, this.ascender = Math.round(this.ascender * this.scaleFactor), this.decender = Math.round(this.decender * this.scaleFactor), this.lineGap = Math.round(this.lineGap * this.scaleFactor), this.capHeight = this.os2.exists && this.os2.capHeight || this.ascender, this.xHeight = this.os2.exists && this.os2.xHeight || 0, this.familyClass = (this.os2.exists && this.os2.familyClass || 0) >> 8, this.isSerif = (i2 = this.familyClass) === 1 || i2 === 2 || i2 === 3 || i2 === 4 || i2 === 5 || i2 === 7, this.isScript = this.familyClass === 10, this.flags = 0, this.post.isFixedPitch && (this.flags |= 1), this.isSerif && (this.flags |= 2), this.isScript && (this.flags |= 8), this.italicAngle !== 0 && (this.flags |= 64), this.flags |= 32, !this.cmap.unicode)
      throw new Error("No unicode cmap for font");
  }, t3.prototype.characterToGlyph = function(t4) {
    var e2;
    return ((e2 = this.cmap.unicode) != null ? e2.codeMap[t4] : void 0) || 0;
  }, t3.prototype.widthOfGlyph = function(t4) {
    var e2;
    return e2 = 1e3 / this.head.unitsPerEm, this.hmtx.forGlyph(t4).advance * e2;
  }, t3.prototype.widthOfString = function(t4, e2, r2) {
    var n2, i2, a2, o2;
    for (a2 = 0, i2 = 0, o2 = (t4 = "" + t4).length; 0 <= o2 ? i2 < o2 : i2 > o2; i2 = 0 <= o2 ? ++i2 : --i2)
      n2 = t4.charCodeAt(i2), a2 += this.widthOfGlyph(this.characterToGlyph(n2)) + r2 * (1e3 / e2) || 0;
    return a2 * (e2 / 1e3);
  }, t3.prototype.lineHeight = function(t4, e2) {
    var r2;
    return e2 == null && (e2 = false), r2 = e2 ? this.lineGap : 0, (this.ascender + r2 - this.decender) / 1e3 * t4;
  }, t3;
}();
var re;
var ne = function() {
  function t3(t4) {
    this.data = t4 != null ? t4 : [], this.pos = 0, this.length = this.data.length;
  }
  return t3.prototype.readByte = function() {
    return this.data[this.pos++];
  }, t3.prototype.writeByte = function(t4) {
    return this.data[this.pos++] = t4;
  }, t3.prototype.readUInt32 = function() {
    return 16777216 * this.readByte() + (this.readByte() << 16) + (this.readByte() << 8) + this.readByte();
  }, t3.prototype.writeUInt32 = function(t4) {
    return this.writeByte(t4 >>> 24 & 255), this.writeByte(t4 >> 16 & 255), this.writeByte(t4 >> 8 & 255), this.writeByte(255 & t4);
  }, t3.prototype.readInt32 = function() {
    var t4;
    return (t4 = this.readUInt32()) >= 2147483648 ? t4 - 4294967296 : t4;
  }, t3.prototype.writeInt32 = function(t4) {
    return t4 < 0 && (t4 += 4294967296), this.writeUInt32(t4);
  }, t3.prototype.readUInt16 = function() {
    return this.readByte() << 8 | this.readByte();
  }, t3.prototype.writeUInt16 = function(t4) {
    return this.writeByte(t4 >> 8 & 255), this.writeByte(255 & t4);
  }, t3.prototype.readInt16 = function() {
    var t4;
    return (t4 = this.readUInt16()) >= 32768 ? t4 - 65536 : t4;
  }, t3.prototype.writeInt16 = function(t4) {
    return t4 < 0 && (t4 += 65536), this.writeUInt16(t4);
  }, t3.prototype.readString = function(t4) {
    var e2, r2;
    for (r2 = [], e2 = 0; 0 <= t4 ? e2 < t4 : e2 > t4; e2 = 0 <= t4 ? ++e2 : --e2)
      r2[e2] = String.fromCharCode(this.readByte());
    return r2.join("");
  }, t3.prototype.writeString = function(t4) {
    var e2, r2, n2;
    for (n2 = [], e2 = 0, r2 = t4.length; 0 <= r2 ? e2 < r2 : e2 > r2; e2 = 0 <= r2 ? ++e2 : --e2)
      n2.push(this.writeByte(t4.charCodeAt(e2)));
    return n2;
  }, t3.prototype.readShort = function() {
    return this.readInt16();
  }, t3.prototype.writeShort = function(t4) {
    return this.writeInt16(t4);
  }, t3.prototype.readLongLong = function() {
    var t4, e2, r2, n2, i2, a2, o2, s2;
    return t4 = this.readByte(), e2 = this.readByte(), r2 = this.readByte(), n2 = this.readByte(), i2 = this.readByte(), a2 = this.readByte(), o2 = this.readByte(), s2 = this.readByte(), 128 & t4 ? -1 * (72057594037927940 * (255 ^ t4) + 281474976710656 * (255 ^ e2) + 1099511627776 * (255 ^ r2) + 4294967296 * (255 ^ n2) + 16777216 * (255 ^ i2) + 65536 * (255 ^ a2) + 256 * (255 ^ o2) + (255 ^ s2) + 1) : 72057594037927940 * t4 + 281474976710656 * e2 + 1099511627776 * r2 + 4294967296 * n2 + 16777216 * i2 + 65536 * a2 + 256 * o2 + s2;
  }, t3.prototype.writeLongLong = function(t4) {
    var e2, r2;
    return e2 = Math.floor(t4 / 4294967296), r2 = 4294967295 & t4, this.writeByte(e2 >> 24 & 255), this.writeByte(e2 >> 16 & 255), this.writeByte(e2 >> 8 & 255), this.writeByte(255 & e2), this.writeByte(r2 >> 24 & 255), this.writeByte(r2 >> 16 & 255), this.writeByte(r2 >> 8 & 255), this.writeByte(255 & r2);
  }, t3.prototype.readInt = function() {
    return this.readInt32();
  }, t3.prototype.writeInt = function(t4) {
    return this.writeInt32(t4);
  }, t3.prototype.read = function(t4) {
    var e2, r2;
    for (e2 = [], r2 = 0; 0 <= t4 ? r2 < t4 : r2 > t4; r2 = 0 <= t4 ? ++r2 : --r2)
      e2.push(this.readByte());
    return e2;
  }, t3.prototype.write = function(t4) {
    var e2, r2, n2, i2;
    for (i2 = [], r2 = 0, n2 = t4.length; r2 < n2; r2++)
      e2 = t4[r2], i2.push(this.writeByte(e2));
    return i2;
  }, t3;
}();
var ie = function() {
  var t3;
  function e2(t4) {
    var e3, r2, n2;
    for (this.scalarType = t4.readInt(), this.tableCount = t4.readShort(), this.searchRange = t4.readShort(), this.entrySelector = t4.readShort(), this.rangeShift = t4.readShort(), this.tables = {}, r2 = 0, n2 = this.tableCount; 0 <= n2 ? r2 < n2 : r2 > n2; r2 = 0 <= n2 ? ++r2 : --r2)
      e3 = { tag: t4.readString(4), checksum: t4.readInt(), offset: t4.readInt(), length: t4.readInt() }, this.tables[e3.tag] = e3;
  }
  return e2.prototype.encode = function(e3) {
    var r2, n2, i2, a2, o2, s2, c2, u2, h2, l2, f2, d2, p5;
    for (p5 in f2 = Object.keys(e3).length, s2 = Math.log(2), h2 = 16 * Math.floor(Math.log(f2) / s2), a2 = Math.floor(h2 / s2), u2 = 16 * f2 - h2, (n2 = new ne()).writeInt(this.scalarType), n2.writeShort(f2), n2.writeShort(h2), n2.writeShort(a2), n2.writeShort(u2), i2 = 16 * f2, c2 = n2.pos + i2, o2 = null, d2 = [], e3)
      for (l2 = e3[p5], n2.writeString(p5), n2.writeInt(t3(l2)), n2.writeInt(c2), n2.writeInt(l2.length), d2 = d2.concat(l2), p5 === "head" && (o2 = c2), c2 += l2.length; c2 % 4; )
        d2.push(0), c2++;
    return n2.write(d2), r2 = 2981146554 - t3(n2.data), n2.pos = o2 + 8, n2.writeUInt32(r2), n2.data;
  }, t3 = function(t4) {
    var e3, r2, n2, i2;
    for (t4 = ve.call(t4); t4.length % 4; )
      t4.push(0);
    for (n2 = new ne(t4), r2 = 0, e3 = 0, i2 = t4.length; e3 < i2; e3 = e3 += 4)
      r2 += n2.readUInt32();
    return 4294967295 & r2;
  }, e2;
}();
var ae = {}.hasOwnProperty;
var oe = function(t3, e2) {
  for (var r2 in e2)
    ae.call(e2, r2) && (t3[r2] = e2[r2]);
  function n2() {
    this.constructor = t3;
  }
  return n2.prototype = e2.prototype, t3.prototype = new n2(), t3.__super__ = e2.prototype, t3;
};
re = function() {
  function t3(t4) {
    var e2;
    this.file = t4, e2 = this.file.directory.tables[this.tag], this.exists = !!e2, e2 && (this.offset = e2.offset, this.length = e2.length, this.parse(this.file.contents));
  }
  return t3.prototype.parse = function() {
  }, t3.prototype.encode = function() {
  }, t3.prototype.raw = function() {
    return this.exists ? (this.file.contents.pos = this.offset, this.file.contents.read(this.length)) : null;
  }, t3;
}();
var se = function(t3) {
  function e2() {
    return e2.__super__.constructor.apply(this, arguments);
  }
  return oe(e2, re), e2.prototype.tag = "head", e2.prototype.parse = function(t4) {
    return t4.pos = this.offset, this.version = t4.readInt(), this.revision = t4.readInt(), this.checkSumAdjustment = t4.readInt(), this.magicNumber = t4.readInt(), this.flags = t4.readShort(), this.unitsPerEm = t4.readShort(), this.created = t4.readLongLong(), this.modified = t4.readLongLong(), this.xMin = t4.readShort(), this.yMin = t4.readShort(), this.xMax = t4.readShort(), this.yMax = t4.readShort(), this.macStyle = t4.readShort(), this.lowestRecPPEM = t4.readShort(), this.fontDirectionHint = t4.readShort(), this.indexToLocFormat = t4.readShort(), this.glyphDataFormat = t4.readShort();
  }, e2.prototype.encode = function(t4) {
    var e3;
    return (e3 = new ne()).writeInt(this.version), e3.writeInt(this.revision), e3.writeInt(this.checkSumAdjustment), e3.writeInt(this.magicNumber), e3.writeShort(this.flags), e3.writeShort(this.unitsPerEm), e3.writeLongLong(this.created), e3.writeLongLong(this.modified), e3.writeShort(this.xMin), e3.writeShort(this.yMin), e3.writeShort(this.xMax), e3.writeShort(this.yMax), e3.writeShort(this.macStyle), e3.writeShort(this.lowestRecPPEM), e3.writeShort(this.fontDirectionHint), e3.writeShort(t4), e3.writeShort(this.glyphDataFormat), e3.data;
  }, e2;
}();
var ce = function() {
  function t3(t4, e2) {
    var r2, n2, i2, a2, o2, s2, c2, u2, h2, l2, f2, d2, p5, g2, m2, v2, b2;
    switch (this.platformID = t4.readUInt16(), this.encodingID = t4.readShort(), this.offset = e2 + t4.readInt(), h2 = t4.pos, t4.pos = this.offset, this.format = t4.readUInt16(), this.length = t4.readUInt16(), this.language = t4.readUInt16(), this.isUnicode = this.platformID === 3 && this.encodingID === 1 && this.format === 4 || this.platformID === 0 && this.format === 4, this.codeMap = {}, this.format) {
      case 0:
        for (s2 = 0; s2 < 256; ++s2)
          this.codeMap[s2] = t4.readByte();
        break;
      case 4:
        for (f2 = t4.readUInt16(), l2 = f2 / 2, t4.pos += 6, i2 = function() {
          var e3, r3;
          for (r3 = [], s2 = e3 = 0; 0 <= l2 ? e3 < l2 : e3 > l2; s2 = 0 <= l2 ? ++e3 : --e3)
            r3.push(t4.readUInt16());
          return r3;
        }(), t4.pos += 2, p5 = function() {
          var e3, r3;
          for (r3 = [], s2 = e3 = 0; 0 <= l2 ? e3 < l2 : e3 > l2; s2 = 0 <= l2 ? ++e3 : --e3)
            r3.push(t4.readUInt16());
          return r3;
        }(), c2 = function() {
          var e3, r3;
          for (r3 = [], s2 = e3 = 0; 0 <= l2 ? e3 < l2 : e3 > l2; s2 = 0 <= l2 ? ++e3 : --e3)
            r3.push(t4.readUInt16());
          return r3;
        }(), u2 = function() {
          var e3, r3;
          for (r3 = [], s2 = e3 = 0; 0 <= l2 ? e3 < l2 : e3 > l2; s2 = 0 <= l2 ? ++e3 : --e3)
            r3.push(t4.readUInt16());
          return r3;
        }(), n2 = (this.length - t4.pos + this.offset) / 2, o2 = function() {
          var e3, r3;
          for (r3 = [], s2 = e3 = 0; 0 <= n2 ? e3 < n2 : e3 > n2; s2 = 0 <= n2 ? ++e3 : --e3)
            r3.push(t4.readUInt16());
          return r3;
        }(), s2 = m2 = 0, b2 = i2.length; m2 < b2; s2 = ++m2)
          for (g2 = i2[s2], r2 = v2 = d2 = p5[s2]; d2 <= g2 ? v2 <= g2 : v2 >= g2; r2 = d2 <= g2 ? ++v2 : --v2)
            u2[s2] === 0 ? a2 = r2 + c2[s2] : (a2 = o2[u2[s2] / 2 + (r2 - d2) - (l2 - s2)] || 0) !== 0 && (a2 += c2[s2]), this.codeMap[r2] = 65535 & a2;
    }
    t4.pos = h2;
  }
  return t3.encode = function(t4, e2) {
    var r2, n2, i2, a2, o2, s2, c2, u2, h2, l2, f2, d2, p5, g2, m2, v2, b2, y2, w2, N2, L2, A2, x2, S2, _2, P2, k2, I2, F2, C2, j2, O2, B3, M2, E2, q2, D2, R2, T2, z2, U2, H4, W2, V2, G2, Y2;
    switch (I2 = new ne(), a2 = Object.keys(t4).sort(function(t5, e3) {
      return t5 - e3;
    }), e2) {
      case "macroman":
        for (p5 = 0, g2 = function() {
          var t5 = [];
          for (d2 = 0; d2 < 256; ++d2)
            t5.push(0);
          return t5;
        }(), v2 = { 0: 0 }, i2 = {}, F2 = 0, B3 = a2.length; F2 < B3; F2++)
          v2[W2 = t4[n2 = a2[F2]]] == null && (v2[W2] = ++p5), i2[n2] = { old: t4[n2], new: v2[t4[n2]] }, g2[n2] = v2[t4[n2]];
        return I2.writeUInt16(1), I2.writeUInt16(0), I2.writeUInt32(12), I2.writeUInt16(0), I2.writeUInt16(262), I2.writeUInt16(0), I2.write(g2), { charMap: i2, subtable: I2.data, maxGlyphID: p5 + 1 };
      case "unicode":
        for (P2 = [], h2 = [], b2 = 0, v2 = {}, r2 = {}, m2 = c2 = null, C2 = 0, M2 = a2.length; C2 < M2; C2++)
          v2[w2 = t4[n2 = a2[C2]]] == null && (v2[w2] = ++b2), r2[n2] = { old: w2, new: v2[w2] }, o2 = v2[w2] - n2, m2 != null && o2 === c2 || (m2 && h2.push(m2), P2.push(n2), c2 = o2), m2 = n2;
        for (m2 && h2.push(m2), h2.push(65535), P2.push(65535), S2 = 2 * (x2 = P2.length), A2 = 2 * Math.pow(Math.log(x2) / Math.LN2, 2), l2 = Math.log(A2 / 2) / Math.LN2, L2 = 2 * x2 - A2, s2 = [], N2 = [], f2 = [], d2 = j2 = 0, E2 = P2.length; j2 < E2; d2 = ++j2) {
          if (_2 = P2[d2], u2 = h2[d2], _2 === 65535) {
            s2.push(0), N2.push(0);
            break;
          }
          if (_2 - (k2 = r2[_2].new) >= 32768)
            for (s2.push(0), N2.push(2 * (f2.length + x2 - d2)), n2 = O2 = _2; _2 <= u2 ? O2 <= u2 : O2 >= u2; n2 = _2 <= u2 ? ++O2 : --O2)
              f2.push(r2[n2].new);
          else
            s2.push(k2 - _2), N2.push(0);
        }
        for (I2.writeUInt16(3), I2.writeUInt16(1), I2.writeUInt32(12), I2.writeUInt16(4), I2.writeUInt16(16 + 8 * x2 + 2 * f2.length), I2.writeUInt16(0), I2.writeUInt16(S2), I2.writeUInt16(A2), I2.writeUInt16(l2), I2.writeUInt16(L2), U2 = 0, q2 = h2.length; U2 < q2; U2++)
          n2 = h2[U2], I2.writeUInt16(n2);
        for (I2.writeUInt16(0), H4 = 0, D2 = P2.length; H4 < D2; H4++)
          n2 = P2[H4], I2.writeUInt16(n2);
        for (V2 = 0, R2 = s2.length; V2 < R2; V2++)
          o2 = s2[V2], I2.writeUInt16(o2);
        for (G2 = 0, T2 = N2.length; G2 < T2; G2++)
          y2 = N2[G2], I2.writeUInt16(y2);
        for (Y2 = 0, z2 = f2.length; Y2 < z2; Y2++)
          p5 = f2[Y2], I2.writeUInt16(p5);
        return { charMap: r2, subtable: I2.data, maxGlyphID: b2 + 1 };
    }
  }, t3;
}();
var ue = function(t3) {
  function e2() {
    return e2.__super__.constructor.apply(this, arguments);
  }
  return oe(e2, re), e2.prototype.tag = "cmap", e2.prototype.parse = function(t4) {
    var e3, r2, n2;
    for (t4.pos = this.offset, this.version = t4.readUInt16(), n2 = t4.readUInt16(), this.tables = [], this.unicode = null, r2 = 0; 0 <= n2 ? r2 < n2 : r2 > n2; r2 = 0 <= n2 ? ++r2 : --r2)
      e3 = new ce(t4, this.offset), this.tables.push(e3), e3.isUnicode && this.unicode == null && (this.unicode = e3);
    return true;
  }, e2.encode = function(t4, e3) {
    var r2, n2;
    return e3 == null && (e3 = "macroman"), r2 = ce.encode(t4, e3), (n2 = new ne()).writeUInt16(0), n2.writeUInt16(1), r2.table = n2.data.concat(r2.subtable), r2;
  }, e2;
}();
var he = function(t3) {
  function e2() {
    return e2.__super__.constructor.apply(this, arguments);
  }
  return oe(e2, re), e2.prototype.tag = "hhea", e2.prototype.parse = function(t4) {
    return t4.pos = this.offset, this.version = t4.readInt(), this.ascender = t4.readShort(), this.decender = t4.readShort(), this.lineGap = t4.readShort(), this.advanceWidthMax = t4.readShort(), this.minLeftSideBearing = t4.readShort(), this.minRightSideBearing = t4.readShort(), this.xMaxExtent = t4.readShort(), this.caretSlopeRise = t4.readShort(), this.caretSlopeRun = t4.readShort(), this.caretOffset = t4.readShort(), t4.pos += 8, this.metricDataFormat = t4.readShort(), this.numberOfMetrics = t4.readUInt16();
  }, e2;
}();
var le = function(t3) {
  function e2() {
    return e2.__super__.constructor.apply(this, arguments);
  }
  return oe(e2, re), e2.prototype.tag = "OS/2", e2.prototype.parse = function(t4) {
    if (t4.pos = this.offset, this.version = t4.readUInt16(), this.averageCharWidth = t4.readShort(), this.weightClass = t4.readUInt16(), this.widthClass = t4.readUInt16(), this.type = t4.readShort(), this.ySubscriptXSize = t4.readShort(), this.ySubscriptYSize = t4.readShort(), this.ySubscriptXOffset = t4.readShort(), this.ySubscriptYOffset = t4.readShort(), this.ySuperscriptXSize = t4.readShort(), this.ySuperscriptYSize = t4.readShort(), this.ySuperscriptXOffset = t4.readShort(), this.ySuperscriptYOffset = t4.readShort(), this.yStrikeoutSize = t4.readShort(), this.yStrikeoutPosition = t4.readShort(), this.familyClass = t4.readShort(), this.panose = function() {
      var e3, r2;
      for (r2 = [], e3 = 0; e3 < 10; ++e3)
        r2.push(t4.readByte());
      return r2;
    }(), this.charRange = function() {
      var e3, r2;
      for (r2 = [], e3 = 0; e3 < 4; ++e3)
        r2.push(t4.readInt());
      return r2;
    }(), this.vendorID = t4.readString(4), this.selection = t4.readShort(), this.firstCharIndex = t4.readShort(), this.lastCharIndex = t4.readShort(), this.version > 0 && (this.ascent = t4.readShort(), this.descent = t4.readShort(), this.lineGap = t4.readShort(), this.winAscent = t4.readShort(), this.winDescent = t4.readShort(), this.codePageRange = function() {
      var e3, r2;
      for (r2 = [], e3 = 0; e3 < 2; e3 = ++e3)
        r2.push(t4.readInt());
      return r2;
    }(), this.version > 1))
      return this.xHeight = t4.readShort(), this.capHeight = t4.readShort(), this.defaultChar = t4.readShort(), this.breakChar = t4.readShort(), this.maxContext = t4.readShort();
  }, e2;
}();
var fe = function(t3) {
  function e2() {
    return e2.__super__.constructor.apply(this, arguments);
  }
  return oe(e2, re), e2.prototype.tag = "post", e2.prototype.parse = function(t4) {
    var e3, r2, n2;
    switch (t4.pos = this.offset, this.format = t4.readInt(), this.italicAngle = t4.readInt(), this.underlinePosition = t4.readShort(), this.underlineThickness = t4.readShort(), this.isFixedPitch = t4.readInt(), this.minMemType42 = t4.readInt(), this.maxMemType42 = t4.readInt(), this.minMemType1 = t4.readInt(), this.maxMemType1 = t4.readInt(), this.format) {
      case 65536:
        break;
      case 131072:
        var i2;
        for (r2 = t4.readUInt16(), this.glyphNameIndex = [], i2 = 0; 0 <= r2 ? i2 < r2 : i2 > r2; i2 = 0 <= r2 ? ++i2 : --i2)
          this.glyphNameIndex.push(t4.readUInt16());
        for (this.names = [], n2 = []; t4.pos < this.offset + this.length; )
          e3 = t4.readByte(), n2.push(this.names.push(t4.readString(e3)));
        return n2;
      case 151552:
        return r2 = t4.readUInt16(), this.offsets = t4.read(r2);
      case 196608:
        break;
      case 262144:
        return this.map = function() {
          var e4, r3, n3;
          for (n3 = [], i2 = e4 = 0, r3 = this.file.maxp.numGlyphs; 0 <= r3 ? e4 < r3 : e4 > r3; i2 = 0 <= r3 ? ++e4 : --e4)
            n3.push(t4.readUInt32());
          return n3;
        }.call(this);
    }
  }, e2;
}();
var de = function(t3, e2) {
  this.raw = t3, this.length = t3.length, this.platformID = e2.platformID, this.encodingID = e2.encodingID, this.languageID = e2.languageID;
};
var pe = function(t3) {
  function e2() {
    return e2.__super__.constructor.apply(this, arguments);
  }
  return oe(e2, re), e2.prototype.tag = "name", e2.prototype.parse = function(t4) {
    var e3, r2, n2, i2, a2, o2, s2, c2, u2, h2, l2;
    for (t4.pos = this.offset, t4.readShort(), e3 = t4.readShort(), o2 = t4.readShort(), r2 = [], i2 = 0; 0 <= e3 ? i2 < e3 : i2 > e3; i2 = 0 <= e3 ? ++i2 : --i2)
      r2.push({ platformID: t4.readShort(), encodingID: t4.readShort(), languageID: t4.readShort(), nameID: t4.readShort(), length: t4.readShort(), offset: this.offset + o2 + t4.readShort() });
    for (s2 = {}, i2 = u2 = 0, h2 = r2.length; u2 < h2; i2 = ++u2)
      n2 = r2[i2], t4.pos = n2.offset, c2 = t4.readString(n2.length), a2 = new de(c2, n2), s2[l2 = n2.nameID] == null && (s2[l2] = []), s2[n2.nameID].push(a2);
    this.strings = s2, this.copyright = s2[0], this.fontFamily = s2[1], this.fontSubfamily = s2[2], this.uniqueSubfamily = s2[3], this.fontName = s2[4], this.version = s2[5];
    try {
      this.postscriptName = s2[6][0].raw.replace(/[\x00-\x19\x80-\xff]/g, "");
    } catch (t5) {
      this.postscriptName = s2[4][0].raw.replace(/[\x00-\x19\x80-\xff]/g, "");
    }
    return this.trademark = s2[7], this.manufacturer = s2[8], this.designer = s2[9], this.description = s2[10], this.vendorUrl = s2[11], this.designerUrl = s2[12], this.license = s2[13], this.licenseUrl = s2[14], this.preferredFamily = s2[15], this.preferredSubfamily = s2[17], this.compatibleFull = s2[18], this.sampleText = s2[19];
  }, e2;
}();
var ge = function(t3) {
  function e2() {
    return e2.__super__.constructor.apply(this, arguments);
  }
  return oe(e2, re), e2.prototype.tag = "maxp", e2.prototype.parse = function(t4) {
    return t4.pos = this.offset, this.version = t4.readInt(), this.numGlyphs = t4.readUInt16(), this.maxPoints = t4.readUInt16(), this.maxContours = t4.readUInt16(), this.maxCompositePoints = t4.readUInt16(), this.maxComponentContours = t4.readUInt16(), this.maxZones = t4.readUInt16(), this.maxTwilightPoints = t4.readUInt16(), this.maxStorage = t4.readUInt16(), this.maxFunctionDefs = t4.readUInt16(), this.maxInstructionDefs = t4.readUInt16(), this.maxStackElements = t4.readUInt16(), this.maxSizeOfInstructions = t4.readUInt16(), this.maxComponentElements = t4.readUInt16(), this.maxComponentDepth = t4.readUInt16();
  }, e2;
}();
var me = function(t3) {
  function e2() {
    return e2.__super__.constructor.apply(this, arguments);
  }
  return oe(e2, re), e2.prototype.tag = "hmtx", e2.prototype.parse = function(t4) {
    var e3, r2, n2, i2, a2, o2, s2;
    for (t4.pos = this.offset, this.metrics = [], e3 = 0, o2 = this.file.hhea.numberOfMetrics; 0 <= o2 ? e3 < o2 : e3 > o2; e3 = 0 <= o2 ? ++e3 : --e3)
      this.metrics.push({ advance: t4.readUInt16(), lsb: t4.readInt16() });
    for (n2 = this.file.maxp.numGlyphs - this.file.hhea.numberOfMetrics, this.leftSideBearings = function() {
      var r3, i3;
      for (i3 = [], e3 = r3 = 0; 0 <= n2 ? r3 < n2 : r3 > n2; e3 = 0 <= n2 ? ++r3 : --r3)
        i3.push(t4.readInt16());
      return i3;
    }(), this.widths = function() {
      var t5, e4, r3, n3;
      for (n3 = [], t5 = 0, e4 = (r3 = this.metrics).length; t5 < e4; t5++)
        i2 = r3[t5], n3.push(i2.advance);
      return n3;
    }.call(this), r2 = this.widths[this.widths.length - 1], s2 = [], e3 = a2 = 0; 0 <= n2 ? a2 < n2 : a2 > n2; e3 = 0 <= n2 ? ++a2 : --a2)
      s2.push(this.widths.push(r2));
    return s2;
  }, e2.prototype.forGlyph = function(t4) {
    return t4 in this.metrics ? this.metrics[t4] : { advance: this.metrics[this.metrics.length - 1].advance, lsb: this.leftSideBearings[t4 - this.metrics.length] };
  }, e2;
}();
var ve = [].slice;
var be = function(t3) {
  function e2() {
    return e2.__super__.constructor.apply(this, arguments);
  }
  return oe(e2, re), e2.prototype.tag = "glyf", e2.prototype.parse = function() {
    return this.cache = {};
  }, e2.prototype.glyphFor = function(t4) {
    var e3, r2, n2, i2, a2, o2, s2, c2, u2, h2;
    return t4 in this.cache ? this.cache[t4] : (i2 = this.file.loca, e3 = this.file.contents, r2 = i2.indexOf(t4), (n2 = i2.lengthOf(t4)) === 0 ? this.cache[t4] = null : (e3.pos = this.offset + r2, a2 = (o2 = new ne(e3.read(n2))).readShort(), c2 = o2.readShort(), h2 = o2.readShort(), s2 = o2.readShort(), u2 = o2.readShort(), this.cache[t4] = a2 === -1 ? new we(o2, c2, h2, s2, u2) : new ye(o2, a2, c2, h2, s2, u2), this.cache[t4]));
  }, e2.prototype.encode = function(t4, e3, r2) {
    var n2, i2, a2, o2, s2;
    for (a2 = [], i2 = [], o2 = 0, s2 = e3.length; o2 < s2; o2++)
      n2 = t4[e3[o2]], i2.push(a2.length), n2 && (a2 = a2.concat(n2.encode(r2)));
    return i2.push(a2.length), { table: a2, offsets: i2 };
  }, e2;
}();
var ye = function() {
  function t3(t4, e2, r2, n2, i2, a2) {
    this.raw = t4, this.numberOfContours = e2, this.xMin = r2, this.yMin = n2, this.xMax = i2, this.yMax = a2, this.compound = false;
  }
  return t3.prototype.encode = function() {
    return this.raw.data;
  }, t3;
}();
var we = function() {
  function t3(t4, e2, r2, n2, i2) {
    var a2, o2;
    for (this.raw = t4, this.xMin = e2, this.yMin = r2, this.xMax = n2, this.yMax = i2, this.compound = true, this.glyphIDs = [], this.glyphOffsets = [], a2 = this.raw; o2 = a2.readShort(), this.glyphOffsets.push(a2.pos), this.glyphIDs.push(a2.readUInt16()), 32 & o2; )
      a2.pos += 1 & o2 ? 4 : 2, 128 & o2 ? a2.pos += 8 : 64 & o2 ? a2.pos += 4 : 8 & o2 && (a2.pos += 2);
  }
  return t3.prototype.encode = function() {
    var t4, e2, r2;
    for (e2 = new ne(ve.call(this.raw.data)), t4 = 0, r2 = this.glyphIDs.length; t4 < r2; ++t4)
      e2.pos = this.glyphOffsets[t4];
    return e2.data;
  }, t3;
}();
var Ne = function(t3) {
  function e2() {
    return e2.__super__.constructor.apply(this, arguments);
  }
  return oe(e2, re), e2.prototype.tag = "loca", e2.prototype.parse = function(t4) {
    var e3, r2;
    return t4.pos = this.offset, e3 = this.file.head.indexToLocFormat, this.offsets = e3 === 0 ? function() {
      var e4, n2;
      for (n2 = [], r2 = 0, e4 = this.length; r2 < e4; r2 += 2)
        n2.push(2 * t4.readUInt16());
      return n2;
    }.call(this) : function() {
      var e4, n2;
      for (n2 = [], r2 = 0, e4 = this.length; r2 < e4; r2 += 4)
        n2.push(t4.readUInt32());
      return n2;
    }.call(this);
  }, e2.prototype.indexOf = function(t4) {
    return this.offsets[t4];
  }, e2.prototype.lengthOf = function(t4) {
    return this.offsets[t4 + 1] - this.offsets[t4];
  }, e2.prototype.encode = function(t4, e3) {
    for (var r2 = new Uint32Array(this.offsets.length), n2 = 0, i2 = 0, a2 = 0; a2 < r2.length; ++a2)
      if (r2[a2] = n2, i2 < e3.length && e3[i2] == a2) {
        ++i2, r2[a2] = n2;
        var o2 = this.offsets[a2], s2 = this.offsets[a2 + 1] - o2;
        s2 > 0 && (n2 += s2);
      }
    for (var c2 = new Array(4 * r2.length), u2 = 0; u2 < r2.length; ++u2)
      c2[4 * u2 + 3] = 255 & r2[u2], c2[4 * u2 + 2] = (65280 & r2[u2]) >> 8, c2[4 * u2 + 1] = (16711680 & r2[u2]) >> 16, c2[4 * u2] = (4278190080 & r2[u2]) >> 24;
    return c2;
  }, e2;
}();
var Le = function() {
  function t3(t4) {
    this.font = t4, this.subset = {}, this.unicodes = {}, this.next = 33;
  }
  return t3.prototype.generateCmap = function() {
    var t4, e2, r2, n2, i2;
    for (e2 in n2 = this.font.cmap.tables[0].codeMap, t4 = {}, i2 = this.subset)
      r2 = i2[e2], t4[e2] = n2[r2];
    return t4;
  }, t3.prototype.glyphsFor = function(t4) {
    var e2, r2, n2, i2, a2, o2, s2;
    for (n2 = {}, a2 = 0, o2 = t4.length; a2 < o2; a2++)
      n2[i2 = t4[a2]] = this.font.glyf.glyphFor(i2);
    for (i2 in e2 = [], n2)
      ((r2 = n2[i2]) != null ? r2.compound : void 0) && e2.push.apply(e2, r2.glyphIDs);
    if (e2.length > 0)
      for (i2 in s2 = this.glyphsFor(e2))
        r2 = s2[i2], n2[i2] = r2;
    return n2;
  }, t3.prototype.encode = function(t4, e2) {
    var r2, n2, i2, a2, o2, s2, c2, u2, h2, l2, f2, d2, p5, g2, m2;
    for (n2 in r2 = ue.encode(this.generateCmap(), "unicode"), a2 = this.glyphsFor(t4), f2 = { 0: 0 }, m2 = r2.charMap)
      f2[(s2 = m2[n2]).old] = s2.new;
    for (d2 in l2 = r2.maxGlyphID, a2)
      d2 in f2 || (f2[d2] = l2++);
    return u2 = function(t5) {
      var e3, r3;
      for (e3 in r3 = {}, t5)
        r3[t5[e3]] = e3;
      return r3;
    }(f2), h2 = Object.keys(u2).sort(function(t5, e3) {
      return t5 - e3;
    }), p5 = function() {
      var t5, e3, r3;
      for (r3 = [], t5 = 0, e3 = h2.length; t5 < e3; t5++)
        o2 = h2[t5], r3.push(u2[o2]);
      return r3;
    }(), i2 = this.font.glyf.encode(a2, p5, f2), c2 = this.font.loca.encode(i2.offsets, p5), g2 = { cmap: this.font.cmap.raw(), glyf: i2.table, loca: c2, hmtx: this.font.hmtx.raw(), hhea: this.font.hhea.raw(), maxp: this.font.maxp.raw(), post: this.font.post.raw(), name: this.font.name.raw(), head: this.font.head.encode(e2) }, this.font.os2.exists && (g2["OS/2"] = this.font.os2.raw()), this.font.directory.encode(g2);
  }, t3;
}();
E$1.API.PDFObject = function() {
  var t3;
  function e2() {
  }
  return t3 = function(t4, e3) {
    return (Array(e3 + 1).join("0") + t4).slice(-e3);
  }, e2.convert = function(r2) {
    var n2, i2, a2, o2;
    if (Array.isArray(r2))
      return "[" + function() {
        var t4, i3, a3;
        for (a3 = [], t4 = 0, i3 = r2.length; t4 < i3; t4++)
          n2 = r2[t4], a3.push(e2.convert(n2));
        return a3;
      }().join(" ") + "]";
    if (typeof r2 == "string")
      return "/" + r2;
    if (r2 != null ? r2.isString : void 0)
      return "(" + r2 + ")";
    if (r2 instanceof Date)
      return "(D:" + t3(r2.getUTCFullYear(), 4) + t3(r2.getUTCMonth(), 2) + t3(r2.getUTCDate(), 2) + t3(r2.getUTCHours(), 2) + t3(r2.getUTCMinutes(), 2) + t3(r2.getUTCSeconds(), 2) + "Z)";
    if ({}.toString.call(r2) === "[object Object]") {
      for (i2 in a2 = ["<<"], r2)
        o2 = r2[i2], a2.push("/" + i2 + " " + e2.convert(o2));
      return a2.push(">>"), a2.join("\n");
    }
    return "" + r2;
  }, e2;
}();
var _sfc_main$w = {
  name: "ol-control-printdialog",
  setup(props, context) {
    const {
      control
    } = useControl(ol_control_PrintDialog, props, context);
    control.value.on(["print", "error"], function(e2) {
      if (e2.image) {
        if (e2.pdf) {
          var pdf = new E$1({
            orientation: e2.print.orientation,
            unit: e2.print.unit,
            format: e2.print.size
          });
          pdf.addImage(e2.image, "JPEG", e2.print.position[0], e2.print.position[0], e2.print.imageWidth, e2.print.imageHeight);
          pdf.save(e2.print.legend ? "legend.pdf" : "map.pdf");
        } else {
          e2.canvas.toBlob(function(blob) {
            var name = (e2.print.legend ? "legend." : "map.") + e2.imageType.replace("image/", "");
            FileSaver_min.exports.saveAs(blob, name);
          }, e2.imageType, e2.quality);
        }
      } else {
        console.warn("No canvas to export");
      }
    });
    return {
      control
    };
  },
  props: {
    lang: {
      type: String
    }
  }
};
function _sfc_render$w(_ctx, _cache, $props, $setup, $data, $options) {
  return createCommentVNode("", true);
}
var PrintDialog = _export_sfc(_sfc_main$w, [["render", _sfc_render$w]]);
var ol_control_VideoRecorder = function(options) {
  if (!options)
    options = {};
  var element = ol_ext_element.create("DIV", {
    className: (options.className || "ol-videorec") + " ol-unselectable ol-control"
  });
  ol_ext_element.create("BUTTON", {
    type: "button",
    className: "ol-start",
    title: "start",
    click: function() {
      this.start();
    }.bind(this),
    parent: element
  });
  ol_ext_element.create("BUTTON", {
    type: "button",
    className: "ol-stop",
    title: "stop",
    click: function() {
      this.stop();
    }.bind(this),
    parent: element
  });
  ol_ext_element.create("BUTTON", {
    type: "button",
    className: "ol-pause",
    title: "pause",
    click: function() {
      this.pause();
    }.bind(this),
    parent: element
  });
  ol_ext_element.create("BUTTON", {
    type: "button",
    className: "ol-resume",
    title: "resume",
    click: function() {
      this.resume();
    }.bind(this),
    parent: element
  });
  ol_control_Control.call(this, {
    element,
    target: options.target
  });
  this.set("framerate", 30);
  this.set("videoBitsPerSecond", 5e6);
  if (options.videoTarget === "DIALOG") {
    this._dialog = new ol_control_Dialog({
      className: "ol-fullscreen-dialog",
      target: document.body,
      closeBox: true
    });
    this._videoTarget = this._dialog.getContentElement();
  } else {
    this._videoTarget = options.videoTarget;
  }
  this._printCtrl = new ol_control_Print({
    target: ol_ext_element.create("DIV")
  });
};
ol_ext_inherits(ol_control_VideoRecorder, ol_control_Control);
ol_control_VideoRecorder.prototype.setMap = function(map) {
  if (this.getMap()) {
    this.getMap().removeControl(this._printCtrl);
    if (this._dialog)
      this.getMap().removeControl(this._dialog);
  }
  ol_control_Control.prototype.setMap.call(this, map);
  if (this.getMap()) {
    this.getMap().addControl(this._printCtrl);
    if (this._dialog)
      this.getMap().addControl(this._dialog);
  }
};
ol_control_VideoRecorder.prototype.start = function() {
  var print = this._printCtrl;
  var stop = false;
  function capture(canvas) {
    if (stop)
      return;
    print.fastPrint({
      canvas
    }, capture);
  }
  print.fastPrint({}, function(canvas) {
    var videoStream;
    try {
      videoStream = canvas.captureStream(this.get("framerate") || 30);
    } catch (e2) {
      this.dispatchEvent({
        type: "error",
        error: e2
      });
      return;
    }
    this._mediaRecorder = new MediaRecorder(videoStream, {
      videoBitsPerSecond: this.get("videoBitsPerSecond") || 5e6
    });
    var chunks = [];
    this._mediaRecorder.ondataavailable = function(e2) {
      chunks.push(e2.data);
    };
    this._mediaRecorder.onstop = function() {
      stop = true;
      var blob = new Blob(chunks, { "type": "video/mp4" });
      chunks = [];
      if (this._videoTarget instanceof Element) {
        var video;
        if (this._videoTarget.tagName === "VIDEO") {
          video = this._videoTarget;
        } else {
          video = this._videoTarget.querySelector("video");
          if (!video) {
            video = ol_ext_element.create("VIDEO", {
              controls: "",
              parent: this._videoTarget
            });
          }
        }
        if (this._dialog)
          this._dialog.show();
        video.src = URL.createObjectURL(blob);
        this.dispatchEvent({ type: "stop", videoURL: video.src });
      } else {
        this.dispatchEvent({ type: "stop", videoURL: URL.createObjectURL(blob) });
      }
    }.bind(this);
    this._mediaRecorder.onpause = function() {
      stop = true;
      this.dispatchEvent({ type: "pause" });
    }.bind(this);
    this._mediaRecorder.onresume = function() {
      stop = false;
      capture(canvas);
      this.dispatchEvent({ type: "resume" });
    }.bind(this);
    this._mediaRecorder.onerror = function(e2) {
      this.dispatchEvent({ type: "error", error: e2 });
    }.bind(this);
    stop = false;
    capture(canvas);
    this._mediaRecorder.start();
    this.dispatchEvent({ type: "start", canvas });
    this.element.setAttribute("data-state", "rec");
  }.bind(this));
};
ol_control_VideoRecorder.prototype.stop = function() {
  if (this._mediaRecorder) {
    this._mediaRecorder.stop();
    this._mediaRecorder = null;
    this.element.setAttribute("data-state", "inactive");
  }
};
ol_control_VideoRecorder.prototype.pause = function() {
  if (this._mediaRecorder) {
    this._mediaRecorder.pause();
    this.element.setAttribute("data-state", "pause");
  }
};
ol_control_VideoRecorder.prototype.resume = function() {
  if (this._mediaRecorder) {
    this._mediaRecorder.resume();
    this.element.setAttribute("data-state", "rec");
  }
};
var _sfc_main$v = {
  name: "ol-control-videorecorder",
  emits: ["start", "stop"],
  setup(props, context) {
    const {
      control
    } = useControl(ol_control_VideoRecorder, props, context);
    const { downloadName } = toRefs(props);
    control.value.on("start", (event) => {
      context.emit("start", event);
    });
    control.value.on("stop", (event) => {
      context.emit("stop", event);
      FileSaver_min.exports.saveAs(event.videoURL, downloadName.value);
    });
    return {
      control
    };
  },
  props: {
    className: {
      type: String
    },
    framerate: {
      type: Number,
      default: 30
    },
    videoBitsPerSecond: {
      type: Number,
      default: 5e6
    },
    videoTarget: {
      type: String
    },
    downloadName: {
      type: String,
      default: "mapVideo.mp4"
    }
  }
};
function _sfc_render$v(_ctx, _cache, $props, $setup, $data, $options) {
  return createCommentVNode("", true);
}
var VideoRecorderControl = _export_sfc(_sfc_main$v, [["render", _sfc_render$v]]);
var VectorTileRenderType = {
  IMAGE: "image",
  HYBRID: "hybrid",
  VECTOR: "vector"
};
var __extends$s = globalThis && globalThis.__extends || function() {
  var extendStatics2 = function(d2, b2) {
    extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {
      d3.__proto__ = b3;
    } || function(d3, b3) {
      for (var p5 in b3)
        if (Object.prototype.hasOwnProperty.call(b3, p5))
          d3[p5] = b3[p5];
    };
    return extendStatics2(d2, b2);
  };
  return function(d2, b2) {
    if (typeof b2 !== "function" && b2 !== null)
      throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
    extendStatics2(d2, b2);
    function __() {
      this.constructor = d2;
    }
    d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
  };
}();
var IMAGE_REPLAYS = {
  "image": [
    ReplayType.POLYGON,
    ReplayType.CIRCLE,
    ReplayType.LINE_STRING,
    ReplayType.IMAGE,
    ReplayType.TEXT
  ],
  "hybrid": [ReplayType.POLYGON, ReplayType.LINE_STRING],
  "vector": []
};
var VECTOR_REPLAYS = {
  "hybrid": [ReplayType.IMAGE, ReplayType.TEXT, ReplayType.DEFAULT],
  "vector": [
    ReplayType.POLYGON,
    ReplayType.CIRCLE,
    ReplayType.LINE_STRING,
    ReplayType.IMAGE,
    ReplayType.TEXT,
    ReplayType.DEFAULT
  ]
};
var CanvasVectorTileLayerRenderer = function(_super) {
  __extends$s(CanvasVectorTileLayerRenderer2, _super);
  function CanvasVectorTileLayerRenderer2(layer) {
    var _this = _super.call(this, layer) || this;
    _this.boundHandleStyleImageChange_ = _this.handleStyleImageChange_.bind(_this);
    _this.dirty_ = false;
    _this.renderedLayerRevision_;
    _this.renderedPixelToCoordinateTransform_ = null;
    _this.renderedRotation_;
    _this.tmpTransform_ = create$6();
    return _this;
  }
  CanvasVectorTileLayerRenderer2.prototype.prepareTile = function(tile2, pixelRatio, projection) {
    var render2;
    var state = tile2.getState();
    if (state === TileState.LOADED || state === TileState.ERROR) {
      this.updateExecutorGroup_(tile2, pixelRatio, projection);
      if (this.tileImageNeedsRender_(tile2)) {
        render2 = true;
      }
    }
    return render2;
  };
  CanvasVectorTileLayerRenderer2.prototype.getTile = function(z2, x2, y2, frameState) {
    var pixelRatio = frameState.pixelRatio;
    var viewState = frameState.viewState;
    var resolution = viewState.resolution;
    var projection = viewState.projection;
    var layer = this.getLayer();
    var tile2 = layer.getSource().getTile(z2, x2, y2, pixelRatio, projection);
    var viewHints = frameState.viewHints;
    var hifi = !(viewHints[ViewHint.ANIMATING] || viewHints[ViewHint.INTERACTING]);
    if (hifi || !tile2.wantedResolution) {
      tile2.wantedResolution = resolution;
    }
    var render2 = this.prepareTile(tile2, pixelRatio, projection);
    if (render2 && (hifi || Date.now() - frameState.time < 8) && layer.getRenderMode() !== VectorTileRenderType.VECTOR) {
      this.renderTileImage_(tile2, frameState);
    }
    return _super.prototype.getTile.call(this, z2, x2, y2, frameState);
  };
  CanvasVectorTileLayerRenderer2.prototype.isDrawableTile = function(tile2) {
    var layer = this.getLayer();
    return _super.prototype.isDrawableTile.call(this, tile2) && (layer.getRenderMode() === VectorTileRenderType.VECTOR ? getUid(layer) in tile2.executorGroups : tile2.hasContext(layer));
  };
  CanvasVectorTileLayerRenderer2.prototype.getTileImage = function(tile2) {
    return tile2.getImage(this.getLayer());
  };
  CanvasVectorTileLayerRenderer2.prototype.prepareFrame = function(frameState) {
    var layerRevision = this.getLayer().getRevision();
    if (this.renderedLayerRevision_ != layerRevision) {
      this.renderedTiles.length = 0;
    }
    this.renderedLayerRevision_ = layerRevision;
    return _super.prototype.prepareFrame.call(this, frameState);
  };
  CanvasVectorTileLayerRenderer2.prototype.updateExecutorGroup_ = function(tile2, pixelRatio, projection) {
    var layer = this.getLayer();
    var revision = layer.getRevision();
    var renderOrder = layer.getRenderOrder() || null;
    var resolution = tile2.wantedResolution;
    var builderState = tile2.getReplayState(layer);
    if (!builderState.dirty && builderState.renderedResolution === resolution && builderState.renderedRevision == revision && builderState.renderedRenderOrder == renderOrder) {
      return;
    }
    var source = layer.getSource();
    var declutter = layer.getDeclutter();
    var sourceTileGrid = source.getTileGrid();
    var tileGrid = source.getTileGridForProjection(projection);
    var tileExtent = tileGrid.getTileCoordExtent(tile2.wrappedTileCoord);
    var sourceTiles = source.getSourceTiles(pixelRatio, projection, tile2);
    var layerUid = getUid(layer);
    delete tile2.hitDetectionImageData[layerUid];
    tile2.executorGroups[layerUid] = [];
    if (declutter) {
      tile2.declutterExecutorGroups[layerUid] = [];
    }
    var _loop_1 = function(t4, tt3) {
      var sourceTile = sourceTiles[t4];
      if (sourceTile.getState() != TileState.LOADED) {
        return "continue";
      }
      var sourceTileCoord = sourceTile.tileCoord;
      var sourceTileExtent = sourceTileGrid.getTileCoordExtent(sourceTileCoord);
      var sharedExtent = getIntersection(tileExtent, sourceTileExtent);
      var builderExtent = buffer$1(sharedExtent, layer.getRenderBuffer() * resolution, this_1.tmpExtent);
      var bufferedExtent = equals$1(sourceTileExtent, sharedExtent) ? null : builderExtent;
      builderState.dirty = false;
      var builderGroup = new CanvasBuilderGroup(0, builderExtent, resolution, pixelRatio);
      var declutterBuilderGroup = declutter ? new CanvasBuilderGroup(0, sharedExtent, resolution, pixelRatio) : void 0;
      var squaredTolerance = getSquaredTolerance(resolution, pixelRatio);
      var render2 = function(feature3) {
        var styles;
        var styleFunction = feature3.getStyleFunction() || layer.getStyleFunction();
        if (styleFunction) {
          styles = styleFunction(feature3, resolution);
        }
        if (styles) {
          var dirty = this.renderFeature(feature3, squaredTolerance, styles, builderGroup, declutterBuilderGroup);
          this.dirty_ = this.dirty_ || dirty;
          builderState.dirty = builderState.dirty || dirty;
        }
      };
      var features = sourceTile.getFeatures();
      if (renderOrder && renderOrder !== builderState.renderedRenderOrder) {
        features.sort(renderOrder);
      }
      for (var i2 = 0, ii = features.length; i2 < ii; ++i2) {
        var feature2 = features[i2];
        if (!bufferedExtent || intersects$1(bufferedExtent, feature2.getGeometry().getExtent())) {
          render2.call(this_1, feature2);
        }
      }
      var executorGroupInstructions = builderGroup.finish();
      var replayExtent = layer.getRenderMode() !== VectorTileRenderType.VECTOR && declutter && sourceTiles.length === 1 ? null : sharedExtent;
      var renderingReplayGroup = new CanvasExecutorGroup(replayExtent, resolution, pixelRatio, source.getOverlaps(), executorGroupInstructions, layer.getRenderBuffer());
      tile2.executorGroups[layerUid].push(renderingReplayGroup);
      if (declutterBuilderGroup) {
        var declutterExecutorGroup = new CanvasExecutorGroup(null, resolution, pixelRatio, source.getOverlaps(), declutterBuilderGroup.finish(), layer.getRenderBuffer());
        tile2.declutterExecutorGroups[layerUid].push(declutterExecutorGroup);
      }
    };
    var this_1 = this;
    for (var t3 = 0, tt2 = sourceTiles.length; t3 < tt2; ++t3) {
      _loop_1(t3);
    }
    builderState.renderedRevision = revision;
    builderState.renderedRenderOrder = renderOrder;
    builderState.renderedResolution = resolution;
  };
  CanvasVectorTileLayerRenderer2.prototype.forEachFeatureAtCoordinate = function(coordinate, frameState, hitTolerance, callback, matches) {
    var resolution = frameState.viewState.resolution;
    var rotation = frameState.viewState.rotation;
    hitTolerance = hitTolerance == void 0 ? 0 : hitTolerance;
    var layer = this.getLayer();
    var source = layer.getSource();
    var tileGrid = source.getTileGridForProjection(frameState.viewState.projection);
    var hitExtent = boundingExtent([coordinate]);
    buffer$1(hitExtent, resolution * hitTolerance, hitExtent);
    var features = {};
    var featureCallback = function(feature2, geometry, distanceSq) {
      var key = feature2.getId();
      if (key === void 0) {
        key = getUid(feature2);
      }
      var match2 = features[key];
      if (!match2) {
        if (distanceSq === 0) {
          features[key] = true;
          return callback(feature2, layer, geometry);
        }
        matches.push(features[key] = {
          feature: feature2,
          layer,
          geometry,
          distanceSq,
          callback
        });
      } else if (match2 !== true && distanceSq < match2.distanceSq) {
        if (distanceSq === 0) {
          features[key] = true;
          matches.splice(matches.lastIndexOf(match2), 1);
          return callback(feature2, layer, geometry);
        }
        match2.geometry = geometry;
        match2.distanceSq = distanceSq;
      }
      return void 0;
    };
    var renderedTiles = this.renderedTiles;
    var found;
    var _loop_2 = function(i3, ii2) {
      var tile2 = renderedTiles[i3];
      var tileExtent = tileGrid.getTileCoordExtent(tile2.wrappedTileCoord);
      if (!intersects$1(tileExtent, hitExtent)) {
        return "continue";
      }
      var layerUid = getUid(layer);
      var executorGroups = [tile2.executorGroups[layerUid]];
      var declutterExecutorGroups = tile2.declutterExecutorGroups[layerUid];
      if (declutterExecutorGroups) {
        executorGroups.push(declutterExecutorGroups);
      }
      executorGroups.some(function(executorGroups2) {
        var declutteredFeatures = executorGroups2 === declutterExecutorGroups ? frameState.declutterTree.all().map(function(item) {
          return item.value;
        }) : null;
        for (var t3 = 0, tt2 = executorGroups2.length; t3 < tt2; ++t3) {
          var executorGroup = executorGroups2[t3];
          found = executorGroup.forEachFeatureAtCoordinate(coordinate, resolution, rotation, hitTolerance, featureCallback, declutteredFeatures);
          if (found) {
            return true;
          }
        }
      });
    };
    for (var i2 = 0, ii = renderedTiles.length; !found && i2 < ii; ++i2) {
      _loop_2(i2);
    }
    return found;
  };
  CanvasVectorTileLayerRenderer2.prototype.getFeatures = function(pixel) {
    return new Promise(function(resolve2, reject2) {
      var layer = this.getLayer();
      var layerUid = getUid(layer);
      var source = layer.getSource();
      var projection = this.renderedProjection;
      var projectionExtent = projection.getExtent();
      var resolution = this.renderedResolution;
      var tileGrid = source.getTileGridForProjection(projection);
      var coordinate = apply$5(this.renderedPixelToCoordinateTransform_, pixel.slice());
      var tileCoord = tileGrid.getTileCoordForCoordAndResolution(coordinate, resolution);
      var tile2;
      for (var i2 = 0, ii = this.renderedTiles.length; i2 < ii; ++i2) {
        if (tileCoord.toString() === this.renderedTiles[i2].tileCoord.toString()) {
          tile2 = this.renderedTiles[i2];
          if (tile2.getState() === TileState.LOADED) {
            var extent_1 = tileGrid.getTileCoordExtent(tile2.tileCoord);
            if (source.getWrapX() && projection.canWrapX() && !containsExtent(projectionExtent, extent_1)) {
              wrapX$1(coordinate, projection);
            }
            break;
          }
          tile2 = void 0;
        }
      }
      if (!tile2 || tile2.loadingSourceTiles > 0) {
        resolve2([]);
        return;
      }
      var extent2 = tileGrid.getTileCoordExtent(tile2.wrappedTileCoord);
      var corner = getTopLeft(extent2);
      var tilePixel = [
        (coordinate[0] - corner[0]) / resolution,
        (corner[1] - coordinate[1]) / resolution
      ];
      var features = tile2.getSourceTiles().reduce(function(accumulator, sourceTile) {
        return accumulator.concat(sourceTile.getFeatures());
      }, []);
      var hitDetectionImageData = tile2.hitDetectionImageData[layerUid];
      if (!hitDetectionImageData && !this.animatingOrInteracting_) {
        var tileSize = toSize(tileGrid.getTileSize(tileGrid.getZForResolution(resolution)));
        var rotation = this.renderedRotation_;
        var transforms2 = [
          this.getRenderTransform(tileGrid.getTileCoordCenter(tile2.wrappedTileCoord), resolution, 0, HIT_DETECT_RESOLUTION, tileSize[0] * HIT_DETECT_RESOLUTION, tileSize[1] * HIT_DETECT_RESOLUTION, 0)
        ];
        hitDetectionImageData = createHitDetectionImageData(tileSize, transforms2, features, layer.getStyleFunction(), tileGrid.getTileCoordExtent(tile2.wrappedTileCoord), tile2.getReplayState(layer).renderedResolution, rotation);
        tile2.hitDetectionImageData[layerUid] = hitDetectionImageData;
      }
      resolve2(hitDetect(tilePixel, features, hitDetectionImageData));
    }.bind(this));
  };
  CanvasVectorTileLayerRenderer2.prototype.handleFontsChanged = function() {
    var layer = this.getLayer();
    if (layer.getVisible() && this.renderedLayerRevision_ !== void 0) {
      layer.changed();
    }
  };
  CanvasVectorTileLayerRenderer2.prototype.handleStyleImageChange_ = function(event) {
    this.renderIfReadyAndVisible();
  };
  CanvasVectorTileLayerRenderer2.prototype.renderDeclutter = function(frameState) {
    var context = this.context;
    var alpha = context.globalAlpha;
    context.globalAlpha = this.getLayer().getOpacity();
    var viewHints = frameState.viewHints;
    var hifi = !(viewHints[ViewHint.ANIMATING] || viewHints[ViewHint.INTERACTING]);
    var tiles = this.renderedTiles;
    for (var i2 = 0, ii = tiles.length; i2 < ii; ++i2) {
      var tile2 = tiles[i2];
      var declutterExecutorGroups = tile2.declutterExecutorGroups[getUid(this.getLayer())];
      if (declutterExecutorGroups) {
        for (var j2 = declutterExecutorGroups.length - 1; j2 >= 0; --j2) {
          declutterExecutorGroups[j2].execute(this.context, 1, this.getTileRenderTransform(tile2, frameState), frameState.viewState.rotation, hifi, void 0, frameState.declutterTree);
        }
      }
    }
    context.globalAlpha = alpha;
  };
  CanvasVectorTileLayerRenderer2.prototype.getTileRenderTransform = function(tile2, frameState) {
    var pixelRatio = frameState.pixelRatio;
    var viewState = frameState.viewState;
    var center = viewState.center;
    var resolution = viewState.resolution;
    var rotation = viewState.rotation;
    var size = frameState.size;
    var width = Math.round(size[0] * pixelRatio);
    var height = Math.round(size[1] * pixelRatio);
    var source = this.getLayer().getSource();
    var tileGrid = source.getTileGridForProjection(frameState.viewState.projection);
    var tileCoord = tile2.tileCoord;
    var tileExtent = tileGrid.getTileCoordExtent(tile2.wrappedTileCoord);
    var worldOffset = tileGrid.getTileCoordExtent(tileCoord, this.tmpExtent)[0] - tileExtent[0];
    var transform2 = multiply(scale$3(this.inversePixelTransform.slice(), 1 / pixelRatio, 1 / pixelRatio), this.getRenderTransform(center, resolution, rotation, pixelRatio, width, height, worldOffset));
    return transform2;
  };
  CanvasVectorTileLayerRenderer2.prototype.renderFrame = function(frameState, target) {
    var viewHints = frameState.viewHints;
    var hifi = !(viewHints[ViewHint.ANIMATING] || viewHints[ViewHint.INTERACTING]);
    _super.prototype.renderFrame.call(this, frameState, target);
    this.renderedPixelToCoordinateTransform_ = frameState.pixelToCoordinateTransform.slice();
    this.renderedRotation_ = frameState.viewState.rotation;
    var layer = this.getLayer();
    var renderMode = layer.getRenderMode();
    var context = this.context;
    var alpha = context.globalAlpha;
    context.globalAlpha = layer.getOpacity();
    var replayTypes = VECTOR_REPLAYS[renderMode];
    var viewState = frameState.viewState;
    var rotation = viewState.rotation;
    var tileSource = layer.getSource();
    var tileGrid = tileSource.getTileGridForProjection(viewState.projection);
    var z2 = tileGrid.getZForResolution(viewState.resolution, tileSource.zDirection);
    var tiles = this.renderedTiles;
    var clips = [];
    var clipZs = [];
    for (var i2 = tiles.length - 1; i2 >= 0; --i2) {
      var tile2 = tiles[i2];
      var executorGroups = tile2.executorGroups[getUid(layer)].filter(function(group) {
        return group.hasExecutors(replayTypes);
      });
      if (executorGroups.length === 0) {
        continue;
      }
      var transform2 = this.getTileRenderTransform(tile2, frameState);
      var currentZ = tile2.tileCoord[0];
      var contextSaved = false;
      var currentClip = executorGroups[0].getClipCoords(transform2);
      for (var j2 = 0, jj = clips.length; j2 < jj; ++j2) {
        if (z2 !== currentZ && currentZ < clipZs[j2]) {
          var clip = clips[j2];
          if (intersects$1([currentClip[0], currentClip[3], currentClip[4], currentClip[7]], [clip[0], clip[3], clip[4], clip[7]])) {
            if (!contextSaved) {
              context.save();
              contextSaved = true;
            }
            context.beginPath();
            context.moveTo(currentClip[0], currentClip[1]);
            context.lineTo(currentClip[2], currentClip[3]);
            context.lineTo(currentClip[4], currentClip[5]);
            context.lineTo(currentClip[6], currentClip[7]);
            context.moveTo(clip[6], clip[7]);
            context.lineTo(clip[4], clip[5]);
            context.lineTo(clip[2], clip[3]);
            context.lineTo(clip[0], clip[1]);
            context.clip();
          }
        }
      }
      clips.push(currentClip);
      clipZs.push(currentZ);
      for (var t3 = 0, tt2 = executorGroups.length; t3 < tt2; ++t3) {
        var executorGroup = executorGroups[t3];
        executorGroup.execute(context, 1, transform2, rotation, hifi, replayTypes);
      }
      if (contextSaved) {
        context.restore();
      }
    }
    context.globalAlpha = alpha;
    return this.container;
  };
  CanvasVectorTileLayerRenderer2.prototype.renderFeature = function(feature2, squaredTolerance, styles, builderGroup, opt_declutterBuilderGroup) {
    if (!styles) {
      return false;
    }
    var loading = false;
    if (Array.isArray(styles)) {
      for (var i2 = 0, ii = styles.length; i2 < ii; ++i2) {
        loading = renderFeature(builderGroup, feature2, styles[i2], squaredTolerance, this.boundHandleStyleImageChange_, void 0, opt_declutterBuilderGroup) || loading;
      }
    } else {
      loading = renderFeature(builderGroup, feature2, styles, squaredTolerance, this.boundHandleStyleImageChange_, void 0, opt_declutterBuilderGroup);
    }
    return loading;
  };
  CanvasVectorTileLayerRenderer2.prototype.tileImageNeedsRender_ = function(tile2) {
    var layer = this.getLayer();
    if (layer.getRenderMode() === VectorTileRenderType.VECTOR) {
      return false;
    }
    var replayState = tile2.getReplayState(layer);
    var revision = layer.getRevision();
    var resolution = tile2.wantedResolution;
    return replayState.renderedTileResolution !== resolution || replayState.renderedTileRevision !== revision;
  };
  CanvasVectorTileLayerRenderer2.prototype.renderTileImage_ = function(tile2, frameState) {
    var layer = this.getLayer();
    var replayState = tile2.getReplayState(layer);
    var revision = layer.getRevision();
    var executorGroups = tile2.executorGroups[getUid(layer)];
    replayState.renderedTileRevision = revision;
    var tileCoord = tile2.wrappedTileCoord;
    var z2 = tileCoord[0];
    var source = layer.getSource();
    var pixelRatio = frameState.pixelRatio;
    var viewState = frameState.viewState;
    var projection = viewState.projection;
    var tileGrid = source.getTileGridForProjection(projection);
    var tileResolution = tileGrid.getResolution(tile2.tileCoord[0]);
    var renderPixelRatio = frameState.pixelRatio / tile2.wantedResolution * tileResolution;
    var resolution = tileGrid.getResolution(z2);
    var context = tile2.getContext(layer);
    pixelRatio = Math.round(Math.max(pixelRatio, renderPixelRatio / pixelRatio));
    var size = source.getTilePixelSize(z2, pixelRatio, projection);
    context.canvas.width = size[0];
    context.canvas.height = size[1];
    var renderScale = pixelRatio / renderPixelRatio;
    if (renderScale !== 1) {
      var canvasTransform = reset(this.tmpTransform_);
      scale$3(canvasTransform, renderScale, renderScale);
      context.setTransform.apply(context, canvasTransform);
    }
    var tileExtent = tileGrid.getTileCoordExtent(tileCoord, this.tmpExtent);
    var pixelScale = renderPixelRatio / resolution;
    var transform2 = reset(this.tmpTransform_);
    scale$3(transform2, pixelScale, -pixelScale);
    translate$1(transform2, -tileExtent[0], -tileExtent[3]);
    for (var i2 = 0, ii = executorGroups.length; i2 < ii; ++i2) {
      var executorGroup = executorGroups[i2];
      executorGroup.execute(context, renderScale, transform2, 0, true, IMAGE_REPLAYS[layer.getRenderMode()]);
    }
    replayState.renderedTileResolution = tile2.wantedResolution;
  };
  return CanvasVectorTileLayerRenderer2;
}(CanvasTileLayerRenderer$1);
var CanvasVectorTileLayerRenderer$1 = CanvasVectorTileLayerRenderer;
var __extends$r = globalThis && globalThis.__extends || function() {
  var extendStatics2 = function(d2, b2) {
    extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {
      d3.__proto__ = b3;
    } || function(d3, b3) {
      for (var p5 in b3)
        if (Object.prototype.hasOwnProperty.call(b3, p5))
          d3[p5] = b3[p5];
    };
    return extendStatics2(d2, b2);
  };
  return function(d2, b2) {
    if (typeof b2 !== "function" && b2 !== null)
      throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
    extendStatics2(d2, b2);
    function __() {
      this.constructor = d2;
    }
    d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
  };
}();
var VectorTileLayer = function(_super) {
  __extends$r(VectorTileLayer2, _super);
  function VectorTileLayer2(opt_options) {
    var _this = this;
    var options = opt_options ? opt_options : {};
    var baseOptions = assign({}, options);
    delete baseOptions.preload;
    delete baseOptions.useInterimTilesOnError;
    _this = _super.call(this, baseOptions) || this;
    _this.on;
    _this.once;
    _this.un;
    if (options.renderMode === VectorTileRenderType.IMAGE) {
      console.warn('renderMode: "image" is deprecated. Option ignored.');
      options.renderMode = void 0;
    }
    var renderMode = options.renderMode || VectorTileRenderType.HYBRID;
    assert(renderMode == VectorTileRenderType.HYBRID || renderMode == VectorTileRenderType.VECTOR, 28);
    _this.renderMode_ = renderMode;
    _this.setPreload(options.preload ? options.preload : 0);
    _this.setUseInterimTilesOnError(options.useInterimTilesOnError !== void 0 ? options.useInterimTilesOnError : true);
    _this.getBackground;
    _this.setBackground;
    return _this;
  }
  VectorTileLayer2.prototype.createRenderer = function() {
    return new CanvasVectorTileLayerRenderer$1(this);
  };
  VectorTileLayer2.prototype.getFeatures = function(pixel) {
    return _super.prototype.getFeatures.call(this, pixel);
  };
  VectorTileLayer2.prototype.getRenderMode = function() {
    return this.renderMode_;
  };
  VectorTileLayer2.prototype.getPreload = function() {
    return this.get(TileProperty.PRELOAD);
  };
  VectorTileLayer2.prototype.getUseInterimTilesOnError = function() {
    return this.get(TileProperty.USE_INTERIM_TILES_ON_ERROR);
  };
  VectorTileLayer2.prototype.setPreload = function(preload) {
    this.set(TileProperty.PRELOAD, preload);
  };
  VectorTileLayer2.prototype.setUseInterimTilesOnError = function(useInterimTilesOnError) {
    this.set(TileProperty.USE_INTERIM_TILES_ON_ERROR, useInterimTilesOnError);
  };
  return VectorTileLayer2;
}(BaseVectorLayer$1);
var ol_layer_VectorTile = VectorTileLayer;
var ol_control_LayerSwitcher = function(options) {
  options = options || {};
  var self2 = this;
  this.dcount = 0;
  this.show_progress = options.show_progress;
  this.oninfo = typeof options.oninfo == "function" ? options.oninfo : null;
  this.onextent = typeof options.onextent == "function" ? options.onextent : null;
  this.hasextent = options.extent || options.onextent;
  this.hastrash = options.trash;
  this.reordering = options.reordering !== false;
  this._layers = [];
  this._layerGroup = options.layerGroup && options.layerGroup.getLayers ? options.layerGroup : null;
  this.onchangeCheck = typeof options.onchangeCheck == "function" ? options.onchangeCheck : null;
  if (typeof options.displayInLayerSwitcher === "function") {
    this.displayInLayerSwitcher = options.displayInLayerSwitcher;
  }
  var element;
  if (options.target) {
    element = ol_ext_element.create("DIV", {
      className: options.switcherClass || "ol-layerswitcher"
    });
  } else {
    element = ol_ext_element.create("DIV", {
      className: (options.switcherClass || "ol-layerswitcher") + " ol-unselectable ol-control"
    });
    if (options.collapsed !== false)
      element.classList.add("ol-collapsed");
    else
      element.classList.add("ol-forceopen");
    this.button = ol_ext_element.create("BUTTON", {
      type: "button",
      parent: element
    });
    this.button.addEventListener("touchstart", function(e2) {
      element.classList.toggle("ol-forceopen");
      element.classList.add("ol-collapsed");
      self2.dispatchEvent({ type: "toggle", collapsed: element.classList.contains("ol-collapsed") });
      e2.preventDefault();
      self2.overflow();
    });
    this.button.addEventListener("click", function() {
      element.classList.toggle("ol-forceopen");
      element.classList.add("ol-collapsed");
      self2.dispatchEvent({ type: "toggle", collapsed: !element.classList.contains("ol-forceopen") });
      self2.overflow();
    });
    if (options.mouseover) {
      element.addEventListener("mouseleave", function() {
        element.classList.add("ol-collapsed");
        self2.dispatchEvent({ type: "toggle", collapsed: true });
      });
      element.addEventListener("mouseover", function() {
        element.classList.remove("ol-collapsed");
        self2.dispatchEvent({ type: "toggle", collapsed: false });
      });
    }
    if (options.minibar)
      options.noScroll = true;
    if (!options.noScroll) {
      this.topv = ol_ext_element.create("DIV", {
        className: "ol-switchertopdiv",
        parent: element,
        click: function() {
          self2.overflow("+50%");
        }
      });
      this.botv = ol_ext_element.create("DIV", {
        className: "ol-switcherbottomdiv",
        parent: element,
        click: function() {
          self2.overflow("-50%");
        }
      });
    }
    this._noScroll = options.noScroll;
  }
  this.panel_ = ol_ext_element.create("UL", {
    className: "panel"
  });
  this.panelContainer_ = ol_ext_element.create("DIV", {
    className: "panel-container",
    html: this.panel_,
    parent: element
  });
  if (!options.target && !options.noScroll) {
    ol_ext_element.addListener(this.panel_, "mousewheel DOMMouseScroll onmousewheel", function(e2) {
      if (self2.overflow(Math.max(-1, Math.min(1, e2.wheelDelta || -e2.detail)))) {
        e2.stopPropagation();
        e2.preventDefault();
      }
    });
  }
  this.header_ = ol_ext_element.create("LI", {
    className: "ol-header",
    parent: this.panel_
  });
  ol_control_Control.call(this, {
    element,
    target: options.target
  });
  this.set("drawDelay", options.drawDelay || 0);
  this.set("selection", options.selection);
  if (options.minibar) {
    setTimeout(function() {
      var mbar = ol_ext_element.scrollDiv(this.panelContainer_, {
        mousewheel: true,
        vertical: true,
        minibar: true
      });
      this.on(["drawlist", "toggle"], function() {
        mbar.refresh();
      });
    }.bind(this));
  }
};
ol_ext_inherits(ol_control_LayerSwitcher, ol_control_Control);
ol_control_LayerSwitcher.prototype.tip = {
  up: "up/down",
  down: "down",
  info: "informations...",
  extent: "zoom to extent",
  trash: "remove layer",
  plus: "expand/shrink"
};
ol_control_LayerSwitcher.prototype.displayInLayerSwitcher = function(layer) {
  return layer.get("displayInLayerSwitcher") !== false;
};
ol_control_LayerSwitcher.prototype.setMap = function(map) {
  ol_control_Control.prototype.setMap.call(this, map);
  this.drawPanel();
  if (this._listener) {
    for (var i2 in this._listener)
      unByKey(this._listener[i2]);
  }
  this._listener = null;
  if (map) {
    this._listener = {
      moveend: map.on("moveend", this.viewChange.bind(this)),
      size: map.on("change:size", this.overflow.bind(this))
    };
    if (this._layerGroup) {
      this._listener.change = this._layerGroup.getLayers().on("change:length", this.drawPanel.bind(this));
    } else {
      this._listener.change = map.getLayerGroup().getLayers().on("change:length", this.drawPanel.bind(this));
    }
  }
};
ol_control_LayerSwitcher.prototype.show = function() {
  this.element.classList.add("ol-forceopen");
  this.overflow();
  self.dispatchEvent({ type: "toggle", collapsed: false });
};
ol_control_LayerSwitcher.prototype.hide = function() {
  this.element.classList.remove("ol-forceopen");
  this.overflow();
  self.dispatchEvent({ type: "toggle", collapsed: true });
};
ol_control_LayerSwitcher.prototype.toggle = function() {
  this.element.classList.toggle("ol-forceopen");
  this.overflow();
};
ol_control_LayerSwitcher.prototype.isOpen = function() {
  return this.element.classList.contains("ol-forceopen");
};
ol_control_LayerSwitcher.prototype.setHeader = function(html2) {
  ol_ext_element.setHTML(this.header_, html2);
};
ol_control_LayerSwitcher.prototype.overflow = function(dir) {
  if (this.button && !this._noScroll) {
    if (ol_ext_element.hidden(this.panel_)) {
      ol_ext_element.setStyle(this.element, { height: "auto" });
      return;
    }
    var h2 = ol_ext_element.outerHeight(this.element);
    var hp = ol_ext_element.outerHeight(this.panel_);
    var dh = this.button.offsetTop + ol_ext_element.outerHeight(this.button);
    var top = this.panel_.offsetTop - dh;
    if (hp > h2 - dh) {
      ol_ext_element.setStyle(this.element, { height: "100%" });
      var li = this.panel_.querySelectorAll("li.visible .li-content")[0];
      var lh = li ? 2 * ol_ext_element.getStyle(li, "height") : 0;
      switch (dir) {
        case 1:
          top += lh;
          break;
        case -1:
          top -= lh;
          break;
        case "+50%":
          top += Math.round(h2 / 2);
          break;
        case "-50%":
          top -= Math.round(h2 / 2);
          break;
      }
      if (top + hp <= h2 - 3 * dh / 2) {
        top = h2 - 3 * dh / 2 - hp;
        ol_ext_element.hide(this.botv);
      } else {
        ol_ext_element.show(this.botv);
      }
      if (top >= 0) {
        top = 0;
        ol_ext_element.hide(this.topv);
      } else {
        ol_ext_element.show(this.topv);
      }
      ol_ext_element.setStyle(this.panel_, { top: top + "px" });
      return true;
    } else {
      ol_ext_element.setStyle(this.element, { height: "auto" });
      ol_ext_element.setStyle(this.panel_, { top: 0 });
      ol_ext_element.hide(this.botv);
      ol_ext_element.hide(this.topv);
      return false;
    }
  } else
    return false;
};
ol_control_LayerSwitcher.prototype._setLayerForLI = function(li, layer) {
  var listeners = [];
  if (layer.getLayers) {
    listeners.push(layer.getLayers().on("change:length", this.drawPanel.bind(this)));
  }
  if (li) {
    listeners.push(layer.on("change:opacity", function() {
      this.setLayerOpacity(layer, li);
    }.bind(this)));
    listeners.push(layer.on("change:visible", function() {
      this.setLayerVisibility(layer, li);
    }.bind(this)));
  }
  listeners.push(layer.on("propertychange", function(e2) {
    if (e2.key === "displayInLayerSwitcher" || e2.key === "openInLayerSwitcher") {
      this.drawPanel(e2);
    }
  }.bind(this)));
  this._layers.push({ li, layer, listeners });
};
ol_control_LayerSwitcher.prototype.setLayerOpacity = function(layer, li) {
  var i2 = li.querySelector(".layerswitcher-opacity-cursor");
  if (i2)
    i2.style.left = layer.getOpacity() * 100 + "%";
  this.dispatchEvent({ type: "layer:opacity", layer });
};
ol_control_LayerSwitcher.prototype.setLayerVisibility = function(layer, li) {
  var i2 = li.querySelector(".ol-visibility");
  if (i2)
    i2.checked = layer.getVisible();
  if (layer.getVisible())
    li.classList.add("ol-visible");
  else
    li.classList.remove("ol-visible");
  this.dispatchEvent({ type: "layer:visible", layer });
};
ol_control_LayerSwitcher.prototype._clearLayerForLI = function() {
  this._layers.forEach(function(li) {
    li.listeners.forEach(function(l2) {
      unByKey(l2);
    });
  });
  this._layers = [];
};
ol_control_LayerSwitcher.prototype._getLayerForLI = function(li) {
  for (var i2 = 0, l2; l2 = this._layers[i2]; i2++) {
    if (l2.li === li)
      return l2.layer;
  }
  return null;
};
ol_control_LayerSwitcher.prototype.viewChange = function() {
  this.panel_.querySelectorAll("li").forEach(function(li) {
    var l2 = this._getLayerForLI(li);
    if (l2) {
      if (this.testLayerVisibility(l2))
        li.classList.remove("ol-layer-hidden");
      else
        li.classList.add("ol-layer-hidden");
    }
  }.bind(this));
};
ol_control_LayerSwitcher.prototype.getPanel = function() {
  return this.panelContainer_;
};
ol_control_LayerSwitcher.prototype.drawPanel = function() {
  if (!this.getMap())
    return;
  var self2 = this;
  this.dcount++;
  setTimeout(function() {
    self2.drawPanel_();
  }, this.get("drawDelay") || 0);
};
ol_control_LayerSwitcher.prototype.drawPanel_ = function() {
  if (--this.dcount || this.dragging_)
    return;
  var scrollTop = this.panelContainer_.scrollTop;
  this._clearLayerForLI();
  this.panel_.querySelectorAll("li").forEach(function(li) {
    if (!li.classList.contains("ol-header"))
      li.remove();
  }.bind(this));
  if (this._layerGroup)
    this.drawList(this.panel_, this._layerGroup.getLayers());
  else if (this.getMap())
    this.drawList(this.panel_, this.getMap().getLayers());
  this.panelContainer_.scrollTop = scrollTop;
};
ol_control_LayerSwitcher.prototype.switchLayerVisibility = function(l2, layers) {
  if (!l2.get("baseLayer")) {
    l2.setVisible(!l2.getVisible());
  } else {
    if (!l2.getVisible())
      l2.setVisible(true);
    layers.forEach(function(li) {
      if (l2 !== li && li.get("baseLayer") && li.getVisible())
        li.setVisible(false);
    });
  }
};
ol_control_LayerSwitcher.prototype.testLayerVisibility = function(layer) {
  if (!this.getMap())
    return true;
  var res = this.getMap().getView().getResolution();
  var zoom = this.getMap().getView().getZoom();
  if (layer.getMaxResolution() <= res || layer.getMinResolution() >= res) {
    return false;
  } else if (layer.getMinZoom && (layer.getMinZoom() >= zoom || layer.getMaxZoom() < zoom)) {
    return false;
  } else {
    var ex0 = layer.getExtent();
    if (ex0) {
      var ex = this.getMap().getView().calculateExtent(this.getMap().getSize());
      return intersects$1(ex, ex0);
    }
    return true;
  }
};
ol_control_LayerSwitcher.prototype.dragOrdering_ = function(e2) {
  e2.stopPropagation();
  e2.preventDefault();
  var self2 = this;
  var elt = e2.currentTarget.parentNode.parentNode;
  var start2 = true;
  var panel = this.panel_;
  var pageY;
  var pageY0 = e2.pageY || e2.touches && e2.touches.length && e2.touches[0].pageY || e2.changedTouches && e2.changedTouches.length && e2.changedTouches[0].pageY;
  var target, dragElt;
  var layer, group;
  elt.parentNode.classList.add("drag");
  function stop() {
    if (target) {
      var drop = layer;
      var isSelected = self2.getSelection() === drop;
      if (drop && target) {
        var collection;
        if (group)
          collection = group.getLayers();
        else
          collection = self2._layerGroup ? self2._layerGroup.getLayers() : self2.getMap().getLayers();
        var layers = collection.getArray();
        for (var i2 = 0; i2 < layers.length; i2++) {
          if (layers[i2] == drop) {
            collection.removeAt(i2);
            break;
          }
        }
        for (var j2 = 0; j2 < layers.length; j2++) {
          if (layers[j2] === target) {
            if (i2 > j2)
              collection.insertAt(j2, drop);
            else
              collection.insertAt(j2 + 1, drop);
            break;
          }
        }
      }
      if (isSelected)
        self2.selectLayer(drop);
      self2.dispatchEvent({ type: "reorder-end", layer: drop, group });
    }
    elt.parentNode.querySelectorAll("li").forEach(function(li) {
      li.classList.remove("dropover");
      li.classList.remove("dropover-after");
      li.classList.remove("dropover-before");
    });
    elt.classList.remove("drag");
    elt.parentNode.classList.remove("drag");
    self2.element.classList.remove("drag");
    if (dragElt)
      dragElt.remove();
    ol_ext_element.removeListener(document, "mousemove touchmove", move);
    ol_ext_element.removeListener(document, "mouseup touchend touchcancel", stop);
  }
  function move(e3) {
    pageY = e3.pageY || e3.touches && e3.touches.length && e3.touches[0].pageY || e3.changedTouches && e3.changedTouches.length && e3.changedTouches[0].pageY;
    if (start2 && Math.abs(pageY0 - pageY) > 2) {
      start2 = false;
      elt.classList.add("drag");
      layer = self2._getLayerForLI(elt);
      target = false;
      group = self2._getLayerForLI(elt.parentNode.parentNode);
      dragElt = ol_ext_element.create("LI", {
        className: "ol-dragover",
        html: elt.innerHTML,
        style: {
          position: "absolute",
          "z-index": 1e4,
          left: elt.offsetLeft,
          opacity: 0.5,
          width: ol_ext_element.outerWidth(elt),
          height: ol_ext_element.getStyle(elt, "height")
        },
        parent: panel
      });
      self2.element.classList.add("drag");
      self2.dispatchEvent({ type: "reorder-start", layer, group });
    }
    if (!start2) {
      e3.preventDefault();
      e3.stopPropagation();
      ol_ext_element.setStyle(dragElt, { top: pageY - ol_ext_element.offsetRect(panel).top + panel.scrollTop + 5 });
      var li;
      if (!e3.touches) {
        li = e3.target;
      } else {
        li = document.elementFromPoint(e3.touches[0].clientX, e3.touches[0].clientY);
      }
      if (li.classList.contains("ol-switcherbottomdiv")) {
        self2.overflow(-1);
      } else if (li.classList.contains("ol-switchertopdiv")) {
        self2.overflow(1);
      }
      while (li && li.tagName !== "LI") {
        li = li.parentNode;
      }
      if (!li || !li.classList.contains("dropover")) {
        elt.parentNode.querySelectorAll("li").forEach(function(li2) {
          li2.classList.remove("dropover");
          li2.classList.remove("dropover-after");
          li2.classList.remove("dropover-before");
        });
      }
      if (li && li.parentNode.classList.contains("drag") && li !== elt) {
        target = self2._getLayerForLI(li);
        if (target && !target.get("allwaysOnTop") == !layer.get("allwaysOnTop")) {
          li.classList.add("dropover");
          li.classList.add(elt.offsetTop < li.offsetTop ? "dropover-after" : "dropover-before");
        } else {
          target = false;
        }
        ol_ext_element.show(dragElt);
      } else {
        target = false;
        if (li === elt)
          ol_ext_element.hide(dragElt);
        else
          ol_ext_element.show(dragElt);
      }
      if (!target)
        dragElt.classList.add("forbidden");
      else
        dragElt.classList.remove("forbidden");
    }
  }
  ol_ext_element.addListener(document, "mousemove touchmove", move);
  ol_ext_element.addListener(document, "mouseup touchend touchcancel", stop);
};
ol_control_LayerSwitcher.prototype.dragOpacity_ = function(e2) {
  e2.stopPropagation();
  e2.preventDefault();
  var self2 = this;
  var elt = e2.target;
  var layer = this._getLayerForLI(elt.parentNode.parentNode.parentNode);
  if (!layer)
    return;
  var x2 = e2.pageX || e2.touches && e2.touches.length && e2.touches[0].pageX || e2.changedTouches && e2.changedTouches.length && e2.changedTouches[0].pageX;
  var start2 = ol_ext_element.getStyle(elt, "left") - x2;
  self2.dragging_ = true;
  function stop() {
    ol_ext_element.removeListener(document, "mouseup touchend touchcancel", stop);
    ol_ext_element.removeListener(document, "mousemove touchmove", move);
    self2.dragging_ = false;
  }
  function move(e3) {
    var x3 = e3.pageX || e3.touches && e3.touches.length && e3.touches[0].pageX || e3.changedTouches && e3.changedTouches.length && e3.changedTouches[0].pageX;
    var delta = (start2 + x3) / ol_ext_element.getStyle(elt.parentNode, "width");
    var opacity2 = Math.max(0, Math.min(1, delta));
    ol_ext_element.setStyle(elt, { left: opacity2 * 100 + "%" });
    elt.parentNode.nextElementSibling.innerHTML = Math.round(opacity2 * 100);
    layer.setOpacity(opacity2);
  }
  ol_ext_element.addListener(document, "mouseup touchend touchcancel", stop);
  ol_ext_element.addListener(document, "mousemove touchmove", move);
};
ol_control_LayerSwitcher.prototype.drawList = function(ul, collection) {
  var self2 = this;
  var layers = collection.getArray();
  var setVisibility = function(e2) {
    e2.stopPropagation();
    e2.preventDefault();
    var l2 = self2._getLayerForLI(this.parentNode.parentNode);
    self2.switchLayerVisibility(l2, collection);
    if (self2.get("selection") && l2.getVisible()) {
      self2.selectLayer(l2);
    }
    if (self2.onchangeCheck) {
      self2.onchangeCheck(l2);
    }
  };
  function onInfo(e2) {
    e2.stopPropagation();
    e2.preventDefault();
    var l2 = self2._getLayerForLI(this.parentNode.parentNode);
    self2.oninfo(l2);
    self2.dispatchEvent({ type: "info", layer: l2 });
  }
  function zoomExtent(e2) {
    e2.stopPropagation();
    e2.preventDefault();
    var l2 = self2._getLayerForLI(this.parentNode.parentNode);
    if (self2.onextent)
      self2.onextent(l2);
    else
      self2.getMap().getView().fit(l2.getExtent(), self2.getMap().getSize());
    self2.dispatchEvent({ type: "extent", layer: l2 });
  }
  function removeLayer(e2) {
    e2.stopPropagation();
    e2.preventDefault();
    var li = this.parentNode.parentNode.parentNode.parentNode;
    var layer, group = self2._getLayerForLI(li);
    if (group) {
      layer = self2._getLayerForLI(this.parentNode.parentNode);
      group.getLayers().remove(layer);
      if (group.getLayers().getLength() == 0 && !group.get("noSwitcherDelete")) {
        removeLayer.call(li.querySelectorAll(".layerTrash")[0], e2);
      }
    } else {
      li = this.parentNode.parentNode;
      self2.getMap().removeLayer(self2._getLayerForLI(li));
    }
  }
  function createLi(layer) {
    if (!this.displayInLayerSwitcher(layer)) {
      this._setLayerForLI(null, layer);
      return;
    }
    var li = ol_ext_element.create("LI", {
      className: (layer.getVisible() ? "visible " : " ") + (layer.get("baseLayer") ? "baselayer" : ""),
      parent: ul
    });
    this._setLayerForLI(li, layer);
    if (this._selectedLayer === layer) {
      li.classList.add("ol-layer-select");
    }
    var layer_buttons = ol_ext_element.create("DIV", {
      className: "ol-layerswitcher-buttons",
      parent: li
    });
    var d2 = ol_ext_element.create("DIV", {
      className: "li-content",
      parent: li
    });
    ol_ext_element.create("INPUT", {
      type: layer.get("baseLayer") ? "radio" : "checkbox",
      className: "ol-visibility",
      checked: layer.getVisible(),
      click: setVisibility,
      parent: d2
    });
    var label = ol_ext_element.create("LABEL", {
      title: layer.get("title") || layer.get("name"),
      click: setVisibility,
      unselectable: "on",
      style: {
        userSelect: "none"
      },
      parent: d2
    });
    label.addEventListener("selectstart", function() {
      return false;
    });
    ol_ext_element.create("SPAN", {
      html: layer.get("title") || layer.get("name"),
      click: function(e2) {
        if (this.get("selection")) {
          e2.stopPropagation();
          this.selectLayer(layer);
        }
      }.bind(this),
      parent: label
    });
    if (this.reordering) {
      if (i2 < layers.length - 1 && (layer.get("allwaysOnTop") || !layers[i2 + 1].get("allwaysOnTop")) || i2 > 0 && (!layer.get("allwaysOnTop") || layers[i2 - 1].get("allwaysOnTop"))) {
        ol_ext_element.create("DIV", {
          className: "layerup ol-noscroll",
          title: this.tip.up,
          on: { "mousedown touchstart": function(e2) {
            self2.dragOrdering_(e2);
          } },
          parent: layer_buttons
        });
      }
    }
    if (layer.getLayers) {
      var nb = 0;
      layer.getLayers().forEach(function(l2) {
        if (self2.displayInLayerSwitcher(l2))
          nb++;
      });
      if (nb) {
        ol_ext_element.create("DIV", {
          className: layer.get("openInLayerSwitcher") ? "collapse-layers" : "expend-layers",
          title: this.tip.plus,
          click: function() {
            var l2 = self2._getLayerForLI(this.parentNode.parentNode);
            l2.set("openInLayerSwitcher", !l2.get("openInLayerSwitcher"));
          },
          parent: layer_buttons
        });
      }
    }
    if (this.oninfo) {
      ol_ext_element.create("DIV", {
        className: "layerInfo",
        title: this.tip.info,
        click: onInfo,
        parent: layer_buttons
      });
    }
    if (this.hastrash && !layer.get("noSwitcherDelete")) {
      ol_ext_element.create("DIV", {
        className: "layerTrash",
        title: this.tip.trash,
        click: removeLayer,
        parent: layer_buttons
      });
    }
    if (this.hasextent && layers[i2].getExtent()) {
      var ex = layers[i2].getExtent();
      if (ex.length == 4 && ex[0] < ex[2] && ex[1] < ex[3]) {
        ol_ext_element.create("DIV", {
          className: "layerExtent",
          title: this.tip.extent,
          click: zoomExtent,
          parent: layer_buttons
        });
      }
    }
    if (this.show_progress && layer instanceof ol_layer_Tile) {
      var p5 = ol_ext_element.create("DIV", {
        className: "layerswitcher-progress",
        parent: d2
      });
      this.setprogress_(layer);
      layer.layerswitcher_progress = ol_ext_element.create("DIV", { parent: p5 });
    }
    var opacity2 = ol_ext_element.create("DIV", {
      className: "layerswitcher-opacity",
      click: function(e2) {
        if (e2.target !== this)
          return;
        e2.stopPropagation();
        e2.preventDefault();
        var op = Math.max(0, Math.min(1, e2.offsetX / ol_ext_element.getStyle(this, "width")));
        self2._getLayerForLI(this.parentNode.parentNode).setOpacity(op);
      },
      parent: d2
    });
    ol_ext_element.create("DIV", {
      className: "layerswitcher-opacity-cursor ol-noscroll",
      style: { left: layer.getOpacity() * 100 + "%" },
      on: {
        "mousedown touchstart": function(e2) {
          self2.dragOpacity_(e2);
        }
      },
      parent: opacity2
    });
    ol_ext_element.create("DIV", {
      className: "layerswitcher-opacity-label",
      html: Math.round(layer.getOpacity() * 100),
      parent: d2
    });
    if (layer.getLayers) {
      li.classList.add("ol-layer-group");
      if (layer.get("openInLayerSwitcher") === true) {
        var ul2 = ol_ext_element.create("UL", {
          parent: li
        });
        this.drawList(ul2, layer.getLayers());
      }
    }
    li.classList.add(this.getLayerClass(layer));
    this.dispatchEvent({ type: "drawlist", layer, li });
  }
  for (var i2 = layers.length - 1; i2 >= 0; i2--) {
    createLi.call(this, layers[i2]);
  }
  this.viewChange();
  if (ul === this.panel_)
    this.overflow();
};
ol_control_LayerSwitcher.prototype.getLayerClass = function(layer) {
  if (!layer)
    return "none";
  if (layer.getLayers)
    return "ol-layer-group";
  if (layer instanceof ol_layer_Vector)
    return "ol-layer-vector";
  if (layer instanceof ol_layer_VectorTile)
    return "ol-layer-vectortile";
  if (layer instanceof ol_layer_Tile)
    return "ol-layer-tile";
  if (layer instanceof ol_layer_Image)
    return "ol-layer-image";
  if (layer instanceof ol_layer_Heatmap)
    return "ol-layer-heatmap";
  if (layer.getFeatures)
    return "ol-layer-vectorimage";
  return "unknown";
};
ol_control_LayerSwitcher.prototype.selectLayer = function(layer, silent) {
  if (!layer) {
    if (!this.getMap())
      return;
    layer = this.getMap().getLayers().item(this.getMap().getLayers().getLength() - 1);
  }
  this._selectedLayer = layer;
  this.drawPanel();
  if (!silent)
    this.dispatchEvent({ type: "select", layer });
};
ol_control_LayerSwitcher.prototype.getSelection = function() {
  return this._selectedLayer;
};
ol_control_LayerSwitcher.prototype.setprogress_ = function(layer) {
  if (!layer.layerswitcher_progress) {
    var loaded = 0;
    var loading = 0;
    var draw = function() {
      if (loading === loaded) {
        loading = loaded = 0;
        ol_ext_element.setStyle(layer.layerswitcher_progress, { width: 0 });
      } else {
        ol_ext_element.setStyle(layer.layerswitcher_progress, { width: (loaded / loading * 100).toFixed(1) + "%" });
      }
    };
    layer.getSource().on("tileloadstart", function() {
      loading++;
      draw();
    });
    layer.getSource().on("tileloadend", function() {
      loaded++;
      draw();
    });
    layer.getSource().on("tileloaderror", function() {
      loaded++;
      draw();
    });
  }
};
var _sfc_main$u = {
  name: "ol-layerswitcher-control",
  setup(props, context) {
    const {
      control
    } = useControl(ol_control_LayerSwitcher, props, context);
    return {
      control
    };
  },
  props: {
    selection: {
      type: Boolean
    },
    displayInLayerSwitcher: {
      type: Function
    },
    show_progress: {
      type: Boolean,
      default: false
    },
    mouseover: {
      type: Boolean,
      default: false
    },
    reordering: {
      type: Boolean,
      default: true
    },
    trash: {
      type: Boolean,
      default: false
    },
    oninfo: {
      type: Function
    },
    extent: {
      type: Boolean
    },
    onextent: {
      type: Function
    },
    drawDelay: {
      type: Number
    },
    collapsed: {
      type: Boolean,
      default: true
    },
    layerGroup: {
      type: Object
    },
    noScroll: {
      type: Boolean,
      default: false
    }
  }
};
function _sfc_render$u(_ctx, _cache, $props, $setup, $data, $options) {
  return createCommentVNode("", true);
}
var LayerSwitcherControl = _export_sfc(_sfc_main$u, [["render", _sfc_render$u]]);
ol_source_Source.prototype.getPreview = function() {
  return "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEAAAABACAYAAACqaXHeAAAABHNCSVQICAgIfAhkiAAAAAlwSFlzAAAk6QAAJOkBUCTn+AAAABl0RVh0U29mdHdhcmUAd3d3Lmlua3NjYXBlLm9yZ5vuPBoAAANeSURBVHic7ZpPiE1RHMc/780MBhkik79JSUlIUbOxI+wkI2yRhYSUlJLNpJF/xcpiJBmZGBZsNM1CkmhKITGkGbH0/BuPmXnP4rxbb/TOn3fvOffeec6nfqvb/b7f93fveeec37ng8Xg8Ho/nf6Uu4d+fDswFssCvhHOJhaXAMeApMAQUyyIPPAdOAiuTStAVy4EHjDWsix5gdRLJ2mY34ulWYz6IEeA4kIk9awtkgTOEM/5vdAKT4k0/Ou3YMR/ELcbRm9AKFLBbgCJwNE4TYZkJfMG++SIwDCyLz0o4bI17WdyJz0r1TAZ+oDcxCBwAFgIzEIuhvcBbg3sLwOK4DFXLFvQGniCGSSUagS4DjUPOHESkA3XiOWCORqMR6Nfo9DjI3QqPUSd+ylBnv0Zn0GrWFvmIOvGNhjqrNDp/EAutyFgRKUM2tgO+Gur81FxvAKYZaimxXYBvmuuLDHWWaK4X0RfJCNsF6NdcbzXU2a65PohYFKWOc+jn8PUajbWIXaBKp9NB7lZYh34OzwFbFfd/NtDYYSth27urLGIm0M31AL3APWAAmIooymaDnPIl/Vz4NN1yHrd7gcvxWQnHAuA3bsyPop8hUsE13BSgK04TUViBeFo2zedJ8S6wElexW4D2eNOPTjNi6WvD/DtEr8E6tk6GGoAmxFY2iFHE9NZiQf8gogiB9gTEH23izAZuE77vHyU+ANucO1QwD3hD/MbLowAcdm20EmkwXx4n3NodS9rMB2HabYpEWs0HcRqHp0fNwAvJD+eBTZr7p6BvmQVxUaEzEbiruNfJekH15L8jtrEm7JJolEcOmKXRqQOuKDQuY7HZY8s8iNfzkSLxIuI43FTrkkLnOlBfRW4VsWk+oAX5weknxFAxJQNckGgVgZuIRVoomoGXEmGTMa+iQ6K7M4SW7k24QYgiuDQPYinbhugiF4H3RGtzZYCzyIvQXfpNI1ybLyeLpf5+iTbkRbiP2EcocTHm4+YI8iI8RFHwWjAfsA95Q+YZFU6wasl8wB7kReijtNbIILa0vcg/PRlGfPQwHmlCviDqAzaA+OREtzqr1ejOIDorxlNEjTGUBV4nnUWCvAJxGDlA8q9j3DEArAn2zvXAfOwfl6eVAmJrPpJ0Ih6Px+PxeJLjLwPul3vj5d0eAAAAAElFTkSuQmCC";
};
ol_source_Tile.prototype.getPreview = function(lonlat, resolution) {
  if (!lonlat)
    lonlat = [21020, 6355964];
  if (!resolution)
    resolution = 150;
  var coord = this.getTileGrid().getTileCoordForCoordAndResolution(lonlat, resolution);
  var fn = this.getTileUrlFunction();
  return fn.call(this, coord, this.getProjection());
};
ol_source_TileWMS.prototype.getPreview = function(lonlat, resolution) {
  if (!lonlat)
    lonlat = [21020, 6355964];
  if (!resolution)
    resolution = 150;
  var fn = this.getTileUrlFunction();
  if (fn) {
    var tileGrid = this.getTileGrid() || this.getTileGridForProjection(this.getProjection());
    var coord = tileGrid.getTileCoordForCoordAndResolution(lonlat, resolution);
    return fn.call(this, coord, 1, this.getProjection());
  }
  var url = this.getGetFeatureInfoUrl ? this.getGetFeatureInfoUrl(lonlat, resolution, this.getProjection() || "EPSG:3857", {}) : this.getFeatureInfoUrl(lonlat, resolution, this.getProjection() || "EPSG:3857", {});
  url = url.replace(/getfeatureinfo/i, "GetMap");
  return url;
};
ol_layer_Base.prototype.getPreview = function(lonlat, resolution, projection) {
  if (this.get("preview"))
    return [this.get("preview")];
  if (!resolution)
    resolution = 150;
  if (resolution < this.getMinResolution() || resolution > this.getMaxResolution()) {
    var rmin = this.getMinResolution(), rmax = this.getMaxResolution();
    if (rmax > 1e5)
      rmax = 156543;
    if (rmin < 0.15)
      rmin = 0.15;
    resolution = rmax;
    while (rmax > rmin) {
      rmin *= 2;
      rmax /= 2;
      resolution = rmin;
    }
  }
  var e2 = this.getExtent();
  if (!lonlat)
    lonlat = [21020, 6355964];
  if (e2 && !containsCoordinate(e2, lonlat))
    lonlat = [(e2[0] + e2[2]) / 2, (e2[1] + e2[3]) / 2];
  if (projection)
    lonlat = transform$3(lonlat, projection, this.getSource().getProjection());
  if (this.getSource && this.getSource()) {
    return [this.getSource().getPreview(lonlat, resolution)];
  }
  return [];
};
ol_layer_Group.prototype.getPreview = function(lonlat, resolution) {
  if (this.get("preview"))
    return [this.get("preview")];
  var t3 = [];
  if (this.getLayers) {
    var l2 = this.getLayers().getArray();
    for (var i2 = 0; i2 < l2.length; i2++) {
      t3 = t3.concat(l2[i2].getPreview(lonlat, resolution));
    }
  }
  return t3;
};
var ol_control_LayerSwitcherImage = function(options) {
  options = options || {};
  options.switcherClass = "ol-layerswitcher-image";
  if (options.mouseover !== false)
    options.mouseover = true;
  ol_control_LayerSwitcher.call(this, options);
};
ol_ext_inherits(ol_control_LayerSwitcherImage, ol_control_LayerSwitcher);
ol_control_LayerSwitcherImage.prototype.drawList = function(ul, layers) {
  var self2 = this;
  var setVisibility = function(e2) {
    e2.preventDefault();
    var l2 = self2._getLayerForLI(this);
    self2.switchLayerVisibility(l2, layers);
    if (e2.type == "touchstart")
      self2.element.classList.add("ol-collapsed");
  };
  ol_ext_element.setStyle(ul, { height: "auto" });
  layers.forEach(function(layer) {
    if (self2.displayInLayerSwitcher(layer)) {
      var preview = layer.getPreview ? layer.getPreview() : ["none"];
      var d2 = ol_ext_element.create("LI", {
        className: "ol-imgcontainer" + (layer.getVisible() ? " ol-visible" : ""),
        on: { "touchstart click": setVisibility },
        parent: ul
      });
      self2._setLayerForLI(d2, layer);
      preview.forEach(function(img) {
        ol_ext_element.create("IMG", {
          src: img,
          parent: d2
        });
      });
      ol_ext_element.create("p", {
        html: layer.get("title") || layer.get("name"),
        parent: d2
      });
      if (self2.testLayerVisibility(layer))
        d2.classList.add("ol-layer-hidden");
    }
  });
};
ol_control_LayerSwitcherImage.prototype.overflow = function() {
};
var _sfc_main$t = {
  name: "ol-layerswitcherimage-control",
  extends: LayerSwitcherControl,
  setup(props, context) {
    const {
      control
    } = useControl(ol_control_LayerSwitcherImage, props, context);
    return {
      control
    };
  }
};
function _sfc_render$t(_ctx, _cache, $props, $setup, $data, $options) {
  return createCommentVNode("", true);
}
var LayerSwitcherImageControl = _export_sfc(_sfc_main$t, [["render", _sfc_render$t]]);
var ol_control_MapZone = function(options) {
  if (!options)
    options = {};
  var element = document.createElement("div");
  if (options.target) {
    element = ol_ext_element.create("DIV", {
      className: options.className || "ol-mapzone"
    });
  } else {
    element = ol_ext_element.create("DIV", {
      className: (options.className || "ol-mapzone") + " ol-unselectable ol-control ol-collapsed"
    });
    var bt2 = ol_ext_element.create("BUTTON", {
      type: "button",
      on: {
        "click": function() {
          element.classList.toggle("ol-collapsed");
          maps.forEach(function(m2) {
            m2.updateSize();
          });
        }.bind(this)
      },
      parent: element
    });
    ol_ext_element.create("I", {
      parent: bt2
    });
  }
  ol_control_Control.call(this, {
    element,
    target: options.target
  });
  this.set("centerOnClick", options.centerOnClick);
  var maps = this._maps = [];
  this._projection = options.projection;
  this._layer = options.layer;
  options.zones.forEach(this.addZone.bind(this));
  setTimeout(function() {
    maps.forEach(function(m2) {
      m2.updateSize();
    });
  });
};
ol_ext_inherits(ol_control_MapZone, ol_control_Control);
ol_control_MapZone.prototype.setCollapsed = function(b2) {
  if (b2) {
    this.element.classList.remove("ol-collapsed");
    this.getMaps().forEach(function(m2) {
      m2.updateSize();
    });
  } else {
    this.element.classList.add("ol-collapsed");
  }
};
ol_control_MapZone.prototype.getCollapsed = function() {
  return this.element.classList.contains("ol-collapsed");
};
ol_control_MapZone.prototype.setVisible = ol_control_MapZone.prototype.setCollapsed;
ol_control_MapZone.prototype.getMaps = function() {
  return this._maps;
};
ol_control_MapZone.prototype.getLength = function() {
  return this._maps.length;
};
ol_control_MapZone.prototype.addZone = function(z2) {
  var view = new ol_View({ zoom: 6, center: [0, 0], projection: this._projection });
  var extent2;
  if (z2.map) {
    extent2 = transformExtent(z2.map.getView().calculateExtent(), z2.map.getView().getProjection(), view.getProjection());
  } else {
    extent2 = transformExtent(z2.extent, "EPSG:4326", view.getProjection());
  }
  var div = ol_ext_element.create("DIV", {
    className: "ol-mapzonezone",
    parent: this.element,
    click: function() {
      var index2 = -1;
      this._maps.forEach(function(m2, i2) {
        if (m2.get("zone") === z2) {
          index2 = i2;
        }
      });
      this.dispatchEvent({
        type: "select",
        zone: z2,
        index: index2,
        coordinate: getCenter(extent2),
        extent: extent2
      });
      if (this.get("centerOnClick") !== false) {
        this.getMap().getView().fit(extent2);
      }
      this.setVisible(false);
    }.bind(this)
  });
  var layer;
  if (z2.layer) {
    layer = z2.layer;
  } else if (typeof this._layer === "function") {
    layer = this._layer(z2);
  } else {
    layer = new this._layer.constructor({
      source: this._layer.getSource()
    });
  }
  var map = new ol_Map({
    target: div,
    view,
    controls: [],
    interactions: [],
    layers: [layer]
  });
  map.set("zone", z2);
  this._maps.push(map);
  view.fit(extent2);
  ol_ext_element.create("P", {
    html: z2.title,
    parent: div
  });
};
ol_control_MapZone.prototype.removeZone = function(index2) {
  var z2 = this.element.querySelectorAll(".ol-mapzonezone")[index2];
  if (z2) {
    z2.remove();
    this._maps.splice(index2, 1);
  }
};
ol_control_MapZone.zones = {};
ol_control_MapZone.zones.DOM = [{
  "title": "Guadeloupe",
  "extent": [-61.898594315312444, 15.75623038647845, -60.957887532935324, 16.575317670979473]
}, {
  "title": "Guyane",
  "extent": [-54.72525931072715, 2.1603763430019, -51.528236062921344, 5.7984307809552575]
}, {
  "title": "Martinique",
  "extent": [-61.257556528564756, 14.387506317407514, -60.76934912110432, 14.895067461729951]
}, {
  "title": "Mayotte",
  "extent": [44.959844536967815, -13.01674138212816, 45.35328866510648, -12.65521942207829]
}, {
  "title": "La r\xE9union",
  "extent": [55.17059012967656, -21.407680069231688, 55.88195702001797, -20.85560221637526]
}];
ol_control_MapZone.zones.TOM = [{
  "title": "Polyn\xE9sie Fran\xE7aise",
  "extent": [206.23664226630862, -22.189040615809787, 221.85920743981987, -10.835039595040698]
}, {
  "title": "Nouvelle Cal\xE9donie",
  "extent": [163.76420580160925, -22.581641092751838, 167.66984709498706, -19.816411635668445]
}, {
  "title": "St-Pierre et Miquelon",
  "extent": [-56.453698765748676, 46.74449858188555, -56.0980198121544, 47.14669874229787]
}, {
  "title": "Wallis et Futuna",
  "extent": [181.7588623143665, -14.7341169873267, 183.95612353301715, -13.134720799175085]
}, {
  "title": "St-Martin St-Barth\xE9lemy",
  "extent": [-63.1726389501678, 17.806097291313506, -62.7606535945649, 18.13267688837938]
}];
ol_control_MapZone.zones.DOMTOM = [{
  title: "M\xE9tropole",
  extent: [-5.318421740712579, 41.16082274292913, 9.73284186155716, 51.21957336557702]
}].concat(ol_control_MapZone.zones.DOM, ol_control_MapZone.zones.TOM);
var _sfc_main$s = {
  name: "ol-zone-control",
  setup(props, context) {
    const {
      control
    } = useControl(ol_control_MapZone, props, context);
    return {
      control
    };
  },
  props: {
    className: {
      type: String
    },
    zones: {
      type: Array
    },
    layer: {
      type: [Object, Function]
    },
    projection: {
      type: String,
      default: "EPSG:3857"
    },
    centerOnClick: {
      type: Boolean,
      default: true
    }
  }
};
function _sfc_render$s(_ctx, _cache, $props, $setup, $data, $options) {
  return createCommentVNode("", true);
}
var ZoneControl = _export_sfc(_sfc_main$s, [["render", _sfc_render$s]]);
function install$5(app) {
  if (install$5.installed) {
    return;
  }
  install$5.installed = true;
  app.component(FullScreenControl.name, FullScreenControl);
  app.component(MousePositionControl.name, MousePositionControl);
  app.component(AttributionControl.name, AttributionControl);
  app.component(OverviewMapControl.name, OverviewMapControl);
  app.component(ScaleLineControl.name, ScaleLineControl);
  app.component(ZoomControl.name, ZoomControl);
  app.component(ZoomSliderControl.name, ZoomSliderControl);
  app.component(ZoomToExtentControl.name, ZoomToExtentControl);
  app.component(RotateControl.name, RotateControl);
  app.component(ContextMenuControl.name, ContextMenuControl);
  app.component(SwipeControl.name, SwipeControl);
  app.component(ControlBar.name, ControlBar);
  app.component(ToggleControl.name, ToggleControl);
  app.component(ButtonControl.name, ButtonControl);
  app.component(PrintDialog.name, PrintDialog);
  app.component(VideoRecorderControl.name, VideoRecorderControl);
  app.component(LayerSwitcherControl.name, LayerSwitcherControl);
  app.component(LayerSwitcherImageControl.name, LayerSwitcherImageControl);
  app.component(ZoneControl.name, ZoneControl);
}
var MapControls = Object.freeze(Object.defineProperty({
  __proto__: null,
  "default": install$5,
  install: install$5,
  FullScreenControl,
  MousePositionControl,
  AttributionControl,
  OverviewMapControl,
  ScaleLineControl,
  ZoomControl,
  ZoomSliderControl,
  ZoomToExtentControl,
  ContextMenuControl,
  SwipeControl,
  ControlBar,
  ToggleControl,
  ButtonControl,
  PrintDialog,
  VideoRecorderControl,
  LayerSwitcherControl,
  LayerSwitcherImageControl,
  ZoneControl
}, Symbol.toStringTag, { value: "Module" }));
function useGeometry(GeometryType2, props) {
  const feature2 = inject("feature");
  const {
    properties
  } = usePropsAsObjectProperties(props);
  let geometry = computed(() => new GeometryType2(...Object.values(properties)));
  watch(properties, () => {
    feature2.value.setGeometry(geometry.value);
    feature2.value.changed();
  });
  watch(feature2, () => {
    feature2.value.setGeometry(geometry.value);
  });
  onMounted(() => {
    feature2.value.setGeometry(geometry.value);
  });
  onUnmounted(() => {
    feature2.value.setGeometry(null);
  });
  return {
    geometry
  };
}
var _sfc_main$r = {
  name: "ol-geom-point",
  setup(props) {
    const {
      geometry
    } = useGeometry(Point$4, props);
    return {
      geometry
    };
  },
  props: {
    coordinates: {
      type: Array
    },
    opt_layout: {
      type: String,
      default: "XY"
    }
  }
};
function _sfc_render$r(_ctx, _cache, $props, $setup, $data, $options) {
  return createCommentVNode("", true);
}
var Point$1 = _export_sfc(_sfc_main$r, [["render", _sfc_render$r]]);
var _sfc_main$q = {
  name: "ol-geom-line-string",
  setup(props) {
    const {
      geometry
    } = useGeometry(LineString$2, props);
    return {
      geometry
    };
  },
  props: {
    coordinates: {
      type: Array
    },
    opt_layout: {
      type: String,
      default: "XY"
    }
  }
};
function _sfc_render$q(_ctx, _cache, $props, $setup, $data, $options) {
  return createCommentVNode("", true);
}
var LineString = _export_sfc(_sfc_main$q, [["render", _sfc_render$q]]);
var _sfc_main$p = {
  name: "ol-geom-polygon",
  setup(props) {
    const {
      geometry
    } = useGeometry(Polygon$2, props);
    return {
      geometry
    };
  },
  props: {
    coordinates: {
      type: Array
    },
    opt_layout: {
      type: String,
      default: "XY"
    }
  }
};
function _sfc_render$p(_ctx, _cache, $props, $setup, $data, $options) {
  return createCommentVNode("", true);
}
var Polygon = _export_sfc(_sfc_main$p, [["render", _sfc_render$p]]);
var _sfc_main$o = {
  name: "ol-geom-multi-point",
  setup(props) {
    const {
      geometry
    } = useGeometry(MultiPoint$2, props);
    return {
      geometry
    };
  },
  props: {
    coordinates: {
      type: Array
    },
    opt_layout: {
      type: String,
      default: "XY"
    }
  }
};
function _sfc_render$o(_ctx, _cache, $props, $setup, $data, $options) {
  return createCommentVNode("", true);
}
var MultiPoint = _export_sfc(_sfc_main$o, [["render", _sfc_render$o]]);
var _sfc_main$n = {
  name: "ol-geom-multi-line-string",
  setup(props) {
    const {
      geometry
    } = useGeometry(MultiLineString$2, props);
    return {
      geometry
    };
  },
  props: {
    coordinates: {
      type: Array
    },
    opt_layout: {
      type: String,
      default: "XY"
    }
  }
};
function _sfc_render$n(_ctx, _cache, $props, $setup, $data, $options) {
  return createCommentVNode("", true);
}
var MultiLineString = _export_sfc(_sfc_main$n, [["render", _sfc_render$n]]);
var _sfc_main$m = {
  name: "ol-geom-multi-polygon",
  setup(props) {
    const {
      geometry
    } = useGeometry(MultiPolygon$2, props);
    return {
      geometry
    };
  },
  props: {
    coordinates: {
      type: Array
    },
    opt_layout: {
      type: String,
      default: "XY"
    }
  }
};
function _sfc_render$m(_ctx, _cache, $props, $setup, $data, $options) {
  return createCommentVNode("", true);
}
var MultiPolygon = _export_sfc(_sfc_main$m, [["render", _sfc_render$m]]);
function install$4(app) {
  if (install$4.installed) {
    return;
  }
  install$4.installed = true;
  app.component(Point$1.name, Point$1);
  app.component(LineString.name, LineString);
  app.component(Polygon.name, Polygon);
  app.component(MultiPoint.name, MultiPoint);
  app.component(MultiLineString.name, MultiLineString);
  app.component(MultiPolygon.name, MultiPolygon);
}
var Geometries = Object.freeze(Object.defineProperty({
  __proto__: null,
  "default": install$4,
  install: install$4,
  Point: Point$1,
  LineString,
  Polygon,
  MultiPoint,
  MultiLineString,
  MultiPolygon
}, Symbol.toStringTag, { value: "Module" }));
var _sfc_main$l = {
  name: "ol-style",
  setup(props) {
    const styledObj = inject("stylable", null);
    const {
      properties
    } = usePropsAsObjectProperties(props);
    let style2 = computed(() => new Style$2(properties));
    const setStyle = (val) => {
      if (styledObj instanceof Draw$1 || styledObj instanceof Modify$1) {
        styledObj.getOverlay().setStyle(val);
        styledObj.value.dispatchEvent("styleChanged");
        return;
      }
      try {
        styledObj.value.setStyle(val);
        styledObj.value.changed();
        styledObj.value.dispatchEvent("styleChanged");
      } catch (error) {
        styledObj.value.style_ = val;
        styledObj.value.values_.style = val;
        styledObj.value.changed();
        styledObj.value.dispatchEvent("styleChanged");
      }
    };
    const styleFunc = computed(() => {
      return (feature2) => {
        if (properties.overrideStyleFunction != null) {
          properties.overrideStyleFunction(feature2, style2.value);
        }
        return style2.value;
      };
    });
    watch(properties, () => {
      if (properties.overrideStyleFunction == null) {
        setStyle(style2.value);
      } else {
        setStyle(styleFunc.value);
      }
    });
    onMounted(() => {
      if (properties.overrideStyleFunction == null) {
        setStyle(style2.value);
      } else {
        setStyle(styleFunc.value);
      }
    });
    onUnmounted(() => {
      setStyle(null);
    });
    provide("style", style2);
    provide("styledObj", styledObj);
    return {
      style: style2
    };
  },
  props: {
    zIndex: {
      type: Number
    },
    overrideStyleFunction: {
      type: Function
    }
  }
};
function _sfc_render$l(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", null, [
    renderSlot(_ctx.$slots, "default")
  ]);
}
var Style = _export_sfc(_sfc_main$l, [["render", _sfc_render$l]]);
var _sfc_main$k = {
  name: "ol-style-circle",
  setup(props) {
    const style2 = inject("style", null);
    const styledObj = inject("styledObj", null);
    const {
      properties
    } = usePropsAsObjectProperties(props);
    const createCircleStyle = (properties2) => {
      return new ol_style_Circle(__spreadProps(__spreadValues({}, properties2), {
        fill: new Fill$2(),
        stroke: new Stroke$2()
      }));
    };
    let circle = computed(() => createCircleStyle(properties));
    const applyStyle = () => {
      style2.value.setImage(null);
      style2.value.setImage(circle.value);
      styledObj.value.changed();
    };
    watch(properties, () => {
      applyStyle();
    });
    watch(style2, () => {
      applyStyle();
    });
    onMounted(() => {
      style2.value.setImage(circle.value);
    });
    onUnmounted(() => {
      style2.value.setImage(null);
    });
    provide("circle", circle);
    provide("styledObj", styledObj);
  },
  props: {
    radius: {
      type: Number
    },
    scale: {
      type: Number
    }
  }
};
function _sfc_render$k(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", null, [
    renderSlot(_ctx.$slots, "default")
  ]);
}
var Circle = _export_sfc(_sfc_main$k, [["render", _sfc_render$k]]);
var _sfc_main$j = {
  name: "ol-style-stroke",
  setup(props) {
    const style2 = inject("style", null);
    const circle = inject("circle", null);
    const styledObj = inject("styledObj", null);
    const {
      properties
    } = usePropsAsObjectProperties(props);
    if (style2 != null && circle == null) {
      let stroke = new Stroke$2(properties);
      style2.value.setStroke(stroke);
      const applyStroke = () => {
        style2.value.setStroke(null);
        stroke = new Stroke$2(properties);
        style2.value.setStroke(stroke);
      };
      watch(properties, () => {
        applyStroke();
      });
      watch(style2, () => {
        applyStroke();
      });
      onMounted(() => {
        style2.value.setStroke(stroke);
      });
      onUnmounted(() => {
        style2.value.setStroke(null);
      });
    } else if (circle != null) {
      const applyStroketoCircle = (properties2) => {
        circle.value.getStroke().setColor(properties2.color);
        circle.value.getStroke().setLineCap(properties2.lineCap);
        circle.value.getStroke().setLineDash(properties2.lineDash);
        circle.value.getStroke().setLineDashOffset(properties2.lineDashOffset);
        circle.value.getStroke().setLineJoin(properties2.lineJoin);
        circle.value.getStroke().setMiterLimit(properties2.miterLimit);
        circle.value.getStroke().setWidth(properties2.width);
        circle.value.setRadius(circle.value.getRadius());
        try {
          styledObj.value.changed();
        } catch (error) {
          styledObj.changed();
        }
      };
      applyStroketoCircle(properties);
      watch(properties, (newVal) => {
        applyStroketoCircle(newVal);
      });
      watch(circle, () => {
        applyStroketoCircle(properties);
      });
    }
  },
  props: {
    color: {
      type: String
    },
    lineCap: {
      type: String,
      default: "round"
    },
    lineJoin: {
      type: String,
      default: "round"
    },
    lineDash: {
      type: Array
    },
    lineDashOffset: {
      type: Number,
      default: 0
    },
    miterLimit: {
      type: Number,
      default: 10
    },
    width: {
      type: Number,
      default: 1
    }
  }
};
function _sfc_render$j(_ctx, _cache, $props, $setup, $data, $options) {
  return createCommentVNode("", true);
}
var Stroke = _export_sfc(_sfc_main$j, [["render", _sfc_render$j]]);
var _sfc_main$i = {
  name: "ol-style-fill",
  setup(props) {
    const style2 = inject("style", null);
    const circle = inject("circle", null);
    const styledObj = inject("styledObj", null);
    const {
      properties
    } = usePropsAsObjectProperties(props);
    if (style2 != null && circle == null) {
      let fill = new Fill$2(properties);
      style2.value.setFill(fill);
      const applyFill = () => {
        style2.value.setFill(null);
        fill = new Fill$2(properties);
        style2.value.setFill(fill);
      };
      watch(properties, () => {
        applyFill();
      });
      watch(style2, () => {
        applyFill();
      });
      onMounted(() => {
        style2.value.setFill(fill);
      });
      onUnmounted(() => {
        style2.value.setFill(null);
      });
    } else if (circle != null) {
      const applyFilltoCircle = (color2) => {
        circle.value.getFill().setColor(color2);
        circle.value.setRadius(circle.value.getRadius());
        try {
          styledObj.value.changed();
        } catch (error) {
          styledObj.changed();
        }
      };
      applyFilltoCircle(properties.color);
      watch(properties, () => {
        applyFilltoCircle(properties.color);
      });
      watch(circle, () => {
        applyFilltoCircle(properties.color);
      });
    }
  },
  props: {
    color: {
      type: String
    }
  }
};
function _sfc_render$i(_ctx, _cache, $props, $setup, $data, $options) {
  return createCommentVNode("", true);
}
var Fill = _export_sfc(_sfc_main$i, [["render", _sfc_render$i]]);
var _sfc_main$h = {
  name: "ol-style-icon",
  setup(props) {
    const style2 = inject("style", null);
    const styledObj = inject("styledObj", null);
    const {
      properties
    } = usePropsAsObjectProperties(props);
    let icon = computed(() => {
      let ic = new Icon$2(properties);
      ic.load();
      return ic;
    });
    const applyStyle = () => {
      style2.value.setImage(null);
      style2.value.setImage(icon.value);
      styledObj.value.changed();
    };
    watch(properties, () => {
      applyStyle();
    });
    watch(style2, () => {
      applyStyle();
    });
    onMounted(() => {
      style2.value.setImage(icon.value);
    });
    onUnmounted(() => {
      style2.value.setImage(null);
    });
  },
  props: {
    anchor: {
      type: Array
    },
    anchorOrigin: {
      type: String,
      default: "top-left"
    },
    anchorXUnits: {
      type: String,
      default: "fraction"
    },
    color: {
      type: String
    },
    crossOrigin: {
      type: String
    },
    img: {
      type: [HTMLImageElement, HTMLCanvasElement]
    },
    offset: {
      type: Array,
      default: () => [0, 0]
    },
    displacement: {
      type: Array,
      default: () => [0, 0]
    },
    offsetOrigin: {
      type: String,
      default: "top-left"
    },
    opacity: {
      type: Number,
      default: 1
    },
    scale: {
      type: Number,
      default: 1
    },
    rotateWithView: {
      type: Boolean,
      default: false
    },
    rotation: {
      type: Number,
      default: 0
    },
    size: {
      type: Array
    },
    imgSize: {
      type: Array
    },
    src: {
      type: String
    }
  }
};
function _sfc_render$h(_ctx, _cache, $props, $setup, $data, $options) {
  return createCommentVNode("", true);
}
var Icon = _export_sfc(_sfc_main$h, [["render", _sfc_render$h]]);
var _sfc_main$g = {
  name: "ol-style-text",
  setup(props) {
    const style2 = inject("style", null);
    const styledObj = inject("styledObj", null);
    const {
      properties
    } = usePropsAsObjectProperties(props);
    const createText = (properties2) => {
      return new Text$2(__spreadProps(__spreadValues({}, properties2), {
        fill: new Fill$2(),
        stroke: new Stroke$2()
      }));
    };
    let text2 = computed(() => createText(properties));
    const applyStyle = () => {
      style2.value.setText(null);
      style2.value.setText(text2.value);
      styledObj.value.changed();
    };
    watch(properties, () => {
      applyStyle();
    });
    watch(style2, () => {
      applyStyle();
    });
    onMounted(() => {
      style2.value.setText(text2.value);
    });
    onUnmounted(() => {
      style2.value.setText(null);
    });
    provide("style", text2);
    provide("styledObj", styledObj);
  },
  props: {
    font: {
      type: String
    },
    maxAngle: {
      type: Number,
      default: Math.PI / 4
    },
    offsetX: {
      type: Number,
      default: 0
    },
    offsetY: {
      type: Number,
      default: 0
    },
    overflow: {
      type: Boolean,
      default: false
    },
    placement: {
      type: String,
      default: "point"
    },
    scale: {
      type: Number
    },
    rotateWithView: {
      type: Boolean,
      default: false
    },
    rotation: {
      type: Number,
      default: 0
    },
    text: {
      type: String
    },
    textAlign: {
      type: String
    },
    textBaseline: {
      type: String,
      default: "middle"
    },
    padding: {
      type: Array,
      default: () => [0, 0, 0, 0]
    }
  }
};
function _sfc_render$g(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", null, [
    renderSlot(_ctx.$slots, "default")
  ]);
}
var Text = _export_sfc(_sfc_main$g, [["render", _sfc_render$g]]);
var ol_coordinate_dist2d = function(p12, p22) {
  var dx = p12[0] - p22[0];
  var dy = p12[1] - p22[1];
  return Math.sqrt(dx * dx + dy * dy);
};
var ol_coordinate_equal = function(p12, p22) {
  return p12[0] == p22[0] && p12[1] == p22[1];
};
var ol_extent_intersection;
(function() {
  function splitX(pts, x2) {
    var pt2;
    for (let i2 = pts.length - 1; i2 > 0; i2--) {
      if (pts[i2][0] > x2 && pts[i2 - 1][0] < x2 || pts[i2][0] < x2 && pts[i2 - 1][0] > x2) {
        pt2 = [x2, (x2 - pts[i2][0]) / (pts[i2 - 1][0] - pts[i2][0]) * (pts[i2 - 1][1] - pts[i2][1]) + pts[i2][1]];
        pts.splice(i2, 0, pt2);
      }
    }
  }
  function splitY(pts, y2) {
    var pt2;
    for (let i2 = pts.length - 1; i2 > 0; i2--) {
      if (pts[i2][1] > y2 && pts[i2 - 1][1] < y2 || pts[i2][1] < y2 && pts[i2 - 1][1] > y2) {
        pt2 = [(y2 - pts[i2][1]) / (pts[i2 - 1][1] - pts[i2][1]) * (pts[i2 - 1][0] - pts[i2][0]) + pts[i2][0], y2];
        pts.splice(i2, 0, pt2);
      }
    }
  }
  ol_extent_intersection = function(extent2, polygon) {
    var poly2 = polygon.getType() === "Polygon";
    if (!poly2 && polygon.getType() !== "MultiPolygon")
      return null;
    var geom2 = polygon.getCoordinates();
    if (poly2)
      geom2 = [geom2];
    geom2.forEach(function(g2) {
      g2.forEach(function(c2) {
        splitX(c2, extent2[0]);
        splitX(c2, extent2[2]);
        splitY(c2, extent2[1]);
        splitY(c2, extent2[3]);
      });
    });
    geom2.forEach(function(g2) {
      g2.forEach(function(c2) {
        c2.forEach(function(p5) {
          if (p5[0] < extent2[0])
            p5[0] = extent2[0];
          else if (p5[0] > extent2[2])
            p5[0] = extent2[2];
          if (p5[1] < extent2[1])
            p5[1] = extent2[1];
          else if (p5[1] > extent2[3])
            p5[1] = extent2[3];
        });
      });
    });
    if (poly2) {
      return new Polygon$2(geom2[0]);
    } else {
      return new MultiPolygon$2(geom2);
    }
  };
})();
var ol_coordinate_sampleAt = function(p12, p22, d2, start2) {
  var pts = [];
  if (start2 !== false)
    pts.push(p12);
  var dl = ol_coordinate_dist2d(p12, p22);
  if (dl) {
    var nb = Math.round(dl / d2);
    if (nb > 1) {
      var dx = (p22[0] - p12[0]) / nb;
      var dy = (p22[1] - p12[1]) / nb;
      for (var i2 = 1; i2 < nb; i2++) {
        pts.push([p12[0] + dx * i2, p12[1] + dy * i2]);
      }
    }
  }
  pts.push(p22);
  return pts;
};
LineString$2.prototype.sampleAt = function(d2) {
  var line = this.getCoordinates();
  var result = [];
  for (var i2 = 1; i2 < line.length; i2++) {
    result = result.concat(ol_coordinate_sampleAt(line[i2 - 1], line[i2], d2, i2 === 1));
  }
  return new LineString$2(result);
};
MultiLineString$2.prototype.sampleAt = function(d2) {
  var lines = this.getCoordinates();
  var result = [];
  lines.forEach(function(p5) {
    var l2 = [];
    for (var i2 = 1; i2 < p5.length; i2++) {
      l2 = l2.concat(ol_coordinate_sampleAt(p5[i2 - 1], p5[i2], d2, i2 === 1));
    }
    result.push(l2);
  });
  return new MultiLineString$2(result);
};
Polygon$2.prototype.sampleAt = function(res) {
  var poly2 = this.getCoordinates();
  var result = [];
  poly2.forEach(function(p5) {
    var l2 = [];
    for (var i2 = 1; i2 < p5.length; i2++) {
      l2 = l2.concat(ol_coordinate_sampleAt(p5[i2 - 1], p5[i2], res, i2 === 1));
    }
    result.push(l2);
  });
  return new Polygon$2(result);
};
MultiPolygon$2.prototype.sampleAt = function(res) {
  var mpoly = this.getCoordinates();
  var result = [];
  mpoly.forEach(function(poly2) {
    var a2 = [];
    result.push(a2);
    poly2.forEach(function(p5) {
      var l2 = [];
      for (var i2 = 1; i2 < p5.length; i2++) {
        l2 = l2.concat(ol_coordinate_sampleAt(p5[i2 - 1], p5[i2], res, i2 === 1));
      }
      a2.push(l2);
    });
  });
  return new MultiPolygon$2(result);
};
ol_geom_Circle.prototype.intersection = function(geom2, resolution) {
  if (geom2.sampleAt) {
    var ext = buffer$1(this.getCenter().concat(this.getCenter()), this.getRadius());
    geom2 = ol_extent_intersection(ext, geom2);
    geom2 = geom2.simplify(resolution);
    var c2 = this.getCenter();
    var r2 = this.getRadius();
    var g2 = geom2.sampleAt(resolution).getCoordinates();
    switch (geom2.getType()) {
      case "Polygon":
        g2 = [g2];
      case "MultiPolygon": {
        var hasout = false;
        var result = [];
        g2.forEach(function(poly2) {
          var a2 = [];
          result.push(a2);
          poly2.forEach(function(ring) {
            var l2 = [];
            a2.push(l2);
            ring.forEach(function(p5) {
              var d2 = ol_coordinate_dist2d(c2, p5);
              if (d2 > r2) {
                hasout = true;
                l2.push([
                  c2[0] + r2 / d2 * (p5[0] - c2[0]),
                  c2[1] + r2 / d2 * (p5[1] - c2[1])
                ]);
              } else {
                l2.push(p5);
              }
            });
          });
        });
        if (!hasout)
          return geom2;
        if (geom2.getType() === "Polygon") {
          return new Polygon$2(result[0]);
        } else {
          return new MultiPolygon$2(result);
        }
      }
    }
  } else {
    console.warn("[ol/geom/Circle~intersection] Unsupported geometry type: " + geom2.getType());
  }
  return geom2;
};
LineString$2.prototype.splitAt = function(pt2, tol) {
  var i2;
  if (!pt2)
    return [this];
  if (!tol)
    tol = 1e-10;
  if (pt2.length && pt2[0].length) {
    var result = [this];
    for (i2 = 0; i2 < pt2.length; i2++) {
      var r2 = [];
      for (var k2 = 0; k2 < result.length; k2++) {
        var ri = result[k2].splitAt(pt2[i2], tol);
        r2 = r2.concat(ri);
      }
      result = r2;
    }
    return result;
  }
  if (ol_coordinate_equal(pt2, this.getFirstCoordinate()) || ol_coordinate_equal(pt2, this.getLastCoordinate())) {
    return [this];
  }
  var c0 = this.getCoordinates();
  var ci = [c0[0]];
  var c2 = [];
  for (i2 = 0; i2 < c0.length - 1; i2++) {
    if (ol_coordinate_equal(c0[i2], c0[i2 + 1]))
      continue;
    if (ol_coordinate_equal(pt2, c0[i2 + 1])) {
      ci.push(c0[i2 + 1]);
      c2.push(new LineString$2(ci));
      ci = [];
    } else if (!ol_coordinate_equal(pt2, c0[i2])) {
      var d1, d2, split2 = false;
      if (c0[i2][0] == c0[i2 + 1][0]) {
        d1 = (c0[i2][1] - pt2[1]) / (c0[i2][1] - c0[i2 + 1][1]);
        split2 = c0[i2][0] == pt2[0] && (0 < d1 && d1 <= 1);
      } else if (c0[i2][1] == c0[i2 + 1][1]) {
        d1 = (c0[i2][0] - pt2[0]) / (c0[i2][0] - c0[i2 + 1][0]);
        split2 = c0[i2][1] == pt2[1] && (0 < d1 && d1 <= 1);
      } else {
        d1 = (c0[i2][0] - pt2[0]) / (c0[i2][0] - c0[i2 + 1][0]);
        d2 = (c0[i2][1] - pt2[1]) / (c0[i2][1] - c0[i2 + 1][1]);
        split2 = Math.abs(d1 - d2) <= tol && 0 < d1 && d1 <= 1;
      }
      if (split2) {
        ci.push(pt2);
        c2.push(new LineString$2(ci));
        ci = [pt2];
      }
    }
    ci.push(c0[i2 + 1]);
  }
  if (ci.length > 1)
    c2.push(new LineString$2(ci));
  if (c2.length)
    return c2;
  else
    return [this];
};
var ol_style_FlowLine = function(options) {
  if (!options)
    options = {};
  Style$2.call(this, {
    renderer: this._render.bind(this),
    stroke: options.stroke,
    text: options.text,
    zIndex: options.zIndex,
    geometry: options.geometry
  });
  this._visible = options.visible !== false;
  if (typeof options.width === "function") {
    this._widthFn = options.width;
  } else {
    this.setWidth(options.width);
  }
  this.setWidth2(options.width2);
  if (typeof options.color === "function") {
    this._colorFn = options.color;
  } else {
    this.setColor(options.color);
  }
  this.setColor2(options.color2);
  this.setLineCap(options.lineCap);
  this.setArrow(options.arrow);
  this.setArrowSize(options.arrowSize);
  this.setArrowColor(options.arrowColor);
  this._offset = [0, 0];
  this.setOffset(options.offset0, 0);
  this.setOffset(options.offset1, 1);
  this._noOverlap = options.noOverlap;
};
ol_ext_inherits(ol_style_FlowLine, Style$2);
ol_style_FlowLine.prototype.setWidth = function(width) {
  this._width = width || 0;
};
ol_style_FlowLine.prototype.setWidth2 = function(width) {
  this._width2 = width;
};
ol_style_FlowLine.prototype.getOffset = function(where) {
  return this._offset[where];
};
ol_style_FlowLine.prototype.setOffset = function(width, where) {
  width = Math.max(0, parseFloat(width));
  switch (where) {
    case 0: {
      this._offset[0] = width;
      break;
    }
    case 1: {
      this._offset[1] = width;
      break;
    }
  }
};
ol_style_FlowLine.prototype.setLineCap = function(cap) {
  this._lineCap = cap === "round" ? "round" : "butt";
};
ol_style_FlowLine.prototype.getWidth = function(feature2, step) {
  if (this._widthFn)
    return this._widthFn(feature2, step);
  var w2 = typeof this._width2 === "number" ? this._width2 : this._width;
  return this._width + (w2 - this._width) * step;
};
ol_style_FlowLine.prototype.setColor = function(color2) {
  try {
    this._color = asArray(color2);
  } catch (e2) {
    this._color = [0, 0, 0, 1];
  }
};
ol_style_FlowLine.prototype.setColor2 = function(color2) {
  try {
    this._color2 = asArray(color2);
  } catch (e2) {
    this._color2 = null;
  }
};
ol_style_FlowLine.prototype.setArrowColor = function(color2) {
  try {
    this._acolor = asString$1(color2);
  } catch (e2) {
    this._acolor = null;
  }
};
ol_style_FlowLine.prototype.getColor = function(feature2, step) {
  if (this._colorFn)
    return asString$1(this._colorFn(feature2, step));
  var color2 = this._color;
  var color22 = this._color2 || this._color;
  return "rgba(" + +Math.round(color2[0] + (color22[0] - color2[0]) * step) + "," + Math.round(color2[1] + (color22[1] - color2[1]) * step) + "," + Math.round(color2[2] + (color22[2] - color2[2]) * step) + "," + (color2[3] + (color22[3] - color2[3]) * step) + ")";
};
ol_style_FlowLine.prototype.getArrow = function() {
  return this._arrow;
};
ol_style_FlowLine.prototype.setArrow = function(n2) {
  this._arrow = parseInt(n2);
  if (this._arrow < -1 || this._arrow > 2)
    this._arrow = 0;
};
ol_style_FlowLine.prototype.getArrowSize = function() {
  return this._arrowSize || [16, 16];
};
ol_style_FlowLine.prototype.setArrowSize = function(size) {
  if (Array.isArray(size))
    this._arrowSize = size;
  else if (typeof size === "number")
    this._arrowSize = [size, size];
};
ol_style_FlowLine.prototype.drawArrow = function(ctx, p0, p12, width, ratio) {
  var asize = this.getArrowSize()[0] * ratio;
  var l2 = ol_coordinate_dist2d(p0, p12);
  var dx = (p0[0] - p12[0]) / l2;
  var dy = (p0[1] - p12[1]) / l2;
  width = Math.max(this.getArrowSize()[1] / 2, width / 2) * ratio;
  ctx.beginPath();
  ctx.moveTo(p0[0], p0[1]);
  ctx.lineTo(p0[0] - asize * dx + width * dy, p0[1] - asize * dy - width * dx);
  ctx.lineTo(p0[0] - asize * dx - width * dy, p0[1] - asize * dy + width * dx);
  ctx.lineTo(p0[0], p0[1]);
  ctx.fill();
};
ol_style_FlowLine.prototype._render = function(geom2, e2) {
  if (e2.geometry.getType() === "LineString") {
    var i2, g2, p5, ctx = e2.context;
    if (!this._visible) {
      var a2 = e2.pixelRatio / e2.resolution;
      var cos = Math.cos(e2.rotation);
      var sin = Math.sin(e2.rotation);
      g2 = e2.geometry.getCoordinates();
      var dx = geom2[0][0] - g2[0][0] * a2 * cos - g2[0][1] * a2 * sin;
      var dy = geom2[0][1] - g2[0][0] * a2 * sin + g2[0][1] * a2 * cos;
      geom2 = [];
      for (i2 = 0; p5 = g2[i2]; i2++) {
        geom2[i2] = [
          dx + p5[0] * a2 * cos + p5[1] * a2 * sin,
          dy + p5[0] * a2 * sin - p5[1] * a2 * cos,
          p5[2]
        ];
      }
    }
    var asize = this.getArrowSize()[0] * e2.pixelRatio;
    ctx.save();
    if (this.getOffset(0))
      this._splitAsize(geom2, this.getOffset(0) * e2.pixelRatio);
    if (this.getOffset(1))
      this._splitAsize(geom2, this.getOffset(1) * e2.pixelRatio, true);
    if (geom2.length > 1 && (this.getArrow() === -1 || this.getArrow() === 2)) {
      p5 = this._splitAsize(geom2, asize);
      if (this._acolor)
        ctx.fillStyle = this._acolor;
      else
        ctx.fillStyle = this.getColor(e2.feature, 0);
      this.drawArrow(ctx, p5[0], p5[1], this.getWidth(e2.feature, 0), e2.pixelRatio);
    }
    if (geom2.length > 1 && this.getArrow() > 0) {
      p5 = this._splitAsize(geom2, asize, true);
      if (this._acolor)
        ctx.fillStyle = this._acolor;
      else
        ctx.fillStyle = this.getColor(e2.feature, 1);
      this.drawArrow(ctx, p5[0], p5[1], this.getWidth(e2.feature, 1), e2.pixelRatio);
    }
    var geoms = this._splitInto(geom2, 255, 2);
    var k2 = 0;
    var nb = geoms.length;
    ctx.lineJoin = "round";
    ctx.lineCap = this._lineCap || "butt";
    if (geoms.length > 1) {
      for (k2 = 0; k2 < geoms.length; k2++) {
        var step = k2 / nb;
        g2 = geoms[k2];
        ctx.lineWidth = this.getWidth(e2.feature, step) * e2.pixelRatio;
        ctx.strokeStyle = this.getColor(e2.feature, step);
        ctx.beginPath();
        ctx.moveTo(g2[0][0], g2[0][1]);
        for (i2 = 1; p5 = g2[i2]; i2++) {
          ctx.lineTo(p5[0], p5[1]);
        }
        ctx.stroke();
      }
    }
    ctx.restore();
  }
};
ol_style_FlowLine.prototype._splitAsize = function(geom2, asize, end) {
  var p5, p12, p0;
  var dl, d2 = 0;
  if (end)
    p0 = geom2.pop();
  else
    p0 = geom2.shift();
  p5 = p0;
  while (geom2.length) {
    if (end)
      p12 = geom2.pop();
    else
      p12 = geom2.shift();
    dl = ol_coordinate_dist2d(p5, p12);
    if (d2 + dl > asize) {
      p5 = [p5[0] + (p12[0] - p5[0]) * (asize - d2) / dl, p5[1] + (p12[1] - p5[1]) * (asize - d2) / dl];
      dl = ol_coordinate_dist2d(p5, p0);
      if (end) {
        geom2.push(p12);
        geom2.push(p5);
        geom2.push([p5[0] + (p0[0] - p5[0]) / dl, p5[1] + (p0[1] - p5[1]) / dl]);
      } else {
        geom2.unshift(p12);
        geom2.unshift(p5);
        geom2.unshift([p5[0] + (p0[0] - p5[0]) / dl, p5[1] + (p0[1] - p5[1]) / dl]);
      }
      break;
    }
    d2 += dl;
    p5 = p12;
  }
  return [p0, p5];
};
ol_style_FlowLine.prototype._splitInto = function(geom2, nb, min2) {
  var i2, p5;
  var dt2 = this._noOverlap ? 1 : 0.9;
  var geoms = [];
  var dl, l2 = 0;
  for (i2 = 1; p5 = geom2[i2]; i2++) {
    l2 += ol_coordinate_dist2d(geom2[i2 - 1], p5);
  }
  var length = Math.max(min2 || 2, l2 / (nb || 255));
  var p0 = geom2[0];
  l2 = 0;
  var g2 = [p0];
  i2 = 1;
  p5 = geom2[1];
  while (i2 < geom2.length) {
    var dx = p5[0] - p0[0];
    var dy = p5[1] - p0[1];
    dl = Math.sqrt(dx * dx + dy * dy);
    if (l2 + dl > length) {
      var d2 = (length - l2) / dl;
      g2.push([
        p0[0] + dx * d2,
        p0[1] + dy * d2
      ]);
      geoms.push(g2);
      p0 = [
        p0[0] + dx * d2 * dt2,
        p0[1] + dy * d2 * dt2
      ];
      g2 = [p0];
      l2 = 0;
    } else {
      l2 += dl;
      p0 = p5;
      g2.push(p0);
      i2++;
      p5 = geom2[i2];
    }
  }
  geoms.push(g2);
  return geoms;
};
var _sfc_main$f = {
  name: "ol-style-flowline",
  setup(props) {
    const styledObj = inject("stylable", null);
    const {
      properties
    } = usePropsAsObjectProperties(props);
    let style2 = computed(() => new ol_style_FlowLine(properties));
    const setStyle = (val) => {
      if (styledObj instanceof Draw$1 || styledObj instanceof Modify$1) {
        styledObj.getOverlay().setStyle(val);
        styledObj.value.dispatchEvent("styleChanged");
        return;
      }
      try {
        styledObj.value.setStyle(val);
        styledObj.value.changed();
        styledObj.value.dispatchEvent("styleChanged");
      } catch (error) {
        styledObj.value.style_ = val;
        styledObj.value.values_.style = val;
        styledObj.value.changed();
        styledObj.value.dispatchEvent("styleChanged");
      }
    };
    const styleFunc = computed(() => {
      return (feature2) => {
        if (properties.overrideStyleFunction != null) {
          properties.overrideStyleFunction(feature2, style2.value);
        }
        return style2.value;
      };
    });
    watch(properties, () => {
      if (properties.overrideStyleFunction == null) {
        setStyle(style2.value);
      } else {
        setStyle(styleFunc.value);
      }
    });
    onMounted(() => {
      if (properties.overrideStyleFunction == null) {
        setStyle(style2.value);
      } else {
        setStyle(styleFunc.value);
      }
    });
    onUnmounted(() => {
      setStyle(null);
    });
    return {
      style: style2
    };
  },
  props: {
    color: {
      type: [String, Function]
    },
    color2: {
      type: String
    },
    width: {
      type: [Number, Function]
    },
    width2: {
      type: Number
    },
    arrow: {
      type: Number
    },
    arrowColor: {
      type: String
    }
  }
};
function _sfc_render$f(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", null, [
    renderSlot(_ctx.$slots, "default")
  ]);
}
var FlowLine = _export_sfc(_sfc_main$f, [["render", _sfc_render$f]]);
function install$3(app) {
  if (install$3.installed) {
    return;
  }
  install$3.installed = true;
  app.component(Style.name, Style);
  app.component(Circle.name, Circle);
  app.component(Stroke.name, Stroke);
  app.component(Fill.name, Fill);
  app.component(Icon.name, Icon);
  app.component(Text.name, Text);
  app.component(FlowLine.name, FlowLine);
}
var Styles = Object.freeze(Object.defineProperty({
  __proto__: null,
  "default": install$3,
  install: install$3,
  Style,
  Stroke,
  Fill,
  Icon,
  Text,
  FlowLine,
  Circle
}, Symbol.toStringTag, { value: "Module" }));
var _sfc_main$e = {
  name: "ol-interaction-select",
  emits: ["select"],
  setup(props, {
    emit
  }) {
    const map = inject("map");
    const {
      properties
    } = usePropsAsObjectProperties(props);
    let select = computed(() => {
      let s2 = new ol_interaction_Select(__spreadProps(__spreadValues({}, properties), {
        style: new Style$2()
      }));
      s2.on("select", (event) => {
        emit("select", event);
      });
      return s2;
    });
    watch(select, (newVal, oldVal) => {
      map.removeInteraction(oldVal);
      map.addInteraction(newVal);
      map.changed();
    });
    onMounted(() => {
      map.addInteraction(select.value);
    });
    onUnmounted(() => {
      map.removeInteraction(select.value);
    });
    provide("stylable", select);
    return {
      select
    };
  },
  props: {
    multi: {
      type: Boolean,
      default: false
    },
    condition: {
      type: Function
    },
    filter: {
      type: Function
    },
    features: {
      type: [ol_Collection, Object]
    },
    hitTolerance: {
      type: Number,
      default: 0,
      validator: (value) => value >= 0
    }
  }
};
function _sfc_render$e(_ctx, _cache, $props, $setup, $data, $options) {
  return renderSlot(_ctx.$slots, "default");
}
var SelectInteraction = _export_sfc(_sfc_main$e, [["render", _sfc_render$e]]);
var ol_interaction_SelectCluster = function(options) {
  options = options || {};
  this.pointRadius = options.pointRadius || 12;
  this.circleMaxObjects = options.circleMaxObjects || 10;
  this.maxObjects = options.maxObjects || 60;
  this.spiral = options.spiral !== false;
  this.animate = options.animate;
  this.animationDuration = options.animationDuration || 500;
  this.selectCluster_ = options.selectCluster !== false;
  this._autoClose = options.autoClose !== false;
  var overlay = this.overlayLayer_ = new ol_layer_Vector({
    source: new ol_source_Vector({
      features: new ol_Collection(),
      wrapX: options.wrapX,
      useSpatialIndex: true
    }),
    name: "Cluster overlay",
    updateWhileAnimating: true,
    updateWhileInteracting: true,
    displayInLayerSwitcher: false,
    style: options.featureStyle
  });
  if (options.layers) {
    if (typeof options.layers == "function") {
      var fnLayers = options.layers;
      options.layers = function(layer) {
        return layer === overlay || fnLayers(layer);
      };
    } else if (options.layers.push) {
      options.layers.push(this.overlayLayer_);
    }
  }
  if (options.filter) {
    var fnFilter = options.filter;
    options.filter = function(f2, l2) {
      if (!l2 && f2.get("selectclusterlink"))
        return false;
      else
        return fnFilter(f2, l2);
    };
  } else
    options.filter = function(f2, l2) {
      if (!l2 && f2.get("selectclusterlink"))
        return false;
      else
        return true;
    };
  this.filter_ = options.filter;
  if (!this._autoClose && !options.toggleCondition) {
    options.toggleCondition = singleClick;
  }
  ol_interaction_Select.call(this, options);
  this.on("select", this.selectCluster.bind(this));
};
ol_ext_inherits(ol_interaction_SelectCluster, ol_interaction_Select);
ol_interaction_SelectCluster.prototype.setMap = function(map) {
  if (this.getMap()) {
    this.getMap().removeLayer(this.overlayLayer_);
  }
  if (this._listener)
    unByKey(this._listener);
  this._listener = null;
  ol_interaction_Select.prototype.setMap.call(this, map);
  this.overlayLayer_.setMap(map);
  if (map && map.getView()) {
    this._listener = map.getView().on("change:resolution", this.clear.bind(this));
  }
};
ol_interaction_SelectCluster.prototype.clear = function() {
  this.getFeatures().clear();
  this.overlayLayer_.getSource().clear();
};
ol_interaction_SelectCluster.prototype.getLayer = function() {
  return this.overlayLayer_;
};
ol_interaction_SelectCluster.prototype.selectCluster = function(e2) {
  if (e2 instanceof feature) {
    e2 = { selected: [e2] };
  }
  if (!e2.selected.length) {
    if (this._autoClose) {
      this.clear();
    } else {
      const deselectedFeatures = e2.deselected;
      deselectedFeatures.forEach((deselectedFeature) => {
        const selectClusterFeatures = deselectedFeature.get("selectcluserfeatures");
        selectClusterFeatures.forEach((selectClusterFeature) => {
          this.overlayLayer_.getSource().removeFeature(selectClusterFeature);
        });
      });
    }
    return;
  }
  var feature$1 = e2.selected[0];
  if (feature$1.get("selectclusterfeature"))
    return;
  var source = this.overlayLayer_.getSource();
  if (this._autoClose) {
    source.clear();
  }
  var cluster = feature$1.get("features");
  if (!cluster || cluster.length == 1)
    return;
  if (!this.selectCluster_)
    this.getFeatures().clear();
  var center = feature$1.getGeometry().getCoordinates();
  var pix = this.getMap().getView().getResolution();
  var r2, a2, i2, max2;
  var p5, cf, lk;
  var features = [];
  if (!this.spiral || cluster.length <= this.circleMaxObjects) {
    max2 = Math.min(cluster.length, this.circleMaxObjects);
    r2 = pix * this.pointRadius * (0.5 + max2 / 4);
    for (i2 = 0; i2 < max2; i2++) {
      a2 = 2 * Math.PI * i2 / max2;
      if (max2 == 2 || max2 == 4)
        a2 += Math.PI / 4;
      p5 = [center[0] + r2 * Math.sin(a2), center[1] + r2 * Math.cos(a2)];
      cf = new feature({ "selectclusterfeature": true, "features": [cluster[i2]], geometry: new Point$4(p5) });
      cf.setStyle(cluster[i2].getStyle());
      features.push(cf);
      lk = new feature({ "selectclusterlink": true, geometry: new LineString$2([center, p5]) });
      features.push(lk);
    }
  } else {
    a2 = 0;
    var d2 = 2 * this.pointRadius;
    max2 = Math.min(this.maxObjects, cluster.length);
    for (i2 = 0; i2 < max2; i2++) {
      r2 = d2 / 2 + d2 * a2 / (2 * Math.PI);
      a2 = a2 + (d2 + 0.1) / r2;
      var dx = pix * r2 * Math.sin(a2);
      var dy = pix * r2 * Math.cos(a2);
      p5 = [center[0] + dx, center[1] + dy];
      cf = new feature({ "selectclusterfeature": true, "features": [cluster[i2]], geometry: new Point$4(p5) });
      cf.setStyle(cluster[i2].getStyle());
      features.push(cf);
      lk = new feature({ "selectclusterlink": true, geometry: new LineString$2([center, p5]) });
      features.push(lk);
    }
  }
  feature$1.set("selectcluserfeatures", features);
  if (this.animate) {
    this.animateCluster_(center, features);
  } else {
    source.addFeatures(features);
  }
};
ol_interaction_SelectCluster.prototype.animateCluster_ = function(center, features) {
  if (this.listenerKey_) {
    unByKey(this.listenerKey_);
  }
  if (!features.length)
    return;
  var style2 = this.overlayLayer_.getStyle();
  var stylefn = typeof style2 == "function" ? style2 : style2.length ? function() {
    return style2;
  } : function() {
    return [style2];
  };
  var duration2 = this.animationDuration || 500;
  var start2 = new Date().getTime();
  function animate(event) {
    var vectorContext = event.vectorContext || getVectorContext(event);
    var ratio = event.frameState.pixelRatio;
    var res = this.getMap().getView().getResolution();
    var e2 = easeOut((event.frameState.time - start2) / duration2);
    for (var i2 = 0, feature2; feature2 = features[i2]; i2++)
      if (feature2.get("features")) {
        var pt2 = feature2.getGeometry().getCoordinates();
        pt2[0] = center[0] + e2 * (pt2[0] - center[0]);
        pt2[1] = center[1] + e2 * (pt2[1] - center[1]);
        var geo = new Point$4(pt2);
        var st2 = stylefn(feature2, res);
        for (var s2 = 0; s2 < st2.length; s2++) {
          var sc;
          var imgs = ol_Map.prototype.getFeaturesAtPixel ? false : st2[s2].getImage();
          if (imgs) {
            sc = imgs.getScale();
            imgs.setScale(ratio);
          }
          if (vectorContext.setStyle) {
            vectorContext.setStyle(st2[s2]);
            vectorContext.drawGeometry(geo);
          } else {
            vectorContext.setImageStyle(imgs);
            vectorContext.drawPointGeometry(geo);
          }
          if (imgs)
            imgs.setScale(sc);
        }
      }
    if (e2 > 1) {
      unByKey(this.listenerKey_);
      this.overlayLayer_.getSource().addFeatures(features);
      this.overlayLayer_.changed();
      return;
    }
    event.frameState.animate = true;
  }
  this.listenerKey_ = this.overlayLayer_.on(["postcompose", "postrender"], animate.bind(this));
  var feature$1 = new feature(new Point$4(this.getMap().getView().getCenter()));
  feature$1.setStyle(new Style$2({ image: new ol_style_Circle({}) }));
  this.overlayLayer_.getSource().addFeature(feature$1);
};
ol_interaction_SelectCluster.prototype.getClusterExtent = function(feature2) {
  if (!feature2.get("features"))
    return null;
  var extent2 = createEmpty();
  feature2.get("features").forEach(function(f2) {
    extent2 = extend$2(extent2, f2.getGeometry().getExtent());
  });
  if (extent2[0] === extent2[2] && extent2[1] === extent2[3])
    return null;
  return extent2;
};
var _sfc_main$d = {
  name: "ol-interaction-clusterselect",
  emits: ["select"],
  setup(props, {
    emit
  }) {
    const map = inject("map");
    const {
      properties
    } = usePropsAsObjectProperties(props);
    let select = computed(() => {
      let s2 = new ol_interaction_SelectCluster(__spreadProps(__spreadValues({}, properties), {
        style: new Style$2()
      }));
      s2.on("select", (event) => {
        emit("select", event);
      });
      return s2;
    });
    watch(select, (newVal, oldVal) => {
      map.removeInteraction(oldVal);
      map.addInteraction(newVal);
      map.changed();
    });
    onMounted(() => {
      map.addInteraction(select.value);
    });
    onUnmounted(() => {
      map.removeInteraction(select.value);
    });
    provide("stylable", select);
  },
  props: {
    multi: {
      type: Boolean,
      default: false
    },
    condition: {
      type: Function
    },
    filter: {
      type: Function
    },
    pointRadius: {
      type: Number,
      default: 7
    },
    animate: {
      type: Boolean,
      default: true
    },
    featureStyle: {
      type: Function
    },
    style: {
      type: Function
    }
  }
};
function _sfc_render$d(_ctx, _cache, $props, $setup, $data, $options) {
  return renderSlot(_ctx.$slots, "default");
}
var ClusterSelectInteraction = _export_sfc(_sfc_main$d, [["render", _sfc_render$d]]);
var _sfc_main$c = {
  name: "ol-interaction-draw",
  emits: ["drawstart", "drawend"],
  setup(props, {
    emit
  }) {
    const map = inject("map");
    const source = inject("vectorSource");
    const {
      type,
      clickTolerance,
      dragVertexDelay,
      snapTolerance,
      stopClick,
      maxPoints,
      minPoints,
      finishCondition,
      geometryFunction,
      geometryName,
      condition,
      freehand,
      freehandCondition,
      wrapX: wrapX2
    } = toRefs(props);
    let createDraw = () => {
      let draw2 = new Draw$1({
        source: source.value,
        type: type.value,
        clickTolerance: clickTolerance.value,
        dragVertexDelay: dragVertexDelay.value,
        snapTolerance: snapTolerance.value,
        stopClick: stopClick.value,
        maxPoints: maxPoints.value,
        minPoints: minPoints.value,
        finishCondition: finishCondition.value,
        geometryFunction: geometryFunction.value,
        geometryName: geometryName.value,
        condition: condition.value,
        freehand: freehand.value,
        freehandCondition: freehandCondition.value,
        wrapX: wrapX2.value
      });
      draw2.on("drawstart", (event) => {
        emit("drawstart", event);
      });
      draw2.on("drawend", (event) => {
        emit("drawend", event);
      });
      return draw2;
    };
    let draw = createDraw();
    watch([
      type,
      clickTolerance,
      dragVertexDelay,
      snapTolerance,
      stopClick,
      maxPoints,
      minPoints,
      finishCondition,
      geometryFunction,
      geometryName,
      condition,
      freehand,
      freehandCondition,
      wrapX2
    ], () => {
      map.removeInteraction(draw);
      draw = createDraw();
      map.addInteraction(draw);
      draw.changed();
      map.changed();
    });
    onMounted(() => {
      map.addInteraction(draw);
    });
    onUnmounted(() => {
      map.removeInteraction(draw);
    });
    provide("stylable", draw);
  },
  props: {
    type: {
      type: String,
      required: true
    },
    clickTolerance: {
      type: Number,
      default: 6
    },
    dragVertexDelay: {
      type: Number,
      default: 500
    },
    snapTolerance: {
      type: Number,
      default: 12
    },
    stopClick: {
      type: Boolean,
      default: false
    },
    maxPoints: {
      type: Number
    },
    minPoints: {
      type: Number
    },
    finishCondition: {
      type: Function
    },
    geometryFunction: {
      type: Function
    },
    geometryName: {
      type: String
    },
    condition: {
      type: Function
    },
    freehand: {
      type: Boolean,
      default: false
    },
    freehandCondition: {
      type: Function
    },
    wrapX: {
      type: Boolean,
      default: false
    }
  }
};
function _sfc_render$c(_ctx, _cache, $props, $setup, $data, $options) {
  return renderSlot(_ctx.$slots, "default");
}
var DrawInteraction = _export_sfc(_sfc_main$c, [["render", _sfc_render$c]]);
var _sfc_main$b = {
  name: "ol-interaction-snap",
  setup(props) {
    const map = inject("map");
    const source = inject("vectorSource");
    const {
      properties
    } = usePropsAsObjectProperties(props);
    let createSnap = () => {
      let s2 = new Snap$1(__spreadProps(__spreadValues({}, properties), {
        source: source.value
      }));
      return s2;
    };
    let snap2 = createSnap();
    watch(properties, () => {
      map.removeInteraction(snap2);
      snap2 = createSnap();
      map.addInteraction(snap2);
      map.changed();
    });
    onMounted(() => {
      map.addInteraction(snap2);
    });
    onUnmounted(() => {
      map.removeInteraction(snap2);
    });
  },
  props: {
    vertex: {
      type: Boolean,
      default: true
    },
    edge: {
      type: Boolean,
      default: true
    },
    pixelTolerance: {
      type: Number,
      default: 10
    }
  }
};
function _sfc_render$b(_ctx, _cache, $props, $setup, $data, $options) {
  return renderSlot(_ctx.$slots, "default");
}
var SnapInteraction = _export_sfc(_sfc_main$b, [["render", _sfc_render$b]]);
var _sfc_main$a = {
  name: "ol-interaction-modify",
  emits: ["modifystart", "modifyend"],
  setup(props, {
    emit
  }) {
    const map = inject("map");
    const source = inject("vectorSource");
    const {
      features,
      condition,
      deleteCondition,
      insertVertexCondition,
      pixelTolerance,
      wrapX: wrapX2,
      hitDetection
    } = toRefs(props);
    let createModify = () => {
      let modify2 = new Modify$1({
        source: source.value,
        features: features.value,
        condition: condition.value,
        deleteCondition: deleteCondition.value,
        insertVertexCondition: insertVertexCondition.value,
        pixelTolerance: pixelTolerance.value,
        wrapX: wrapX2.value,
        hitDetection: hitDetection.value
      });
      modify2.on("modifystart", (event) => {
        emit("modifystart", event);
      });
      modify2.on("modifyend", (event) => {
        emit("modifyend", event);
      });
      return modify2;
    };
    let modify = createModify();
    watch([
      condition,
      deleteCondition,
      insertVertexCondition,
      pixelTolerance,
      wrapX2,
      hitDetection
    ], () => {
      map.removeInteraction(modify);
      modify = createModify();
      map.addInteraction(modify);
      modify.changed();
      map.changed();
    });
    onMounted(() => {
      map.addInteraction(modify);
    });
    onUnmounted(() => {
      map.removeInteraction(modify);
    });
    provide("stylable", modify);
  },
  props: {
    condition: {
      type: Function
    },
    deleteCondition: {
      type: Function
    },
    insertVertexCondition: {
      type: Function
    },
    pixelTolerance: {
      type: Number,
      default: 10
    },
    wrapX: {
      type: Boolean,
      default: false
    },
    hitDetection: {
      type: Boolean
    },
    features: {
      type: [ol_Collection, Object]
    }
  }
};
function _sfc_render$a(_ctx, _cache, $props, $setup, $data, $options) {
  return renderSlot(_ctx.$slots, "default");
}
var ModifyInteraction = _export_sfc(_sfc_main$a, [["render", _sfc_render$a]]);
var ol_interaction_Transform = function(options) {
  if (!options)
    options = {};
  var self2 = this;
  this.selection_ = new ol_Collection();
  this.handles_ = new ol_Collection();
  this.overlayLayer_ = new ol_layer_Vector({
    source: new ol_source_Vector({
      features: this.handles_,
      useSpatialIndex: false,
      wrapX: false
    }),
    name: "Transform overlay",
    displayInLayerSwitcher: false,
    style: function(feature2) {
      return self2.style[(feature2.get("handle") || "default") + (feature2.get("constraint") || "") + (feature2.get("option") || "")];
    }
  });
  ol_interaction_Pointer.call(this, {
    handleDownEvent: this.handleDownEvent_,
    handleDragEvent: this.handleDragEvent_,
    handleMoveEvent: this.handleMoveEvent_,
    handleUpEvent: this.handleUpEvent_
  });
  this.features_ = options.features;
  if (typeof options.filter === "function")
    this._filter = options.filter;
  this.layers_ = options.layers ? options.layers instanceof Array ? options.layers : [options.layers] : null;
  this._handleEvent = options.condition || function() {
    return true;
  };
  this.addFn_ = options.addCondition || function() {
    return false;
  };
  this.set("translateFeature", options.translateFeature !== false);
  this.set("translate", options.translate !== false);
  this.set("translateBBox", options.translateBBox === true);
  this.set("stretch", options.stretch !== false);
  this.set("scale", options.scale !== false);
  this.set("rotate", options.rotate !== false);
  this.set("keepAspectRatio", options.keepAspectRatio || function(e2) {
    return e2.originalEvent.shiftKey;
  });
  this.set("modifyCenter", options.modifyCenter || function(e2) {
    return e2.originalEvent.metaKey || e2.originalEvent.ctrlKey;
  });
  this.set("noFlip", options.noFlip || false);
  this.set("selection", options.selection !== false);
  this.set("hitTolerance", options.hitTolerance || 0);
  this.set("enableRotatedTransform", options.enableRotatedTransform || false);
  this.set("keepRectangle", options.keepRectangle || false);
  this.on("propertychange", function() {
    this.drawSketch_();
  });
  this.setDefaultStyle();
};
ol_ext_inherits(ol_interaction_Transform, ol_interaction_Pointer);
ol_interaction_Transform.prototype.Cursors = {
  "default": "auto",
  "select": "pointer",
  "translate": "move",
  "rotate": "move",
  "rotate0": "move",
  "scale": "nesw-resize",
  "scale1": "nwse-resize",
  "scale2": "nesw-resize",
  "scale3": "nwse-resize",
  "scalev": "ew-resize",
  "scaleh1": "ns-resize",
  "scalev2": "ew-resize",
  "scaleh3": "ns-resize"
};
ol_interaction_Transform.prototype.setMap = function(map) {
  var oldMap = this.getMap();
  if (oldMap) {
    var targetElement = oldMap.getTargetElement();
    oldMap.removeLayer(this.overlayLayer_);
    if (this.previousCursor_ && targetElement) {
      targetElement.style.cursor = this.previousCursor_;
    }
    this.previousCursor_ = void 0;
  }
  ol_interaction_Pointer.prototype.setMap.call(this, map);
  this.overlayLayer_.setMap(map);
  if (map === null) {
    this.select(null);
  }
  if (map !== null) {
    this.isTouch = /touch/.test(map.getViewport().className);
    this.setDefaultStyle();
  }
};
ol_interaction_Transform.prototype.setActive = function(b2) {
  this.select(null);
  this.overlayLayer_.setVisible(b2);
  ol_interaction_Pointer.prototype.setActive.call(this, b2);
};
ol_interaction_Transform.prototype.setDefaultStyle = function(options) {
  options = options || {};
  var stroke = options.pointStroke || new Stroke$2({ color: [255, 0, 0, 1], width: 1 });
  var strokedash = options.stroke || new Stroke$2({ color: [255, 0, 0, 1], width: 1, lineDash: [4, 4] });
  var fill0 = options.fill || new Fill$2({ color: [255, 0, 0, 0.01] });
  var fill = options.pointFill || new Fill$2({ color: [255, 255, 255, 0.8] });
  var circle = new ol_style_RegularShape({
    fill,
    stroke,
    radius: this.isTouch ? 12 : 6,
    displacement: this.isTouch ? [24, -24] : [12, -12],
    points: 15
  });
  if (!circle.setDisplacement)
    circle.getAnchor()[0] = this.isTouch ? -10 : -5;
  var bigpt = new ol_style_RegularShape({
    fill,
    stroke,
    radius: this.isTouch ? 16 : 8,
    points: 4,
    angle: Math.PI / 4
  });
  var smallpt = new ol_style_RegularShape({
    fill,
    stroke,
    radius: this.isTouch ? 12 : 6,
    points: 4,
    angle: Math.PI / 4
  });
  function createStyle(img, stroke2, fill2) {
    return [new Style$2({ image: img, stroke: stroke2, fill: fill2 })];
  }
  this.style = {
    "default": createStyle(bigpt, strokedash, fill0),
    "translate": createStyle(bigpt, stroke, fill),
    "rotate": createStyle(circle, stroke, fill),
    "rotate0": createStyle(bigpt, stroke, fill),
    "scale": createStyle(bigpt, stroke, fill),
    "scale1": createStyle(bigpt, stroke, fill),
    "scale2": createStyle(bigpt, stroke, fill),
    "scale3": createStyle(bigpt, stroke, fill),
    "scalev": createStyle(smallpt, stroke, fill),
    "scaleh1": createStyle(smallpt, stroke, fill),
    "scalev2": createStyle(smallpt, stroke, fill),
    "scaleh3": createStyle(smallpt, stroke, fill)
  };
  this.drawSketch_();
};
ol_interaction_Transform.prototype.setStyle = function(style2, olstyle) {
  if (!olstyle)
    return;
  if (olstyle instanceof Array)
    this.style[style2] = olstyle;
  else
    this.style[style2] = [olstyle];
  for (var i2 = 0; i2 < this.style[style2].length; i2++) {
    var im = this.style[style2][i2].getImage();
    if (im) {
      if (style2 == "rotate") {
        im.getAnchor()[0] = -5;
      }
      if (this.isTouch)
        im.setScale(1.8);
    }
    var tx = this.style[style2][i2].getText();
    if (tx) {
      if (style2 == "rotate")
        tx.setOffsetX(this.isTouch ? 14 : 7);
      if (this.isTouch)
        tx.setScale(1.8);
    }
  }
  this.drawSketch_();
};
ol_interaction_Transform.prototype.getFeatureAtPixel_ = function(pixel) {
  var self2 = this;
  return this.getMap().forEachFeatureAtPixel(pixel, function(feature2, layer) {
    var found = false;
    if (!layer) {
      if (feature2 === self2.bbox_) {
        if (self2.get("translateBBox")) {
          return { feature: feature2, handle: "translate", constraint: "", option: "" };
        } else {
          return false;
        }
      }
      self2.handles_.forEach(function(f2) {
        if (f2 === feature2)
          found = true;
      });
      if (found)
        return { feature: feature2, handle: feature2.get("handle"), constraint: feature2.get("constraint"), option: feature2.get("option") };
    }
    if (!self2.get("selection")) {
      if (self2.selection_.getArray().some(function(f2) {
        return feature2 === f2;
      })) {
        return { feature: feature2 };
      }
      return null;
    }
    if (self2._filter) {
      if (self2._filter(feature2, layer))
        return { feature: feature2 };
      else
        return null;
    } else if (self2.layers_) {
      for (var i2 = 0; i2 < self2.layers_.length; i2++) {
        if (self2.layers_[i2] === layer)
          return { feature: feature2 };
      }
      return null;
    } else if (self2.features_) {
      self2.features_.forEach(function(f2) {
        if (f2 === feature2)
          found = true;
      });
      if (found)
        return { feature: feature2 };
      else
        return null;
    } else
      return { feature: feature2 };
  }, { hitTolerance: this.get("hitTolerance") }) || {};
};
ol_interaction_Transform.prototype.getGeometryRotateToZero_ = function(f2, clone2) {
  var origGeom = f2.getGeometry();
  var viewRotation = this.getMap().getView().getRotation();
  if (viewRotation === 0 || !this.get("enableRotatedTransform")) {
    return clone2 ? origGeom.clone() : origGeom;
  }
  var rotGeom = origGeom.clone();
  rotGeom.rotate(viewRotation * -1, this.getMap().getView().getCenter());
  return rotGeom;
};
ol_interaction_Transform.prototype._isRectangle = function(geom2) {
  if (this.get("keepRectangle") && geom2.getType() === "Polygon") {
    var coords = geom2.getCoordinates()[0];
    return coords.length === 5;
  }
  return false;
};
ol_interaction_Transform.prototype.drawSketch_ = function(center) {
  var i2, f2, geom2;
  var keepRectangle = this.selection_.item(0) && this._isRectangle(this.selection_.item(0).getGeometry());
  this.overlayLayer_.getSource().clear();
  if (!this.selection_.getLength())
    return;
  var viewRotation = this.getMap().getView().getRotation();
  var ext = this.getGeometryRotateToZero_(this.selection_.item(0)).getExtent();
  var coords;
  if (keepRectangle) {
    coords = this.getGeometryRotateToZero_(this.selection_.item(0)).getCoordinates()[0].slice(0, 4);
    coords.unshift(coords[3]);
  }
  ext = buffer$1(ext, 0);
  this.selection_.forEach(function(f3) {
    var extendExt = this.getGeometryRotateToZero_(f3).getExtent();
    extend$2(ext, extendExt);
  }.bind(this));
  if (center === true) {
    if (!this.ispt_) {
      this.overlayLayer_.getSource().addFeature(new feature({ geometry: new Point$4(this.center_), handle: "rotate0" }));
      geom2 = fromExtent(ext);
      if (this.get("enableRotatedTransform") && viewRotation !== 0) {
        geom2.rotate(viewRotation, this.getMap().getView().getCenter());
      }
      f2 = this.bbox_ = new feature(geom2);
      this.overlayLayer_.getSource().addFeature(f2);
    }
  } else {
    if (this.ispt_) {
      var p5 = this.getMap().getPixelFromCoordinate([ext[0], ext[1]]);
      if (p5) {
        ext = boundingExtent([
          this.getMap().getCoordinateFromPixel([p5[0] - 10, p5[1] - 10]),
          this.getMap().getCoordinateFromPixel([p5[0] + 10, p5[1] + 10])
        ]);
      }
    }
    geom2 = keepRectangle ? new Polygon$2([coords]) : fromExtent(ext);
    if (this.get("enableRotatedTransform") && viewRotation !== 0) {
      geom2.rotate(viewRotation, this.getMap().getView().getCenter());
    }
    f2 = this.bbox_ = new feature(geom2);
    var features = [];
    var g2 = geom2.getCoordinates()[0];
    if (!this.ispt_) {
      features.push(f2);
      if (!this.iscircle_ && this.get("stretch") && this.get("scale"))
        for (i2 = 0; i2 < g2.length - 1; i2++) {
          f2 = new feature({ geometry: new Point$4([(g2[i2][0] + g2[i2 + 1][0]) / 2, (g2[i2][1] + g2[i2 + 1][1]) / 2]), handle: "scale", constraint: i2 % 2 ? "h" : "v", option: i2 });
          features.push(f2);
        }
      if (this.get("scale"))
        for (i2 = 0; i2 < g2.length - 1; i2++) {
          f2 = new feature({ geometry: new Point$4(g2[i2]), handle: "scale", option: i2 });
          features.push(f2);
        }
      if (this.get("translate") && !this.get("translateFeature")) {
        f2 = new feature({ geometry: new Point$4([(g2[0][0] + g2[2][0]) / 2, (g2[0][1] + g2[2][1]) / 2]), handle: "translate" });
        features.push(f2);
      }
    }
    if (!this.iscircle_ && this.get("rotate")) {
      f2 = new feature({ geometry: new Point$4(g2[3]), handle: "rotate" });
      features.push(f2);
    }
    this.overlayLayer_.getSource().addFeatures(features);
  }
};
ol_interaction_Transform.prototype.select = function(feature2, add2) {
  if (!feature2) {
    this.selection_.clear();
    this.drawSketch_();
    return;
  }
  if (!feature2.getGeometry || !feature2.getGeometry())
    return;
  if (add2) {
    this.selection_.push(feature2);
  } else {
    var index2 = this.selection_.getArray().indexOf(feature2);
    this.selection_.removeAt(index2);
  }
  this.ispt_ = this.selection_.getLength() === 1 ? this.selection_.item(0).getGeometry().getType() == "Point" : false;
  this.iscircle_ = this.selection_.getLength() === 1 ? this.selection_.item(0).getGeometry().getType() == "Circle" : false;
  this.drawSketch_();
  this.watchFeatures_();
  this.dispatchEvent({ type: "select", feature: feature2, features: this.selection_ });
};
ol_interaction_Transform.prototype.setSelection = function(features) {
  this.selection_.clear();
  features.forEach(function(feature2) {
    this.selection_.push(feature2);
  }.bind(this));
  this.ispt_ = this.selection_.getLength() === 1 ? this.selection_.item(0).getGeometry().getType() == "Point" : false;
  this.iscircle_ = this.selection_.getLength() === 1 ? this.selection_.item(0).getGeometry().getType() == "Circle" : false;
  this.drawSketch_();
  this.watchFeatures_();
  this.dispatchEvent({ type: "select", features: this.selection_ });
};
ol_interaction_Transform.prototype.watchFeatures_ = function() {
  if (this._featureListeners) {
    this._featureListeners.forEach(function(l2) {
      unByKey(l2);
    });
  }
  this._featureListeners = [];
  this.selection_.forEach(function(f2) {
    this._featureListeners.push(f2.on("change", function() {
      if (!this.isUpdating_) {
        this.drawSketch_();
      }
    }.bind(this)));
  }.bind(this));
};
ol_interaction_Transform.prototype.handleDownEvent_ = function(evt) {
  if (!this._handleEvent(evt, this.selection_))
    return;
  var sel = this.getFeatureAtPixel_(evt.pixel);
  var feature2 = sel.feature;
  if (this.selection_.getLength() && this.selection_.getArray().indexOf(feature2) >= 0 && (this.ispt_ && this.get("translate") || this.get("translateFeature"))) {
    sel.handle = "translate";
  }
  if (sel.handle) {
    this.mode_ = sel.handle;
    this.opt_ = sel.option;
    this.constraint_ = sel.constraint;
    var viewRotation = this.getMap().getView().getRotation();
    this.coordinate_ = evt.coordinate;
    this.pixel_ = evt.pixel;
    this.geoms_ = [];
    this.rotatedGeoms_ = [];
    var extent2 = createEmpty();
    var rotExtent = createEmpty();
    for (var i2 = 0, f2; f2 = this.selection_.item(i2); i2++) {
      this.geoms_.push(f2.getGeometry().clone());
      extent2 = extend$2(extent2, f2.getGeometry().getExtent());
      if (this.get("enableRotatedTransform") && viewRotation !== 0) {
        var rotGeom = this.getGeometryRotateToZero_(f2, true);
        this.rotatedGeoms_.push(rotGeom);
        rotExtent = extend$2(rotExtent, rotGeom.getExtent());
      }
    }
    this.extent_ = fromExtent(extent2).getCoordinates()[0];
    if (this.get("enableRotatedTransform") && viewRotation !== 0) {
      this.rotatedExtent_ = fromExtent(rotExtent).getCoordinates()[0];
    }
    if (this.mode_ === "rotate") {
      this.center_ = this.getCenter() || getCenter(extent2);
      var element = evt.map.getTargetElement();
      element.style.cursor = this.Cursors.rotate0;
      this.previousCursor_ = element.style.cursor;
    } else {
      this.center_ = getCenter(extent2);
    }
    this.angle_ = Math.atan2(this.center_[1] - evt.coordinate[1], this.center_[0] - evt.coordinate[0]);
    this.dispatchEvent({
      type: this.mode_ + "start",
      feature: this.selection_.item(0),
      features: this.selection_,
      pixel: evt.pixel,
      coordinate: evt.coordinate
    });
    return true;
  } else if (this.get("selection")) {
    if (feature2) {
      if (!this.addFn_(evt))
        this.selection_.clear();
      var index2 = this.selection_.getArray().indexOf(feature2);
      if (index2 < 0)
        this.selection_.push(feature2);
      else
        this.selection_.removeAt(index2);
    } else {
      this.selection_.clear();
    }
    this.ispt_ = this.selection_.getLength() === 1 ? this.selection_.item(0).getGeometry().getType() == "Point" : false;
    this.iscircle_ = this.selection_.getLength() === 1 ? this.selection_.item(0).getGeometry().getType() == "Circle" : false;
    this.drawSketch_();
    this.watchFeatures_();
    this.dispatchEvent({ type: "select", feature: feature2, features: this.selection_, pixel: evt.pixel, coordinate: evt.coordinate });
    return false;
  }
};
ol_interaction_Transform.prototype.getFeatures = function() {
  return this.selection_;
};
ol_interaction_Transform.prototype.getCenter = function() {
  return this.get("center");
};
ol_interaction_Transform.prototype.setCenter = function(c2) {
  return this.set("center", c2);
};
function projectVectorOnVector(displacement_vector, base) {
  var k2 = (displacement_vector[0] * base[0] + displacement_vector[1] * base[1]) / (base[0] * base[0] + base[1] * base[1]);
  return [base[0] * k2, base[1] * k2];
}
function countVector(start2, end) {
  return [end[0] - start2[0], end[1] - start2[1]];
}
function movePoint(point, displacementVector) {
  return [point[0] + displacementVector[0], point[1] + displacementVector[1]];
}
ol_interaction_Transform.prototype.handleDragEvent_ = function(evt) {
  if (!this._handleEvent(evt, this.features_))
    return;
  var viewRotation = this.getMap().getView().getRotation();
  var i2, j2, f2, geometry;
  var pt0 = [this.coordinate_[0], this.coordinate_[1]];
  var pt2 = [evt.coordinate[0], evt.coordinate[1]];
  this.isUpdating_ = true;
  switch (this.mode_) {
    case "rotate": {
      var a2 = Math.atan2(this.center_[1] - pt2[1], this.center_[0] - pt2[0]);
      if (!this.ispt) {
        for (i2 = 0, f2; f2 = this.selection_.item(i2); i2++) {
          geometry = this.geoms_[i2].clone();
          geometry.rotate(a2 - this.angle_, this.center_);
          if (geometry.getType() == "Circle")
            geometry.setCenterAndRadius(geometry.getCenter(), geometry.getRadius());
          f2.setGeometry(geometry);
        }
      }
      this.drawSketch_(true);
      this.dispatchEvent({
        type: "rotating",
        feature: this.selection_.item(0),
        features: this.selection_,
        angle: a2 - this.angle_,
        pixel: evt.pixel,
        coordinate: evt.coordinate
      });
      break;
    }
    case "translate": {
      var deltaX = pt2[0] - pt0[0];
      var deltaY = pt2[1] - pt0[1];
      for (i2 = 0, f2; f2 = this.selection_.item(i2); i2++) {
        f2.getGeometry().translate(deltaX, deltaY);
      }
      this.handles_.forEach(function(f3) {
        f3.getGeometry().translate(deltaX, deltaY);
      });
      this.coordinate_ = evt.coordinate;
      this.dispatchEvent({
        type: "translating",
        feature: this.selection_.item(0),
        features: this.selection_,
        delta: [deltaX, deltaY],
        pixel: evt.pixel,
        coordinate: evt.coordinate
      });
      break;
    }
    case "scale": {
      var center = this.center_;
      if (this.get("modifyCenter")(evt)) {
        var extentCoordinates = this.extent_;
        if (this.get("enableRotatedTransform") && viewRotation !== 0) {
          extentCoordinates = this.rotatedExtent_;
        }
        center = extentCoordinates[(Number(this.opt_) + 2) % 4];
      }
      var keepRectangle = this.geoms_.length == 1 && this._isRectangle(this.geoms_[0]);
      var stretch = this.constraint_;
      var opt = this.opt_;
      var downCoordinate = this.coordinate_;
      var dragCoordinate = evt.coordinate;
      if (this.get("enableRotatedTransform") && viewRotation !== 0) {
        var downPoint = new Point$4(this.coordinate_);
        downPoint.rotate(viewRotation * -1, center);
        downCoordinate = downPoint.getCoordinates();
        var dragPoint = new Point$4(evt.coordinate);
        dragPoint.rotate(viewRotation * -1, center);
        dragCoordinate = dragPoint.getCoordinates();
      }
      var scx = (dragCoordinate[0] - center[0]) / (downCoordinate[0] - center[0]);
      var scy = (dragCoordinate[1] - center[1]) / (downCoordinate[1] - center[1]);
      var displacementVector = [dragCoordinate[0] - downCoordinate[0], dragCoordinate[1] - downCoordinate[1]];
      if (this.get("enableRotatedTransform") && viewRotation !== 0) {
        var centerPoint = new Point$4(center);
        centerPoint.rotate(viewRotation * -1, this.getMap().getView().getCenter());
        center = centerPoint.getCoordinates();
      }
      if (this.get("noFlip")) {
        if (scx < 0)
          scx = -scx;
        if (scy < 0)
          scy = -scy;
      }
      if (this.constraint_) {
        if (this.constraint_ == "h")
          scx = 1;
        else
          scy = 1;
      } else {
        if (this.get("keepAspectRatio")(evt)) {
          scx = scy = Math.min(scx, scy);
        }
      }
      for (i2 = 0, f2; f2 = this.selection_.item(i2); i2++) {
        geometry = viewRotation === 0 || !this.get("enableRotatedTransform") ? this.geoms_[i2].clone() : this.rotatedGeoms_[i2].clone();
        geometry.applyTransform(function(g1, g2, dim) {
          if (dim < 2)
            return g2;
          if (!keepRectangle) {
            for (j2 = 0; j2 < g1.length; j2 += dim) {
              if (scx != 1)
                g2[j2] = center[0] + (g1[j2] - center[0]) * scx;
              if (scy != 1)
                g2[j2 + 1] = center[1] + (g1[j2 + 1] - center[1]) * scy;
            }
          } else {
            var pointArray = [[6], [0, 8], [2], [4]];
            var pointA = [g1[0], g1[1]];
            var pointB = [g1[2], g1[3]];
            var pointC = [g1[4], g1[5]];
            var pointD = [g1[6], g1[7]];
            var pointA1 = [g1[8], g1[9]];
            if (stretch) {
              var base = opt % 2 === 0 ? countVector(pointA, pointB) : countVector(pointD, pointA);
              var projectedVector = projectVectorOnVector(displacementVector, base);
              var nextIndex = opt + 1 < pointArray.length ? opt + 1 : 0;
              var coordsToChange = [...pointArray[opt], ...pointArray[nextIndex]];
              for (j2 = 0; j2 < g1.length; j2 += dim) {
                g2[j2] = coordsToChange.includes(j2) ? g1[j2] + projectedVector[0] : g1[j2];
                g2[j2 + 1] = coordsToChange.includes(j2) ? g1[j2 + 1] + projectedVector[1] : g1[j2 + 1];
              }
            } else {
              var projectedLeft, projectedRight;
              switch (opt) {
                case 0:
                  displacementVector = countVector(pointD, dragCoordinate);
                  projectedLeft = projectVectorOnVector(displacementVector, countVector(pointC, pointD));
                  projectedRight = projectVectorOnVector(displacementVector, countVector(pointA, pointD));
                  [g2[0], g2[1]] = movePoint(pointA, projectedLeft);
                  [g2[4], g2[5]] = movePoint(pointC, projectedRight);
                  [g2[6], g2[7]] = movePoint(pointD, displacementVector);
                  [g2[8], g2[9]] = movePoint(pointA1, projectedLeft);
                  break;
                case 1:
                  displacementVector = countVector(pointA, dragCoordinate);
                  projectedLeft = projectVectorOnVector(displacementVector, countVector(pointD, pointA));
                  projectedRight = projectVectorOnVector(displacementVector, countVector(pointB, pointA));
                  [g2[0], g2[1]] = movePoint(pointA, displacementVector);
                  [g2[2], g2[3]] = movePoint(pointB, projectedLeft);
                  [g2[6], g2[7]] = movePoint(pointD, projectedRight);
                  [g2[8], g2[9]] = movePoint(pointA1, displacementVector);
                  break;
                case 2:
                  displacementVector = countVector(pointB, dragCoordinate);
                  projectedLeft = projectVectorOnVector(displacementVector, countVector(pointA, pointB));
                  projectedRight = projectVectorOnVector(displacementVector, countVector(pointC, pointB));
                  [g2[0], g2[1]] = movePoint(pointA, projectedRight);
                  [g2[2], g2[3]] = movePoint(pointB, displacementVector);
                  [g2[4], g2[5]] = movePoint(pointC, projectedLeft);
                  [g2[8], g2[9]] = movePoint(pointA1, projectedRight);
                  break;
                case 3:
                  displacementVector = countVector(pointC, dragCoordinate);
                  projectedLeft = projectVectorOnVector(displacementVector, countVector(pointB, pointC));
                  projectedRight = projectVectorOnVector(displacementVector, countVector(pointD, pointC));
                  [g2[2], g2[3]] = movePoint(pointB, projectedRight);
                  [g2[4], g2[5]] = movePoint(pointC, displacementVector);
                  [g2[6], g2[7]] = movePoint(pointD, projectedLeft);
                  break;
              }
            }
          }
          if (geometry.getType() == "Circle")
            geometry.setCenterAndRadius(geometry.getCenter(), geometry.getRadius());
          return g2;
        });
        if (this.get("enableRotatedTransform") && viewRotation !== 0) {
          geometry.rotate(viewRotation, this.getMap().getView().getCenter());
        }
        f2.setGeometry(geometry);
      }
      this.drawSketch_();
      this.dispatchEvent({
        type: "scaling",
        feature: this.selection_.item(0),
        features: this.selection_,
        scale: [scx, scy],
        pixel: evt.pixel,
        coordinate: evt.coordinate
      });
      break;
    }
  }
  this.isUpdating_ = false;
};
ol_interaction_Transform.prototype.handleMoveEvent_ = function(evt) {
  if (!this._handleEvent(evt, this.features_))
    return;
  if (!this.mode_) {
    var sel = this.getFeatureAtPixel_(evt.pixel);
    var element = evt.map.getTargetElement();
    if (sel.feature) {
      var c2 = sel.handle ? this.Cursors[(sel.handle || "default") + (sel.constraint || "") + (sel.option || "")] : this.Cursors.select;
      if (this.previousCursor_ === void 0) {
        this.previousCursor_ = element.style.cursor;
      }
      element.style.cursor = c2;
    } else {
      if (this.previousCursor_ !== void 0)
        element.style.cursor = this.previousCursor_;
      this.previousCursor_ = void 0;
    }
  }
};
ol_interaction_Transform.prototype.handleUpEvent_ = function(evt) {
  if (this.mode_ === "rotate") {
    var element = evt.map.getTargetElement();
    element.style.cursor = this.Cursors.default;
    this.previousCursor_ = void 0;
  }
  this.dispatchEvent({
    type: this.mode_ + "end",
    feature: this.selection_.item(0),
    features: this.selection_,
    oldgeom: this.geoms_[0],
    oldgeoms: this.geoms_
  });
  this.drawSketch_();
  this.mode_ = null;
  return false;
};
ol_interaction_Transform.prototype.getFeatures = function() {
  return this.selection_;
};
var _sfc_main$9 = {
  name: "ol-interaction-transform",
  setup(props) {
    const map = inject("map");
    const {
      properties
    } = usePropsAsObjectProperties(props);
    let transform2 = computed(() => {
      let interaction = new ol_interaction_Transform(__spreadValues({}, properties));
      return interaction;
    });
    watch(transform2, (newVal, oldVal) => {
      map.removeInteraction(oldVal);
      map.addInteraction(newVal);
      map.changed();
    });
    onMounted(() => {
      map.addInteraction(transform2.value);
    });
    onUnmounted(() => {
      map.removeInteraction(transform2.value);
    });
    provide("stylable", transform2);
  },
  props: {
    enableRotatedTransform: {
      type: Boolean,
      default: false
    },
    condition: {
      type: Function
    },
    addCondition: {
      type: Function
    },
    filter: {
      type: Function
    },
    layers: {
      type: Array
    },
    hitTolerance: {
      type: Number,
      default: 2
    },
    translateFeature: {
      type: Boolean,
      default: true
    },
    scale: {
      type: Boolean,
      default: true
    },
    rotate: {
      type: Boolean,
      default: true
    },
    keepAspectRatio: {
      type: Boolean,
      default: false
    },
    translate: {
      type: Boolean,
      default: true
    },
    stretch: {
      type: Boolean,
      default: true
    }
  }
};
function _sfc_render$9(_ctx, _cache, $props, $setup, $data, $options) {
  return renderSlot(_ctx.$slots, "default");
}
var TransformInteraction = _export_sfc(_sfc_main$9, [["render", _sfc_render$9]]);
var _sfc_main$8 = {
  name: "ol-interaction-dragrotatezoom",
  setup(props) {
    const map = inject("map");
    const {
      properties
    } = usePropsAsObjectProperties(props);
    let dragrotatezoom = computed(() => {
      let s2 = new DragRotateAndZoom$1(__spreadValues({}, properties));
      return s2;
    });
    watch(dragrotatezoom, (newVal, oldVal) => {
      map.removeInteraction(oldVal);
      map.addInteraction(newVal);
      map.changed();
    });
    onMounted(() => {
      map.addInteraction(dragrotatezoom.value);
    });
    onUnmounted(() => {
      map.removeInteraction(dragrotatezoom.value);
    });
  },
  props: {
    condition: {
      type: Function
    },
    duration: {
      type: Number,
      default: 400
    }
  }
};
function _sfc_render$8(_ctx, _cache, $props, $setup, $data, $options) {
  return renderSlot(_ctx.$slots, "default");
}
var DragRotateAndZoomInteraction = _export_sfc(_sfc_main$8, [["render", _sfc_render$8]]);
function install$2(app) {
  if (install$2.installed) {
    return;
  }
  install$2.installed = true;
  app.component(SelectInteraction.name, SelectInteraction);
  app.component(ClusterSelectInteraction.name, ClusterSelectInteraction);
  app.component(DrawInteraction.name, DrawInteraction);
  app.component(SnapInteraction.name, SnapInteraction);
  app.component(ModifyInteraction.name, ModifyInteraction);
  app.component(TransformInteraction.name, TransformInteraction);
  app.component(DragRotateAndZoomInteraction.name, DragRotateAndZoomInteraction);
}
var Interactions = Object.freeze(Object.defineProperty({
  __proto__: null,
  "default": install$2,
  install: install$2,
  SelectInteraction,
  ClusterSelectInteraction,
  DrawInteraction,
  SnapInteraction,
  ModifyInteraction,
  TransformInteraction,
  DragRotateAndZoomInteraction
}, Symbol.toStringTag, { value: "Module" }));
var _sfc_main$7 = {
  setup() {
    const map = inject("map");
    const vectorLayer = inject("vectorLayer");
    return {
      map,
      vectorLayer
    };
  },
  props: {
    duration: {
      type: Number,
      default: 1e3
    },
    revers: {
      type: Boolean,
      default: false
    },
    repeat: {
      type: Number,
      default: 0
    },
    fade: {
      type: Function
    },
    easing: {
      type: Function,
      default: easeOut
    }
  }
};
function _sfc_render$7(_ctx, _cache, $props, $setup, $data, $options) {
  return renderSlot(_ctx.$slots, "default");
}
var FeatureAnimation = _export_sfc(_sfc_main$7, [["render", _sfc_render$7]]);
var ol_featureAnimation = function(options) {
  options = options || {};
  this.duration_ = typeof options.duration == "number" ? options.duration >= 0 ? options.duration : 0 : 1e3;
  this.fade_ = typeof options.fade == "function" ? options.fade : null;
  this.repeat_ = Number(options.repeat);
  var easing = typeof options.easing == "function" ? options.easing : linear;
  if (options.revers)
    this.easing_ = function(t3) {
      return 1 - easing(t3);
    };
  else
    this.easing_ = easing;
  this.hiddenStyle = options.hiddenStyle;
  ol_Object.call(this);
};
ol_ext_inherits(ol_featureAnimation, ol_Object);
ol_featureAnimation.hiddenStyle = new Style$2({
  image: new ol_style_Circle({}),
  stroke: new Stroke$2({
    color: "transparent"
  })
});
ol_featureAnimation.prototype.drawGeom_ = function(e2, geom2, shadow) {
  if (this.fade_) {
    e2.context.globalAlpha = this.fade_(1 - e2.elapsed);
  }
  var style2 = e2.style;
  for (var i2 = 0; i2 < style2.length; i2++) {
    try {
      var vectorContext = e2.vectorContext || getVectorContext(e2);
      var s2 = ol_ext_getVectorContextStyle(e2, style2[i2]);
      vectorContext.setStyle(s2);
      if (s2.getZIndex() < 0)
        vectorContext.drawGeometry(shadow || geom2);
      else
        vectorContext.drawGeometry(geom2);
    } catch (e3) {
    }
  }
};
ol_featureAnimation.prototype.animate = function() {
  return false;
};
ol_Map.prototype.animateFeature = function(feature2, fanim) {
  var layer = this._featureAnimationLayer;
  if (!layer) {
    layer = this._featureAnimationLayer = new ol_layer_Vector({ source: new ol_source_Vector() });
    layer.setMap(this);
  }
  layer.getSource().addFeature(feature2);
  var listener2 = fanim.on("animationend", function(e2) {
    if (e2.feature === feature2) {
      layer.getSource().removeFeature(feature2);
      unByKey(listener2);
    }
  });
  layer.animateFeature(feature2, fanim);
};
ol_layer_Base$1.prototype.animateFeature = function(feature2, fanim, useFilter) {
  var self2 = this;
  var listenerKey;
  var style2 = feature2.getStyle();
  var flashStyle = style2 || (this.getStyleFunction ? this.getStyleFunction()(feature2) : null);
  if (!flashStyle)
    flashStyle = [];
  if (!(flashStyle instanceof Array))
    flashStyle = [flashStyle];
  var event = {
    vectorContext: null,
    frameState: null,
    start: 0,
    time: 0,
    elapsed: 0,
    extent: false,
    feature: feature2,
    geom: feature2.getGeometry(),
    typeGeom: feature2.getGeometry().getType(),
    bbox: feature2.getGeometry().getExtent(),
    coord: getCenter(feature2.getGeometry().getExtent()),
    style: flashStyle
  };
  if (!(fanim instanceof Array))
    fanim = [fanim];
  for (var i2 = fanim.length - 1; i2 >= 0; i2--) {
    if (fanim[i2].duration_ === 0)
      fanim.splice(i2, 1);
  }
  var nb = 0, step = 0;
  var filters = useFilter && this.getFilters ? this.getFilters() : [];
  function animate(e2) {
    event.type = e2.type;
    try {
      event.vectorContext = e2.vectorContext || getVectorContext(e2);
    } catch (e3) {
    }
    event.frameState = e2.frameState;
    event.inversePixelTransform = e2.inversePixelTransform;
    if (!event.extent) {
      event.extent = e2.frameState.extent;
      event.start = e2.frameState.time;
      event.context = e2.context;
    }
    event.time = e2.frameState.time - event.start;
    event.elapsed = event.time / fanim[step].duration_;
    if (event.elapsed > 1)
      event.elapsed = 1;
    e2.context.save();
    filters.forEach(function(f2) {
      if (f2.get("active"))
        f2.precompose(e2);
    });
    if (this.getOpacity) {
      e2.context.globalAlpha = this.getOpacity();
    }
    if (!fanim[step].animate(event)) {
      nb++;
      if (nb < fanim[step].repeat_) {
        event.extent = false;
      } else if (step < fanim.length - 1) {
        fanim[step].dispatchEvent({ type: "animationend", feature: feature2 });
        step++;
        nb = 0;
        event.extent = false;
      } else {
        stop();
      }
    } else {
      var animEvent = {
        type: "animating",
        step,
        start: event.start,
        time: event.time,
        elapsed: event.elapsed,
        rotation: event.rotation || 0,
        geom: event.geom,
        coordinate: event.coord,
        feature: feature2
      };
      fanim[step].dispatchEvent(animEvent);
      self2.dispatchEvent(animEvent);
    }
    filters.forEach(function(f2) {
      if (f2.get("active"))
        f2.postcompose(e2);
    });
    e2.context.restore();
    e2.frameState.animate = true;
  }
  function stop(options) {
    unByKey(listenerKey);
    listenerKey = null;
    feature2.setStyle(style2);
    var event2 = { type: "animationend", feature: feature2 };
    if (options) {
      for (var i3 in options)
        if (options.hasOwnProperty(i3)) {
          event2[i3] = options[i3];
        }
    }
    fanim[step].dispatchEvent(event2);
    self2.dispatchEvent(event2);
  }
  function start2(options) {
    if (fanim.length && !listenerKey) {
      listenerKey = self2.on(["postcompose", "postrender"], animate.bind(self2));
      if (self2.renderSync) {
        try {
          self2.renderSync();
        } catch (e2) {
        }
      } else {
        self2.changed();
      }
      feature2.setStyle(fanim[step].hiddenStyle || ol_featureAnimation.hiddenStyle);
      var event2 = { type: "animationstart", feature: feature2 };
      if (options) {
        for (var i3 in options)
          if (options.hasOwnProperty(i3)) {
            event2[i3] = options[i3];
          }
      }
      fanim[step].dispatchEvent(event2);
      self2.dispatchEvent(event2);
    }
  }
  start2();
  return {
    start: start2,
    stop,
    isPlaying: function() {
      return !!listenerKey;
    }
  };
};
var ol_featureAnimation_Drop = function(options) {
  options = options || {};
  this.speed_ = options.speed || 0;
  ol_featureAnimation.call(this, options);
  this.side_ = options.side || "top";
};
ol_ext_inherits(ol_featureAnimation_Drop, ol_featureAnimation);
ol_featureAnimation_Drop.prototype.animate = function(e2) {
  if (!e2.time) {
    var angle2 = e2.frameState.viewState.rotation;
    var s2 = e2.frameState.size[1] * e2.frameState.viewState.resolution;
    if (this.side_ != "top")
      s2 *= -1;
    this.dx = -Math.sin(angle2) * s2;
    this.dy = Math.cos(angle2) * s2;
    if (this.speed_) {
      this.duration_ = s2 / this.speed_ / e2.frameState.viewState.resolution;
    }
  }
  var flashGeom = e2.geom.clone();
  flashGeom.translate(this.dx * (1 - this.easing_(e2.elapsed)), this.dy * (1 - this.easing_(e2.elapsed)));
  this.drawGeom_(e2, flashGeom, e2.geom);
  return e2.time <= this.duration_;
};
function useAnimation(AnimationType, props) {
  const {
    map,
    vectorLayer
  } = FeatureAnimation.setup();
  const {
    properties
  } = usePropsAsObjectProperties(props);
  const animation = computed(() => {
    let anim = new AnimationType(__spreadValues({}, properties));
    return anim;
  });
  provide("animation", animation);
  return {
    map,
    vectorLayer,
    animation,
    properties
  };
}
var _sfc_main$6 = {
  name: "ol-animation-drop",
  extends: FeatureAnimation,
  setup(props) {
    const {
      map,
      vectorLayer,
      properties
    } = useAnimation(ol_featureAnimation_Drop, props);
    return {
      map,
      vectorLayer,
      properties
    };
  },
  props: {
    side: {
      type: Number,
      default: 0
    },
    speed: {
      type: Number,
      default: 0
    }
  }
};
function _sfc_render$6(_ctx, _cache, $props, $setup, $data, $options) {
  return renderSlot(_ctx.$slots, "default");
}
var DropAnimation = _export_sfc(_sfc_main$6, [["render", _sfc_render$6]]);
var ol_featureAnimation_Shake = function(options) {
  options = options || {};
  ol_featureAnimation.call(this, options);
  this.amplitude_ = options.amplitude || 40;
  this.bounce_ = -Math.PI * (options.bounce || 6);
  this.horizontal_ = options.horizontal;
};
ol_ext_inherits(ol_featureAnimation_Shake, ol_featureAnimation);
ol_featureAnimation_Shake.prototype.animate = function(e2) {
  var flashGeom = e2.geom.clone();
  var shadow = e2.geom.clone();
  var t3 = this.easing_(e2.elapsed);
  t3 = Math.sin(this.bounce_ * t3) * this.amplitude_ * (1 - t3) * e2.frameState.viewState.resolution;
  if (this.horizontal_) {
    flashGeom.translate(t3, 0);
    shadow.translate(t3, 0);
  } else
    flashGeom.translate(0, t3);
  this.drawGeom_(e2, flashGeom, shadow);
  return e2.time <= this.duration_;
};
var _sfc_main$5 = {
  name: "ol-animation-shake",
  extends: FeatureAnimation,
  setup(props) {
    const {
      map,
      vectorLayer,
      properties,
      animation
    } = useAnimation(ol_featureAnimation_Shake, props);
    return {
      map,
      vectorLayer,
      properties,
      animation
    };
  },
  props: {
    bounce: {
      type: Number,
      default: 6
    },
    amplitude: {
      type: Number,
      default: 40
    },
    horizontal: {
      type: Boolean,
      default: false
    }
  }
};
function _sfc_render$5(_ctx, _cache, $props, $setup, $data, $options) {
  return renderSlot(_ctx.$slots, "default");
}
var ShakeAnimation = _export_sfc(_sfc_main$5, [["render", _sfc_render$5]]);
var ol_featureAnimation_Zoom = function(options) {
  options = options || {};
  ol_featureAnimation.call(this, options);
  this.set("zoomout", options.zoomOut);
};
ol_ext_inherits(ol_featureAnimation_Zoom, ol_featureAnimation);
var ol_featureAnimation_ZoomOut = function(options) {
  options = options || {};
  options.zoomOut = true;
  ol_featureAnimation_Zoom.call(this, options);
};
ol_ext_inherits(ol_featureAnimation_ZoomOut, ol_featureAnimation_Zoom);
ol_featureAnimation_Zoom.prototype.animate = function(e2) {
  var fac = this.easing_(e2.elapsed);
  if (fac) {
    if (this.get("zoomout"))
      fac = 1 / fac;
    var style2 = e2.style;
    var i2, imgs, sc = [];
    for (i2 = 0; i2 < style2.length; i2++) {
      imgs = style2[i2].getImage();
      if (imgs) {
        sc[i2] = imgs.getScale();
        if (e2.type === "postrender")
          imgs.setScale(sc[i2] * fac / e2.frameState.pixelRatio);
        else
          imgs.setScale(sc[i2] * fac);
      }
    }
    this.drawGeom_(e2, e2.geom);
    for (i2 = 0; i2 < style2.length; i2++) {
      imgs = style2[i2].getImage();
      if (imgs)
        imgs.setScale(sc[i2]);
    }
  }
  return e2.time <= this.duration_;
};
var _sfc_main$4 = {
  name: "ol-animation-zoom",
  extends: FeatureAnimation,
  setup(props) {
    const {
      map,
      vectorLayer,
      properties
    } = useAnimation(ol_featureAnimation_Zoom, props);
    return {
      map,
      vectorLayer,
      properties
    };
  },
  props: {
    zoomOut: {
      type: Boolean,
      default: false
    }
  }
};
function _sfc_render$4(_ctx, _cache, $props, $setup, $data, $options) {
  return renderSlot(_ctx.$slots, "default");
}
var ZoomAnimation = _export_sfc(_sfc_main$4, [["render", _sfc_render$4]]);
var ol_featureAnimation_Teleport = function(options) {
  ol_featureAnimation.call(this, options);
};
ol_ext_inherits(ol_featureAnimation_Teleport, ol_featureAnimation);
ol_featureAnimation_Teleport.prototype.animate = function(e2) {
  var sc = this.easing_(e2.elapsed);
  if (sc) {
    e2.context.save();
    var ratio = e2.frameState.pixelRatio;
    e2.context.globalAlpha = sc;
    e2.context.scale(sc, 1 / sc);
    var m2 = e2.frameState.coordinateToPixelTransform;
    var dx = (1 / sc - 1) * ratio * (m2[0] * e2.coord[0] + m2[1] * e2.coord[1] + m2[4]);
    var dy = (sc - 1) * ratio * (m2[2] * e2.coord[0] + m2[3] * e2.coord[1] + m2[5]);
    e2.context.translate(dx, dy);
    this.drawGeom_(e2, e2.geom);
    e2.context.restore();
  }
  return e2.time <= this.duration_;
};
var _sfc_main$3 = {
  name: "ol-animation-teleport",
  extends: FeatureAnimation,
  setup(props) {
    const {
      map,
      vectorLayer,
      properties
    } = useAnimation(ol_featureAnimation_Teleport, props);
    return {
      map,
      vectorLayer,
      properties
    };
  },
  props: {}
};
function _sfc_render$3(_ctx, _cache, $props, $setup, $data, $options) {
  return renderSlot(_ctx.$slots, "default");
}
var TeleportAnimation = _export_sfc(_sfc_main$3, [["render", _sfc_render$3]]);
var ol_featureAnimation_Fade = function(options) {
  options = options || {};
  this.speed_ = options.speed || 0;
  ol_featureAnimation.call(this, options);
};
ol_ext_inherits(ol_featureAnimation_Fade, ol_featureAnimation);
ol_featureAnimation_Fade.prototype.animate = function(e2) {
  e2.context.globalAlpha = this.easing_(e2.elapsed);
  this.drawGeom_(e2, e2.geom);
  return e2.time <= this.duration_;
};
var _sfc_main$2 = {
  name: "ol-animation-fade",
  extends: FeatureAnimation,
  setup(props) {
    const {
      map,
      vectorLayer,
      properties
    } = useAnimation(ol_featureAnimation_Fade, props);
    return {
      map,
      vectorLayer,
      properties
    };
  }
};
function _sfc_render$2(_ctx, _cache, $props, $setup, $data, $options) {
  return renderSlot(_ctx.$slots, "default");
}
var FadeAnimation = _export_sfc(_sfc_main$2, [["render", _sfc_render$2]]);
var ol_featureAnimation_Slide = function(options) {
  options = options || {};
  this.speed_ = options.speed || 0;
  ol_featureAnimation.call(this, options);
  this.side_ = options.side || "left";
};
ol_ext_inherits(ol_featureAnimation_Slide, ol_featureAnimation);
ol_featureAnimation_Slide.prototype.animate = function(e2) {
  if (!e2.time) {
    if (this.side_ == "left")
      this.dx = e2.extent[0] - e2.bbox[2];
    else
      this.dx = e2.extent[2] - e2.bbox[0];
    if (this.speed_)
      this.duration_ = Math.abs(this.dx) / this.speed_ / e2.frameState.viewState.resolution;
  }
  var flashGeom = e2.geom.clone();
  flashGeom.translate(this.dx * (1 - this.easing_(e2.elapsed)), 0);
  this.drawGeom_(e2, flashGeom);
  return e2.time <= this.duration_;
};
var _sfc_main$1 = {
  name: "ol-animation-slide",
  extends: FeatureAnimation,
  setup(props) {
    const {
      map,
      vectorLayer,
      properties
    } = useAnimation(ol_featureAnimation_Slide, props);
    return {
      map,
      vectorLayer,
      properties
    };
  },
  props: {
    speed: {
      type: Number,
      default: 0
    }
  }
};
function _sfc_render$1(_ctx, _cache, $props, $setup, $data, $options) {
  return renderSlot(_ctx.$slots, "default");
}
var SlideAnimation = _export_sfc(_sfc_main$1, [["render", _sfc_render$1]]);
var ol_featureAnimation_Path = function(options) {
  options = options || {};
  ol_featureAnimation.call(this, options);
  this.speed_ = options.speed || 0;
  this.path_ = options.path;
  switch (options.rotate) {
    case true:
    case 0:
      this.rotate_ = 0;
      break;
    default:
      this.rotate_ = options.rotate || false;
      break;
  }
  if (this.path_ && this.path_.getGeometry)
    this.path_ = this.path_.getGeometry();
  if (this.path_ && this.path_.getLineString)
    this.path_ = this.path_.getLineString();
  if (this.path_.getLength) {
    this.dist_ = this.path_.getLength();
    if (this.path_ && this.path_.getCoordinates)
      this.path_ = this.path_.getCoordinates();
  } else {
    this.dist_ = 0;
  }
  if (this.speed_ > 0)
    this.duration_ = this.dist_ / this.speed_;
};
ol_ext_inherits(ol_featureAnimation_Path, ol_featureAnimation);
ol_featureAnimation_Path.prototype.animate = function(e2) {
  if (!e2.time) {
    if (!this.dist_)
      return false;
  }
  var dmax = this.dist_ * this.easing_(e2.elapsed);
  var p0, p5, s2, dx, dy, dl, d2 = 0;
  p5 = this.path_[0];
  for (var i2 = 1; i2 < this.path_.length; i2++) {
    p0 = p5;
    p5 = this.path_[i2];
    dx = p5[0] - p0[0];
    dy = p5[1] - p0[1];
    dl = Math.sqrt(dx * dx + dy * dy);
    if (dl && d2 + dl >= dmax) {
      s2 = (dmax - d2) / dl;
      p5 = [p0[0] + (p5[0] - p0[0]) * s2, p0[1] + (p5[1] - p0[1]) * s2];
      break;
    }
    d2 += dl;
  }
  var style2 = e2.style;
  e2.rotation = Math.PI / 2 + Math.atan2(p0[1] - p5[1], p0[0] - p5[0]);
  if (this.rotate_ !== false) {
    var st2 = [];
    var angle2 = this.rotate_ - e2.rotation + e2.frameState.viewState.rotation;
    e2.rotation = Math.PI / 2 + Math.atan2(p0[1] - p5[1], p0[0] - p5[0]);
    for (var k2 = 0; s2 = e2.style[k2]; k2++) {
      if (s2.getImage()) {
        s2.getImage().setRotation(angle2);
      }
      st2.push(s2);
    }
    e2.style = st2;
  }
  e2.geom.setCoordinates(p5);
  this.drawGeom_(e2, e2.geom);
  e2.style = style2;
  return e2.time <= this.duration_;
};
var _sfc_main = {
  name: "ol-animation-path",
  extends: FeatureAnimation,
  setup(props) {
    const {
      map,
      vectorLayer,
      properties
    } = useAnimation(ol_featureAnimation_Path, props);
    return {
      map,
      vectorLayer,
      properties
    };
  },
  props: {
    rotate: {
      type: Boolean,
      default: false
    },
    speed: {
      type: Number,
      default: 0
    },
    path: {
      type: Object
    }
  }
};
function _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
  return renderSlot(_ctx.$slots, "default");
}
var PathAnimation = _export_sfc(_sfc_main, [["render", _sfc_render]]);
function install$1(app) {
  if (install$1.installed) {
    return;
  }
  install$1.installed = true;
  app.component(FeatureAnimation.name, FeatureAnimation);
  app.component(DropAnimation.name, DropAnimation);
  app.component(ShakeAnimation.name, ShakeAnimation);
  app.component(ZoomAnimation.name, ZoomAnimation);
  app.component(TeleportAnimation.name, TeleportAnimation);
  app.component(FadeAnimation.name, FadeAnimation);
  app.component(SlideAnimation.name, SlideAnimation);
  app.component(PathAnimation.name, PathAnimation);
}
var Animations = Object.freeze(Object.defineProperty({
  __proto__: null,
  "default": install$1,
  install: install$1,
  FeatureAnimation,
  DropAnimation,
  ShakeAnimation,
  ZoomAnimation,
  TeleportAnimation,
  FadeAnimation,
  PathAnimation,
  SlideAnimation
}, Symbol.toStringTag, { value: "Module" }));
var __extends$q = globalThis && globalThis.__extends || function() {
  var extendStatics2 = function(d2, b2) {
    extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {
      d3.__proto__ = b3;
    } || function(d3, b3) {
      for (var p5 in b3)
        if (Object.prototype.hasOwnProperty.call(b3, p5))
          d3[p5] = b3[p5];
    };
    return extendStatics2(d2, b2);
  };
  return function(d2, b2) {
    if (typeof b2 !== "function" && b2 !== null)
      throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
    extendStatics2(d2, b2);
    function __() {
      this.constructor = d2;
    }
    d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
  };
}();
var GeometryCollection = function(_super) {
  __extends$q(GeometryCollection2, _super);
  function GeometryCollection2(opt_geometries) {
    var _this = _super.call(this) || this;
    _this.geometries_ = opt_geometries ? opt_geometries : null;
    _this.changeEventsKeys_ = [];
    _this.listenGeometriesChange_();
    return _this;
  }
  GeometryCollection2.prototype.unlistenGeometriesChange_ = function() {
    this.changeEventsKeys_.forEach(unlistenByKey);
    this.changeEventsKeys_.length = 0;
  };
  GeometryCollection2.prototype.listenGeometriesChange_ = function() {
    if (!this.geometries_) {
      return;
    }
    for (var i2 = 0, ii = this.geometries_.length; i2 < ii; ++i2) {
      this.changeEventsKeys_.push(listen(this.geometries_[i2], EventType.CHANGE, this.changed, this));
    }
  };
  GeometryCollection2.prototype.clone = function() {
    var geometryCollection = new GeometryCollection2(null);
    geometryCollection.setGeometries(this.geometries_);
    geometryCollection.applyProperties(this);
    return geometryCollection;
  };
  GeometryCollection2.prototype.closestPointXY = function(x2, y2, closestPoint, minSquaredDistance) {
    if (minSquaredDistance < closestSquaredDistanceXY(this.getExtent(), x2, y2)) {
      return minSquaredDistance;
    }
    var geometries = this.geometries_;
    for (var i2 = 0, ii = geometries.length; i2 < ii; ++i2) {
      minSquaredDistance = geometries[i2].closestPointXY(x2, y2, closestPoint, minSquaredDistance);
    }
    return minSquaredDistance;
  };
  GeometryCollection2.prototype.containsXY = function(x2, y2) {
    var geometries = this.geometries_;
    for (var i2 = 0, ii = geometries.length; i2 < ii; ++i2) {
      if (geometries[i2].containsXY(x2, y2)) {
        return true;
      }
    }
    return false;
  };
  GeometryCollection2.prototype.computeExtent = function(extent2) {
    createOrUpdateEmpty(extent2);
    var geometries = this.geometries_;
    for (var i2 = 0, ii = geometries.length; i2 < ii; ++i2) {
      extend$2(extent2, geometries[i2].getExtent());
    }
    return extent2;
  };
  GeometryCollection2.prototype.getGeometries = function() {
    return cloneGeometries(this.geometries_);
  };
  GeometryCollection2.prototype.getGeometriesArray = function() {
    return this.geometries_;
  };
  GeometryCollection2.prototype.getGeometriesArrayRecursive = function() {
    var geometriesArray = [];
    var geometries = this.geometries_;
    for (var i2 = 0, ii = geometries.length; i2 < ii; ++i2) {
      if (geometries[i2].getType() === this.getType()) {
        geometriesArray = geometriesArray.concat(geometries[i2].getGeometriesArrayRecursive());
      } else {
        geometriesArray.push(geometries[i2]);
      }
    }
    return geometriesArray;
  };
  GeometryCollection2.prototype.getSimplifiedGeometry = function(squaredTolerance) {
    if (this.simplifiedGeometryRevision !== this.getRevision()) {
      this.simplifiedGeometryMaxMinSquaredTolerance = 0;
      this.simplifiedGeometryRevision = this.getRevision();
    }
    if (squaredTolerance < 0 || this.simplifiedGeometryMaxMinSquaredTolerance !== 0 && squaredTolerance < this.simplifiedGeometryMaxMinSquaredTolerance) {
      return this;
    }
    var simplifiedGeometries = [];
    var geometries = this.geometries_;
    var simplified = false;
    for (var i2 = 0, ii = geometries.length; i2 < ii; ++i2) {
      var geometry = geometries[i2];
      var simplifiedGeometry = geometry.getSimplifiedGeometry(squaredTolerance);
      simplifiedGeometries.push(simplifiedGeometry);
      if (simplifiedGeometry !== geometry) {
        simplified = true;
      }
    }
    if (simplified) {
      var simplifiedGeometryCollection = new GeometryCollection2(null);
      simplifiedGeometryCollection.setGeometriesArray(simplifiedGeometries);
      return simplifiedGeometryCollection;
    } else {
      this.simplifiedGeometryMaxMinSquaredTolerance = squaredTolerance;
      return this;
    }
  };
  GeometryCollection2.prototype.getType = function() {
    return GeometryType.GEOMETRY_COLLECTION;
  };
  GeometryCollection2.prototype.intersectsExtent = function(extent2) {
    var geometries = this.geometries_;
    for (var i2 = 0, ii = geometries.length; i2 < ii; ++i2) {
      if (geometries[i2].intersectsExtent(extent2)) {
        return true;
      }
    }
    return false;
  };
  GeometryCollection2.prototype.isEmpty = function() {
    return this.geometries_.length === 0;
  };
  GeometryCollection2.prototype.rotate = function(angle2, anchor) {
    var geometries = this.geometries_;
    for (var i2 = 0, ii = geometries.length; i2 < ii; ++i2) {
      geometries[i2].rotate(angle2, anchor);
    }
    this.changed();
  };
  GeometryCollection2.prototype.scale = function(sx, opt_sy, opt_anchor) {
    var anchor = opt_anchor;
    if (!anchor) {
      anchor = getCenter(this.getExtent());
    }
    var geometries = this.geometries_;
    for (var i2 = 0, ii = geometries.length; i2 < ii; ++i2) {
      geometries[i2].scale(sx, opt_sy, anchor);
    }
    this.changed();
  };
  GeometryCollection2.prototype.setGeometries = function(geometries) {
    this.setGeometriesArray(cloneGeometries(geometries));
  };
  GeometryCollection2.prototype.setGeometriesArray = function(geometries) {
    this.unlistenGeometriesChange_();
    this.geometries_ = geometries;
    this.listenGeometriesChange_();
    this.changed();
  };
  GeometryCollection2.prototype.applyTransform = function(transformFn) {
    var geometries = this.geometries_;
    for (var i2 = 0, ii = geometries.length; i2 < ii; ++i2) {
      geometries[i2].applyTransform(transformFn);
    }
    this.changed();
  };
  GeometryCollection2.prototype.translate = function(deltaX, deltaY) {
    var geometries = this.geometries_;
    for (var i2 = 0, ii = geometries.length; i2 < ii; ++i2) {
      geometries[i2].translate(deltaX, deltaY);
    }
    this.changed();
  };
  GeometryCollection2.prototype.disposeInternal = function() {
    this.unlistenGeometriesChange_();
    _super.prototype.disposeInternal.call(this);
  };
  return GeometryCollection2;
}(Geometry$1);
function cloneGeometries(geometries) {
  var clonedGeometries = [];
  for (var i2 = 0, ii = geometries.length; i2 < ii; ++i2) {
    clonedGeometries.push(geometries[i2].clone());
  }
  return clonedGeometries;
}
var GeometryCollection$1 = GeometryCollection;
var geom = Object.freeze(Object.defineProperty({
  __proto__: null,
  Circle: ol_geom_Circle,
  Geometry: Geometry$1,
  GeometryCollection: GeometryCollection$1,
  LinearRing: LinearRing$1,
  LineString: LineString$2,
  MultiLineString: MultiLineString$2,
  MultiPoint: MultiPoint$2,
  MultiPolygon: MultiPolygon$2,
  Point: Point$4,
  Polygon: Polygon$2,
  SimpleGeometry: SimpleGeometry$1
}, Symbol.toStringTag, { value: "Module" }));
var FeatureFormat = function() {
  function FeatureFormat2() {
    this.dataProjection = void 0;
    this.defaultFeatureProjection = void 0;
    this.supportedMediaTypes = null;
  }
  FeatureFormat2.prototype.getReadOptions = function(source, opt_options) {
    var options;
    if (opt_options) {
      var dataProjection = opt_options.dataProjection ? get$3(opt_options.dataProjection) : this.readProjection(source);
      if (opt_options.extent && dataProjection && dataProjection.getUnits() === Units$2.TILE_PIXELS) {
        dataProjection = get$3(dataProjection);
        dataProjection.setWorldExtent(opt_options.extent);
      }
      options = {
        dataProjection,
        featureProjection: opt_options.featureProjection
      };
    }
    return this.adaptOptions(options);
  };
  FeatureFormat2.prototype.adaptOptions = function(options) {
    return assign({
      dataProjection: this.dataProjection,
      featureProjection: this.defaultFeatureProjection
    }, options);
  };
  FeatureFormat2.prototype.getType = function() {
    return abstract();
  };
  FeatureFormat2.prototype.readFeature = function(source, opt_options) {
    return abstract();
  };
  FeatureFormat2.prototype.readFeatures = function(source, opt_options) {
    return abstract();
  };
  FeatureFormat2.prototype.readGeometry = function(source, opt_options) {
    return abstract();
  };
  FeatureFormat2.prototype.readProjection = function(source) {
    return abstract();
  };
  FeatureFormat2.prototype.writeFeature = function(feature2, opt_options) {
    return abstract();
  };
  FeatureFormat2.prototype.writeFeatures = function(features, opt_options) {
    return abstract();
  };
  FeatureFormat2.prototype.writeGeometry = function(geometry, opt_options) {
    return abstract();
  };
  return FeatureFormat2;
}();
var FeatureFormat$1 = FeatureFormat;
function transformGeometryWithOptions(geometry, write, opt_options) {
  var featureProjection = opt_options ? get$3(opt_options.featureProjection) : null;
  var dataProjection = opt_options ? get$3(opt_options.dataProjection) : null;
  var transformed;
  if (featureProjection && dataProjection && !equivalent(featureProjection, dataProjection)) {
    transformed = (write ? geometry.clone() : geometry).transform(write ? featureProjection : dataProjection, write ? dataProjection : featureProjection);
  } else {
    transformed = geometry;
  }
  if (write && opt_options && opt_options.decimals !== void 0) {
    var power_1 = Math.pow(10, opt_options.decimals);
    var transform2 = function(coordinates2) {
      for (var i2 = 0, ii = coordinates2.length; i2 < ii; ++i2) {
        coordinates2[i2] = Math.round(coordinates2[i2] * power_1) / power_1;
      }
      return coordinates2;
    };
    if (transformed === geometry) {
      transformed = geometry.clone();
    }
    transformed.applyTransform(transform2);
  }
  return transformed;
}
function transformExtentWithOptions(extent2, opt_options) {
  var featureProjection = opt_options ? get$3(opt_options.featureProjection) : null;
  var dataProjection = opt_options ? get$3(opt_options.dataProjection) : null;
  if (featureProjection && dataProjection && !equivalent(featureProjection, dataProjection)) {
    return transformExtent(extent2, dataProjection, featureProjection);
  } else {
    return extent2;
  }
}
var __extends$p = globalThis && globalThis.__extends || function() {
  var extendStatics2 = function(d2, b2) {
    extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {
      d3.__proto__ = b3;
    } || function(d3, b3) {
      for (var p5 in b3)
        if (Object.prototype.hasOwnProperty.call(b3, p5))
          d3[p5] = b3[p5];
    };
    return extendStatics2(d2, b2);
  };
  return function(d2, b2) {
    if (typeof b2 !== "function" && b2 !== null)
      throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
    extendStatics2(d2, b2);
    function __() {
      this.constructor = d2;
    }
    d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
  };
}();
var JSONFeature = function(_super) {
  __extends$p(JSONFeature2, _super);
  function JSONFeature2() {
    return _super.call(this) || this;
  }
  JSONFeature2.prototype.getType = function() {
    return FormatType.JSON;
  };
  JSONFeature2.prototype.readFeature = function(source, opt_options) {
    return this.readFeatureFromObject(getObject(source), this.getReadOptions(source, opt_options));
  };
  JSONFeature2.prototype.readFeatures = function(source, opt_options) {
    return this.readFeaturesFromObject(getObject(source), this.getReadOptions(source, opt_options));
  };
  JSONFeature2.prototype.readFeatureFromObject = function(object, opt_options) {
    return abstract();
  };
  JSONFeature2.prototype.readFeaturesFromObject = function(object, opt_options) {
    return abstract();
  };
  JSONFeature2.prototype.readGeometry = function(source, opt_options) {
    return this.readGeometryFromObject(getObject(source), this.getReadOptions(source, opt_options));
  };
  JSONFeature2.prototype.readGeometryFromObject = function(object, opt_options) {
    return abstract();
  };
  JSONFeature2.prototype.readProjection = function(source) {
    return this.readProjectionFromObject(getObject(source));
  };
  JSONFeature2.prototype.readProjectionFromObject = function(object) {
    return abstract();
  };
  JSONFeature2.prototype.writeFeature = function(feature2, opt_options) {
    return JSON.stringify(this.writeFeatureObject(feature2, opt_options));
  };
  JSONFeature2.prototype.writeFeatureObject = function(feature2, opt_options) {
    return abstract();
  };
  JSONFeature2.prototype.writeFeatures = function(features, opt_options) {
    return JSON.stringify(this.writeFeaturesObject(features, opt_options));
  };
  JSONFeature2.prototype.writeFeaturesObject = function(features, opt_options) {
    return abstract();
  };
  JSONFeature2.prototype.writeGeometry = function(geometry, opt_options) {
    return JSON.stringify(this.writeGeometryObject(geometry, opt_options));
  };
  JSONFeature2.prototype.writeGeometryObject = function(geometry, opt_options) {
    return abstract();
  };
  return JSONFeature2;
}(FeatureFormat$1);
function getObject(source) {
  if (typeof source === "string") {
    var object = JSON.parse(source);
    return object ? object : null;
  } else if (source !== null) {
    return source;
  } else {
    return null;
  }
}
var JSONFeature$1 = JSONFeature;
var __extends$o = globalThis && globalThis.__extends || function() {
  var extendStatics2 = function(d2, b2) {
    extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {
      d3.__proto__ = b3;
    } || function(d3, b3) {
      for (var p5 in b3)
        if (Object.prototype.hasOwnProperty.call(b3, p5))
          d3[p5] = b3[p5];
    };
    return extendStatics2(d2, b2);
  };
  return function(d2, b2) {
    if (typeof b2 !== "function" && b2 !== null)
      throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
    extendStatics2(d2, b2);
    function __() {
      this.constructor = d2;
    }
    d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
  };
}();
var GEOMETRY_READERS$1 = {};
GEOMETRY_READERS$1[GeometryType.POINT] = readPointGeometry$2;
GEOMETRY_READERS$1[GeometryType.LINE_STRING] = readLineStringGeometry$2;
GEOMETRY_READERS$1[GeometryType.POLYGON] = readPolygonGeometry$2;
GEOMETRY_READERS$1[GeometryType.MULTI_POINT] = readMultiPointGeometry$2;
GEOMETRY_READERS$1[GeometryType.MULTI_LINE_STRING] = readMultiLineStringGeometry$2;
GEOMETRY_READERS$1[GeometryType.MULTI_POLYGON] = readMultiPolygonGeometry$2;
var GEOMETRY_WRITERS = {};
GEOMETRY_WRITERS[GeometryType.POINT] = writePointGeometry$1;
GEOMETRY_WRITERS[GeometryType.LINE_STRING] = writeLineStringGeometry$1;
GEOMETRY_WRITERS[GeometryType.POLYGON] = writePolygonGeometry$1;
GEOMETRY_WRITERS[GeometryType.MULTI_POINT] = writeMultiPointGeometry$1;
GEOMETRY_WRITERS[GeometryType.MULTI_LINE_STRING] = writeMultiLineStringGeometry$1;
GEOMETRY_WRITERS[GeometryType.MULTI_POLYGON] = writeMultiPolygonGeometry$1;
var EsriJSON = function(_super) {
  __extends$o(EsriJSON2, _super);
  function EsriJSON2(opt_options) {
    var _this = this;
    var options = opt_options ? opt_options : {};
    _this = _super.call(this) || this;
    _this.geometryName_ = options.geometryName;
    return _this;
  }
  EsriJSON2.prototype.readFeatureFromObject = function(object, opt_options, opt_idField) {
    var esriJSONFeature = object;
    var geometry = readGeometry$1(esriJSONFeature.geometry, opt_options);
    var feature$1 = new feature();
    if (this.geometryName_) {
      feature$1.setGeometryName(this.geometryName_);
    }
    feature$1.setGeometry(geometry);
    if (esriJSONFeature.attributes) {
      feature$1.setProperties(esriJSONFeature.attributes, true);
      var id = esriJSONFeature.attributes[opt_idField];
      if (id !== void 0) {
        feature$1.setId(id);
      }
    }
    return feature$1;
  };
  EsriJSON2.prototype.readFeaturesFromObject = function(object, opt_options) {
    var options = opt_options ? opt_options : {};
    if (object["features"]) {
      var esriJSONFeatureSet = object;
      var features = [];
      var esriJSONFeatures = esriJSONFeatureSet.features;
      for (var i2 = 0, ii = esriJSONFeatures.length; i2 < ii; ++i2) {
        features.push(this.readFeatureFromObject(esriJSONFeatures[i2], options, object.objectIdFieldName));
      }
      return features;
    } else {
      return [this.readFeatureFromObject(object, options)];
    }
  };
  EsriJSON2.prototype.readGeometryFromObject = function(object, opt_options) {
    return readGeometry$1(object, opt_options);
  };
  EsriJSON2.prototype.readProjectionFromObject = function(object) {
    if (object["spatialReference"] && object["spatialReference"]["wkid"] !== void 0) {
      var spatialReference = object["spatialReference"];
      var crs = spatialReference.wkid;
      return get$3("EPSG:" + crs);
    } else {
      return null;
    }
  };
  EsriJSON2.prototype.writeGeometryObject = function(geometry, opt_options) {
    return writeGeometry$1(geometry, this.adaptOptions(opt_options));
  };
  EsriJSON2.prototype.writeFeatureObject = function(feature2, opt_options) {
    opt_options = this.adaptOptions(opt_options);
    var object = {};
    if (!feature2.hasProperties()) {
      object["attributes"] = {};
      return object;
    }
    var properties = feature2.getProperties();
    var geometry = feature2.getGeometry();
    if (geometry) {
      object["geometry"] = writeGeometry$1(geometry, opt_options);
      var projection = opt_options && (opt_options.dataProjection || opt_options.featureProjection);
      if (projection) {
        object["geometry"]["spatialReference"] = {
          wkid: Number(get$3(projection).getCode().split(":").pop())
        };
      }
      delete properties[feature2.getGeometryName()];
    }
    if (!isEmpty(properties)) {
      object["attributes"] = properties;
    } else {
      object["attributes"] = {};
    }
    return object;
  };
  EsriJSON2.prototype.writeFeaturesObject = function(features, opt_options) {
    opt_options = this.adaptOptions(opt_options);
    var objects = [];
    for (var i2 = 0, ii = features.length; i2 < ii; ++i2) {
      objects.push(this.writeFeatureObject(features[i2], opt_options));
    }
    return {
      "features": objects
    };
  };
  return EsriJSON2;
}(JSONFeature$1);
function readGeometry$1(object, opt_options) {
  var _a2, _b2;
  if (!object) {
    return null;
  }
  var type;
  if (typeof object["x"] === "number" && typeof object["y"] === "number") {
    type = GeometryType.POINT;
  } else if (object["points"]) {
    type = GeometryType.MULTI_POINT;
  } else if (object["paths"]) {
    var esriJSONPolyline = object;
    if (esriJSONPolyline.paths.length === 1) {
      type = GeometryType.LINE_STRING;
    } else {
      type = GeometryType.MULTI_LINE_STRING;
    }
  } else if (object["rings"]) {
    var esriJSONPolygon = object;
    var layout = getGeometryLayout(esriJSONPolygon);
    var rings = convertRings(esriJSONPolygon.rings, layout);
    if (rings.length === 1) {
      type = GeometryType.POLYGON;
      object = assign({}, object, (_a2 = {}, _a2["rings"] = rings[0], _a2));
    } else {
      type = GeometryType.MULTI_POLYGON;
      object = assign({}, object, (_b2 = {}, _b2["rings"] = rings, _b2));
    }
  }
  var geometryReader = GEOMETRY_READERS$1[type];
  return transformGeometryWithOptions(geometryReader(object), false, opt_options);
}
function convertRings(rings, layout) {
  var flatRing = [];
  var outerRings = [];
  var holes = [];
  var i2, ii;
  for (i2 = 0, ii = rings.length; i2 < ii; ++i2) {
    flatRing.length = 0;
    deflateCoordinates(flatRing, 0, rings[i2], layout.length);
    var clockwise = linearRingIsClockwise(flatRing, 0, flatRing.length, layout.length);
    if (clockwise) {
      outerRings.push([rings[i2]]);
    } else {
      holes.push(rings[i2]);
    }
  }
  while (holes.length) {
    var hole = holes.shift();
    var matched = false;
    for (i2 = outerRings.length - 1; i2 >= 0; i2--) {
      var outerRing = outerRings[i2][0];
      var containsHole = containsExtent(new LinearRing$1(outerRing).getExtent(), new LinearRing$1(hole).getExtent());
      if (containsHole) {
        outerRings[i2].push(hole);
        matched = true;
        break;
      }
    }
    if (!matched) {
      outerRings.push([hole.reverse()]);
    }
  }
  return outerRings;
}
function readPointGeometry$2(object) {
  var point;
  if (object.m !== void 0 && object.z !== void 0) {
    point = new Point$4([object.x, object.y, object.z, object.m], GeometryLayout.XYZM);
  } else if (object.z !== void 0) {
    point = new Point$4([object.x, object.y, object.z], GeometryLayout.XYZ);
  } else if (object.m !== void 0) {
    point = new Point$4([object.x, object.y, object.m], GeometryLayout.XYM);
  } else {
    point = new Point$4([object.x, object.y]);
  }
  return point;
}
function readLineStringGeometry$2(object) {
  var layout = getGeometryLayout(object);
  return new LineString$2(object.paths[0], layout);
}
function readMultiLineStringGeometry$2(object) {
  var layout = getGeometryLayout(object);
  return new MultiLineString$2(object.paths, layout);
}
function getGeometryLayout(object) {
  var layout = GeometryLayout.XY;
  if (object.hasZ === true && object.hasM === true) {
    layout = GeometryLayout.XYZM;
  } else if (object.hasZ === true) {
    layout = GeometryLayout.XYZ;
  } else if (object.hasM === true) {
    layout = GeometryLayout.XYM;
  }
  return layout;
}
function readMultiPointGeometry$2(object) {
  var layout = getGeometryLayout(object);
  return new MultiPoint$2(object.points, layout);
}
function readMultiPolygonGeometry$2(object) {
  var layout = getGeometryLayout(object);
  return new MultiPolygon$2(object.rings, layout);
}
function readPolygonGeometry$2(object) {
  var layout = getGeometryLayout(object);
  return new Polygon$2(object.rings, layout);
}
function writePointGeometry$1(geometry, opt_options) {
  var coordinates2 = geometry.getCoordinates();
  var esriJSON;
  var layout = geometry.getLayout();
  if (layout === GeometryLayout.XYZ) {
    esriJSON = {
      x: coordinates2[0],
      y: coordinates2[1],
      z: coordinates2[2]
    };
  } else if (layout === GeometryLayout.XYM) {
    esriJSON = {
      x: coordinates2[0],
      y: coordinates2[1],
      m: coordinates2[2]
    };
  } else if (layout === GeometryLayout.XYZM) {
    esriJSON = {
      x: coordinates2[0],
      y: coordinates2[1],
      z: coordinates2[2],
      m: coordinates2[3]
    };
  } else if (layout === GeometryLayout.XY) {
    esriJSON = {
      x: coordinates2[0],
      y: coordinates2[1]
    };
  } else {
    assert(false, 34);
  }
  return esriJSON;
}
function getHasZM(geometry) {
  var layout = geometry.getLayout();
  return {
    hasZ: layout === GeometryLayout.XYZ || layout === GeometryLayout.XYZM,
    hasM: layout === GeometryLayout.XYM || layout === GeometryLayout.XYZM
  };
}
function writeLineStringGeometry$1(lineString, opt_options) {
  var hasZM = getHasZM(lineString);
  return {
    hasZ: hasZM.hasZ,
    hasM: hasZM.hasM,
    paths: [
      lineString.getCoordinates()
    ]
  };
}
function writePolygonGeometry$1(polygon, opt_options) {
  var hasZM = getHasZM(polygon);
  return {
    hasZ: hasZM.hasZ,
    hasM: hasZM.hasM,
    rings: polygon.getCoordinates(false)
  };
}
function writeMultiLineStringGeometry$1(multiLineString, opt_options) {
  var hasZM = getHasZM(multiLineString);
  return {
    hasZ: hasZM.hasZ,
    hasM: hasZM.hasM,
    paths: multiLineString.getCoordinates()
  };
}
function writeMultiPointGeometry$1(multiPoint, opt_options) {
  var hasZM = getHasZM(multiPoint);
  return {
    hasZ: hasZM.hasZ,
    hasM: hasZM.hasM,
    points: multiPoint.getCoordinates()
  };
}
function writeMultiPolygonGeometry$1(geometry, opt_options) {
  var hasZM = getHasZM(geometry);
  var coordinates2 = geometry.getCoordinates(false);
  var output = [];
  for (var i2 = 0; i2 < coordinates2.length; i2++) {
    for (var x2 = coordinates2[i2].length - 1; x2 >= 0; x2--) {
      output.push(coordinates2[i2][x2]);
    }
  }
  return {
    hasZ: hasZM.hasZ,
    hasM: hasZM.hasM,
    rings: output
  };
}
function writeGeometry$1(geometry, opt_options) {
  var geometryWriter = GEOMETRY_WRITERS[geometry.getType()];
  return geometryWriter(transformGeometryWithOptions(geometry, true, opt_options), opt_options);
}
var EsriJSON$1 = EsriJSON;
var __extends$n = globalThis && globalThis.__extends || function() {
  var extendStatics2 = function(d2, b2) {
    extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {
      d3.__proto__ = b3;
    } || function(d3, b3) {
      for (var p5 in b3)
        if (Object.prototype.hasOwnProperty.call(b3, p5))
          d3[p5] = b3[p5];
    };
    return extendStatics2(d2, b2);
  };
  return function(d2, b2) {
    if (typeof b2 !== "function" && b2 !== null)
      throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
    extendStatics2(d2, b2);
    function __() {
      this.constructor = d2;
    }
    d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
  };
}();
var GeoJSON = function(_super) {
  __extends$n(GeoJSON2, _super);
  function GeoJSON2(opt_options) {
    var _this = this;
    var options = opt_options ? opt_options : {};
    _this = _super.call(this) || this;
    _this.dataProjection = get$3(options.dataProjection ? options.dataProjection : "EPSG:4326");
    if (options.featureProjection) {
      _this.defaultFeatureProjection = get$3(options.featureProjection);
    }
    _this.geometryName_ = options.geometryName;
    _this.extractGeometryName_ = options.extractGeometryName;
    _this.supportedMediaTypes = [
      "application/geo+json",
      "application/vnd.geo+json"
    ];
    return _this;
  }
  GeoJSON2.prototype.readFeatureFromObject = function(object, opt_options) {
    var geoJSONFeature = null;
    if (object["type"] === "Feature") {
      geoJSONFeature = object;
    } else {
      geoJSONFeature = {
        "type": "Feature",
        "geometry": object,
        "properties": null
      };
    }
    var geometry = readGeometry(geoJSONFeature["geometry"], opt_options);
    var feature$1 = new feature();
    if (this.geometryName_) {
      feature$1.setGeometryName(this.geometryName_);
    } else if (this.extractGeometryName_ && "geometry_name" in geoJSONFeature !== void 0) {
      feature$1.setGeometryName(geoJSONFeature["geometry_name"]);
    }
    feature$1.setGeometry(geometry);
    if ("id" in geoJSONFeature) {
      feature$1.setId(geoJSONFeature["id"]);
    }
    if (geoJSONFeature["properties"]) {
      feature$1.setProperties(geoJSONFeature["properties"], true);
    }
    return feature$1;
  };
  GeoJSON2.prototype.readFeaturesFromObject = function(object, opt_options) {
    var geoJSONObject = object;
    var features = null;
    if (geoJSONObject["type"] === "FeatureCollection") {
      var geoJSONFeatureCollection = object;
      features = [];
      var geoJSONFeatures = geoJSONFeatureCollection["features"];
      for (var i2 = 0, ii = geoJSONFeatures.length; i2 < ii; ++i2) {
        features.push(this.readFeatureFromObject(geoJSONFeatures[i2], opt_options));
      }
    } else {
      features = [this.readFeatureFromObject(object, opt_options)];
    }
    return features;
  };
  GeoJSON2.prototype.readGeometryFromObject = function(object, opt_options) {
    return readGeometry(object, opt_options);
  };
  GeoJSON2.prototype.readProjectionFromObject = function(object) {
    var crs = object["crs"];
    var projection;
    if (crs) {
      if (crs["type"] == "name") {
        projection = get$3(crs["properties"]["name"]);
      } else if (crs["type"] === "EPSG") {
        projection = get$3("EPSG:" + crs["properties"]["code"]);
      } else {
        assert(false, 36);
      }
    } else {
      projection = this.dataProjection;
    }
    return projection;
  };
  GeoJSON2.prototype.writeFeatureObject = function(feature2, opt_options) {
    opt_options = this.adaptOptions(opt_options);
    var object = {
      "type": "Feature",
      geometry: null,
      properties: null
    };
    var id = feature2.getId();
    if (id !== void 0) {
      object.id = id;
    }
    if (!feature2.hasProperties()) {
      return object;
    }
    var properties = feature2.getProperties();
    var geometry = feature2.getGeometry();
    if (geometry) {
      object.geometry = writeGeometry(geometry, opt_options);
      delete properties[feature2.getGeometryName()];
    }
    if (!isEmpty(properties)) {
      object.properties = properties;
    }
    return object;
  };
  GeoJSON2.prototype.writeFeaturesObject = function(features, opt_options) {
    opt_options = this.adaptOptions(opt_options);
    var objects = [];
    for (var i2 = 0, ii = features.length; i2 < ii; ++i2) {
      objects.push(this.writeFeatureObject(features[i2], opt_options));
    }
    return {
      type: "FeatureCollection",
      features: objects
    };
  };
  GeoJSON2.prototype.writeGeometryObject = function(geometry, opt_options) {
    return writeGeometry(geometry, this.adaptOptions(opt_options));
  };
  return GeoJSON2;
}(JSONFeature$1);
function readGeometry(object, opt_options) {
  if (!object) {
    return null;
  }
  var geometry;
  switch (object["type"]) {
    case GeometryType.POINT: {
      geometry = readPointGeometry$1(object);
      break;
    }
    case GeometryType.LINE_STRING: {
      geometry = readLineStringGeometry$1(object);
      break;
    }
    case GeometryType.POLYGON: {
      geometry = readPolygonGeometry$1(object);
      break;
    }
    case GeometryType.MULTI_POINT: {
      geometry = readMultiPointGeometry$1(object);
      break;
    }
    case GeometryType.MULTI_LINE_STRING: {
      geometry = readMultiLineStringGeometry$1(object);
      break;
    }
    case GeometryType.MULTI_POLYGON: {
      geometry = readMultiPolygonGeometry$1(object);
      break;
    }
    case GeometryType.GEOMETRY_COLLECTION: {
      geometry = readGeometryCollectionGeometry(object);
      break;
    }
    default: {
      throw new Error("Unsupported GeoJSON type: " + object.type);
    }
  }
  return transformGeometryWithOptions(geometry, false, opt_options);
}
function readGeometryCollectionGeometry(object, opt_options) {
  var geometries = object["geometries"].map(function(geometry) {
    return readGeometry(geometry, opt_options);
  });
  return new GeometryCollection$1(geometries);
}
function readPointGeometry$1(object) {
  return new Point$4(object["coordinates"]);
}
function readLineStringGeometry$1(object) {
  return new LineString$2(object["coordinates"]);
}
function readMultiLineStringGeometry$1(object) {
  return new MultiLineString$2(object["coordinates"]);
}
function readMultiPointGeometry$1(object) {
  return new MultiPoint$2(object["coordinates"]);
}
function readMultiPolygonGeometry$1(object) {
  return new MultiPolygon$2(object["coordinates"]);
}
function readPolygonGeometry$1(object) {
  return new Polygon$2(object["coordinates"]);
}
function writeGeometry(geometry, opt_options) {
  geometry = transformGeometryWithOptions(geometry, true, opt_options);
  var type = geometry.getType();
  var geoJSON;
  switch (type) {
    case GeometryType.POINT: {
      geoJSON = writePointGeometry(geometry);
      break;
    }
    case GeometryType.LINE_STRING: {
      geoJSON = writeLineStringGeometry(geometry);
      break;
    }
    case GeometryType.POLYGON: {
      geoJSON = writePolygonGeometry(geometry, opt_options);
      break;
    }
    case GeometryType.MULTI_POINT: {
      geoJSON = writeMultiPointGeometry(geometry);
      break;
    }
    case GeometryType.MULTI_LINE_STRING: {
      geoJSON = writeMultiLineStringGeometry(geometry);
      break;
    }
    case GeometryType.MULTI_POLYGON: {
      geoJSON = writeMultiPolygonGeometry(geometry, opt_options);
      break;
    }
    case GeometryType.GEOMETRY_COLLECTION: {
      geoJSON = writeGeometryCollectionGeometry(geometry, opt_options);
      break;
    }
    case GeometryType.CIRCLE: {
      geoJSON = {
        type: "GeometryCollection",
        geometries: []
      };
      break;
    }
    default: {
      throw new Error("Unsupported geometry type: " + type);
    }
  }
  return geoJSON;
}
function writeGeometryCollectionGeometry(geometry, opt_options) {
  var geometries = geometry.getGeometriesArray().map(function(geometry2) {
    var options = assign({}, opt_options);
    delete options.featureProjection;
    return writeGeometry(geometry2, options);
  });
  return {
    type: "GeometryCollection",
    geometries
  };
}
function writeLineStringGeometry(geometry, opt_options) {
  return {
    type: "LineString",
    coordinates: geometry.getCoordinates()
  };
}
function writeMultiLineStringGeometry(geometry, opt_options) {
  return {
    type: "MultiLineString",
    coordinates: geometry.getCoordinates()
  };
}
function writeMultiPointGeometry(geometry, opt_options) {
  return {
    type: "MultiPoint",
    coordinates: geometry.getCoordinates()
  };
}
function writeMultiPolygonGeometry(geometry, opt_options) {
  var right;
  if (opt_options) {
    right = opt_options.rightHanded;
  }
  return {
    type: "MultiPolygon",
    coordinates: geometry.getCoordinates(right)
  };
}
function writePointGeometry(geometry, opt_options) {
  return {
    type: "Point",
    coordinates: geometry.getCoordinates()
  };
}
function writePolygonGeometry(geometry, opt_options) {
  var right;
  if (opt_options) {
    right = opt_options.rightHanded;
  }
  return {
    type: "Polygon",
    coordinates: geometry.getCoordinates(right)
  };
}
var GeoJSON$1 = GeoJSON;
var XML_SCHEMA_INSTANCE_URI = "http://www.w3.org/2001/XMLSchema-instance";
function createElementNS(namespaceURI, qualifiedName) {
  return getDocument().createElementNS(namespaceURI, qualifiedName);
}
function getAllTextContent(node2, normalizeWhitespace) {
  return getAllTextContent_(node2, normalizeWhitespace, []).join("");
}
function getAllTextContent_(node2, normalizeWhitespace, accumulator) {
  if (node2.nodeType == Node.CDATA_SECTION_NODE || node2.nodeType == Node.TEXT_NODE) {
    if (normalizeWhitespace) {
      accumulator.push(String(node2.nodeValue).replace(/(\r\n|\r|\n)/g, ""));
    } else {
      accumulator.push(node2.nodeValue);
    }
  } else {
    var n2 = void 0;
    for (n2 = node2.firstChild; n2; n2 = n2.nextSibling) {
      getAllTextContent_(n2, normalizeWhitespace, accumulator);
    }
  }
  return accumulator;
}
function isDocument(object) {
  return "documentElement" in object;
}
function getAttributeNS(node2, namespaceURI, name) {
  return node2.getAttributeNS(namespaceURI, name) || "";
}
function parse$1(xml2) {
  return new DOMParser().parseFromString(xml2, "application/xml");
}
function makeArrayExtender(valueReader, opt_this) {
  return function(node2, objectStack) {
    var value = valueReader.call(opt_this !== void 0 ? opt_this : this, node2, objectStack);
    if (value !== void 0) {
      var array = objectStack[objectStack.length - 1];
      extend$3(array, value);
    }
  };
}
function makeArrayPusher(valueReader, opt_this) {
  return function(node2, objectStack) {
    var value = valueReader.call(opt_this !== void 0 ? opt_this : this, node2, objectStack);
    if (value !== void 0) {
      var array = objectStack[objectStack.length - 1];
      array.push(value);
    }
  };
}
function makeReplacer(valueReader, opt_this) {
  return function(node2, objectStack) {
    var value = valueReader.call(opt_this !== void 0 ? opt_this : this, node2, objectStack);
    if (value !== void 0) {
      objectStack[objectStack.length - 1] = value;
    }
  };
}
function makeObjectPropertyPusher(valueReader, opt_property, opt_this) {
  return function(node2, objectStack) {
    var value = valueReader.call(opt_this !== void 0 ? opt_this : this, node2, objectStack);
    if (value !== void 0) {
      var object = objectStack[objectStack.length - 1];
      var property = opt_property !== void 0 ? opt_property : node2.localName;
      var array = void 0;
      if (property in object) {
        array = object[property];
      } else {
        array = [];
        object[property] = array;
      }
      array.push(value);
    }
  };
}
function makeObjectPropertySetter(valueReader, opt_property, opt_this) {
  return function(node2, objectStack) {
    var value = valueReader.call(opt_this !== void 0 ? opt_this : this, node2, objectStack);
    if (value !== void 0) {
      var object = objectStack[objectStack.length - 1];
      var property = opt_property !== void 0 ? opt_property : node2.localName;
      object[property] = value;
    }
  };
}
function makeChildAppender(nodeWriter, opt_this) {
  return function(node2, value, objectStack) {
    nodeWriter.call(opt_this !== void 0 ? opt_this : this, node2, value, objectStack);
    var parent = objectStack[objectStack.length - 1];
    var parentNode = parent.node;
    parentNode.appendChild(node2);
  };
}
function makeArraySerializer(nodeWriter, opt_this) {
  var serializersNS, nodeFactory;
  return function(node2, value, objectStack) {
    if (serializersNS === void 0) {
      serializersNS = {};
      var serializers = {};
      serializers[node2.localName] = nodeWriter;
      serializersNS[node2.namespaceURI] = serializers;
      nodeFactory = makeSimpleNodeFactory(node2.localName);
    }
    serialize(serializersNS, nodeFactory, value, objectStack);
  };
}
function makeSimpleNodeFactory(opt_nodeName, opt_namespaceURI) {
  var fixedNodeName = opt_nodeName;
  return function(value, objectStack, opt_nodeName2) {
    var context = objectStack[objectStack.length - 1];
    var node2 = context.node;
    var nodeName = fixedNodeName;
    if (nodeName === void 0) {
      nodeName = opt_nodeName2;
    }
    var namespaceURI = opt_namespaceURI !== void 0 ? opt_namespaceURI : node2.namespaceURI;
    return createElementNS(namespaceURI, nodeName);
  };
}
var OBJECT_PROPERTY_NODE_FACTORY = makeSimpleNodeFactory();
function makeSequence(object, orderedKeys) {
  var length = orderedKeys.length;
  var sequence = new Array(length);
  for (var i2 = 0; i2 < length; ++i2) {
    sequence[i2] = object[orderedKeys[i2]];
  }
  return sequence;
}
function makeStructureNS(namespaceURIs, structure, opt_structureNS) {
  var structureNS = opt_structureNS !== void 0 ? opt_structureNS : {};
  var i2, ii;
  for (i2 = 0, ii = namespaceURIs.length; i2 < ii; ++i2) {
    structureNS[namespaceURIs[i2]] = structure;
  }
  return structureNS;
}
function parseNode(parsersNS, node2, objectStack, opt_this) {
  var n2;
  for (n2 = node2.firstElementChild; n2; n2 = n2.nextElementSibling) {
    var parsers = parsersNS[n2.namespaceURI];
    if (parsers !== void 0) {
      var parser = parsers[n2.localName];
      if (parser !== void 0) {
        parser.call(opt_this, n2, objectStack);
      }
    }
  }
}
function pushParseAndPop(object, parsersNS, node2, objectStack, opt_this) {
  objectStack.push(object);
  parseNode(parsersNS, node2, objectStack, opt_this);
  return objectStack.pop();
}
function serialize(serializersNS, nodeFactory, values2, objectStack, opt_keys, opt_this) {
  var length = (opt_keys !== void 0 ? opt_keys : values2).length;
  var value, node2;
  for (var i2 = 0; i2 < length; ++i2) {
    value = values2[i2];
    if (value !== void 0) {
      node2 = nodeFactory.call(opt_this !== void 0 ? opt_this : this, value, objectStack, opt_keys !== void 0 ? opt_keys[i2] : void 0);
      if (node2 !== void 0) {
        serializersNS[node2.namespaceURI][node2.localName].call(opt_this, node2, value, objectStack);
      }
    }
  }
}
function pushSerializeAndPop(object, serializersNS, nodeFactory, values2, objectStack, opt_keys, opt_this) {
  objectStack.push(object);
  serialize(serializersNS, nodeFactory, values2, objectStack, opt_keys, opt_this);
  return objectStack.pop();
}
var xmlSerializer_ = void 0;
function getXMLSerializer() {
  if (xmlSerializer_ === void 0 && typeof XMLSerializer !== "undefined") {
    xmlSerializer_ = new XMLSerializer();
  }
  return xmlSerializer_;
}
var document_ = void 0;
function getDocument() {
  if (document_ === void 0 && typeof document !== "undefined") {
    document_ = document.implementation.createDocument("", "", null);
  }
  return document_;
}
var __extends$m = globalThis && globalThis.__extends || function() {
  var extendStatics2 = function(d2, b2) {
    extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {
      d3.__proto__ = b3;
    } || function(d3, b3) {
      for (var p5 in b3)
        if (Object.prototype.hasOwnProperty.call(b3, p5))
          d3[p5] = b3[p5];
    };
    return extendStatics2(d2, b2);
  };
  return function(d2, b2) {
    if (typeof b2 !== "function" && b2 !== null)
      throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
    extendStatics2(d2, b2);
    function __() {
      this.constructor = d2;
    }
    d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
  };
}();
var XMLFeature = function(_super) {
  __extends$m(XMLFeature2, _super);
  function XMLFeature2() {
    var _this = _super.call(this) || this;
    _this.xmlSerializer_ = getXMLSerializer();
    return _this;
  }
  XMLFeature2.prototype.getType = function() {
    return FormatType.XML;
  };
  XMLFeature2.prototype.readFeature = function(source, opt_options) {
    if (!source) {
      return null;
    } else if (typeof source === "string") {
      var doc = parse$1(source);
      return this.readFeatureFromDocument(doc, opt_options);
    } else if (isDocument(source)) {
      return this.readFeatureFromDocument(source, opt_options);
    } else {
      return this.readFeatureFromNode(source, opt_options);
    }
  };
  XMLFeature2.prototype.readFeatureFromDocument = function(doc, opt_options) {
    var features = this.readFeaturesFromDocument(doc, opt_options);
    if (features.length > 0) {
      return features[0];
    } else {
      return null;
    }
  };
  XMLFeature2.prototype.readFeatureFromNode = function(node2, opt_options) {
    return null;
  };
  XMLFeature2.prototype.readFeatures = function(source, opt_options) {
    if (!source) {
      return [];
    } else if (typeof source === "string") {
      var doc = parse$1(source);
      return this.readFeaturesFromDocument(doc, opt_options);
    } else if (isDocument(source)) {
      return this.readFeaturesFromDocument(source, opt_options);
    } else {
      return this.readFeaturesFromNode(source, opt_options);
    }
  };
  XMLFeature2.prototype.readFeaturesFromDocument = function(doc, opt_options) {
    var features = [];
    for (var n2 = doc.firstChild; n2; n2 = n2.nextSibling) {
      if (n2.nodeType == Node.ELEMENT_NODE) {
        extend$3(features, this.readFeaturesFromNode(n2, opt_options));
      }
    }
    return features;
  };
  XMLFeature2.prototype.readFeaturesFromNode = function(node2, opt_options) {
    return abstract();
  };
  XMLFeature2.prototype.readGeometry = function(source, opt_options) {
    if (!source) {
      return null;
    } else if (typeof source === "string") {
      var doc = parse$1(source);
      return this.readGeometryFromDocument(doc, opt_options);
    } else if (isDocument(source)) {
      return this.readGeometryFromDocument(source, opt_options);
    } else {
      return this.readGeometryFromNode(source, opt_options);
    }
  };
  XMLFeature2.prototype.readGeometryFromDocument = function(doc, opt_options) {
    return null;
  };
  XMLFeature2.prototype.readGeometryFromNode = function(node2, opt_options) {
    return null;
  };
  XMLFeature2.prototype.readProjection = function(source) {
    if (!source) {
      return null;
    } else if (typeof source === "string") {
      var doc = parse$1(source);
      return this.readProjectionFromDocument(doc);
    } else if (isDocument(source)) {
      return this.readProjectionFromDocument(source);
    } else {
      return this.readProjectionFromNode(source);
    }
  };
  XMLFeature2.prototype.readProjectionFromDocument = function(doc) {
    return this.dataProjection;
  };
  XMLFeature2.prototype.readProjectionFromNode = function(node2) {
    return this.dataProjection;
  };
  XMLFeature2.prototype.writeFeature = function(feature2, opt_options) {
    var node2 = this.writeFeatureNode(feature2, opt_options);
    return this.xmlSerializer_.serializeToString(node2);
  };
  XMLFeature2.prototype.writeFeatureNode = function(feature2, opt_options) {
    return null;
  };
  XMLFeature2.prototype.writeFeatures = function(features, opt_options) {
    var node2 = this.writeFeaturesNode(features, opt_options);
    return this.xmlSerializer_.serializeToString(node2);
  };
  XMLFeature2.prototype.writeFeaturesNode = function(features, opt_options) {
    return null;
  };
  XMLFeature2.prototype.writeGeometry = function(geometry, opt_options) {
    var node2 = this.writeGeometryNode(geometry, opt_options);
    return this.xmlSerializer_.serializeToString(node2);
  };
  XMLFeature2.prototype.writeGeometryNode = function(geometry, opt_options) {
    return null;
  };
  return XMLFeature2;
}(FeatureFormat$1);
var XMLFeature$1 = XMLFeature;
var __extends$l = globalThis && globalThis.__extends || function() {
  var extendStatics2 = function(d2, b2) {
    extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {
      d3.__proto__ = b3;
    } || function(d3, b3) {
      for (var p5 in b3)
        if (Object.prototype.hasOwnProperty.call(b3, p5))
          d3[p5] = b3[p5];
    };
    return extendStatics2(d2, b2);
  };
  return function(d2, b2) {
    if (typeof b2 !== "function" && b2 !== null)
      throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
    extendStatics2(d2, b2);
    function __() {
      this.constructor = d2;
    }
    d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
  };
}();
var GMLNS = "http://www.opengis.net/gml";
var ONLY_WHITESPACE_RE = /^[\s\xa0]*$/;
var GMLBase = function(_super) {
  __extends$l(GMLBase2, _super);
  function GMLBase2(opt_options) {
    var _this = _super.call(this) || this;
    var options = opt_options ? opt_options : {};
    _this.featureType = options.featureType;
    _this.featureNS = options.featureNS;
    _this.srsName = options.srsName;
    _this.schemaLocation = "";
    _this.FEATURE_COLLECTION_PARSERS = {};
    _this.FEATURE_COLLECTION_PARSERS[_this.namespace] = {
      "featureMember": makeArrayPusher(_this.readFeaturesInternal),
      "featureMembers": makeReplacer(_this.readFeaturesInternal)
    };
    _this.supportedMediaTypes = ["application/gml+xml"];
    return _this;
  }
  GMLBase2.prototype.readFeaturesInternal = function(node2, objectStack) {
    var localName = node2.localName;
    var features = null;
    if (localName == "FeatureCollection") {
      features = pushParseAndPop([], this.FEATURE_COLLECTION_PARSERS, node2, objectStack, this);
    } else if (localName == "featureMembers" || localName == "featureMember" || localName == "member") {
      var context = objectStack[0];
      var featureType = context["featureType"];
      var featureNS = context["featureNS"];
      var prefix = "p";
      var defaultPrefix = "p0";
      if (!featureType && node2.childNodes) {
        featureType = [], featureNS = {};
        for (var i2 = 0, ii = node2.childNodes.length; i2 < ii; ++i2) {
          var child = node2.childNodes[i2];
          if (child.nodeType === 1) {
            var ft2 = child.nodeName.split(":").pop();
            if (featureType.indexOf(ft2) === -1) {
              var key = "";
              var count = 0;
              var uri = child.namespaceURI;
              for (var candidate in featureNS) {
                if (featureNS[candidate] === uri) {
                  key = candidate;
                  break;
                }
                ++count;
              }
              if (!key) {
                key = prefix + count;
                featureNS[key] = uri;
              }
              featureType.push(key + ":" + ft2);
            }
          }
        }
        if (localName != "featureMember") {
          context["featureType"] = featureType;
          context["featureNS"] = featureNS;
        }
      }
      if (typeof featureNS === "string") {
        var ns = featureNS;
        featureNS = {};
        featureNS[defaultPrefix] = ns;
      }
      var parsersNS = {};
      var featureTypes = Array.isArray(featureType) ? featureType : [featureType];
      for (var p5 in featureNS) {
        var parsers = {};
        for (var i2 = 0, ii = featureTypes.length; i2 < ii; ++i2) {
          var featurePrefix = featureTypes[i2].indexOf(":") === -1 ? defaultPrefix : featureTypes[i2].split(":")[0];
          if (featurePrefix === p5) {
            parsers[featureTypes[i2].split(":").pop()] = localName == "featureMembers" ? makeArrayPusher(this.readFeatureElement, this) : makeReplacer(this.readFeatureElement, this);
          }
        }
        parsersNS[featureNS[p5]] = parsers;
      }
      if (localName == "featureMember" || localName == "member") {
        features = pushParseAndPop(void 0, parsersNS, node2, objectStack);
      } else {
        features = pushParseAndPop([], parsersNS, node2, objectStack);
      }
    }
    if (features === null) {
      features = [];
    }
    return features;
  };
  GMLBase2.prototype.readGeometryOrExtent = function(node2, objectStack) {
    var context = objectStack[0];
    context["srsName"] = node2.firstElementChild.getAttribute("srsName");
    context["srsDimension"] = node2.firstElementChild.getAttribute("srsDimension");
    return pushParseAndPop(null, this.GEOMETRY_PARSERS, node2, objectStack, this);
  };
  GMLBase2.prototype.readExtentElement = function(node2, objectStack) {
    var context = objectStack[0];
    var extent2 = this.readGeometryOrExtent(node2, objectStack);
    return extent2 ? transformExtentWithOptions(extent2, context) : void 0;
  };
  GMLBase2.prototype.readGeometryElement = function(node2, objectStack) {
    var context = objectStack[0];
    var geometry = this.readGeometryOrExtent(node2, objectStack);
    return geometry ? transformGeometryWithOptions(geometry, false, context) : void 0;
  };
  GMLBase2.prototype.readFeatureElementInternal = function(node2, objectStack, asFeature) {
    var geometryName;
    var values2 = {};
    for (var n2 = node2.firstElementChild; n2; n2 = n2.nextElementSibling) {
      var value = void 0;
      var localName = n2.localName;
      if (n2.childNodes.length === 0 || n2.childNodes.length === 1 && (n2.firstChild.nodeType === 3 || n2.firstChild.nodeType === 4)) {
        value = getAllTextContent(n2, false);
        if (ONLY_WHITESPACE_RE.test(value)) {
          value = void 0;
        }
      } else {
        if (asFeature) {
          value = localName === "boundedBy" ? this.readExtentElement(n2, objectStack) : this.readGeometryElement(n2, objectStack);
        }
        if (!value) {
          value = this.readFeatureElementInternal(n2, objectStack, false);
        } else if (localName !== "boundedBy") {
          geometryName = localName;
        }
      }
      if (values2[localName]) {
        if (!(values2[localName] instanceof Array)) {
          values2[localName] = [values2[localName]];
        }
        values2[localName].push(value);
      } else {
        values2[localName] = value;
      }
      var len = n2.attributes.length;
      if (len > 0) {
        values2[localName] = { _content_: values2[localName] };
        for (var i2 = 0; i2 < len; i2++) {
          var attName = n2.attributes[i2].name;
          values2[localName][attName] = n2.attributes[i2].value;
        }
      }
    }
    if (!asFeature) {
      return values2;
    } else {
      var feature$1 = new feature(values2);
      if (geometryName) {
        feature$1.setGeometryName(geometryName);
      }
      var fid = node2.getAttribute("fid") || getAttributeNS(node2, this.namespace, "id");
      if (fid) {
        feature$1.setId(fid);
      }
      return feature$1;
    }
  };
  GMLBase2.prototype.readFeatureElement = function(node2, objectStack) {
    return this.readFeatureElementInternal(node2, objectStack, true);
  };
  GMLBase2.prototype.readPoint = function(node2, objectStack) {
    var flatCoordinates = this.readFlatCoordinatesFromNode(node2, objectStack);
    if (flatCoordinates) {
      return new Point$4(flatCoordinates, GeometryLayout.XYZ);
    }
  };
  GMLBase2.prototype.readMultiPoint = function(node2, objectStack) {
    var coordinates2 = pushParseAndPop([], this.MULTIPOINT_PARSERS, node2, objectStack, this);
    if (coordinates2) {
      return new MultiPoint$2(coordinates2);
    } else {
      return void 0;
    }
  };
  GMLBase2.prototype.readMultiLineString = function(node2, objectStack) {
    var lineStrings = pushParseAndPop([], this.MULTILINESTRING_PARSERS, node2, objectStack, this);
    if (lineStrings) {
      return new MultiLineString$2(lineStrings);
    }
  };
  GMLBase2.prototype.readMultiPolygon = function(node2, objectStack) {
    var polygons = pushParseAndPop([], this.MULTIPOLYGON_PARSERS, node2, objectStack, this);
    if (polygons) {
      return new MultiPolygon$2(polygons);
    }
  };
  GMLBase2.prototype.pointMemberParser = function(node2, objectStack) {
    parseNode(this.POINTMEMBER_PARSERS, node2, objectStack, this);
  };
  GMLBase2.prototype.lineStringMemberParser = function(node2, objectStack) {
    parseNode(this.LINESTRINGMEMBER_PARSERS, node2, objectStack, this);
  };
  GMLBase2.prototype.polygonMemberParser = function(node2, objectStack) {
    parseNode(this.POLYGONMEMBER_PARSERS, node2, objectStack, this);
  };
  GMLBase2.prototype.readLineString = function(node2, objectStack) {
    var flatCoordinates = this.readFlatCoordinatesFromNode(node2, objectStack);
    if (flatCoordinates) {
      var lineString = new LineString$2(flatCoordinates, GeometryLayout.XYZ);
      return lineString;
    } else {
      return void 0;
    }
  };
  GMLBase2.prototype.readFlatLinearRing = function(node2, objectStack) {
    var ring = pushParseAndPop(null, this.GEOMETRY_FLAT_COORDINATES_PARSERS, node2, objectStack, this);
    if (ring) {
      return ring;
    } else {
      return void 0;
    }
  };
  GMLBase2.prototype.readLinearRing = function(node2, objectStack) {
    var flatCoordinates = this.readFlatCoordinatesFromNode(node2, objectStack);
    if (flatCoordinates) {
      return new LinearRing$1(flatCoordinates, GeometryLayout.XYZ);
    }
  };
  GMLBase2.prototype.readPolygon = function(node2, objectStack) {
    var flatLinearRings = pushParseAndPop([null], this.FLAT_LINEAR_RINGS_PARSERS, node2, objectStack, this);
    if (flatLinearRings && flatLinearRings[0]) {
      var flatCoordinates = flatLinearRings[0];
      var ends = [flatCoordinates.length];
      var i2 = void 0, ii = void 0;
      for (i2 = 1, ii = flatLinearRings.length; i2 < ii; ++i2) {
        extend$3(flatCoordinates, flatLinearRings[i2]);
        ends.push(flatCoordinates.length);
      }
      return new Polygon$2(flatCoordinates, GeometryLayout.XYZ, ends);
    } else {
      return void 0;
    }
  };
  GMLBase2.prototype.readFlatCoordinatesFromNode = function(node2, objectStack) {
    return pushParseAndPop(null, this.GEOMETRY_FLAT_COORDINATES_PARSERS, node2, objectStack, this);
  };
  GMLBase2.prototype.readGeometryFromNode = function(node2, opt_options) {
    var geometry = this.readGeometryElement(node2, [
      this.getReadOptions(node2, opt_options ? opt_options : {})
    ]);
    return geometry ? geometry : null;
  };
  GMLBase2.prototype.readFeaturesFromNode = function(node2, opt_options) {
    var options = {
      featureType: this.featureType,
      featureNS: this.featureNS
    };
    if (opt_options) {
      assign(options, this.getReadOptions(node2, opt_options));
    }
    var features = this.readFeaturesInternal(node2, [options]);
    return features || [];
  };
  GMLBase2.prototype.readProjectionFromNode = function(node2) {
    return get$3(this.srsName ? this.srsName : node2.firstElementChild.getAttribute("srsName"));
  };
  return GMLBase2;
}(XMLFeature$1);
GMLBase.prototype.namespace = GMLNS;
GMLBase.prototype.FLAT_LINEAR_RINGS_PARSERS = {
  "http://www.opengis.net/gml": {}
};
GMLBase.prototype.GEOMETRY_FLAT_COORDINATES_PARSERS = {
  "http://www.opengis.net/gml": {}
};
GMLBase.prototype.GEOMETRY_PARSERS = {
  "http://www.opengis.net/gml": {}
};
GMLBase.prototype.MULTIPOINT_PARSERS = {
  "http://www.opengis.net/gml": {
    "pointMember": makeArrayPusher(GMLBase.prototype.pointMemberParser),
    "pointMembers": makeArrayPusher(GMLBase.prototype.pointMemberParser)
  }
};
GMLBase.prototype.MULTILINESTRING_PARSERS = {
  "http://www.opengis.net/gml": {
    "lineStringMember": makeArrayPusher(GMLBase.prototype.lineStringMemberParser),
    "lineStringMembers": makeArrayPusher(GMLBase.prototype.lineStringMemberParser)
  }
};
GMLBase.prototype.MULTIPOLYGON_PARSERS = {
  "http://www.opengis.net/gml": {
    "polygonMember": makeArrayPusher(GMLBase.prototype.polygonMemberParser),
    "polygonMembers": makeArrayPusher(GMLBase.prototype.polygonMemberParser)
  }
};
GMLBase.prototype.POINTMEMBER_PARSERS = {
  "http://www.opengis.net/gml": {
    "Point": makeArrayPusher(GMLBase.prototype.readFlatCoordinatesFromNode)
  }
};
GMLBase.prototype.LINESTRINGMEMBER_PARSERS = {
  "http://www.opengis.net/gml": {
    "LineString": makeArrayPusher(GMLBase.prototype.readLineString)
  }
};
GMLBase.prototype.POLYGONMEMBER_PARSERS = {
  "http://www.opengis.net/gml": {
    "Polygon": makeArrayPusher(GMLBase.prototype.readPolygon)
  }
};
GMLBase.prototype.RING_PARSERS = {
  "http://www.opengis.net/gml": {
    "LinearRing": makeReplacer(GMLBase.prototype.readFlatLinearRing)
  }
};
var GMLBase$1 = GMLBase;
function readBoolean(node2) {
  var s2 = getAllTextContent(node2, false);
  return readBooleanString(s2);
}
function readBooleanString(string) {
  var m2 = /^\s*(true|1)|(false|0)\s*$/.exec(string);
  if (m2) {
    return m2[1] !== void 0 || false;
  } else {
    return void 0;
  }
}
function readDateTime(node2) {
  var s2 = getAllTextContent(node2, false);
  var dateTime = Date.parse(s2);
  return isNaN(dateTime) ? void 0 : dateTime / 1e3;
}
function readDecimal(node2) {
  var s2 = getAllTextContent(node2, false);
  return readDecimalString(s2);
}
function readDecimalString(string) {
  var m2 = /^\s*([+\-]?\d*\.?\d+(?:e[+\-]?\d+)?)\s*$/i.exec(string);
  if (m2) {
    return parseFloat(m2[1]);
  } else {
    return void 0;
  }
}
function readPositiveInteger(node2) {
  var s2 = getAllTextContent(node2, false);
  return readNonNegativeIntegerString(s2);
}
function readNonNegativeIntegerString(string) {
  var m2 = /^\s*(\d+)\s*$/.exec(string);
  if (m2) {
    return parseInt(m2[1], 10);
  } else {
    return void 0;
  }
}
function readString(node2) {
  return getAllTextContent(node2, false).trim();
}
function writeBooleanTextNode(node2, bool) {
  writeStringTextNode(node2, bool ? "1" : "0");
}
function writeCDATASection(node2, string) {
  node2.appendChild(getDocument().createCDATASection(string));
}
function writeDateTimeTextNode(node2, dateTime) {
  var date = new Date(dateTime * 1e3);
  var string = date.getUTCFullYear() + "-" + padNumber(date.getUTCMonth() + 1, 2) + "-" + padNumber(date.getUTCDate(), 2) + "T" + padNumber(date.getUTCHours(), 2) + ":" + padNumber(date.getUTCMinutes(), 2) + ":" + padNumber(date.getUTCSeconds(), 2) + "Z";
  node2.appendChild(getDocument().createTextNode(string));
}
function writeDecimalTextNode(node2, decimal) {
  var string = decimal.toPrecision();
  node2.appendChild(getDocument().createTextNode(string));
}
function writeNonNegativeIntegerTextNode(node2, nonNegativeInteger) {
  var string = nonNegativeInteger.toString();
  node2.appendChild(getDocument().createTextNode(string));
}
function writeStringTextNode(node2, string) {
  node2.appendChild(getDocument().createTextNode(string));
}
var __extends$k = globalThis && globalThis.__extends || function() {
  var extendStatics2 = function(d2, b2) {
    extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {
      d3.__proto__ = b3;
    } || function(d3, b3) {
      for (var p5 in b3)
        if (Object.prototype.hasOwnProperty.call(b3, p5))
          d3[p5] = b3[p5];
    };
    return extendStatics2(d2, b2);
  };
  return function(d2, b2) {
    if (typeof b2 !== "function" && b2 !== null)
      throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
    extendStatics2(d2, b2);
    function __() {
      this.constructor = d2;
    }
    d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
  };
}();
var schemaLocation$1 = GMLNS + " http://schemas.opengis.net/gml/2.1.2/feature.xsd";
var MULTIGEOMETRY_TO_MEMBER_NODENAME$1 = {
  "MultiLineString": "lineStringMember",
  "MultiCurve": "curveMember",
  "MultiPolygon": "polygonMember",
  "MultiSurface": "surfaceMember"
};
var GML2 = function(_super) {
  __extends$k(GML22, _super);
  function GML22(opt_options) {
    var _this = this;
    var options = opt_options ? opt_options : {};
    _this = _super.call(this, options) || this;
    _this.FEATURE_COLLECTION_PARSERS[GMLNS]["featureMember"] = makeArrayPusher(_this.readFeaturesInternal);
    _this.schemaLocation = options.schemaLocation ? options.schemaLocation : schemaLocation$1;
    return _this;
  }
  GML22.prototype.readFlatCoordinates = function(node2, objectStack) {
    var s2 = getAllTextContent(node2, false).replace(/^\s*|\s*$/g, "");
    var context = objectStack[0];
    var containerSrs = context["srsName"];
    var axisOrientation = "enu";
    if (containerSrs) {
      var proj = get$3(containerSrs);
      if (proj) {
        axisOrientation = proj.getAxisOrientation();
      }
    }
    var coordsGroups = s2.trim().split(/\s+/);
    var flatCoordinates = [];
    for (var i2 = 0, ii = coordsGroups.length; i2 < ii; i2++) {
      var coords = coordsGroups[i2].split(/,+/);
      var x2 = parseFloat(coords[0]);
      var y2 = parseFloat(coords[1]);
      var z2 = coords.length === 3 ? parseFloat(coords[2]) : 0;
      if (axisOrientation.substr(0, 2) === "en") {
        flatCoordinates.push(x2, y2, z2);
      } else {
        flatCoordinates.push(y2, x2, z2);
      }
    }
    return flatCoordinates;
  };
  GML22.prototype.readBox = function(node2, objectStack) {
    var flatCoordinates = pushParseAndPop([null], this.BOX_PARSERS_, node2, objectStack, this);
    return createOrUpdate$2(flatCoordinates[1][0], flatCoordinates[1][1], flatCoordinates[1][3], flatCoordinates[1][4]);
  };
  GML22.prototype.innerBoundaryIsParser = function(node2, objectStack) {
    var flatLinearRing = pushParseAndPop(void 0, this.RING_PARSERS, node2, objectStack, this);
    if (flatLinearRing) {
      var flatLinearRings = objectStack[objectStack.length - 1];
      flatLinearRings.push(flatLinearRing);
    }
  };
  GML22.prototype.outerBoundaryIsParser = function(node2, objectStack) {
    var flatLinearRing = pushParseAndPop(void 0, this.RING_PARSERS, node2, objectStack, this);
    if (flatLinearRing) {
      var flatLinearRings = objectStack[objectStack.length - 1];
      flatLinearRings[0] = flatLinearRing;
    }
  };
  GML22.prototype.GEOMETRY_NODE_FACTORY_ = function(value, objectStack, opt_nodeName) {
    var context = objectStack[objectStack.length - 1];
    var multiSurface = context["multiSurface"];
    var surface = context["surface"];
    var multiCurve = context["multiCurve"];
    var nodeName;
    if (!Array.isArray(value)) {
      nodeName = value.getType();
      if (nodeName === "MultiPolygon" && multiSurface === true) {
        nodeName = "MultiSurface";
      } else if (nodeName === "Polygon" && surface === true) {
        nodeName = "Surface";
      } else if (nodeName === "MultiLineString" && multiCurve === true) {
        nodeName = "MultiCurve";
      }
    } else {
      nodeName = "Envelope";
    }
    return createElementNS("http://www.opengis.net/gml", nodeName);
  };
  GML22.prototype.writeFeatureElement = function(node2, feature2, objectStack) {
    var fid = feature2.getId();
    if (fid) {
      node2.setAttribute("fid", fid);
    }
    var context = objectStack[objectStack.length - 1];
    var featureNS = context["featureNS"];
    var geometryName = feature2.getGeometryName();
    if (!context.serializers) {
      context.serializers = {};
      context.serializers[featureNS] = {};
    }
    var keys3 = [];
    var values2 = [];
    if (feature2.hasProperties()) {
      var properties = feature2.getProperties();
      for (var key in properties) {
        var value = properties[key];
        if (value !== null) {
          keys3.push(key);
          values2.push(value);
          if (key == geometryName || typeof value.getSimplifiedGeometry === "function") {
            if (!(key in context.serializers[featureNS])) {
              context.serializers[featureNS][key] = makeChildAppender(this.writeGeometryElement, this);
            }
          } else {
            if (!(key in context.serializers[featureNS])) {
              context.serializers[featureNS][key] = makeChildAppender(writeStringTextNode);
            }
          }
        }
      }
    }
    var item = assign({}, context);
    item.node = node2;
    pushSerializeAndPop(item, context.serializers, makeSimpleNodeFactory(void 0, featureNS), values2, objectStack, keys3);
  };
  GML22.prototype.writeCurveOrLineString = function(node2, geometry, objectStack) {
    var context = objectStack[objectStack.length - 1];
    var srsName = context["srsName"];
    if (node2.nodeName !== "LineStringSegment" && srsName) {
      node2.setAttribute("srsName", srsName);
    }
    if (node2.nodeName === "LineString" || node2.nodeName === "LineStringSegment") {
      var coordinates2 = this.createCoordinatesNode_(node2.namespaceURI);
      node2.appendChild(coordinates2);
      this.writeCoordinates_(coordinates2, geometry, objectStack);
    } else if (node2.nodeName === "Curve") {
      var segments = createElementNS(node2.namespaceURI, "segments");
      node2.appendChild(segments);
      this.writeCurveSegments_(segments, geometry, objectStack);
    }
  };
  GML22.prototype.writeLineStringOrCurveMember = function(node2, line, objectStack) {
    var child = this.GEOMETRY_NODE_FACTORY_(line, objectStack);
    if (child) {
      node2.appendChild(child);
      this.writeCurveOrLineString(child, line, objectStack);
    }
  };
  GML22.prototype.writeMultiCurveOrLineString = function(node2, geometry, objectStack) {
    var context = objectStack[objectStack.length - 1];
    var hasZ = context["hasZ"];
    var srsName = context["srsName"];
    var curve = context["curve"];
    if (srsName) {
      node2.setAttribute("srsName", srsName);
    }
    var lines = geometry.getLineStrings();
    pushSerializeAndPop({ node: node2, hasZ, srsName, curve }, this.LINESTRINGORCURVEMEMBER_SERIALIZERS, this.MULTIGEOMETRY_MEMBER_NODE_FACTORY_, lines, objectStack, void 0, this);
  };
  GML22.prototype.writeGeometryElement = function(node2, geometry, objectStack) {
    var context = objectStack[objectStack.length - 1];
    var item = assign({}, context);
    item["node"] = node2;
    var value;
    if (Array.isArray(geometry)) {
      value = transformExtentWithOptions(geometry, context);
    } else {
      value = transformGeometryWithOptions(geometry, true, context);
    }
    pushSerializeAndPop(item, this.GEOMETRY_SERIALIZERS, this.GEOMETRY_NODE_FACTORY_, [value], objectStack, void 0, this);
  };
  GML22.prototype.createCoordinatesNode_ = function(namespaceURI) {
    var coordinates2 = createElementNS(namespaceURI, "coordinates");
    coordinates2.setAttribute("decimal", ".");
    coordinates2.setAttribute("cs", ",");
    coordinates2.setAttribute("ts", " ");
    return coordinates2;
  };
  GML22.prototype.writeCoordinates_ = function(node2, value, objectStack) {
    var context = objectStack[objectStack.length - 1];
    var hasZ = context["hasZ"];
    var srsName = context["srsName"];
    var points = value.getCoordinates();
    var len = points.length;
    var parts = new Array(len);
    for (var i2 = 0; i2 < len; ++i2) {
      var point = points[i2];
      parts[i2] = this.getCoords_(point, srsName, hasZ);
    }
    writeStringTextNode(node2, parts.join(" "));
  };
  GML22.prototype.writeCurveSegments_ = function(node2, line, objectStack) {
    var child = createElementNS(node2.namespaceURI, "LineStringSegment");
    node2.appendChild(child);
    this.writeCurveOrLineString(child, line, objectStack);
  };
  GML22.prototype.writeSurfaceOrPolygon = function(node2, geometry, objectStack) {
    var context = objectStack[objectStack.length - 1];
    var hasZ = context["hasZ"];
    var srsName = context["srsName"];
    if (node2.nodeName !== "PolygonPatch" && srsName) {
      node2.setAttribute("srsName", srsName);
    }
    if (node2.nodeName === "Polygon" || node2.nodeName === "PolygonPatch") {
      var rings = geometry.getLinearRings();
      pushSerializeAndPop({ node: node2, hasZ, srsName }, this.RING_SERIALIZERS, this.RING_NODE_FACTORY_, rings, objectStack, void 0, this);
    } else if (node2.nodeName === "Surface") {
      var patches = createElementNS(node2.namespaceURI, "patches");
      node2.appendChild(patches);
      this.writeSurfacePatches_(patches, geometry, objectStack);
    }
  };
  GML22.prototype.RING_NODE_FACTORY_ = function(value, objectStack, opt_nodeName) {
    var context = objectStack[objectStack.length - 1];
    var parentNode = context.node;
    var exteriorWritten = context["exteriorWritten"];
    if (exteriorWritten === void 0) {
      context["exteriorWritten"] = true;
    }
    return createElementNS(parentNode.namespaceURI, exteriorWritten !== void 0 ? "innerBoundaryIs" : "outerBoundaryIs");
  };
  GML22.prototype.writeSurfacePatches_ = function(node2, polygon, objectStack) {
    var child = createElementNS(node2.namespaceURI, "PolygonPatch");
    node2.appendChild(child);
    this.writeSurfaceOrPolygon(child, polygon, objectStack);
  };
  GML22.prototype.writeRing = function(node2, ring, objectStack) {
    var linearRing2 = createElementNS(node2.namespaceURI, "LinearRing");
    node2.appendChild(linearRing2);
    this.writeLinearRing(linearRing2, ring, objectStack);
  };
  GML22.prototype.getCoords_ = function(point, opt_srsName, opt_hasZ) {
    var axisOrientation = "enu";
    if (opt_srsName) {
      axisOrientation = get$3(opt_srsName).getAxisOrientation();
    }
    var coords = axisOrientation.substr(0, 2) === "en" ? point[0] + "," + point[1] : point[1] + "," + point[0];
    if (opt_hasZ) {
      var z2 = point[2] || 0;
      coords += "," + z2;
    }
    return coords;
  };
  GML22.prototype.writePoint = function(node2, geometry, objectStack) {
    var context = objectStack[objectStack.length - 1];
    var hasZ = context["hasZ"];
    var srsName = context["srsName"];
    if (srsName) {
      node2.setAttribute("srsName", srsName);
    }
    var coordinates2 = this.createCoordinatesNode_(node2.namespaceURI);
    node2.appendChild(coordinates2);
    var point = geometry.getCoordinates();
    var coord = this.getCoords_(point, srsName, hasZ);
    writeStringTextNode(coordinates2, coord);
  };
  GML22.prototype.writeMultiPoint = function(node2, geometry, objectStack) {
    var context = objectStack[objectStack.length - 1];
    var hasZ = context["hasZ"];
    var srsName = context["srsName"];
    if (srsName) {
      node2.setAttribute("srsName", srsName);
    }
    var points = geometry.getPoints();
    pushSerializeAndPop({ node: node2, hasZ, srsName }, this.POINTMEMBER_SERIALIZERS, makeSimpleNodeFactory("pointMember"), points, objectStack, void 0, this);
  };
  GML22.prototype.writePointMember = function(node2, point, objectStack) {
    var child = createElementNS(node2.namespaceURI, "Point");
    node2.appendChild(child);
    this.writePoint(child, point, objectStack);
  };
  GML22.prototype.writeLinearRing = function(node2, geometry, objectStack) {
    var context = objectStack[objectStack.length - 1];
    var srsName = context["srsName"];
    if (srsName) {
      node2.setAttribute("srsName", srsName);
    }
    var coordinates2 = this.createCoordinatesNode_(node2.namespaceURI);
    node2.appendChild(coordinates2);
    this.writeCoordinates_(coordinates2, geometry, objectStack);
  };
  GML22.prototype.writeMultiSurfaceOrPolygon = function(node2, geometry, objectStack) {
    var context = objectStack[objectStack.length - 1];
    var hasZ = context["hasZ"];
    var srsName = context["srsName"];
    var surface = context["surface"];
    if (srsName) {
      node2.setAttribute("srsName", srsName);
    }
    var polygons = geometry.getPolygons();
    pushSerializeAndPop({ node: node2, hasZ, srsName, surface }, this.SURFACEORPOLYGONMEMBER_SERIALIZERS, this.MULTIGEOMETRY_MEMBER_NODE_FACTORY_, polygons, objectStack, void 0, this);
  };
  GML22.prototype.writeSurfaceOrPolygonMember = function(node2, polygon, objectStack) {
    var child = this.GEOMETRY_NODE_FACTORY_(polygon, objectStack);
    if (child) {
      node2.appendChild(child);
      this.writeSurfaceOrPolygon(child, polygon, objectStack);
    }
  };
  GML22.prototype.writeEnvelope = function(node2, extent2, objectStack) {
    var context = objectStack[objectStack.length - 1];
    var srsName = context["srsName"];
    if (srsName) {
      node2.setAttribute("srsName", srsName);
    }
    var keys3 = ["lowerCorner", "upperCorner"];
    var values2 = [extent2[0] + " " + extent2[1], extent2[2] + " " + extent2[3]];
    pushSerializeAndPop({ node: node2 }, this.ENVELOPE_SERIALIZERS, OBJECT_PROPERTY_NODE_FACTORY, values2, objectStack, keys3, this);
  };
  GML22.prototype.MULTIGEOMETRY_MEMBER_NODE_FACTORY_ = function(value, objectStack, opt_nodeName) {
    var parentNode = objectStack[objectStack.length - 1].node;
    return createElementNS("http://www.opengis.net/gml", MULTIGEOMETRY_TO_MEMBER_NODENAME$1[parentNode.nodeName]);
  };
  return GML22;
}(GMLBase$1);
GML2.prototype.GEOMETRY_FLAT_COORDINATES_PARSERS = {
  "http://www.opengis.net/gml": {
    "coordinates": makeReplacer(GML2.prototype.readFlatCoordinates)
  }
};
GML2.prototype.FLAT_LINEAR_RINGS_PARSERS = {
  "http://www.opengis.net/gml": {
    "innerBoundaryIs": GML2.prototype.innerBoundaryIsParser,
    "outerBoundaryIs": GML2.prototype.outerBoundaryIsParser
  }
};
GML2.prototype.BOX_PARSERS_ = {
  "http://www.opengis.net/gml": {
    "coordinates": makeArrayPusher(GML2.prototype.readFlatCoordinates)
  }
};
GML2.prototype.GEOMETRY_PARSERS = {
  "http://www.opengis.net/gml": {
    "Point": makeReplacer(GMLBase$1.prototype.readPoint),
    "MultiPoint": makeReplacer(GMLBase$1.prototype.readMultiPoint),
    "LineString": makeReplacer(GMLBase$1.prototype.readLineString),
    "MultiLineString": makeReplacer(GMLBase$1.prototype.readMultiLineString),
    "LinearRing": makeReplacer(GMLBase$1.prototype.readLinearRing),
    "Polygon": makeReplacer(GMLBase$1.prototype.readPolygon),
    "MultiPolygon": makeReplacer(GMLBase$1.prototype.readMultiPolygon),
    "Box": makeReplacer(GML2.prototype.readBox)
  }
};
GML2.prototype.GEOMETRY_SERIALIZERS = {
  "http://www.opengis.net/gml": {
    "Curve": makeChildAppender(GML2.prototype.writeCurveOrLineString),
    "MultiCurve": makeChildAppender(GML2.prototype.writeMultiCurveOrLineString),
    "Point": makeChildAppender(GML2.prototype.writePoint),
    "MultiPoint": makeChildAppender(GML2.prototype.writeMultiPoint),
    "LineString": makeChildAppender(GML2.prototype.writeCurveOrLineString),
    "MultiLineString": makeChildAppender(GML2.prototype.writeMultiCurveOrLineString),
    "LinearRing": makeChildAppender(GML2.prototype.writeLinearRing),
    "Polygon": makeChildAppender(GML2.prototype.writeSurfaceOrPolygon),
    "MultiPolygon": makeChildAppender(GML2.prototype.writeMultiSurfaceOrPolygon),
    "Surface": makeChildAppender(GML2.prototype.writeSurfaceOrPolygon),
    "MultiSurface": makeChildAppender(GML2.prototype.writeMultiSurfaceOrPolygon),
    "Envelope": makeChildAppender(GML2.prototype.writeEnvelope)
  }
};
GML2.prototype.LINESTRINGORCURVEMEMBER_SERIALIZERS = {
  "http://www.opengis.net/gml": {
    "lineStringMember": makeChildAppender(GML2.prototype.writeLineStringOrCurveMember),
    "curveMember": makeChildAppender(GML2.prototype.writeLineStringOrCurveMember)
  }
};
GML2.prototype.RING_SERIALIZERS = {
  "http://www.opengis.net/gml": {
    "outerBoundaryIs": makeChildAppender(GML2.prototype.writeRing),
    "innerBoundaryIs": makeChildAppender(GML2.prototype.writeRing)
  }
};
GML2.prototype.POINTMEMBER_SERIALIZERS = {
  "http://www.opengis.net/gml": {
    "pointMember": makeChildAppender(GML2.prototype.writePointMember)
  }
};
GML2.prototype.SURFACEORPOLYGONMEMBER_SERIALIZERS = {
  "http://www.opengis.net/gml": {
    "surfaceMember": makeChildAppender(GML2.prototype.writeSurfaceOrPolygonMember),
    "polygonMember": makeChildAppender(GML2.prototype.writeSurfaceOrPolygonMember)
  }
};
GML2.prototype.ENVELOPE_SERIALIZERS = {
  "http://www.opengis.net/gml": {
    "lowerCorner": makeChildAppender(writeStringTextNode),
    "upperCorner": makeChildAppender(writeStringTextNode)
  }
};
var GML2$1 = GML2;
var __extends$j = globalThis && globalThis.__extends || function() {
  var extendStatics2 = function(d2, b2) {
    extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {
      d3.__proto__ = b3;
    } || function(d3, b3) {
      for (var p5 in b3)
        if (Object.prototype.hasOwnProperty.call(b3, p5))
          d3[p5] = b3[p5];
    };
    return extendStatics2(d2, b2);
  };
  return function(d2, b2) {
    if (typeof b2 !== "function" && b2 !== null)
      throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
    extendStatics2(d2, b2);
    function __() {
      this.constructor = d2;
    }
    d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
  };
}();
var schemaLocation = GMLNS + " http://schemas.opengis.net/gml/3.1.1/profiles/gmlsfProfile/1.0.0/gmlsf.xsd";
var MULTIGEOMETRY_TO_MEMBER_NODENAME = {
  "MultiLineString": "lineStringMember",
  "MultiCurve": "curveMember",
  "MultiPolygon": "polygonMember",
  "MultiSurface": "surfaceMember"
};
var GML3 = function(_super) {
  __extends$j(GML33, _super);
  function GML33(opt_options) {
    var _this = this;
    var options = opt_options ? opt_options : {};
    _this = _super.call(this, options) || this;
    _this.surface_ = options.surface !== void 0 ? options.surface : false;
    _this.curve_ = options.curve !== void 0 ? options.curve : false;
    _this.multiCurve_ = options.multiCurve !== void 0 ? options.multiCurve : true;
    _this.multiSurface_ = options.multiSurface !== void 0 ? options.multiSurface : true;
    _this.schemaLocation = options.schemaLocation ? options.schemaLocation : schemaLocation;
    _this.hasZ = options.hasZ !== void 0 ? options.hasZ : false;
    return _this;
  }
  GML33.prototype.readMultiCurve = function(node2, objectStack) {
    var lineStrings = pushParseAndPop([], this.MULTICURVE_PARSERS, node2, objectStack, this);
    if (lineStrings) {
      var multiLineString = new MultiLineString$2(lineStrings);
      return multiLineString;
    } else {
      return void 0;
    }
  };
  GML33.prototype.readMultiSurface = function(node2, objectStack) {
    var polygons = pushParseAndPop([], this.MULTISURFACE_PARSERS, node2, objectStack, this);
    if (polygons) {
      return new MultiPolygon$2(polygons);
    }
  };
  GML33.prototype.curveMemberParser = function(node2, objectStack) {
    parseNode(this.CURVEMEMBER_PARSERS, node2, objectStack, this);
  };
  GML33.prototype.surfaceMemberParser = function(node2, objectStack) {
    parseNode(this.SURFACEMEMBER_PARSERS, node2, objectStack, this);
  };
  GML33.prototype.readPatch = function(node2, objectStack) {
    return pushParseAndPop([null], this.PATCHES_PARSERS, node2, objectStack, this);
  };
  GML33.prototype.readSegment = function(node2, objectStack) {
    return pushParseAndPop([null], this.SEGMENTS_PARSERS, node2, objectStack, this);
  };
  GML33.prototype.readPolygonPatch = function(node2, objectStack) {
    return pushParseAndPop([null], this.FLAT_LINEAR_RINGS_PARSERS, node2, objectStack, this);
  };
  GML33.prototype.readLineStringSegment = function(node2, objectStack) {
    return pushParseAndPop([null], this.GEOMETRY_FLAT_COORDINATES_PARSERS, node2, objectStack, this);
  };
  GML33.prototype.interiorParser = function(node2, objectStack) {
    var flatLinearRing = pushParseAndPop(void 0, this.RING_PARSERS, node2, objectStack, this);
    if (flatLinearRing) {
      var flatLinearRings = objectStack[objectStack.length - 1];
      flatLinearRings.push(flatLinearRing);
    }
  };
  GML33.prototype.exteriorParser = function(node2, objectStack) {
    var flatLinearRing = pushParseAndPop(void 0, this.RING_PARSERS, node2, objectStack, this);
    if (flatLinearRing) {
      var flatLinearRings = objectStack[objectStack.length - 1];
      flatLinearRings[0] = flatLinearRing;
    }
  };
  GML33.prototype.readSurface = function(node2, objectStack) {
    var flatLinearRings = pushParseAndPop([null], this.SURFACE_PARSERS, node2, objectStack, this);
    if (flatLinearRings && flatLinearRings[0]) {
      var flatCoordinates = flatLinearRings[0];
      var ends = [flatCoordinates.length];
      var i2 = void 0, ii = void 0;
      for (i2 = 1, ii = flatLinearRings.length; i2 < ii; ++i2) {
        extend$3(flatCoordinates, flatLinearRings[i2]);
        ends.push(flatCoordinates.length);
      }
      return new Polygon$2(flatCoordinates, GeometryLayout.XYZ, ends);
    } else {
      return void 0;
    }
  };
  GML33.prototype.readCurve = function(node2, objectStack) {
    var flatCoordinates = pushParseAndPop([null], this.CURVE_PARSERS, node2, objectStack, this);
    if (flatCoordinates) {
      var lineString = new LineString$2(flatCoordinates, GeometryLayout.XYZ);
      return lineString;
    } else {
      return void 0;
    }
  };
  GML33.prototype.readEnvelope = function(node2, objectStack) {
    var flatCoordinates = pushParseAndPop([null], this.ENVELOPE_PARSERS, node2, objectStack, this);
    return createOrUpdate$2(flatCoordinates[1][0], flatCoordinates[1][1], flatCoordinates[2][0], flatCoordinates[2][1]);
  };
  GML33.prototype.readFlatPos = function(node2, objectStack) {
    var s2 = getAllTextContent(node2, false);
    var re2 = /^\s*([+\-]?\d*\.?\d+(?:[eE][+\-]?\d+)?)\s*/;
    var flatCoordinates = [];
    var m2;
    while (m2 = re2.exec(s2)) {
      flatCoordinates.push(parseFloat(m2[1]));
      s2 = s2.substr(m2[0].length);
    }
    if (s2 !== "") {
      return void 0;
    }
    var context = objectStack[0];
    var containerSrs = context["srsName"];
    var axisOrientation = "enu";
    if (containerSrs) {
      var proj = get$3(containerSrs);
      axisOrientation = proj.getAxisOrientation();
    }
    if (axisOrientation === "neu") {
      var i2 = void 0, ii = void 0;
      for (i2 = 0, ii = flatCoordinates.length; i2 < ii; i2 += 3) {
        var y2 = flatCoordinates[i2];
        var x2 = flatCoordinates[i2 + 1];
        flatCoordinates[i2] = x2;
        flatCoordinates[i2 + 1] = y2;
      }
    }
    var len = flatCoordinates.length;
    if (len == 2) {
      flatCoordinates.push(0);
    }
    if (len === 0) {
      return void 0;
    }
    return flatCoordinates;
  };
  GML33.prototype.readFlatPosList = function(node2, objectStack) {
    var s2 = getAllTextContent(node2, false).replace(/^\s*|\s*$/g, "");
    var context = objectStack[0];
    var containerSrs = context["srsName"];
    var contextDimension = context["srsDimension"];
    var axisOrientation = "enu";
    if (containerSrs) {
      var proj = get$3(containerSrs);
      axisOrientation = proj.getAxisOrientation();
    }
    var coords = s2.split(/\s+/);
    var dim = 2;
    if (node2.getAttribute("srsDimension")) {
      dim = readNonNegativeIntegerString(node2.getAttribute("srsDimension"));
    } else if (node2.getAttribute("dimension")) {
      dim = readNonNegativeIntegerString(node2.getAttribute("dimension"));
    } else if (node2.parentNode.getAttribute("srsDimension")) {
      dim = readNonNegativeIntegerString(node2.parentNode.getAttribute("srsDimension"));
    } else if (contextDimension) {
      dim = readNonNegativeIntegerString(contextDimension);
    }
    var x2, y2, z2;
    var flatCoordinates = [];
    for (var i2 = 0, ii = coords.length; i2 < ii; i2 += dim) {
      x2 = parseFloat(coords[i2]);
      y2 = parseFloat(coords[i2 + 1]);
      z2 = dim === 3 ? parseFloat(coords[i2 + 2]) : 0;
      if (axisOrientation.substr(0, 2) === "en") {
        flatCoordinates.push(x2, y2, z2);
      } else {
        flatCoordinates.push(y2, x2, z2);
      }
    }
    return flatCoordinates;
  };
  GML33.prototype.writePos_ = function(node2, value, objectStack) {
    var context = objectStack[objectStack.length - 1];
    var hasZ = context["hasZ"];
    var srsDimension = hasZ ? "3" : "2";
    node2.setAttribute("srsDimension", srsDimension);
    var srsName = context["srsName"];
    var axisOrientation = "enu";
    if (srsName) {
      axisOrientation = get$3(srsName).getAxisOrientation();
    }
    var point = value.getCoordinates();
    var coords;
    if (axisOrientation.substr(0, 2) === "en") {
      coords = point[0] + " " + point[1];
    } else {
      coords = point[1] + " " + point[0];
    }
    if (hasZ) {
      var z2 = point[2] || 0;
      coords += " " + z2;
    }
    writeStringTextNode(node2, coords);
  };
  GML33.prototype.getCoords_ = function(point, opt_srsName, opt_hasZ) {
    var axisOrientation = "enu";
    if (opt_srsName) {
      axisOrientation = get$3(opt_srsName).getAxisOrientation();
    }
    var coords = axisOrientation.substr(0, 2) === "en" ? point[0] + " " + point[1] : point[1] + " " + point[0];
    if (opt_hasZ) {
      var z2 = point[2] || 0;
      coords += " " + z2;
    }
    return coords;
  };
  GML33.prototype.writePosList_ = function(node2, value, objectStack) {
    var context = objectStack[objectStack.length - 1];
    var hasZ = context["hasZ"];
    var srsDimension = hasZ ? "3" : "2";
    node2.setAttribute("srsDimension", srsDimension);
    var srsName = context["srsName"];
    var points = value.getCoordinates();
    var len = points.length;
    var parts = new Array(len);
    var point;
    for (var i2 = 0; i2 < len; ++i2) {
      point = points[i2];
      parts[i2] = this.getCoords_(point, srsName, hasZ);
    }
    writeStringTextNode(node2, parts.join(" "));
  };
  GML33.prototype.writePoint = function(node2, geometry, objectStack) {
    var context = objectStack[objectStack.length - 1];
    var srsName = context["srsName"];
    if (srsName) {
      node2.setAttribute("srsName", srsName);
    }
    var pos = createElementNS(node2.namespaceURI, "pos");
    node2.appendChild(pos);
    this.writePos_(pos, geometry, objectStack);
  };
  GML33.prototype.writeEnvelope = function(node2, extent2, objectStack) {
    var context = objectStack[objectStack.length - 1];
    var srsName = context["srsName"];
    if (srsName) {
      node2.setAttribute("srsName", srsName);
    }
    var keys3 = ["lowerCorner", "upperCorner"];
    var values2 = [extent2[0] + " " + extent2[1], extent2[2] + " " + extent2[3]];
    pushSerializeAndPop({ node: node2 }, this.ENVELOPE_SERIALIZERS, OBJECT_PROPERTY_NODE_FACTORY, values2, objectStack, keys3, this);
  };
  GML33.prototype.writeLinearRing = function(node2, geometry, objectStack) {
    var context = objectStack[objectStack.length - 1];
    var srsName = context["srsName"];
    if (srsName) {
      node2.setAttribute("srsName", srsName);
    }
    var posList = createElementNS(node2.namespaceURI, "posList");
    node2.appendChild(posList);
    this.writePosList_(posList, geometry, objectStack);
  };
  GML33.prototype.RING_NODE_FACTORY_ = function(value, objectStack, opt_nodeName) {
    var context = objectStack[objectStack.length - 1];
    var parentNode = context.node;
    var exteriorWritten = context["exteriorWritten"];
    if (exteriorWritten === void 0) {
      context["exteriorWritten"] = true;
    }
    return createElementNS(parentNode.namespaceURI, exteriorWritten !== void 0 ? "interior" : "exterior");
  };
  GML33.prototype.writeSurfaceOrPolygon = function(node2, geometry, objectStack) {
    var context = objectStack[objectStack.length - 1];
    var hasZ = context["hasZ"];
    var srsName = context["srsName"];
    if (node2.nodeName !== "PolygonPatch" && srsName) {
      node2.setAttribute("srsName", srsName);
    }
    if (node2.nodeName === "Polygon" || node2.nodeName === "PolygonPatch") {
      var rings = geometry.getLinearRings();
      pushSerializeAndPop({ node: node2, hasZ, srsName }, this.RING_SERIALIZERS, this.RING_NODE_FACTORY_, rings, objectStack, void 0, this);
    } else if (node2.nodeName === "Surface") {
      var patches = createElementNS(node2.namespaceURI, "patches");
      node2.appendChild(patches);
      this.writeSurfacePatches_(patches, geometry, objectStack);
    }
  };
  GML33.prototype.writeCurveOrLineString = function(node2, geometry, objectStack) {
    var context = objectStack[objectStack.length - 1];
    var srsName = context["srsName"];
    if (node2.nodeName !== "LineStringSegment" && srsName) {
      node2.setAttribute("srsName", srsName);
    }
    if (node2.nodeName === "LineString" || node2.nodeName === "LineStringSegment") {
      var posList = createElementNS(node2.namespaceURI, "posList");
      node2.appendChild(posList);
      this.writePosList_(posList, geometry, objectStack);
    } else if (node2.nodeName === "Curve") {
      var segments = createElementNS(node2.namespaceURI, "segments");
      node2.appendChild(segments);
      this.writeCurveSegments_(segments, geometry, objectStack);
    }
  };
  GML33.prototype.writeMultiSurfaceOrPolygon = function(node2, geometry, objectStack) {
    var context = objectStack[objectStack.length - 1];
    var hasZ = context["hasZ"];
    var srsName = context["srsName"];
    var surface = context["surface"];
    if (srsName) {
      node2.setAttribute("srsName", srsName);
    }
    var polygons = geometry.getPolygons();
    pushSerializeAndPop({ node: node2, hasZ, srsName, surface }, this.SURFACEORPOLYGONMEMBER_SERIALIZERS, this.MULTIGEOMETRY_MEMBER_NODE_FACTORY_, polygons, objectStack, void 0, this);
  };
  GML33.prototype.writeMultiPoint = function(node2, geometry, objectStack) {
    var context = objectStack[objectStack.length - 1];
    var srsName = context["srsName"];
    var hasZ = context["hasZ"];
    if (srsName) {
      node2.setAttribute("srsName", srsName);
    }
    var points = geometry.getPoints();
    pushSerializeAndPop({ node: node2, hasZ, srsName }, this.POINTMEMBER_SERIALIZERS, makeSimpleNodeFactory("pointMember"), points, objectStack, void 0, this);
  };
  GML33.prototype.writeMultiCurveOrLineString = function(node2, geometry, objectStack) {
    var context = objectStack[objectStack.length - 1];
    var hasZ = context["hasZ"];
    var srsName = context["srsName"];
    var curve = context["curve"];
    if (srsName) {
      node2.setAttribute("srsName", srsName);
    }
    var lines = geometry.getLineStrings();
    pushSerializeAndPop({ node: node2, hasZ, srsName, curve }, this.LINESTRINGORCURVEMEMBER_SERIALIZERS, this.MULTIGEOMETRY_MEMBER_NODE_FACTORY_, lines, objectStack, void 0, this);
  };
  GML33.prototype.writeRing = function(node2, ring, objectStack) {
    var linearRing2 = createElementNS(node2.namespaceURI, "LinearRing");
    node2.appendChild(linearRing2);
    this.writeLinearRing(linearRing2, ring, objectStack);
  };
  GML33.prototype.writeSurfaceOrPolygonMember = function(node2, polygon, objectStack) {
    var child = this.GEOMETRY_NODE_FACTORY_(polygon, objectStack);
    if (child) {
      node2.appendChild(child);
      this.writeSurfaceOrPolygon(child, polygon, objectStack);
    }
  };
  GML33.prototype.writePointMember = function(node2, point, objectStack) {
    var child = createElementNS(node2.namespaceURI, "Point");
    node2.appendChild(child);
    this.writePoint(child, point, objectStack);
  };
  GML33.prototype.writeLineStringOrCurveMember = function(node2, line, objectStack) {
    var child = this.GEOMETRY_NODE_FACTORY_(line, objectStack);
    if (child) {
      node2.appendChild(child);
      this.writeCurveOrLineString(child, line, objectStack);
    }
  };
  GML33.prototype.writeSurfacePatches_ = function(node2, polygon, objectStack) {
    var child = createElementNS(node2.namespaceURI, "PolygonPatch");
    node2.appendChild(child);
    this.writeSurfaceOrPolygon(child, polygon, objectStack);
  };
  GML33.prototype.writeCurveSegments_ = function(node2, line, objectStack) {
    var child = createElementNS(node2.namespaceURI, "LineStringSegment");
    node2.appendChild(child);
    this.writeCurveOrLineString(child, line, objectStack);
  };
  GML33.prototype.writeGeometryElement = function(node2, geometry, objectStack) {
    var context = objectStack[objectStack.length - 1];
    var item = assign({}, context);
    item["node"] = node2;
    var value;
    if (Array.isArray(geometry)) {
      value = transformExtentWithOptions(geometry, context);
    } else {
      value = transformGeometryWithOptions(geometry, true, context);
    }
    pushSerializeAndPop(item, this.GEOMETRY_SERIALIZERS, this.GEOMETRY_NODE_FACTORY_, [value], objectStack, void 0, this);
  };
  GML33.prototype.writeFeatureElement = function(node2, feature2, objectStack) {
    var fid = feature2.getId();
    if (fid) {
      node2.setAttribute("fid", fid);
    }
    var context = objectStack[objectStack.length - 1];
    var featureNS = context["featureNS"];
    var geometryName = feature2.getGeometryName();
    if (!context.serializers) {
      context.serializers = {};
      context.serializers[featureNS] = {};
    }
    var keys3 = [];
    var values2 = [];
    if (feature2.hasProperties()) {
      var properties = feature2.getProperties();
      for (var key in properties) {
        var value = properties[key];
        if (value !== null) {
          keys3.push(key);
          values2.push(value);
          if (key == geometryName || typeof value.getSimplifiedGeometry === "function") {
            if (!(key in context.serializers[featureNS])) {
              context.serializers[featureNS][key] = makeChildAppender(this.writeGeometryElement, this);
            }
          } else {
            if (!(key in context.serializers[featureNS])) {
              context.serializers[featureNS][key] = makeChildAppender(writeStringTextNode);
            }
          }
        }
      }
    }
    var item = assign({}, context);
    item.node = node2;
    pushSerializeAndPop(item, context.serializers, makeSimpleNodeFactory(void 0, featureNS), values2, objectStack, keys3);
  };
  GML33.prototype.writeFeatureMembers_ = function(node2, features, objectStack) {
    var context = objectStack[objectStack.length - 1];
    var featureType = context["featureType"];
    var featureNS = context["featureNS"];
    var serializers = {};
    serializers[featureNS] = {};
    serializers[featureNS][featureType] = makeChildAppender(this.writeFeatureElement, this);
    var item = assign({}, context);
    item.node = node2;
    pushSerializeAndPop(item, serializers, makeSimpleNodeFactory(featureType, featureNS), features, objectStack);
  };
  GML33.prototype.MULTIGEOMETRY_MEMBER_NODE_FACTORY_ = function(value, objectStack, opt_nodeName) {
    var parentNode = objectStack[objectStack.length - 1].node;
    return createElementNS(this.namespace, MULTIGEOMETRY_TO_MEMBER_NODENAME[parentNode.nodeName]);
  };
  GML33.prototype.GEOMETRY_NODE_FACTORY_ = function(value, objectStack, opt_nodeName) {
    var context = objectStack[objectStack.length - 1];
    var multiSurface = context["multiSurface"];
    var surface = context["surface"];
    var curve = context["curve"];
    var multiCurve = context["multiCurve"];
    var nodeName;
    if (!Array.isArray(value)) {
      nodeName = value.getType();
      if (nodeName === "MultiPolygon" && multiSurface === true) {
        nodeName = "MultiSurface";
      } else if (nodeName === "Polygon" && surface === true) {
        nodeName = "Surface";
      } else if (nodeName === "LineString" && curve === true) {
        nodeName = "Curve";
      } else if (nodeName === "MultiLineString" && multiCurve === true) {
        nodeName = "MultiCurve";
      }
    } else {
      nodeName = "Envelope";
    }
    return createElementNS(this.namespace, nodeName);
  };
  GML33.prototype.writeGeometryNode = function(geometry, opt_options) {
    opt_options = this.adaptOptions(opt_options);
    var geom2 = createElementNS(this.namespace, "geom");
    var context = {
      node: geom2,
      hasZ: this.hasZ,
      srsName: this.srsName,
      curve: this.curve_,
      surface: this.surface_,
      multiSurface: this.multiSurface_,
      multiCurve: this.multiCurve_
    };
    if (opt_options) {
      assign(context, opt_options);
    }
    this.writeGeometryElement(geom2, geometry, [context]);
    return geom2;
  };
  GML33.prototype.writeFeaturesNode = function(features, opt_options) {
    opt_options = this.adaptOptions(opt_options);
    var node2 = createElementNS(this.namespace, "featureMembers");
    node2.setAttributeNS(XML_SCHEMA_INSTANCE_URI, "xsi:schemaLocation", this.schemaLocation);
    var context = {
      srsName: this.srsName,
      hasZ: this.hasZ,
      curve: this.curve_,
      surface: this.surface_,
      multiSurface: this.multiSurface_,
      multiCurve: this.multiCurve_,
      featureNS: this.featureNS,
      featureType: this.featureType
    };
    if (opt_options) {
      assign(context, opt_options);
    }
    this.writeFeatureMembers_(node2, features, [context]);
    return node2;
  };
  return GML33;
}(GMLBase$1);
GML3.prototype.GEOMETRY_FLAT_COORDINATES_PARSERS = {
  "http://www.opengis.net/gml": {
    "pos": makeReplacer(GML3.prototype.readFlatPos),
    "posList": makeReplacer(GML3.prototype.readFlatPosList),
    "coordinates": makeReplacer(GML2$1.prototype.readFlatCoordinates)
  }
};
GML3.prototype.FLAT_LINEAR_RINGS_PARSERS = {
  "http://www.opengis.net/gml": {
    "interior": GML3.prototype.interiorParser,
    "exterior": GML3.prototype.exteriorParser
  }
};
GML3.prototype.GEOMETRY_PARSERS = {
  "http://www.opengis.net/gml": {
    "Point": makeReplacer(GMLBase$1.prototype.readPoint),
    "MultiPoint": makeReplacer(GMLBase$1.prototype.readMultiPoint),
    "LineString": makeReplacer(GMLBase$1.prototype.readLineString),
    "MultiLineString": makeReplacer(GMLBase$1.prototype.readMultiLineString),
    "LinearRing": makeReplacer(GMLBase$1.prototype.readLinearRing),
    "Polygon": makeReplacer(GMLBase$1.prototype.readPolygon),
    "MultiPolygon": makeReplacer(GMLBase$1.prototype.readMultiPolygon),
    "Surface": makeReplacer(GML3.prototype.readSurface),
    "MultiSurface": makeReplacer(GML3.prototype.readMultiSurface),
    "Curve": makeReplacer(GML3.prototype.readCurve),
    "MultiCurve": makeReplacer(GML3.prototype.readMultiCurve),
    "Envelope": makeReplacer(GML3.prototype.readEnvelope)
  }
};
GML3.prototype.MULTICURVE_PARSERS = {
  "http://www.opengis.net/gml": {
    "curveMember": makeArrayPusher(GML3.prototype.curveMemberParser),
    "curveMembers": makeArrayPusher(GML3.prototype.curveMemberParser)
  }
};
GML3.prototype.MULTISURFACE_PARSERS = {
  "http://www.opengis.net/gml": {
    "surfaceMember": makeArrayPusher(GML3.prototype.surfaceMemberParser),
    "surfaceMembers": makeArrayPusher(GML3.prototype.surfaceMemberParser)
  }
};
GML3.prototype.CURVEMEMBER_PARSERS = {
  "http://www.opengis.net/gml": {
    "LineString": makeArrayPusher(GMLBase$1.prototype.readLineString),
    "Curve": makeArrayPusher(GML3.prototype.readCurve)
  }
};
GML3.prototype.SURFACEMEMBER_PARSERS = {
  "http://www.opengis.net/gml": {
    "Polygon": makeArrayPusher(GMLBase$1.prototype.readPolygon),
    "Surface": makeArrayPusher(GML3.prototype.readSurface)
  }
};
GML3.prototype.SURFACE_PARSERS = {
  "http://www.opengis.net/gml": {
    "patches": makeReplacer(GML3.prototype.readPatch)
  }
};
GML3.prototype.CURVE_PARSERS = {
  "http://www.opengis.net/gml": {
    "segments": makeReplacer(GML3.prototype.readSegment)
  }
};
GML3.prototype.ENVELOPE_PARSERS = {
  "http://www.opengis.net/gml": {
    "lowerCorner": makeArrayPusher(GML3.prototype.readFlatPosList),
    "upperCorner": makeArrayPusher(GML3.prototype.readFlatPosList)
  }
};
GML3.prototype.PATCHES_PARSERS = {
  "http://www.opengis.net/gml": {
    "PolygonPatch": makeReplacer(GML3.prototype.readPolygonPatch)
  }
};
GML3.prototype.SEGMENTS_PARSERS = {
  "http://www.opengis.net/gml": {
    "LineStringSegment": makeReplacer(GML3.prototype.readLineStringSegment)
  }
};
GML3.prototype.writeFeatures;
GML3.prototype.RING_SERIALIZERS = {
  "http://www.opengis.net/gml": {
    "exterior": makeChildAppender(GML3.prototype.writeRing),
    "interior": makeChildAppender(GML3.prototype.writeRing)
  }
};
GML3.prototype.ENVELOPE_SERIALIZERS = {
  "http://www.opengis.net/gml": {
    "lowerCorner": makeChildAppender(writeStringTextNode),
    "upperCorner": makeChildAppender(writeStringTextNode)
  }
};
GML3.prototype.SURFACEORPOLYGONMEMBER_SERIALIZERS = {
  "http://www.opengis.net/gml": {
    "surfaceMember": makeChildAppender(GML3.prototype.writeSurfaceOrPolygonMember),
    "polygonMember": makeChildAppender(GML3.prototype.writeSurfaceOrPolygonMember)
  }
};
GML3.prototype.POINTMEMBER_SERIALIZERS = {
  "http://www.opengis.net/gml": {
    "pointMember": makeChildAppender(GML3.prototype.writePointMember)
  }
};
GML3.prototype.LINESTRINGORCURVEMEMBER_SERIALIZERS = {
  "http://www.opengis.net/gml": {
    "lineStringMember": makeChildAppender(GML3.prototype.writeLineStringOrCurveMember),
    "curveMember": makeChildAppender(GML3.prototype.writeLineStringOrCurveMember)
  }
};
GML3.prototype.GEOMETRY_SERIALIZERS = {
  "http://www.opengis.net/gml": {
    "Curve": makeChildAppender(GML3.prototype.writeCurveOrLineString),
    "MultiCurve": makeChildAppender(GML3.prototype.writeMultiCurveOrLineString),
    "Point": makeChildAppender(GML3.prototype.writePoint),
    "MultiPoint": makeChildAppender(GML3.prototype.writeMultiPoint),
    "LineString": makeChildAppender(GML3.prototype.writeCurveOrLineString),
    "MultiLineString": makeChildAppender(GML3.prototype.writeMultiCurveOrLineString),
    "LinearRing": makeChildAppender(GML3.prototype.writeLinearRing),
    "Polygon": makeChildAppender(GML3.prototype.writeSurfaceOrPolygon),
    "MultiPolygon": makeChildAppender(GML3.prototype.writeMultiSurfaceOrPolygon),
    "Surface": makeChildAppender(GML3.prototype.writeSurfaceOrPolygon),
    "MultiSurface": makeChildAppender(GML3.prototype.writeMultiSurfaceOrPolygon),
    "Envelope": makeChildAppender(GML3.prototype.writeEnvelope)
  }
};
var GML3$1 = GML3;
var GML = GML3$1;
GML.prototype.writeFeatures;
GML.prototype.writeFeaturesNode;
var GML$1 = GML;
var __extends$i = globalThis && globalThis.__extends || function() {
  var extendStatics2 = function(d2, b2) {
    extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {
      d3.__proto__ = b3;
    } || function(d3, b3) {
      for (var p5 in b3)
        if (Object.prototype.hasOwnProperty.call(b3, p5))
          d3[p5] = b3[p5];
    };
    return extendStatics2(d2, b2);
  };
  return function(d2, b2) {
    if (typeof b2 !== "function" && b2 !== null)
      throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
    extendStatics2(d2, b2);
    function __() {
      this.constructor = d2;
    }
    d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
  };
}();
var NAMESPACE_URIS$4 = [
  null,
  "http://www.topografix.com/GPX/1/0",
  "http://www.topografix.com/GPX/1/1"
];
var SCHEMA_LOCATION$1 = "http://www.topografix.com/GPX/1/1 http://www.topografix.com/GPX/1/1/gpx.xsd";
var FEATURE_READER = {
  "rte": readRte,
  "trk": readTrk,
  "wpt": readWpt
};
var GPX_PARSERS = makeStructureNS(NAMESPACE_URIS$4, {
  "rte": makeArrayPusher(readRte),
  "trk": makeArrayPusher(readTrk),
  "wpt": makeArrayPusher(readWpt)
});
var LINK_PARSERS$1 = makeStructureNS(NAMESPACE_URIS$4, {
  "text": makeObjectPropertySetter(readString, "linkText"),
  "type": makeObjectPropertySetter(readString, "linkType")
});
var GPX_SERIALIZERS = makeStructureNS(NAMESPACE_URIS$4, {
  "rte": makeChildAppender(writeRte),
  "trk": makeChildAppender(writeTrk),
  "wpt": makeChildAppender(writeWpt)
});
var GPX = function(_super) {
  __extends$i(GPX2, _super);
  function GPX2(opt_options) {
    var _this = _super.call(this) || this;
    var options = opt_options ? opt_options : {};
    _this.dataProjection = get$3("EPSG:4326");
    _this.readExtensions_ = options.readExtensions;
    return _this;
  }
  GPX2.prototype.handleReadExtensions_ = function(features) {
    if (!features) {
      features = [];
    }
    for (var i2 = 0, ii = features.length; i2 < ii; ++i2) {
      var feature2 = features[i2];
      if (this.readExtensions_) {
        var extensionsNode = feature2.get("extensionsNode_") || null;
        this.readExtensions_(feature2, extensionsNode);
      }
      feature2.set("extensionsNode_", void 0);
    }
  };
  GPX2.prototype.readFeatureFromNode = function(node2, opt_options) {
    if (!includes(NAMESPACE_URIS$4, node2.namespaceURI)) {
      return null;
    }
    var featureReader = FEATURE_READER[node2.localName];
    if (!featureReader) {
      return null;
    }
    var feature2 = featureReader(node2, [
      this.getReadOptions(node2, opt_options)
    ]);
    if (!feature2) {
      return null;
    }
    this.handleReadExtensions_([feature2]);
    return feature2;
  };
  GPX2.prototype.readFeaturesFromNode = function(node2, opt_options) {
    if (!includes(NAMESPACE_URIS$4, node2.namespaceURI)) {
      return [];
    }
    if (node2.localName == "gpx") {
      var features = pushParseAndPop([], GPX_PARSERS, node2, [
        this.getReadOptions(node2, opt_options)
      ]);
      if (features) {
        this.handleReadExtensions_(features);
        return features;
      } else {
        return [];
      }
    }
    return [];
  };
  GPX2.prototype.writeFeaturesNode = function(features, opt_options) {
    opt_options = this.adaptOptions(opt_options);
    var gpx = createElementNS("http://www.topografix.com/GPX/1/1", "gpx");
    var xmlnsUri = "http://www.w3.org/2000/xmlns/";
    gpx.setAttributeNS(xmlnsUri, "xmlns:xsi", XML_SCHEMA_INSTANCE_URI);
    gpx.setAttributeNS(XML_SCHEMA_INSTANCE_URI, "xsi:schemaLocation", SCHEMA_LOCATION$1);
    gpx.setAttribute("version", "1.1");
    gpx.setAttribute("creator", "OpenLayers");
    pushSerializeAndPop({ node: gpx }, GPX_SERIALIZERS, GPX_NODE_FACTORY, features, [opt_options]);
    return gpx;
  };
  return GPX2;
}(XMLFeature$1);
var RTE_PARSERS = makeStructureNS(NAMESPACE_URIS$4, {
  "name": makeObjectPropertySetter(readString),
  "cmt": makeObjectPropertySetter(readString),
  "desc": makeObjectPropertySetter(readString),
  "src": makeObjectPropertySetter(readString),
  "link": parseLink,
  "number": makeObjectPropertySetter(readPositiveInteger),
  "extensions": parseExtensions,
  "type": makeObjectPropertySetter(readString),
  "rtept": parseRtePt
});
var RTEPT_PARSERS = makeStructureNS(NAMESPACE_URIS$4, {
  "ele": makeObjectPropertySetter(readDecimal),
  "time": makeObjectPropertySetter(readDateTime)
});
var TRK_PARSERS = makeStructureNS(NAMESPACE_URIS$4, {
  "name": makeObjectPropertySetter(readString),
  "cmt": makeObjectPropertySetter(readString),
  "desc": makeObjectPropertySetter(readString),
  "src": makeObjectPropertySetter(readString),
  "link": parseLink,
  "number": makeObjectPropertySetter(readPositiveInteger),
  "type": makeObjectPropertySetter(readString),
  "extensions": parseExtensions,
  "trkseg": parseTrkSeg
});
var TRKSEG_PARSERS = makeStructureNS(NAMESPACE_URIS$4, {
  "trkpt": parseTrkPt
});
var TRKPT_PARSERS = makeStructureNS(NAMESPACE_URIS$4, {
  "ele": makeObjectPropertySetter(readDecimal),
  "time": makeObjectPropertySetter(readDateTime)
});
var WPT_PARSERS = makeStructureNS(NAMESPACE_URIS$4, {
  "ele": makeObjectPropertySetter(readDecimal),
  "time": makeObjectPropertySetter(readDateTime),
  "magvar": makeObjectPropertySetter(readDecimal),
  "geoidheight": makeObjectPropertySetter(readDecimal),
  "name": makeObjectPropertySetter(readString),
  "cmt": makeObjectPropertySetter(readString),
  "desc": makeObjectPropertySetter(readString),
  "src": makeObjectPropertySetter(readString),
  "link": parseLink,
  "sym": makeObjectPropertySetter(readString),
  "type": makeObjectPropertySetter(readString),
  "fix": makeObjectPropertySetter(readString),
  "sat": makeObjectPropertySetter(readPositiveInteger),
  "hdop": makeObjectPropertySetter(readDecimal),
  "vdop": makeObjectPropertySetter(readDecimal),
  "pdop": makeObjectPropertySetter(readDecimal),
  "ageofdgpsdata": makeObjectPropertySetter(readDecimal),
  "dgpsid": makeObjectPropertySetter(readPositiveInteger),
  "extensions": parseExtensions
});
var LINK_SEQUENCE = ["text", "type"];
var LINK_SERIALIZERS = makeStructureNS(NAMESPACE_URIS$4, {
  "text": makeChildAppender(writeStringTextNode),
  "type": makeChildAppender(writeStringTextNode)
});
var RTE_SEQUENCE = makeStructureNS(NAMESPACE_URIS$4, [
  "name",
  "cmt",
  "desc",
  "src",
  "link",
  "number",
  "type",
  "rtept"
]);
var RTE_SERIALIZERS = makeStructureNS(NAMESPACE_URIS$4, {
  "name": makeChildAppender(writeStringTextNode),
  "cmt": makeChildAppender(writeStringTextNode),
  "desc": makeChildAppender(writeStringTextNode),
  "src": makeChildAppender(writeStringTextNode),
  "link": makeChildAppender(writeLink),
  "number": makeChildAppender(writeNonNegativeIntegerTextNode),
  "type": makeChildAppender(writeStringTextNode),
  "rtept": makeArraySerializer(makeChildAppender(writeWptType))
});
var RTEPT_TYPE_SEQUENCE = makeStructureNS(NAMESPACE_URIS$4, ["ele", "time"]);
var TRK_SEQUENCE = makeStructureNS(NAMESPACE_URIS$4, [
  "name",
  "cmt",
  "desc",
  "src",
  "link",
  "number",
  "type",
  "trkseg"
]);
var TRK_SERIALIZERS = makeStructureNS(NAMESPACE_URIS$4, {
  "name": makeChildAppender(writeStringTextNode),
  "cmt": makeChildAppender(writeStringTextNode),
  "desc": makeChildAppender(writeStringTextNode),
  "src": makeChildAppender(writeStringTextNode),
  "link": makeChildAppender(writeLink),
  "number": makeChildAppender(writeNonNegativeIntegerTextNode),
  "type": makeChildAppender(writeStringTextNode),
  "trkseg": makeArraySerializer(makeChildAppender(writeTrkSeg))
});
var TRKSEG_NODE_FACTORY = makeSimpleNodeFactory("trkpt");
var TRKSEG_SERIALIZERS = makeStructureNS(NAMESPACE_URIS$4, {
  "trkpt": makeChildAppender(writeWptType)
});
var WPT_TYPE_SEQUENCE = makeStructureNS(NAMESPACE_URIS$4, [
  "ele",
  "time",
  "magvar",
  "geoidheight",
  "name",
  "cmt",
  "desc",
  "src",
  "link",
  "sym",
  "type",
  "fix",
  "sat",
  "hdop",
  "vdop",
  "pdop",
  "ageofdgpsdata",
  "dgpsid"
]);
var WPT_TYPE_SERIALIZERS = makeStructureNS(NAMESPACE_URIS$4, {
  "ele": makeChildAppender(writeDecimalTextNode),
  "time": makeChildAppender(writeDateTimeTextNode),
  "magvar": makeChildAppender(writeDecimalTextNode),
  "geoidheight": makeChildAppender(writeDecimalTextNode),
  "name": makeChildAppender(writeStringTextNode),
  "cmt": makeChildAppender(writeStringTextNode),
  "desc": makeChildAppender(writeStringTextNode),
  "src": makeChildAppender(writeStringTextNode),
  "link": makeChildAppender(writeLink),
  "sym": makeChildAppender(writeStringTextNode),
  "type": makeChildAppender(writeStringTextNode),
  "fix": makeChildAppender(writeStringTextNode),
  "sat": makeChildAppender(writeNonNegativeIntegerTextNode),
  "hdop": makeChildAppender(writeDecimalTextNode),
  "vdop": makeChildAppender(writeDecimalTextNode),
  "pdop": makeChildAppender(writeDecimalTextNode),
  "ageofdgpsdata": makeChildAppender(writeDecimalTextNode),
  "dgpsid": makeChildAppender(writeNonNegativeIntegerTextNode)
});
var GEOMETRY_TYPE_TO_NODENAME$1 = {
  "Point": "wpt",
  "LineString": "rte",
  "MultiLineString": "trk"
};
function GPX_NODE_FACTORY(value, objectStack, opt_nodeName) {
  var geometry = value.getGeometry();
  if (geometry) {
    var nodeName = GEOMETRY_TYPE_TO_NODENAME$1[geometry.getType()];
    if (nodeName) {
      var parentNode = objectStack[objectStack.length - 1].node;
      return createElementNS(parentNode.namespaceURI, nodeName);
    }
  }
}
function appendCoordinate(flatCoordinates, layoutOptions, node2, values2) {
  flatCoordinates.push(parseFloat(node2.getAttribute("lon")), parseFloat(node2.getAttribute("lat")));
  if ("ele" in values2) {
    flatCoordinates.push(values2["ele"]);
    delete values2["ele"];
    layoutOptions.hasZ = true;
  } else {
    flatCoordinates.push(0);
  }
  if ("time" in values2) {
    flatCoordinates.push(values2["time"]);
    delete values2["time"];
    layoutOptions.hasM = true;
  } else {
    flatCoordinates.push(0);
  }
  return flatCoordinates;
}
function applyLayoutOptions(layoutOptions, flatCoordinates, ends) {
  var layout = GeometryLayout.XY;
  var stride = 2;
  if (layoutOptions.hasZ && layoutOptions.hasM) {
    layout = GeometryLayout.XYZM;
    stride = 4;
  } else if (layoutOptions.hasZ) {
    layout = GeometryLayout.XYZ;
    stride = 3;
  } else if (layoutOptions.hasM) {
    layout = GeometryLayout.XYM;
    stride = 3;
  }
  if (stride !== 4) {
    for (var i2 = 0, ii = flatCoordinates.length / 4; i2 < ii; i2++) {
      flatCoordinates[i2 * stride] = flatCoordinates[i2 * 4];
      flatCoordinates[i2 * stride + 1] = flatCoordinates[i2 * 4 + 1];
      if (layoutOptions.hasZ) {
        flatCoordinates[i2 * stride + 2] = flatCoordinates[i2 * 4 + 2];
      }
      if (layoutOptions.hasM) {
        flatCoordinates[i2 * stride + 2] = flatCoordinates[i2 * 4 + 3];
      }
    }
    flatCoordinates.length = flatCoordinates.length / 4 * stride;
    if (ends) {
      for (var i2 = 0, ii = ends.length; i2 < ii; i2++) {
        ends[i2] = ends[i2] / 4 * stride;
      }
    }
  }
  return layout;
}
function parseLink(node2, objectStack) {
  var values2 = objectStack[objectStack.length - 1];
  var href = node2.getAttribute("href");
  if (href !== null) {
    values2["link"] = href;
  }
  parseNode(LINK_PARSERS$1, node2, objectStack);
}
function parseExtensions(node2, objectStack) {
  var values2 = objectStack[objectStack.length - 1];
  values2["extensionsNode_"] = node2;
}
function parseRtePt(node2, objectStack) {
  var values2 = pushParseAndPop({}, RTEPT_PARSERS, node2, objectStack);
  if (values2) {
    var rteValues = objectStack[objectStack.length - 1];
    var flatCoordinates = rteValues["flatCoordinates"];
    var layoutOptions = rteValues["layoutOptions"];
    appendCoordinate(flatCoordinates, layoutOptions, node2, values2);
  }
}
function parseTrkPt(node2, objectStack) {
  var values2 = pushParseAndPop({}, TRKPT_PARSERS, node2, objectStack);
  if (values2) {
    var trkValues = objectStack[objectStack.length - 1];
    var flatCoordinates = trkValues["flatCoordinates"];
    var layoutOptions = trkValues["layoutOptions"];
    appendCoordinate(flatCoordinates, layoutOptions, node2, values2);
  }
}
function parseTrkSeg(node2, objectStack) {
  var values2 = objectStack[objectStack.length - 1];
  parseNode(TRKSEG_PARSERS, node2, objectStack);
  var flatCoordinates = values2["flatCoordinates"];
  var ends = values2["ends"];
  ends.push(flatCoordinates.length);
}
function readRte(node2, objectStack) {
  var options = objectStack[0];
  var values2 = pushParseAndPop({
    "flatCoordinates": [],
    "layoutOptions": {}
  }, RTE_PARSERS, node2, objectStack);
  if (!values2) {
    return void 0;
  }
  var flatCoordinates = values2["flatCoordinates"];
  delete values2["flatCoordinates"];
  var layoutOptions = values2["layoutOptions"];
  delete values2["layoutOptions"];
  var layout = applyLayoutOptions(layoutOptions, flatCoordinates);
  var geometry = new LineString$2(flatCoordinates, layout);
  transformGeometryWithOptions(geometry, false, options);
  var feature$1 = new feature(geometry);
  feature$1.setProperties(values2, true);
  return feature$1;
}
function readTrk(node2, objectStack) {
  var options = objectStack[0];
  var values2 = pushParseAndPop({
    "flatCoordinates": [],
    "ends": [],
    "layoutOptions": {}
  }, TRK_PARSERS, node2, objectStack);
  if (!values2) {
    return void 0;
  }
  var flatCoordinates = values2["flatCoordinates"];
  delete values2["flatCoordinates"];
  var ends = values2["ends"];
  delete values2["ends"];
  var layoutOptions = values2["layoutOptions"];
  delete values2["layoutOptions"];
  var layout = applyLayoutOptions(layoutOptions, flatCoordinates, ends);
  var geometry = new MultiLineString$2(flatCoordinates, layout, ends);
  transformGeometryWithOptions(geometry, false, options);
  var feature$1 = new feature(geometry);
  feature$1.setProperties(values2, true);
  return feature$1;
}
function readWpt(node2, objectStack) {
  var options = objectStack[0];
  var values2 = pushParseAndPop({}, WPT_PARSERS, node2, objectStack);
  if (!values2) {
    return void 0;
  }
  var layoutOptions = {};
  var coordinates2 = appendCoordinate([], layoutOptions, node2, values2);
  var layout = applyLayoutOptions(layoutOptions, coordinates2);
  var geometry = new Point$4(coordinates2, layout);
  transformGeometryWithOptions(geometry, false, options);
  var feature$1 = new feature(geometry);
  feature$1.setProperties(values2, true);
  return feature$1;
}
function writeLink(node2, value, objectStack) {
  node2.setAttribute("href", value);
  var context = objectStack[objectStack.length - 1];
  var properties = context["properties"];
  var link = [properties["linkText"], properties["linkType"]];
  pushSerializeAndPop({ node: node2 }, LINK_SERIALIZERS, OBJECT_PROPERTY_NODE_FACTORY, link, objectStack, LINK_SEQUENCE);
}
function writeWptType(node2, coordinate, objectStack) {
  var context = objectStack[objectStack.length - 1];
  var parentNode = context.node;
  var namespaceURI = parentNode.namespaceURI;
  var properties = context["properties"];
  node2.setAttributeNS(null, "lat", String(coordinate[1]));
  node2.setAttributeNS(null, "lon", String(coordinate[0]));
  var geometryLayout = context["geometryLayout"];
  switch (geometryLayout) {
    case GeometryLayout.XYZM:
      if (coordinate[3] !== 0) {
        properties["time"] = coordinate[3];
      }
    case GeometryLayout.XYZ:
      if (coordinate[2] !== 0) {
        properties["ele"] = coordinate[2];
      }
      break;
    case GeometryLayout.XYM:
      if (coordinate[2] !== 0) {
        properties["time"] = coordinate[2];
      }
      break;
  }
  var orderedKeys = node2.nodeName == "rtept" ? RTEPT_TYPE_SEQUENCE[namespaceURI] : WPT_TYPE_SEQUENCE[namespaceURI];
  var values2 = makeSequence(properties, orderedKeys);
  pushSerializeAndPop({ node: node2, "properties": properties }, WPT_TYPE_SERIALIZERS, OBJECT_PROPERTY_NODE_FACTORY, values2, objectStack, orderedKeys);
}
function writeRte(node2, feature2, objectStack) {
  var options = objectStack[0];
  var properties = feature2.getProperties();
  var context = { node: node2 };
  context["properties"] = properties;
  var geometry = feature2.getGeometry();
  if (geometry.getType() == GeometryType.LINE_STRING) {
    var lineString = transformGeometryWithOptions(geometry, true, options);
    context["geometryLayout"] = lineString.getLayout();
    properties["rtept"] = lineString.getCoordinates();
  }
  var parentNode = objectStack[objectStack.length - 1].node;
  var orderedKeys = RTE_SEQUENCE[parentNode.namespaceURI];
  var values2 = makeSequence(properties, orderedKeys);
  pushSerializeAndPop(context, RTE_SERIALIZERS, OBJECT_PROPERTY_NODE_FACTORY, values2, objectStack, orderedKeys);
}
function writeTrk(node2, feature2, objectStack) {
  var options = objectStack[0];
  var properties = feature2.getProperties();
  var context = { node: node2 };
  context["properties"] = properties;
  var geometry = feature2.getGeometry();
  if (geometry.getType() == GeometryType.MULTI_LINE_STRING) {
    var multiLineString = transformGeometryWithOptions(geometry, true, options);
    properties["trkseg"] = multiLineString.getLineStrings();
  }
  var parentNode = objectStack[objectStack.length - 1].node;
  var orderedKeys = TRK_SEQUENCE[parentNode.namespaceURI];
  var values2 = makeSequence(properties, orderedKeys);
  pushSerializeAndPop(context, TRK_SERIALIZERS, OBJECT_PROPERTY_NODE_FACTORY, values2, objectStack, orderedKeys);
}
function writeTrkSeg(node2, lineString, objectStack) {
  var context = { node: node2 };
  context["geometryLayout"] = lineString.getLayout();
  context["properties"] = {};
  pushSerializeAndPop(context, TRKSEG_SERIALIZERS, TRKSEG_NODE_FACTORY, lineString.getCoordinates(), objectStack);
}
function writeWpt(node2, feature2, objectStack) {
  var options = objectStack[0];
  var context = objectStack[objectStack.length - 1];
  context["properties"] = feature2.getProperties();
  var geometry = feature2.getGeometry();
  if (geometry.getType() == GeometryType.POINT) {
    var point = transformGeometryWithOptions(geometry, true, options);
    context["geometryLayout"] = point.getLayout();
    writeWptType(node2, point.getCoordinates(), objectStack);
  }
}
var GPX$1 = GPX;
var __extends$h = globalThis && globalThis.__extends || function() {
  var extendStatics2 = function(d2, b2) {
    extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {
      d3.__proto__ = b3;
    } || function(d3, b3) {
      for (var p5 in b3)
        if (Object.prototype.hasOwnProperty.call(b3, p5))
          d3[p5] = b3[p5];
    };
    return extendStatics2(d2, b2);
  };
  return function(d2, b2) {
    if (typeof b2 !== "function" && b2 !== null)
      throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
    extendStatics2(d2, b2);
    function __() {
      this.constructor = d2;
    }
    d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
  };
}();
var TextFeature = function(_super) {
  __extends$h(TextFeature2, _super);
  function TextFeature2() {
    return _super.call(this) || this;
  }
  TextFeature2.prototype.getType = function() {
    return FormatType.TEXT;
  };
  TextFeature2.prototype.readFeature = function(source, opt_options) {
    return this.readFeatureFromText(getText(source), this.adaptOptions(opt_options));
  };
  TextFeature2.prototype.readFeatureFromText = function(text2, opt_options) {
    return abstract();
  };
  TextFeature2.prototype.readFeatures = function(source, opt_options) {
    return this.readFeaturesFromText(getText(source), this.adaptOptions(opt_options));
  };
  TextFeature2.prototype.readFeaturesFromText = function(text2, opt_options) {
    return abstract();
  };
  TextFeature2.prototype.readGeometry = function(source, opt_options) {
    return this.readGeometryFromText(getText(source), this.adaptOptions(opt_options));
  };
  TextFeature2.prototype.readGeometryFromText = function(text2, opt_options) {
    return abstract();
  };
  TextFeature2.prototype.readProjection = function(source) {
    return this.readProjectionFromText(getText(source));
  };
  TextFeature2.prototype.readProjectionFromText = function(text2) {
    return this.dataProjection;
  };
  TextFeature2.prototype.writeFeature = function(feature2, opt_options) {
    return this.writeFeatureText(feature2, this.adaptOptions(opt_options));
  };
  TextFeature2.prototype.writeFeatureText = function(feature2, opt_options) {
    return abstract();
  };
  TextFeature2.prototype.writeFeatures = function(features, opt_options) {
    return this.writeFeaturesText(features, this.adaptOptions(opt_options));
  };
  TextFeature2.prototype.writeFeaturesText = function(features, opt_options) {
    return abstract();
  };
  TextFeature2.prototype.writeGeometry = function(geometry, opt_options) {
    return this.writeGeometryText(geometry, this.adaptOptions(opt_options));
  };
  TextFeature2.prototype.writeGeometryText = function(geometry, opt_options) {
    return abstract();
  };
  return TextFeature2;
}(FeatureFormat$1);
function getText(source) {
  if (typeof source === "string") {
    return source;
  } else {
    return "";
  }
}
var TextFeature$1 = TextFeature;
var __extends$g = globalThis && globalThis.__extends || function() {
  var extendStatics2 = function(d2, b2) {
    extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {
      d3.__proto__ = b3;
    } || function(d3, b3) {
      for (var p5 in b3)
        if (Object.prototype.hasOwnProperty.call(b3, p5))
          d3[p5] = b3[p5];
    };
    return extendStatics2(d2, b2);
  };
  return function(d2, b2) {
    if (typeof b2 !== "function" && b2 !== null)
      throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
    extendStatics2(d2, b2);
    function __() {
      this.constructor = d2;
    }
    d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
  };
}();
var IGCZ = {
  BAROMETRIC: "barometric",
  GPS: "gps",
  NONE: "none"
};
var B_RECORD_RE = /^B(\d{2})(\d{2})(\d{2})(\d{2})(\d{5})([NS])(\d{3})(\d{5})([EW])([AV])(\d{5})(\d{5})/;
var H_RECORD_RE = /^H.([A-Z]{3}).*?:(.*)/;
var HFDTE_RECORD_RE = /^HFDTE(\d{2})(\d{2})(\d{2})/;
var NEWLINE_RE = /\r\n|\r|\n/;
var IGC = function(_super) {
  __extends$g(IGC2, _super);
  function IGC2(opt_options) {
    var _this = _super.call(this) || this;
    var options = opt_options ? opt_options : {};
    _this.dataProjection = get$3("EPSG:4326");
    _this.altitudeMode_ = options.altitudeMode ? options.altitudeMode : IGCZ.NONE;
    return _this;
  }
  IGC2.prototype.readFeatureFromText = function(text2, opt_options) {
    var altitudeMode = this.altitudeMode_;
    var lines = text2.split(NEWLINE_RE);
    var properties = {};
    var flatCoordinates = [];
    var year = 2e3;
    var month = 0;
    var day = 1;
    var lastDateTime = -1;
    var i2, ii;
    for (i2 = 0, ii = lines.length; i2 < ii; ++i2) {
      var line = lines[i2];
      var m2 = void 0;
      if (line.charAt(0) == "B") {
        m2 = B_RECORD_RE.exec(line);
        if (m2) {
          var hour = parseInt(m2[1], 10);
          var minute = parseInt(m2[2], 10);
          var second = parseInt(m2[3], 10);
          var y2 = parseInt(m2[4], 10) + parseInt(m2[5], 10) / 6e4;
          if (m2[6] == "S") {
            y2 = -y2;
          }
          var x2 = parseInt(m2[7], 10) + parseInt(m2[8], 10) / 6e4;
          if (m2[9] == "W") {
            x2 = -x2;
          }
          flatCoordinates.push(x2, y2);
          if (altitudeMode != IGCZ.NONE) {
            var z2 = void 0;
            if (altitudeMode == IGCZ.GPS) {
              z2 = parseInt(m2[11], 10);
            } else if (altitudeMode == IGCZ.BAROMETRIC) {
              z2 = parseInt(m2[12], 10);
            } else {
              z2 = 0;
            }
            flatCoordinates.push(z2);
          }
          var dateTime = Date.UTC(year, month, day, hour, minute, second);
          if (dateTime < lastDateTime) {
            dateTime = Date.UTC(year, month, day + 1, hour, minute, second);
          }
          flatCoordinates.push(dateTime / 1e3);
          lastDateTime = dateTime;
        }
      } else if (line.charAt(0) == "H") {
        m2 = HFDTE_RECORD_RE.exec(line);
        if (m2) {
          day = parseInt(m2[1], 10);
          month = parseInt(m2[2], 10) - 1;
          year = 2e3 + parseInt(m2[3], 10);
        } else {
          m2 = H_RECORD_RE.exec(line);
          if (m2) {
            properties[m2[1]] = m2[2].trim();
          }
        }
      }
    }
    if (flatCoordinates.length === 0) {
      return null;
    }
    var layout = altitudeMode == IGCZ.NONE ? GeometryLayout.XYM : GeometryLayout.XYZM;
    var lineString = new LineString$2(flatCoordinates, layout);
    var feature$1 = new feature(transformGeometryWithOptions(lineString, false, opt_options));
    feature$1.setProperties(properties, true);
    return feature$1;
  };
  IGC2.prototype.readFeaturesFromText = function(text2, opt_options) {
    var feature2 = this.readFeatureFromText(text2, opt_options);
    if (feature2) {
      return [feature2];
    } else {
      return [];
    }
  };
  return IGC2;
}(TextFeature$1);
var IGC$1 = IGC;
var __extends$f = globalThis && globalThis.__extends || function() {
  var extendStatics2 = function(d2, b2) {
    extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {
      d3.__proto__ = b3;
    } || function(d3, b3) {
      for (var p5 in b3)
        if (Object.prototype.hasOwnProperty.call(b3, p5))
          d3[p5] = b3[p5];
    };
    return extendStatics2(d2, b2);
  };
  return function(d2, b2) {
    if (typeof b2 !== "function" && b2 !== null)
      throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
    extendStatics2(d2, b2);
    function __() {
      this.constructor = d2;
    }
    d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
  };
}();
var GX_NAMESPACE_URIS = ["http://www.google.com/kml/ext/2.2"];
var NAMESPACE_URIS$3 = [
  null,
  "http://earth.google.com/kml/2.0",
  "http://earth.google.com/kml/2.1",
  "http://earth.google.com/kml/2.2",
  "http://www.opengis.net/kml/2.2"
];
var SCHEMA_LOCATION = "http://www.opengis.net/kml/2.2 https://developers.google.com/kml/schema/kml22gx.xsd";
var ICON_ANCHOR_UNITS_MAP = {
  "fraction": IconAnchorUnits.FRACTION,
  "pixels": IconAnchorUnits.PIXELS,
  "insetPixels": IconAnchorUnits.PIXELS
};
var PLACEMARK_PARSERS = makeStructureNS(NAMESPACE_URIS$3, {
  "ExtendedData": extendedDataParser,
  "Region": regionParser,
  "MultiGeometry": makeObjectPropertySetter(readMultiGeometry, "geometry"),
  "LineString": makeObjectPropertySetter(readLineString, "geometry"),
  "LinearRing": makeObjectPropertySetter(readLinearRing, "geometry"),
  "Point": makeObjectPropertySetter(readPoint, "geometry"),
  "Polygon": makeObjectPropertySetter(readPolygon, "geometry"),
  "Style": makeObjectPropertySetter(readStyle$2),
  "StyleMap": placemarkStyleMapParser,
  "address": makeObjectPropertySetter(readString),
  "description": makeObjectPropertySetter(readString),
  "name": makeObjectPropertySetter(readString),
  "open": makeObjectPropertySetter(readBoolean),
  "phoneNumber": makeObjectPropertySetter(readString),
  "styleUrl": makeObjectPropertySetter(readStyleURL),
  "visibility": makeObjectPropertySetter(readBoolean)
}, makeStructureNS(GX_NAMESPACE_URIS, {
  "MultiTrack": makeObjectPropertySetter(readGxMultiTrack, "geometry"),
  "Track": makeObjectPropertySetter(readGxTrack, "geometry")
}));
var NETWORK_LINK_PARSERS = makeStructureNS(NAMESPACE_URIS$3, {
  "ExtendedData": extendedDataParser,
  "Region": regionParser,
  "Link": linkParser,
  "address": makeObjectPropertySetter(readString),
  "description": makeObjectPropertySetter(readString),
  "name": makeObjectPropertySetter(readString),
  "open": makeObjectPropertySetter(readBoolean),
  "phoneNumber": makeObjectPropertySetter(readString),
  "visibility": makeObjectPropertySetter(readBoolean)
});
var LINK_PARSERS = makeStructureNS(NAMESPACE_URIS$3, {
  "href": makeObjectPropertySetter(readURI)
});
var REGION_PARSERS = makeStructureNS(NAMESPACE_URIS$3, {
  "LatLonAltBox": latLonAltBoxParser,
  "Lod": lodParser
});
var KML_SEQUENCE = makeStructureNS(NAMESPACE_URIS$3, ["Document", "Placemark"]);
var KML_SERIALIZERS = makeStructureNS(NAMESPACE_URIS$3, {
  "Document": makeChildAppender(writeDocument),
  "Placemark": makeChildAppender(writePlacemark)
});
var DEFAULT_COLOR;
var DEFAULT_FILL_STYLE = null;
var DEFAULT_IMAGE_STYLE_ANCHOR;
var DEFAULT_IMAGE_STYLE_ANCHOR_X_UNITS;
var DEFAULT_IMAGE_STYLE_ANCHOR_Y_UNITS;
var DEFAULT_IMAGE_STYLE_SIZE;
var DEFAULT_IMAGE_STYLE_SRC;
var DEFAULT_IMAGE_STYLE = null;
var DEFAULT_NO_IMAGE_STYLE;
var DEFAULT_STROKE_STYLE = null;
var DEFAULT_TEXT_STROKE_STYLE;
var DEFAULT_TEXT_STYLE = null;
var DEFAULT_STYLE = null;
var DEFAULT_STYLE_ARRAY = null;
function scaleForSize(size) {
  return 32 / Math.min(size[0], size[1]);
}
function createStyleDefaults() {
  DEFAULT_COLOR = [255, 255, 255, 1];
  DEFAULT_FILL_STYLE = new Fill$2({
    color: DEFAULT_COLOR
  });
  DEFAULT_IMAGE_STYLE_ANCHOR = [20, 2];
  DEFAULT_IMAGE_STYLE_ANCHOR_X_UNITS = IconAnchorUnits.PIXELS;
  DEFAULT_IMAGE_STYLE_ANCHOR_Y_UNITS = IconAnchorUnits.PIXELS;
  DEFAULT_IMAGE_STYLE_SIZE = [64, 64];
  DEFAULT_IMAGE_STYLE_SRC = "https://maps.google.com/mapfiles/kml/pushpin/ylw-pushpin.png";
  DEFAULT_IMAGE_STYLE = new Icon$2({
    anchor: DEFAULT_IMAGE_STYLE_ANCHOR,
    anchorOrigin: IconOrigin.BOTTOM_LEFT,
    anchorXUnits: DEFAULT_IMAGE_STYLE_ANCHOR_X_UNITS,
    anchorYUnits: DEFAULT_IMAGE_STYLE_ANCHOR_Y_UNITS,
    crossOrigin: "anonymous",
    rotation: 0,
    scale: scaleForSize(DEFAULT_IMAGE_STYLE_SIZE),
    size: DEFAULT_IMAGE_STYLE_SIZE,
    src: DEFAULT_IMAGE_STYLE_SRC
  });
  DEFAULT_NO_IMAGE_STYLE = "NO_IMAGE";
  DEFAULT_STROKE_STYLE = new Stroke$2({
    color: DEFAULT_COLOR,
    width: 1
  });
  DEFAULT_TEXT_STROKE_STYLE = new Stroke$2({
    color: [51, 51, 51, 1],
    width: 2
  });
  DEFAULT_TEXT_STYLE = new Text$2({
    font: "bold 16px Helvetica",
    fill: DEFAULT_FILL_STYLE,
    stroke: DEFAULT_TEXT_STROKE_STYLE,
    scale: 0.8
  });
  DEFAULT_STYLE = new Style$2({
    fill: DEFAULT_FILL_STYLE,
    image: DEFAULT_IMAGE_STYLE,
    text: DEFAULT_TEXT_STYLE,
    stroke: DEFAULT_STROKE_STYLE,
    zIndex: 0
  });
  DEFAULT_STYLE_ARRAY = [DEFAULT_STYLE];
}
var TEXTAREA;
function defaultIconUrlFunction(href) {
  return href;
}
var KML = function(_super) {
  __extends$f(KML2, _super);
  function KML2(opt_options) {
    var _this = _super.call(this) || this;
    var options = opt_options ? opt_options : {};
    if (!DEFAULT_STYLE_ARRAY) {
      createStyleDefaults();
    }
    _this.dataProjection = get$3("EPSG:4326");
    _this.defaultStyle_ = options.defaultStyle ? options.defaultStyle : DEFAULT_STYLE_ARRAY;
    _this.extractStyles_ = options.extractStyles !== void 0 ? options.extractStyles : true;
    _this.writeStyles_ = options.writeStyles !== void 0 ? options.writeStyles : true;
    _this.sharedStyles_ = {};
    _this.showPointNames_ = options.showPointNames !== void 0 ? options.showPointNames : true;
    _this.crossOrigin_ = options.crossOrigin !== void 0 ? options.crossOrigin : "anonymous";
    _this.iconUrlFunction_ = options.iconUrlFunction ? options.iconUrlFunction : defaultIconUrlFunction;
    _this.supportedMediaTypes = ["application/vnd.google-earth.kml+xml"];
    return _this;
  }
  KML2.prototype.readDocumentOrFolder_ = function(node2, objectStack) {
    var parsersNS = makeStructureNS(NAMESPACE_URIS$3, {
      "Document": makeArrayExtender(this.readDocumentOrFolder_, this),
      "Folder": makeArrayExtender(this.readDocumentOrFolder_, this),
      "Placemark": makeArrayPusher(this.readPlacemark_, this),
      "Style": this.readSharedStyle_.bind(this),
      "StyleMap": this.readSharedStyleMap_.bind(this)
    });
    var features = pushParseAndPop([], parsersNS, node2, objectStack, this);
    if (features) {
      return features;
    } else {
      return void 0;
    }
  };
  KML2.prototype.readPlacemark_ = function(node2, objectStack) {
    var object = pushParseAndPop({ "geometry": null }, PLACEMARK_PARSERS, node2, objectStack, this);
    if (!object) {
      return void 0;
    }
    var feature$1 = new feature();
    var id = node2.getAttribute("id");
    if (id !== null) {
      feature$1.setId(id);
    }
    var options = objectStack[0];
    var geometry = object["geometry"];
    if (geometry) {
      transformGeometryWithOptions(geometry, false, options);
    }
    feature$1.setGeometry(geometry);
    delete object["geometry"];
    if (this.extractStyles_) {
      var style2 = object["Style"];
      var styleUrl = object["styleUrl"];
      var styleFunction = createFeatureStyleFunction(style2, styleUrl, this.defaultStyle_, this.sharedStyles_, this.showPointNames_);
      feature$1.setStyle(styleFunction);
    }
    delete object["Style"];
    feature$1.setProperties(object, true);
    return feature$1;
  };
  KML2.prototype.readSharedStyle_ = function(node2, objectStack) {
    var id = node2.getAttribute("id");
    if (id !== null) {
      var style2 = readStyle$2.call(this, node2, objectStack);
      if (style2) {
        var styleUri = void 0;
        var baseURI = node2.baseURI;
        if (!baseURI || baseURI == "about:blank") {
          baseURI = window.location.href;
        }
        if (baseURI) {
          var url = new URL("#" + id, baseURI);
          styleUri = url.href;
        } else {
          styleUri = "#" + id;
        }
        this.sharedStyles_[styleUri] = style2;
      }
    }
  };
  KML2.prototype.readSharedStyleMap_ = function(node2, objectStack) {
    var id = node2.getAttribute("id");
    if (id === null) {
      return;
    }
    var styleMapValue = readStyleMapValue.call(this, node2, objectStack);
    if (!styleMapValue) {
      return;
    }
    var styleUri;
    var baseURI = node2.baseURI;
    if (!baseURI || baseURI == "about:blank") {
      baseURI = window.location.href;
    }
    if (baseURI) {
      var url = new URL("#" + id, baseURI);
      styleUri = url.href;
    } else {
      styleUri = "#" + id;
    }
    this.sharedStyles_[styleUri] = styleMapValue;
  };
  KML2.prototype.readFeatureFromNode = function(node2, opt_options) {
    if (!includes(NAMESPACE_URIS$3, node2.namespaceURI)) {
      return null;
    }
    var feature2 = this.readPlacemark_(node2, [
      this.getReadOptions(node2, opt_options)
    ]);
    if (feature2) {
      return feature2;
    } else {
      return null;
    }
  };
  KML2.prototype.readFeaturesFromNode = function(node2, opt_options) {
    if (!includes(NAMESPACE_URIS$3, node2.namespaceURI)) {
      return [];
    }
    var features;
    var localName = node2.localName;
    if (localName == "Document" || localName == "Folder") {
      features = this.readDocumentOrFolder_(node2, [
        this.getReadOptions(node2, opt_options)
      ]);
      if (features) {
        return features;
      } else {
        return [];
      }
    } else if (localName == "Placemark") {
      var feature2 = this.readPlacemark_(node2, [
        this.getReadOptions(node2, opt_options)
      ]);
      if (feature2) {
        return [feature2];
      } else {
        return [];
      }
    } else if (localName == "kml") {
      features = [];
      for (var n2 = node2.firstElementChild; n2; n2 = n2.nextElementSibling) {
        var fs = this.readFeaturesFromNode(n2, opt_options);
        if (fs) {
          extend$3(features, fs);
        }
      }
      return features;
    } else {
      return [];
    }
  };
  KML2.prototype.readName = function(source) {
    if (!source) {
      return void 0;
    } else if (typeof source === "string") {
      var doc = parse$1(source);
      return this.readNameFromDocument(doc);
    } else if (isDocument(source)) {
      return this.readNameFromDocument(source);
    } else {
      return this.readNameFromNode(source);
    }
  };
  KML2.prototype.readNameFromDocument = function(doc) {
    for (var n2 = doc.firstChild; n2; n2 = n2.nextSibling) {
      if (n2.nodeType == Node.ELEMENT_NODE) {
        var name_1 = this.readNameFromNode(n2);
        if (name_1) {
          return name_1;
        }
      }
    }
    return void 0;
  };
  KML2.prototype.readNameFromNode = function(node2) {
    for (var n2 = node2.firstElementChild; n2; n2 = n2.nextElementSibling) {
      if (includes(NAMESPACE_URIS$3, n2.namespaceURI) && n2.localName == "name") {
        return readString(n2);
      }
    }
    for (var n2 = node2.firstElementChild; n2; n2 = n2.nextElementSibling) {
      var localName = n2.localName;
      if (includes(NAMESPACE_URIS$3, n2.namespaceURI) && (localName == "Document" || localName == "Folder" || localName == "Placemark" || localName == "kml")) {
        var name_2 = this.readNameFromNode(n2);
        if (name_2) {
          return name_2;
        }
      }
    }
    return void 0;
  };
  KML2.prototype.readNetworkLinks = function(source) {
    var networkLinks = [];
    if (typeof source === "string") {
      var doc = parse$1(source);
      extend$3(networkLinks, this.readNetworkLinksFromDocument(doc));
    } else if (isDocument(source)) {
      extend$3(networkLinks, this.readNetworkLinksFromDocument(source));
    } else {
      extend$3(networkLinks, this.readNetworkLinksFromNode(source));
    }
    return networkLinks;
  };
  KML2.prototype.readNetworkLinksFromDocument = function(doc) {
    var networkLinks = [];
    for (var n2 = doc.firstChild; n2; n2 = n2.nextSibling) {
      if (n2.nodeType == Node.ELEMENT_NODE) {
        extend$3(networkLinks, this.readNetworkLinksFromNode(n2));
      }
    }
    return networkLinks;
  };
  KML2.prototype.readNetworkLinksFromNode = function(node2) {
    var networkLinks = [];
    for (var n2 = node2.firstElementChild; n2; n2 = n2.nextElementSibling) {
      if (includes(NAMESPACE_URIS$3, n2.namespaceURI) && n2.localName == "NetworkLink") {
        var obj = pushParseAndPop({}, NETWORK_LINK_PARSERS, n2, []);
        networkLinks.push(obj);
      }
    }
    for (var n2 = node2.firstElementChild; n2; n2 = n2.nextElementSibling) {
      var localName = n2.localName;
      if (includes(NAMESPACE_URIS$3, n2.namespaceURI) && (localName == "Document" || localName == "Folder" || localName == "kml")) {
        extend$3(networkLinks, this.readNetworkLinksFromNode(n2));
      }
    }
    return networkLinks;
  };
  KML2.prototype.readRegion = function(source) {
    var regions = [];
    if (typeof source === "string") {
      var doc = parse$1(source);
      extend$3(regions, this.readRegionFromDocument(doc));
    } else if (isDocument(source)) {
      extend$3(regions, this.readRegionFromDocument(source));
    } else {
      extend$3(regions, this.readRegionFromNode(source));
    }
    return regions;
  };
  KML2.prototype.readRegionFromDocument = function(doc) {
    var regions = [];
    for (var n2 = doc.firstChild; n2; n2 = n2.nextSibling) {
      if (n2.nodeType == Node.ELEMENT_NODE) {
        extend$3(regions, this.readRegionFromNode(n2));
      }
    }
    return regions;
  };
  KML2.prototype.readRegionFromNode = function(node2) {
    var regions = [];
    for (var n2 = node2.firstElementChild; n2; n2 = n2.nextElementSibling) {
      if (includes(NAMESPACE_URIS$3, n2.namespaceURI) && n2.localName == "Region") {
        var obj = pushParseAndPop({}, REGION_PARSERS, n2, []);
        regions.push(obj);
      }
    }
    for (var n2 = node2.firstElementChild; n2; n2 = n2.nextElementSibling) {
      var localName = n2.localName;
      if (includes(NAMESPACE_URIS$3, n2.namespaceURI) && (localName == "Document" || localName == "Folder" || localName == "kml")) {
        extend$3(regions, this.readRegionFromNode(n2));
      }
    }
    return regions;
  };
  KML2.prototype.writeFeaturesNode = function(features, opt_options) {
    opt_options = this.adaptOptions(opt_options);
    var kml = createElementNS(NAMESPACE_URIS$3[4], "kml");
    var xmlnsUri = "http://www.w3.org/2000/xmlns/";
    kml.setAttributeNS(xmlnsUri, "xmlns:gx", GX_NAMESPACE_URIS[0]);
    kml.setAttributeNS(xmlnsUri, "xmlns:xsi", XML_SCHEMA_INSTANCE_URI);
    kml.setAttributeNS(XML_SCHEMA_INSTANCE_URI, "xsi:schemaLocation", SCHEMA_LOCATION);
    var context = {
      node: kml
    };
    var properties = {};
    if (features.length > 1) {
      properties["Document"] = features;
    } else if (features.length == 1) {
      properties["Placemark"] = features[0];
    }
    var orderedKeys = KML_SEQUENCE[kml.namespaceURI];
    var values2 = makeSequence(properties, orderedKeys);
    pushSerializeAndPop(context, KML_SERIALIZERS, OBJECT_PROPERTY_NODE_FACTORY, values2, [opt_options], orderedKeys, this);
    return kml;
  };
  return KML2;
}(XMLFeature$1);
function createNameStyleFunction(foundStyle, name) {
  var textOffset = [0, 0];
  var textAlign2 = "start";
  var imageStyle = foundStyle.getImage();
  if (imageStyle) {
    var imageSize = imageStyle.getSize();
    if (imageSize && imageSize.length == 2) {
      var imageScale = imageStyle.getScaleArray();
      var anchor = imageStyle.getAnchor();
      textOffset[0] = imageScale[0] * (imageSize[0] - anchor[0]);
      textOffset[1] = imageScale[1] * (imageSize[1] / 2 - anchor[1]);
      textAlign2 = "left";
    }
  }
  var textStyle = foundStyle.getText();
  if (textStyle) {
    textStyle = textStyle.clone();
    textStyle.setFont(textStyle.getFont() || DEFAULT_TEXT_STYLE.getFont());
    textStyle.setScale(textStyle.getScale() || DEFAULT_TEXT_STYLE.getScale());
    textStyle.setFill(textStyle.getFill() || DEFAULT_TEXT_STYLE.getFill());
    textStyle.setStroke(textStyle.getStroke() || DEFAULT_TEXT_STROKE_STYLE);
  } else {
    textStyle = DEFAULT_TEXT_STYLE.clone();
  }
  textStyle.setText(name);
  textStyle.setOffsetX(textOffset[0]);
  textStyle.setOffsetY(textOffset[1]);
  textStyle.setTextAlign(textAlign2);
  var nameStyle = new Style$2({
    image: imageStyle,
    text: textStyle
  });
  return nameStyle;
}
function createFeatureStyleFunction(style2, styleUrl, defaultStyle, sharedStyles, showPointNames) {
  return function(feature2, resolution) {
    var drawName = showPointNames;
    var name = "";
    var multiGeometryPoints = [];
    if (drawName) {
      var geometry = feature2.getGeometry();
      if (geometry) {
        if (geometry instanceof GeometryCollection$1) {
          multiGeometryPoints = geometry.getGeometriesArrayRecursive().filter(function(geometry2) {
            var type2 = geometry2.getType();
            return type2 === GeometryType.POINT || type2 === GeometryType.MULTI_POINT;
          });
          drawName = multiGeometryPoints.length > 0;
        } else {
          var type = geometry.getType();
          drawName = type === GeometryType.POINT || type === GeometryType.MULTI_POINT;
        }
      }
    }
    if (drawName) {
      name = feature2.get("name");
      drawName = drawName && !!name;
      if (drawName && name.search(/&[^&]+;/) > -1) {
        if (!TEXTAREA) {
          TEXTAREA = document.createElement("textarea");
        }
        TEXTAREA.innerHTML = name;
        name = TEXTAREA.value;
      }
    }
    var featureStyle = defaultStyle;
    if (style2) {
      featureStyle = style2;
    } else if (styleUrl) {
      featureStyle = findStyle(styleUrl, defaultStyle, sharedStyles);
    }
    if (drawName) {
      var nameStyle = createNameStyleFunction(featureStyle[0], name);
      if (multiGeometryPoints.length > 0) {
        nameStyle.setGeometry(new GeometryCollection$1(multiGeometryPoints));
        var baseStyle = new Style$2({
          geometry: featureStyle[0].getGeometry(),
          image: null,
          fill: featureStyle[0].getFill(),
          stroke: featureStyle[0].getStroke(),
          text: null
        });
        return [nameStyle, baseStyle].concat(featureStyle.slice(1));
      }
      return nameStyle;
    }
    return featureStyle;
  };
}
function findStyle(styleValue, defaultStyle, sharedStyles) {
  if (Array.isArray(styleValue)) {
    return styleValue;
  } else if (typeof styleValue === "string") {
    return findStyle(sharedStyles[styleValue], defaultStyle, sharedStyles);
  } else {
    return defaultStyle;
  }
}
function readColor(node2) {
  var s2 = getAllTextContent(node2, false);
  var m2 = /^\s*#?\s*([0-9A-Fa-f]{8})\s*$/.exec(s2);
  if (m2) {
    var hexColor = m2[1];
    return [
      parseInt(hexColor.substr(6, 2), 16),
      parseInt(hexColor.substr(4, 2), 16),
      parseInt(hexColor.substr(2, 2), 16),
      parseInt(hexColor.substr(0, 2), 16) / 255
    ];
  } else {
    return void 0;
  }
}
function readFlatCoordinates(node2) {
  var s2 = getAllTextContent(node2, false);
  var flatCoordinates = [];
  s2 = s2.replace(/\s*,\s*/g, ",");
  var re2 = /^\s*([+\-]?\d*\.?\d+(?:e[+\-]?\d+)?),([+\-]?\d*\.?\d+(?:e[+\-]?\d+)?)(?:\s+|,|$)(?:([+\-]?\d*\.?\d+(?:e[+\-]?\d+)?)(?:\s+|$))?\s*/i;
  var m2;
  while (m2 = re2.exec(s2)) {
    var x2 = parseFloat(m2[1]);
    var y2 = parseFloat(m2[2]);
    var z2 = m2[3] ? parseFloat(m2[3]) : 0;
    flatCoordinates.push(x2, y2, z2);
    s2 = s2.substr(m2[0].length);
  }
  if (s2 !== "") {
    return void 0;
  }
  return flatCoordinates;
}
function readURI(node2) {
  var s2 = getAllTextContent(node2, false).trim();
  var baseURI = node2.baseURI;
  if (!baseURI || baseURI == "about:blank") {
    baseURI = window.location.href;
  }
  if (baseURI) {
    var url = new URL(s2, baseURI);
    return url.href;
  } else {
    return s2;
  }
}
function readStyleURL(node2) {
  var s2 = getAllTextContent(node2, false).trim().replace(/^(?!.*#)/, "#");
  var baseURI = node2.baseURI;
  if (!baseURI || baseURI == "about:blank") {
    baseURI = window.location.href;
  }
  if (baseURI) {
    var url = new URL(s2, baseURI);
    return url.href;
  } else {
    return s2;
  }
}
function readVec2(node2) {
  var xunits = node2.getAttribute("xunits");
  var yunits = node2.getAttribute("yunits");
  var origin;
  if (xunits !== "insetPixels") {
    if (yunits !== "insetPixels") {
      origin = IconOrigin.BOTTOM_LEFT;
    } else {
      origin = IconOrigin.TOP_LEFT;
    }
  } else {
    if (yunits !== "insetPixels") {
      origin = IconOrigin.BOTTOM_RIGHT;
    } else {
      origin = IconOrigin.TOP_RIGHT;
    }
  }
  return {
    x: parseFloat(node2.getAttribute("x")),
    xunits: ICON_ANCHOR_UNITS_MAP[xunits],
    y: parseFloat(node2.getAttribute("y")),
    yunits: ICON_ANCHOR_UNITS_MAP[yunits],
    origin
  };
}
function readScale(node2) {
  return readDecimal(node2);
}
var STYLE_MAP_PARSERS = makeStructureNS(NAMESPACE_URIS$3, {
  "Pair": pairDataParser
});
function readStyleMapValue(node2, objectStack) {
  return pushParseAndPop(void 0, STYLE_MAP_PARSERS, node2, objectStack, this);
}
var ICON_STYLE_PARSERS = makeStructureNS(NAMESPACE_URIS$3, {
  "Icon": makeObjectPropertySetter(readIcon),
  "color": makeObjectPropertySetter(readColor),
  "heading": makeObjectPropertySetter(readDecimal),
  "hotSpot": makeObjectPropertySetter(readVec2),
  "scale": makeObjectPropertySetter(readScale)
});
function iconStyleParser(node2, objectStack) {
  var object = pushParseAndPop({}, ICON_STYLE_PARSERS, node2, objectStack);
  if (!object) {
    return;
  }
  var styleObject = objectStack[objectStack.length - 1];
  var IconObject = "Icon" in object ? object["Icon"] : {};
  var drawIcon = !("Icon" in object) || Object.keys(IconObject).length > 0;
  var src;
  var href = IconObject["href"];
  if (href) {
    src = href;
  } else if (drawIcon) {
    src = DEFAULT_IMAGE_STYLE_SRC;
  }
  var anchor, anchorXUnits, anchorYUnits;
  var anchorOrigin = IconOrigin.BOTTOM_LEFT;
  var hotSpot = object["hotSpot"];
  if (hotSpot) {
    anchor = [hotSpot.x, hotSpot.y];
    anchorXUnits = hotSpot.xunits;
    anchorYUnits = hotSpot.yunits;
    anchorOrigin = hotSpot.origin;
  } else if (/^http:\/\/maps\.(?:google|gstatic)\.com\//.test(src)) {
    if (/pushpin/.test(src)) {
      anchor = DEFAULT_IMAGE_STYLE_ANCHOR;
      anchorXUnits = DEFAULT_IMAGE_STYLE_ANCHOR_X_UNITS;
      anchorYUnits = DEFAULT_IMAGE_STYLE_ANCHOR_Y_UNITS;
    } else if (/arrow-reverse/.test(src)) {
      anchor = [54, 42];
      anchorXUnits = DEFAULT_IMAGE_STYLE_ANCHOR_X_UNITS;
      anchorYUnits = DEFAULT_IMAGE_STYLE_ANCHOR_Y_UNITS;
    } else if (/paddle/.test(src)) {
      anchor = [32, 1];
      anchorXUnits = DEFAULT_IMAGE_STYLE_ANCHOR_X_UNITS;
      anchorYUnits = DEFAULT_IMAGE_STYLE_ANCHOR_Y_UNITS;
    }
  }
  var offset2;
  var x2 = IconObject["x"];
  var y2 = IconObject["y"];
  if (x2 !== void 0 && y2 !== void 0) {
    offset2 = [x2, y2];
  }
  var size;
  var w2 = IconObject["w"];
  var h2 = IconObject["h"];
  if (w2 !== void 0 && h2 !== void 0) {
    size = [w2, h2];
  }
  var rotation;
  var heading = object["heading"];
  if (heading !== void 0) {
    rotation = toRadians(heading);
  }
  var scale2 = object["scale"];
  var color2 = object["color"];
  if (drawIcon) {
    if (src == DEFAULT_IMAGE_STYLE_SRC) {
      size = DEFAULT_IMAGE_STYLE_SIZE;
    }
    var imageStyle_1 = new Icon$2({
      anchor,
      anchorOrigin,
      anchorXUnits,
      anchorYUnits,
      crossOrigin: this.crossOrigin_,
      offset: offset2,
      offsetOrigin: IconOrigin.BOTTOM_LEFT,
      rotation,
      scale: scale2,
      size,
      src: this.iconUrlFunction_(src),
      color: color2
    });
    var imageScale_1 = imageStyle_1.getScaleArray()[0];
    var imageSize = imageStyle_1.getSize();
    if (imageSize === null) {
      var imageState = imageStyle_1.getImageState();
      if (imageState === ImageState.IDLE || imageState === ImageState.LOADING) {
        var listener_1 = function() {
          var imageState2 = imageStyle_1.getImageState();
          if (!(imageState2 === ImageState.IDLE || imageState2 === ImageState.LOADING)) {
            var imageSize_1 = imageStyle_1.getSize();
            if (imageSize_1 && imageSize_1.length == 2) {
              var resizeScale2 = scaleForSize(imageSize_1);
              imageStyle_1.setScale(imageScale_1 * resizeScale2);
            }
            imageStyle_1.unlistenImageChange(listener_1);
          }
        };
        imageStyle_1.listenImageChange(listener_1);
        if (imageState === ImageState.IDLE) {
          imageStyle_1.load();
        }
      }
    } else if (imageSize.length == 2) {
      var resizeScale = scaleForSize(imageSize);
      imageStyle_1.setScale(imageScale_1 * resizeScale);
    }
    styleObject["imageStyle"] = imageStyle_1;
  } else {
    styleObject["imageStyle"] = DEFAULT_NO_IMAGE_STYLE;
  }
}
var LABEL_STYLE_PARSERS = makeStructureNS(NAMESPACE_URIS$3, {
  "color": makeObjectPropertySetter(readColor),
  "scale": makeObjectPropertySetter(readScale)
});
function labelStyleParser(node2, objectStack) {
  var object = pushParseAndPop({}, LABEL_STYLE_PARSERS, node2, objectStack);
  if (!object) {
    return;
  }
  var styleObject = objectStack[objectStack.length - 1];
  var textStyle = new Text$2({
    fill: new Fill$2({
      color: "color" in object ? object["color"] : DEFAULT_COLOR
    }),
    scale: object["scale"]
  });
  styleObject["textStyle"] = textStyle;
}
var LINE_STYLE_PARSERS = makeStructureNS(NAMESPACE_URIS$3, {
  "color": makeObjectPropertySetter(readColor),
  "width": makeObjectPropertySetter(readDecimal)
});
function lineStyleParser(node2, objectStack) {
  var object = pushParseAndPop({}, LINE_STYLE_PARSERS, node2, objectStack);
  if (!object) {
    return;
  }
  var styleObject = objectStack[objectStack.length - 1];
  var strokeStyle = new Stroke$2({
    color: "color" in object ? object["color"] : DEFAULT_COLOR,
    width: "width" in object ? object["width"] : 1
  });
  styleObject["strokeStyle"] = strokeStyle;
}
var POLY_STYLE_PARSERS = makeStructureNS(NAMESPACE_URIS$3, {
  "color": makeObjectPropertySetter(readColor),
  "fill": makeObjectPropertySetter(readBoolean),
  "outline": makeObjectPropertySetter(readBoolean)
});
function polyStyleParser(node2, objectStack) {
  var object = pushParseAndPop({}, POLY_STYLE_PARSERS, node2, objectStack);
  if (!object) {
    return;
  }
  var styleObject = objectStack[objectStack.length - 1];
  var fillStyle = new Fill$2({
    color: "color" in object ? object["color"] : DEFAULT_COLOR
  });
  styleObject["fillStyle"] = fillStyle;
  var fill = object["fill"];
  if (fill !== void 0) {
    styleObject["fill"] = fill;
  }
  var outline = object["outline"];
  if (outline !== void 0) {
    styleObject["outline"] = outline;
  }
}
var FLAT_LINEAR_RING_PARSERS = makeStructureNS(NAMESPACE_URIS$3, {
  "coordinates": makeReplacer(readFlatCoordinates)
});
function readFlatLinearRing(node2, objectStack) {
  return pushParseAndPop(null, FLAT_LINEAR_RING_PARSERS, node2, objectStack);
}
function gxCoordParser(node2, objectStack) {
  var gxTrackObject = objectStack[objectStack.length - 1];
  var coordinates2 = gxTrackObject.coordinates;
  var s2 = getAllTextContent(node2, false);
  var re2 = /^\s*([+\-]?\d+(?:\.\d*)?(?:e[+\-]?\d*)?)\s+([+\-]?\d+(?:\.\d*)?(?:e[+\-]?\d*)?)\s+([+\-]?\d+(?:\.\d*)?(?:e[+\-]?\d*)?)\s*$/i;
  var m2 = re2.exec(s2);
  if (m2) {
    var x2 = parseFloat(m2[1]);
    var y2 = parseFloat(m2[2]);
    var z2 = parseFloat(m2[3]);
    coordinates2.push([x2, y2, z2]);
  } else {
    coordinates2.push([]);
  }
}
var GX_MULTITRACK_GEOMETRY_PARSERS = makeStructureNS(GX_NAMESPACE_URIS, {
  "Track": makeArrayPusher(readGxTrack)
});
function readGxMultiTrack(node2, objectStack) {
  var lineStrings = pushParseAndPop([], GX_MULTITRACK_GEOMETRY_PARSERS, node2, objectStack);
  if (!lineStrings) {
    return void 0;
  }
  return new MultiLineString$2(lineStrings);
}
var GX_TRACK_PARSERS = makeStructureNS(NAMESPACE_URIS$3, {
  "when": whenParser
}, makeStructureNS(GX_NAMESPACE_URIS, {
  "coord": gxCoordParser
}));
function readGxTrack(node2, objectStack) {
  var gxTrackObject = pushParseAndPop({
    coordinates: [],
    whens: []
  }, GX_TRACK_PARSERS, node2, objectStack);
  if (!gxTrackObject) {
    return void 0;
  }
  var flatCoordinates = [];
  var coordinates2 = gxTrackObject.coordinates;
  var whens = gxTrackObject.whens;
  for (var i2 = 0, ii = Math.min(coordinates2.length, whens.length); i2 < ii; ++i2) {
    if (coordinates2[i2].length == 3) {
      flatCoordinates.push(coordinates2[i2][0], coordinates2[i2][1], coordinates2[i2][2], whens[i2]);
    }
  }
  return new LineString$2(flatCoordinates, GeometryLayout.XYZM);
}
var ICON_PARSERS = makeStructureNS(NAMESPACE_URIS$3, {
  "href": makeObjectPropertySetter(readURI)
}, makeStructureNS(GX_NAMESPACE_URIS, {
  "x": makeObjectPropertySetter(readDecimal),
  "y": makeObjectPropertySetter(readDecimal),
  "w": makeObjectPropertySetter(readDecimal),
  "h": makeObjectPropertySetter(readDecimal)
}));
function readIcon(node2, objectStack) {
  var iconObject = pushParseAndPop({}, ICON_PARSERS, node2, objectStack);
  if (iconObject) {
    return iconObject;
  } else {
    return null;
  }
}
var GEOMETRY_FLAT_COORDINATES_PARSERS = makeStructureNS(NAMESPACE_URIS$3, {
  "coordinates": makeReplacer(readFlatCoordinates)
});
function readFlatCoordinatesFromNode(node2, objectStack) {
  return pushParseAndPop(null, GEOMETRY_FLAT_COORDINATES_PARSERS, node2, objectStack);
}
var EXTRUDE_AND_ALTITUDE_MODE_PARSERS = makeStructureNS(NAMESPACE_URIS$3, {
  "extrude": makeObjectPropertySetter(readBoolean),
  "tessellate": makeObjectPropertySetter(readBoolean),
  "altitudeMode": makeObjectPropertySetter(readString)
});
function readLineString(node2, objectStack) {
  var properties = pushParseAndPop({}, EXTRUDE_AND_ALTITUDE_MODE_PARSERS, node2, objectStack);
  var flatCoordinates = readFlatCoordinatesFromNode(node2, objectStack);
  if (flatCoordinates) {
    var lineString = new LineString$2(flatCoordinates, GeometryLayout.XYZ);
    lineString.setProperties(properties, true);
    return lineString;
  } else {
    return void 0;
  }
}
function readLinearRing(node2, objectStack) {
  var properties = pushParseAndPop({}, EXTRUDE_AND_ALTITUDE_MODE_PARSERS, node2, objectStack);
  var flatCoordinates = readFlatCoordinatesFromNode(node2, objectStack);
  if (flatCoordinates) {
    var polygon = new Polygon$2(flatCoordinates, GeometryLayout.XYZ, [
      flatCoordinates.length
    ]);
    polygon.setProperties(properties, true);
    return polygon;
  } else {
    return void 0;
  }
}
var MULTI_GEOMETRY_PARSERS = makeStructureNS(NAMESPACE_URIS$3, {
  "LineString": makeArrayPusher(readLineString),
  "LinearRing": makeArrayPusher(readLinearRing),
  "MultiGeometry": makeArrayPusher(readMultiGeometry),
  "Point": makeArrayPusher(readPoint),
  "Polygon": makeArrayPusher(readPolygon)
});
function readMultiGeometry(node2, objectStack) {
  var geometries = pushParseAndPop([], MULTI_GEOMETRY_PARSERS, node2, objectStack);
  if (!geometries) {
    return null;
  }
  if (geometries.length === 0) {
    return new GeometryCollection$1(geometries);
  }
  var multiGeometry;
  var homogeneous = true;
  var type = geometries[0].getType();
  var geometry;
  for (var i2 = 1, ii = geometries.length; i2 < ii; ++i2) {
    geometry = geometries[i2];
    if (geometry.getType() != type) {
      homogeneous = false;
      break;
    }
  }
  if (homogeneous) {
    var layout = void 0;
    var flatCoordinates = void 0;
    if (type == GeometryType.POINT) {
      var point = geometries[0];
      layout = point.getLayout();
      flatCoordinates = point.getFlatCoordinates();
      for (var i2 = 1, ii = geometries.length; i2 < ii; ++i2) {
        geometry = geometries[i2];
        extend$3(flatCoordinates, geometry.getFlatCoordinates());
      }
      multiGeometry = new MultiPoint$2(flatCoordinates, layout);
      setCommonGeometryProperties(multiGeometry, geometries);
    } else if (type == GeometryType.LINE_STRING) {
      multiGeometry = new MultiLineString$2(geometries);
      setCommonGeometryProperties(multiGeometry, geometries);
    } else if (type == GeometryType.POLYGON) {
      multiGeometry = new MultiPolygon$2(geometries);
      setCommonGeometryProperties(multiGeometry, geometries);
    } else if (type == GeometryType.GEOMETRY_COLLECTION) {
      multiGeometry = new GeometryCollection$1(geometries);
    } else {
      assert(false, 37);
    }
  } else {
    multiGeometry = new GeometryCollection$1(geometries);
  }
  return multiGeometry;
}
function readPoint(node2, objectStack) {
  var properties = pushParseAndPop({}, EXTRUDE_AND_ALTITUDE_MODE_PARSERS, node2, objectStack);
  var flatCoordinates = readFlatCoordinatesFromNode(node2, objectStack);
  if (flatCoordinates) {
    var point = new Point$4(flatCoordinates, GeometryLayout.XYZ);
    point.setProperties(properties, true);
    return point;
  } else {
    return void 0;
  }
}
var FLAT_LINEAR_RINGS_PARSERS = makeStructureNS(NAMESPACE_URIS$3, {
  "innerBoundaryIs": innerBoundaryIsParser,
  "outerBoundaryIs": outerBoundaryIsParser
});
function readPolygon(node2, objectStack) {
  var properties = pushParseAndPop({}, EXTRUDE_AND_ALTITUDE_MODE_PARSERS, node2, objectStack);
  var flatLinearRings = pushParseAndPop([null], FLAT_LINEAR_RINGS_PARSERS, node2, objectStack);
  if (flatLinearRings && flatLinearRings[0]) {
    var flatCoordinates = flatLinearRings[0];
    var ends = [flatCoordinates.length];
    for (var i2 = 1, ii = flatLinearRings.length; i2 < ii; ++i2) {
      extend$3(flatCoordinates, flatLinearRings[i2]);
      ends.push(flatCoordinates.length);
    }
    var polygon = new Polygon$2(flatCoordinates, GeometryLayout.XYZ, ends);
    polygon.setProperties(properties, true);
    return polygon;
  } else {
    return void 0;
  }
}
var STYLE_PARSERS$2 = makeStructureNS(NAMESPACE_URIS$3, {
  "IconStyle": iconStyleParser,
  "LabelStyle": labelStyleParser,
  "LineStyle": lineStyleParser,
  "PolyStyle": polyStyleParser
});
function readStyle$2(node2, objectStack) {
  var styleObject = pushParseAndPop({}, STYLE_PARSERS$2, node2, objectStack, this);
  if (!styleObject) {
    return null;
  }
  var fillStyle = "fillStyle" in styleObject ? styleObject["fillStyle"] : DEFAULT_FILL_STYLE;
  var fill = styleObject["fill"];
  if (fill !== void 0 && !fill) {
    fillStyle = null;
  }
  var imageStyle;
  if ("imageStyle" in styleObject) {
    if (styleObject["imageStyle"] != DEFAULT_NO_IMAGE_STYLE) {
      imageStyle = styleObject["imageStyle"];
    }
  } else {
    imageStyle = DEFAULT_IMAGE_STYLE;
  }
  var textStyle = "textStyle" in styleObject ? styleObject["textStyle"] : DEFAULT_TEXT_STYLE;
  var strokeStyle = "strokeStyle" in styleObject ? styleObject["strokeStyle"] : DEFAULT_STROKE_STYLE;
  var outline = styleObject["outline"];
  if (outline !== void 0 && !outline) {
    return [
      new Style$2({
        geometry: function(feature2) {
          var geometry = feature2.getGeometry();
          var type = geometry.getType();
          if (type === GeometryType.GEOMETRY_COLLECTION) {
            var collection = geometry;
            return new GeometryCollection$1(collection.getGeometriesArrayRecursive().filter(function(geometry2) {
              var type2 = geometry2.getType();
              return type2 !== GeometryType.POLYGON && type2 !== GeometryType.MULTI_POLYGON;
            }));
          } else if (type !== GeometryType.POLYGON && type !== GeometryType.MULTI_POLYGON) {
            return geometry;
          }
        },
        fill: fillStyle,
        image: imageStyle,
        stroke: strokeStyle,
        text: textStyle,
        zIndex: void 0
      }),
      new Style$2({
        geometry: function(feature2) {
          var geometry = feature2.getGeometry();
          var type = geometry.getType();
          if (type === GeometryType.GEOMETRY_COLLECTION) {
            var collection = geometry;
            return new GeometryCollection$1(collection.getGeometriesArrayRecursive().filter(function(geometry2) {
              var type2 = geometry2.getType();
              return type2 === GeometryType.POLYGON || type2 === GeometryType.MULTI_POLYGON;
            }));
          } else if (type === GeometryType.POLYGON || type === GeometryType.MULTI_POLYGON) {
            return geometry;
          }
        },
        fill: fillStyle,
        stroke: null,
        zIndex: void 0
      })
    ];
  }
  return [
    new Style$2({
      fill: fillStyle,
      image: imageStyle,
      stroke: strokeStyle,
      text: textStyle,
      zIndex: void 0
    })
  ];
}
function setCommonGeometryProperties(multiGeometry, geometries) {
  var ii = geometries.length;
  var extrudes = new Array(geometries.length);
  var tessellates = new Array(geometries.length);
  var altitudeModes = new Array(geometries.length);
  var hasExtrude, hasTessellate, hasAltitudeMode;
  hasExtrude = false;
  hasTessellate = false;
  hasAltitudeMode = false;
  for (var i2 = 0; i2 < ii; ++i2) {
    var geometry = geometries[i2];
    extrudes[i2] = geometry.get("extrude");
    tessellates[i2] = geometry.get("tessellate");
    altitudeModes[i2] = geometry.get("altitudeMode");
    hasExtrude = hasExtrude || extrudes[i2] !== void 0;
    hasTessellate = hasTessellate || tessellates[i2] !== void 0;
    hasAltitudeMode = hasAltitudeMode || altitudeModes[i2];
  }
  if (hasExtrude) {
    multiGeometry.set("extrude", extrudes);
  }
  if (hasTessellate) {
    multiGeometry.set("tessellate", tessellates);
  }
  if (hasAltitudeMode) {
    multiGeometry.set("altitudeMode", altitudeModes);
  }
}
var DATA_PARSERS = makeStructureNS(NAMESPACE_URIS$3, {
  "displayName": makeObjectPropertySetter(readString),
  "value": makeObjectPropertySetter(readString)
});
function dataParser(node2, objectStack) {
  var name = node2.getAttribute("name");
  parseNode(DATA_PARSERS, node2, objectStack);
  var featureObject = objectStack[objectStack.length - 1];
  if (name && featureObject.displayName) {
    featureObject[name] = {
      value: featureObject.value,
      displayName: featureObject.displayName,
      toString: function() {
        return featureObject.value;
      }
    };
  } else if (name !== null) {
    featureObject[name] = featureObject.value;
  } else if (featureObject.displayName !== null) {
    featureObject[featureObject.displayName] = featureObject.value;
  }
  delete featureObject["value"];
}
var EXTENDED_DATA_PARSERS = makeStructureNS(NAMESPACE_URIS$3, {
  "Data": dataParser,
  "SchemaData": schemaDataParser
});
function extendedDataParser(node2, objectStack) {
  parseNode(EXTENDED_DATA_PARSERS, node2, objectStack);
}
function regionParser(node2, objectStack) {
  parseNode(REGION_PARSERS, node2, objectStack);
}
var PAIR_PARSERS = makeStructureNS(NAMESPACE_URIS$3, {
  "Style": makeObjectPropertySetter(readStyle$2),
  "key": makeObjectPropertySetter(readString),
  "styleUrl": makeObjectPropertySetter(readStyleURL)
});
function pairDataParser(node2, objectStack) {
  var pairObject = pushParseAndPop({}, PAIR_PARSERS, node2, objectStack, this);
  if (!pairObject) {
    return;
  }
  var key = pairObject["key"];
  if (key && key == "normal") {
    var styleUrl = pairObject["styleUrl"];
    if (styleUrl) {
      objectStack[objectStack.length - 1] = styleUrl;
    }
    var style2 = pairObject["Style"];
    if (style2) {
      objectStack[objectStack.length - 1] = style2;
    }
  }
}
function placemarkStyleMapParser(node2, objectStack) {
  var styleMapValue = readStyleMapValue.call(this, node2, objectStack);
  if (!styleMapValue) {
    return;
  }
  var placemarkObject = objectStack[objectStack.length - 1];
  if (Array.isArray(styleMapValue)) {
    placemarkObject["Style"] = styleMapValue;
  } else if (typeof styleMapValue === "string") {
    placemarkObject["styleUrl"] = styleMapValue;
  } else {
    assert(false, 38);
  }
}
var SCHEMA_DATA_PARSERS = makeStructureNS(NAMESPACE_URIS$3, {
  "SimpleData": simpleDataParser
});
function schemaDataParser(node2, objectStack) {
  parseNode(SCHEMA_DATA_PARSERS, node2, objectStack);
}
function simpleDataParser(node2, objectStack) {
  var name = node2.getAttribute("name");
  if (name !== null) {
    var data2 = readString(node2);
    var featureObject = objectStack[objectStack.length - 1];
    featureObject[name] = data2;
  }
}
var LAT_LON_ALT_BOX_PARSERS = makeStructureNS(NAMESPACE_URIS$3, {
  "altitudeMode": makeObjectPropertySetter(readString),
  "minAltitude": makeObjectPropertySetter(readDecimal),
  "maxAltitude": makeObjectPropertySetter(readDecimal),
  "north": makeObjectPropertySetter(readDecimal),
  "south": makeObjectPropertySetter(readDecimal),
  "east": makeObjectPropertySetter(readDecimal),
  "west": makeObjectPropertySetter(readDecimal)
});
function latLonAltBoxParser(node2, objectStack) {
  var object = pushParseAndPop({}, LAT_LON_ALT_BOX_PARSERS, node2, objectStack);
  if (!object) {
    return;
  }
  var regionObject = objectStack[objectStack.length - 1];
  var extent2 = [
    parseFloat(object["west"]),
    parseFloat(object["south"]),
    parseFloat(object["east"]),
    parseFloat(object["north"])
  ];
  regionObject["extent"] = extent2;
  regionObject["altitudeMode"] = object["altitudeMode"];
  regionObject["minAltitude"] = parseFloat(object["minAltitude"]);
  regionObject["maxAltitude"] = parseFloat(object["maxAltitude"]);
}
var LOD_PARSERS = makeStructureNS(NAMESPACE_URIS$3, {
  "minLodPixels": makeObjectPropertySetter(readDecimal),
  "maxLodPixels": makeObjectPropertySetter(readDecimal),
  "minFadeExtent": makeObjectPropertySetter(readDecimal),
  "maxFadeExtent": makeObjectPropertySetter(readDecimal)
});
function lodParser(node2, objectStack) {
  var object = pushParseAndPop({}, LOD_PARSERS, node2, objectStack);
  if (!object) {
    return;
  }
  var lodObject = objectStack[objectStack.length - 1];
  lodObject["minLodPixels"] = parseFloat(object["minLodPixels"]);
  lodObject["maxLodPixels"] = parseFloat(object["maxLodPixels"]);
  lodObject["minFadeExtent"] = parseFloat(object["minFadeExtent"]);
  lodObject["maxFadeExtent"] = parseFloat(object["maxFadeExtent"]);
}
var INNER_BOUNDARY_IS_PARSERS = makeStructureNS(NAMESPACE_URIS$3, {
  "LinearRing": makeArrayPusher(readFlatLinearRing)
});
function innerBoundaryIsParser(node2, objectStack) {
  var innerBoundaryFlatLinearRings = pushParseAndPop([], INNER_BOUNDARY_IS_PARSERS, node2, objectStack);
  if (innerBoundaryFlatLinearRings.length > 0) {
    var flatLinearRings = objectStack[objectStack.length - 1];
    flatLinearRings.push.apply(flatLinearRings, innerBoundaryFlatLinearRings);
  }
}
var OUTER_BOUNDARY_IS_PARSERS = makeStructureNS(NAMESPACE_URIS$3, {
  "LinearRing": makeReplacer(readFlatLinearRing)
});
function outerBoundaryIsParser(node2, objectStack) {
  var flatLinearRing = pushParseAndPop(void 0, OUTER_BOUNDARY_IS_PARSERS, node2, objectStack);
  if (flatLinearRing) {
    var flatLinearRings = objectStack[objectStack.length - 1];
    flatLinearRings[0] = flatLinearRing;
  }
}
function linkParser(node2, objectStack) {
  parseNode(LINK_PARSERS, node2, objectStack);
}
function whenParser(node2, objectStack) {
  var gxTrackObject = objectStack[objectStack.length - 1];
  var whens = gxTrackObject.whens;
  var s2 = getAllTextContent(node2, false);
  var when = Date.parse(s2);
  whens.push(isNaN(when) ? 0 : when);
}
function writeColorTextNode(node2, color2) {
  var rgba = asArray(color2);
  var opacity2 = rgba.length == 4 ? rgba[3] : 1;
  var abgr = [opacity2 * 255, rgba[2], rgba[1], rgba[0]];
  for (var i2 = 0; i2 < 4; ++i2) {
    var hex = Math.floor(abgr[i2]).toString(16);
    abgr[i2] = hex.length == 1 ? "0" + hex : hex;
  }
  writeStringTextNode(node2, abgr.join(""));
}
function writeCoordinatesTextNode(node2, coordinates2, objectStack) {
  var context = objectStack[objectStack.length - 1];
  var layout = context["layout"];
  var stride = context["stride"];
  var dimension;
  if (layout == GeometryLayout.XY || layout == GeometryLayout.XYM) {
    dimension = 2;
  } else if (layout == GeometryLayout.XYZ || layout == GeometryLayout.XYZM) {
    dimension = 3;
  } else {
    assert(false, 34);
  }
  var ii = coordinates2.length;
  var text2 = "";
  if (ii > 0) {
    text2 += coordinates2[0];
    for (var d2 = 1; d2 < dimension; ++d2) {
      text2 += "," + coordinates2[d2];
    }
    for (var i2 = stride; i2 < ii; i2 += stride) {
      text2 += " " + coordinates2[i2];
      for (var d2 = 1; d2 < dimension; ++d2) {
        text2 += "," + coordinates2[i2 + d2];
      }
    }
  }
  writeStringTextNode(node2, text2);
}
var EXTENDEDDATA_NODE_SERIALIZERS = makeStructureNS(NAMESPACE_URIS$3, {
  "Data": makeChildAppender(writeDataNode),
  "value": makeChildAppender(writeDataNodeValue),
  "displayName": makeChildAppender(writeDataNodeName)
});
function writeDataNode(node2, pair, objectStack) {
  node2.setAttribute("name", pair.name);
  var context = { node: node2 };
  var value = pair.value;
  if (typeof value == "object") {
    if (value !== null && value.displayName) {
      pushSerializeAndPop(context, EXTENDEDDATA_NODE_SERIALIZERS, OBJECT_PROPERTY_NODE_FACTORY, [value.displayName], objectStack, ["displayName"]);
    }
    if (value !== null && value.value) {
      pushSerializeAndPop(context, EXTENDEDDATA_NODE_SERIALIZERS, OBJECT_PROPERTY_NODE_FACTORY, [value.value], objectStack, ["value"]);
    }
  } else {
    pushSerializeAndPop(context, EXTENDEDDATA_NODE_SERIALIZERS, OBJECT_PROPERTY_NODE_FACTORY, [value], objectStack, ["value"]);
  }
}
function writeDataNodeName(node2, name) {
  writeCDATASection(node2, name);
}
function writeDataNodeValue(node2, value) {
  writeStringTextNode(node2, value);
}
var DOCUMENT_SERIALIZERS = makeStructureNS(NAMESPACE_URIS$3, {
  "Placemark": makeChildAppender(writePlacemark)
});
var DOCUMENT_NODE_FACTORY = function(value, objectStack, opt_nodeName) {
  var parentNode = objectStack[objectStack.length - 1].node;
  return createElementNS(parentNode.namespaceURI, "Placemark");
};
function writeDocument(node2, features, objectStack) {
  var context = { node: node2 };
  pushSerializeAndPop(context, DOCUMENT_SERIALIZERS, DOCUMENT_NODE_FACTORY, features, objectStack, void 0, this);
}
var DATA_NODE_FACTORY = makeSimpleNodeFactory("Data");
function writeExtendedData(node2, namesAndValues, objectStack) {
  var context = { node: node2 };
  var names2 = namesAndValues.names;
  var values2 = namesAndValues.values;
  var length = names2.length;
  for (var i2 = 0; i2 < length; i2++) {
    pushSerializeAndPop(context, EXTENDEDDATA_NODE_SERIALIZERS, DATA_NODE_FACTORY, [{ name: names2[i2], value: values2[i2] }], objectStack);
  }
}
var ICON_SEQUENCE = makeStructureNS(NAMESPACE_URIS$3, ["href"], makeStructureNS(GX_NAMESPACE_URIS, ["x", "y", "w", "h"]));
var ICON_SERIALIZERS = makeStructureNS(NAMESPACE_URIS$3, {
  "href": makeChildAppender(writeStringTextNode)
}, makeStructureNS(GX_NAMESPACE_URIS, {
  "x": makeChildAppender(writeDecimalTextNode),
  "y": makeChildAppender(writeDecimalTextNode),
  "w": makeChildAppender(writeDecimalTextNode),
  "h": makeChildAppender(writeDecimalTextNode)
}));
var GX_NODE_FACTORY = function(value, objectStack, opt_nodeName) {
  return createElementNS(GX_NAMESPACE_URIS[0], "gx:" + opt_nodeName);
};
function writeIcon(node2, icon, objectStack) {
  var context = { node: node2 };
  var parentNode = objectStack[objectStack.length - 1].node;
  var orderedKeys = ICON_SEQUENCE[parentNode.namespaceURI];
  var values2 = makeSequence(icon, orderedKeys);
  pushSerializeAndPop(context, ICON_SERIALIZERS, OBJECT_PROPERTY_NODE_FACTORY, values2, objectStack, orderedKeys);
  orderedKeys = ICON_SEQUENCE[GX_NAMESPACE_URIS[0]];
  values2 = makeSequence(icon, orderedKeys);
  pushSerializeAndPop(context, ICON_SERIALIZERS, GX_NODE_FACTORY, values2, objectStack, orderedKeys);
}
var ICON_STYLE_SEQUENCE = makeStructureNS(NAMESPACE_URIS$3, [
  "scale",
  "heading",
  "Icon",
  "color",
  "hotSpot"
]);
var ICON_STYLE_SERIALIZERS = makeStructureNS(NAMESPACE_URIS$3, {
  "Icon": makeChildAppender(writeIcon),
  "color": makeChildAppender(writeColorTextNode),
  "heading": makeChildAppender(writeDecimalTextNode),
  "hotSpot": makeChildAppender(writeVec2),
  "scale": makeChildAppender(writeScaleTextNode)
});
function writeIconStyle(node2, style2, objectStack) {
  var context = { node: node2 };
  var properties = {};
  var src = style2.getSrc();
  var size = style2.getSize();
  var iconImageSize = style2.getImageSize();
  var iconProperties = {
    "href": src
  };
  if (size) {
    iconProperties["w"] = size[0];
    iconProperties["h"] = size[1];
    var anchor = style2.getAnchor();
    var origin_1 = style2.getOrigin();
    if (origin_1 && iconImageSize && origin_1[0] !== 0 && origin_1[1] !== size[1]) {
      iconProperties["x"] = origin_1[0];
      iconProperties["y"] = iconImageSize[1] - (origin_1[1] + size[1]);
    }
    if (anchor && (anchor[0] !== size[0] / 2 || anchor[1] !== size[1] / 2)) {
      var hotSpot = {
        x: anchor[0],
        xunits: IconAnchorUnits.PIXELS,
        y: size[1] - anchor[1],
        yunits: IconAnchorUnits.PIXELS
      };
      properties["hotSpot"] = hotSpot;
    }
  }
  properties["Icon"] = iconProperties;
  var scale2 = style2.getScaleArray()[0];
  var imageSize = size;
  if (imageSize === null) {
    imageSize = DEFAULT_IMAGE_STYLE_SIZE;
  }
  if (imageSize.length == 2) {
    var resizeScale = scaleForSize(imageSize);
    scale2 = scale2 / resizeScale;
  }
  if (scale2 !== 1) {
    properties["scale"] = scale2;
  }
  var rotation = style2.getRotation();
  if (rotation !== 0) {
    properties["heading"] = rotation;
  }
  var color2 = style2.getColor();
  if (color2) {
    properties["color"] = color2;
  }
  var parentNode = objectStack[objectStack.length - 1].node;
  var orderedKeys = ICON_STYLE_SEQUENCE[parentNode.namespaceURI];
  var values2 = makeSequence(properties, orderedKeys);
  pushSerializeAndPop(context, ICON_STYLE_SERIALIZERS, OBJECT_PROPERTY_NODE_FACTORY, values2, objectStack, orderedKeys);
}
var LABEL_STYLE_SEQUENCE = makeStructureNS(NAMESPACE_URIS$3, [
  "color",
  "scale"
]);
var LABEL_STYLE_SERIALIZERS = makeStructureNS(NAMESPACE_URIS$3, {
  "color": makeChildAppender(writeColorTextNode),
  "scale": makeChildAppender(writeScaleTextNode)
});
function writeLabelStyle(node2, style2, objectStack) {
  var context = { node: node2 };
  var properties = {};
  var fill = style2.getFill();
  if (fill) {
    properties["color"] = fill.getColor();
  }
  var scale2 = style2.getScale();
  if (scale2 && scale2 !== 1) {
    properties["scale"] = scale2;
  }
  var parentNode = objectStack[objectStack.length - 1].node;
  var orderedKeys = LABEL_STYLE_SEQUENCE[parentNode.namespaceURI];
  var values2 = makeSequence(properties, orderedKeys);
  pushSerializeAndPop(context, LABEL_STYLE_SERIALIZERS, OBJECT_PROPERTY_NODE_FACTORY, values2, objectStack, orderedKeys);
}
var LINE_STYLE_SEQUENCE = makeStructureNS(NAMESPACE_URIS$3, ["color", "width"]);
var LINE_STYLE_SERIALIZERS = makeStructureNS(NAMESPACE_URIS$3, {
  "color": makeChildAppender(writeColorTextNode),
  "width": makeChildAppender(writeDecimalTextNode)
});
function writeLineStyle(node2, style2, objectStack) {
  var context = { node: node2 };
  var properties = {
    "color": style2.getColor(),
    "width": Number(style2.getWidth()) || 1
  };
  var parentNode = objectStack[objectStack.length - 1].node;
  var orderedKeys = LINE_STYLE_SEQUENCE[parentNode.namespaceURI];
  var values2 = makeSequence(properties, orderedKeys);
  pushSerializeAndPop(context, LINE_STYLE_SERIALIZERS, OBJECT_PROPERTY_NODE_FACTORY, values2, objectStack, orderedKeys);
}
var GEOMETRY_TYPE_TO_NODENAME = {
  "Point": "Point",
  "LineString": "LineString",
  "LinearRing": "LinearRing",
  "Polygon": "Polygon",
  "MultiPoint": "MultiGeometry",
  "MultiLineString": "MultiGeometry",
  "MultiPolygon": "MultiGeometry",
  "GeometryCollection": "MultiGeometry"
};
var GEOMETRY_NODE_FACTORY = function(value, objectStack, opt_nodeName) {
  if (value) {
    var parentNode = objectStack[objectStack.length - 1].node;
    return createElementNS(parentNode.namespaceURI, GEOMETRY_TYPE_TO_NODENAME[value.getType()]);
  }
};
var POINT_NODE_FACTORY = makeSimpleNodeFactory("Point");
var LINE_STRING_NODE_FACTORY = makeSimpleNodeFactory("LineString");
var LINEAR_RING_NODE_FACTORY = makeSimpleNodeFactory("LinearRing");
var POLYGON_NODE_FACTORY = makeSimpleNodeFactory("Polygon");
var MULTI_GEOMETRY_SERIALIZERS = makeStructureNS(NAMESPACE_URIS$3, {
  "LineString": makeChildAppender(writePrimitiveGeometry),
  "Point": makeChildAppender(writePrimitiveGeometry),
  "Polygon": makeChildAppender(writePolygon),
  "GeometryCollection": makeChildAppender(writeMultiGeometry)
});
function writeMultiGeometry(node2, geometry, objectStack) {
  var context = { node: node2 };
  var type = geometry.getType();
  var geometries = [];
  var factory;
  if (type === GeometryType.GEOMETRY_COLLECTION) {
    geometry.getGeometriesArrayRecursive().forEach(function(geometry2) {
      var type2 = geometry2.getType();
      if (type2 === GeometryType.MULTI_POINT) {
        geometries = geometries.concat(geometry2.getPoints());
      } else if (type2 === GeometryType.MULTI_LINE_STRING) {
        geometries = geometries.concat(geometry2.getLineStrings());
      } else if (type2 === GeometryType.MULTI_POLYGON) {
        geometries = geometries.concat(geometry2.getPolygons());
      } else if (type2 === GeometryType.POINT || type2 === GeometryType.LINE_STRING || type2 === GeometryType.POLYGON) {
        geometries.push(geometry2);
      } else {
        assert(false, 39);
      }
    });
    factory = GEOMETRY_NODE_FACTORY;
  } else if (type === GeometryType.MULTI_POINT) {
    geometries = geometry.getPoints();
    factory = POINT_NODE_FACTORY;
  } else if (type === GeometryType.MULTI_LINE_STRING) {
    geometries = geometry.getLineStrings();
    factory = LINE_STRING_NODE_FACTORY;
  } else if (type === GeometryType.MULTI_POLYGON) {
    geometries = geometry.getPolygons();
    factory = POLYGON_NODE_FACTORY;
  } else {
    assert(false, 39);
  }
  pushSerializeAndPop(context, MULTI_GEOMETRY_SERIALIZERS, factory, geometries, objectStack);
}
var BOUNDARY_IS_SERIALIZERS = makeStructureNS(NAMESPACE_URIS$3, {
  "LinearRing": makeChildAppender(writePrimitiveGeometry)
});
function writeBoundaryIs(node2, linearRing2, objectStack) {
  var context = { node: node2 };
  pushSerializeAndPop(context, BOUNDARY_IS_SERIALIZERS, LINEAR_RING_NODE_FACTORY, [linearRing2], objectStack);
}
var PLACEMARK_SERIALIZERS = makeStructureNS(NAMESPACE_URIS$3, {
  "ExtendedData": makeChildAppender(writeExtendedData),
  "MultiGeometry": makeChildAppender(writeMultiGeometry),
  "LineString": makeChildAppender(writePrimitiveGeometry),
  "LinearRing": makeChildAppender(writePrimitiveGeometry),
  "Point": makeChildAppender(writePrimitiveGeometry),
  "Polygon": makeChildAppender(writePolygon),
  "Style": makeChildAppender(writeStyle),
  "address": makeChildAppender(writeStringTextNode),
  "description": makeChildAppender(writeStringTextNode),
  "name": makeChildAppender(writeStringTextNode),
  "open": makeChildAppender(writeBooleanTextNode),
  "phoneNumber": makeChildAppender(writeStringTextNode),
  "styleUrl": makeChildAppender(writeStringTextNode),
  "visibility": makeChildAppender(writeBooleanTextNode)
});
var PLACEMARK_SEQUENCE = makeStructureNS(NAMESPACE_URIS$3, [
  "name",
  "open",
  "visibility",
  "address",
  "phoneNumber",
  "description",
  "styleUrl",
  "Style"
]);
var EXTENDEDDATA_NODE_FACTORY = makeSimpleNodeFactory("ExtendedData");
function writePlacemark(node2, feature2, objectStack) {
  var context = { node: node2 };
  if (feature2.getId()) {
    node2.setAttribute("id", feature2.getId());
  }
  var properties = feature2.getProperties();
  var filter = {
    "address": 1,
    "description": 1,
    "name": 1,
    "open": 1,
    "phoneNumber": 1,
    "styleUrl": 1,
    "visibility": 1
  };
  filter[feature2.getGeometryName()] = 1;
  var keys3 = Object.keys(properties || {}).sort().filter(function(v2) {
    return !filter[v2];
  });
  var styleFunction = feature2.getStyleFunction();
  if (styleFunction) {
    var styles = styleFunction(feature2, 0);
    if (styles) {
      var styleArray = Array.isArray(styles) ? styles : [styles];
      var pointStyles = styleArray;
      if (feature2.getGeometry()) {
        pointStyles = styleArray.filter(function(style2) {
          var geometry2 = style2.getGeometryFunction()(feature2);
          if (geometry2) {
            var type = geometry2.getType();
            if (type === GeometryType.GEOMETRY_COLLECTION) {
              return geometry2.getGeometriesArrayRecursive().filter(function(geometry3) {
                var type2 = geometry3.getType();
                return type2 === GeometryType.POINT || type2 === GeometryType.MULTI_POINT;
              }).length;
            }
            return type === GeometryType.POINT || type === GeometryType.MULTI_POINT;
          }
        });
      }
      if (this.writeStyles_) {
        var lineStyles = styleArray;
        var polyStyles = styleArray;
        if (feature2.getGeometry()) {
          lineStyles = styleArray.filter(function(style2) {
            var geometry2 = style2.getGeometryFunction()(feature2);
            if (geometry2) {
              var type = geometry2.getType();
              if (type === GeometryType.GEOMETRY_COLLECTION) {
                return geometry2.getGeometriesArrayRecursive().filter(function(geometry3) {
                  var type2 = geometry3.getType();
                  return type2 === GeometryType.LINE_STRING || type2 === GeometryType.MULTI_LINE_STRING;
                }).length;
              }
              return type === GeometryType.LINE_STRING || type === GeometryType.MULTI_LINE_STRING;
            }
          });
          polyStyles = styleArray.filter(function(style2) {
            var geometry2 = style2.getGeometryFunction()(feature2);
            if (geometry2) {
              var type = geometry2.getType();
              if (type === GeometryType.GEOMETRY_COLLECTION) {
                return geometry2.getGeometriesArrayRecursive().filter(function(geometry3) {
                  var type2 = geometry3.getType();
                  return type2 === GeometryType.POLYGON || type2 === GeometryType.MULTI_POLYGON;
                }).length;
              }
              return type === GeometryType.POLYGON || type === GeometryType.MULTI_POLYGON;
            }
          });
        }
        properties["Style"] = {
          pointStyles,
          lineStyles,
          polyStyles
        };
      }
      if (pointStyles.length && properties["name"] === void 0) {
        var textStyle = pointStyles[0].getText();
        if (textStyle) {
          properties["name"] = textStyle.getText();
        }
      }
    }
  }
  var parentNode = objectStack[objectStack.length - 1].node;
  var orderedKeys = PLACEMARK_SEQUENCE[parentNode.namespaceURI];
  var values2 = makeSequence(properties, orderedKeys);
  pushSerializeAndPop(context, PLACEMARK_SERIALIZERS, OBJECT_PROPERTY_NODE_FACTORY, values2, objectStack, orderedKeys);
  if (keys3.length > 0) {
    var sequence = makeSequence(properties, keys3);
    var namesAndValues = { names: keys3, values: sequence };
    pushSerializeAndPop(context, PLACEMARK_SERIALIZERS, EXTENDEDDATA_NODE_FACTORY, [namesAndValues], objectStack);
  }
  var options = objectStack[0];
  var geometry = feature2.getGeometry();
  if (geometry) {
    geometry = transformGeometryWithOptions(geometry, true, options);
  }
  pushSerializeAndPop(context, PLACEMARK_SERIALIZERS, GEOMETRY_NODE_FACTORY, [geometry], objectStack);
}
var PRIMITIVE_GEOMETRY_SEQUENCE = makeStructureNS(NAMESPACE_URIS$3, [
  "extrude",
  "tessellate",
  "altitudeMode",
  "coordinates"
]);
var PRIMITIVE_GEOMETRY_SERIALIZERS = makeStructureNS(NAMESPACE_URIS$3, {
  "extrude": makeChildAppender(writeBooleanTextNode),
  "tessellate": makeChildAppender(writeBooleanTextNode),
  "altitudeMode": makeChildAppender(writeStringTextNode),
  "coordinates": makeChildAppender(writeCoordinatesTextNode)
});
function writePrimitiveGeometry(node2, geometry, objectStack) {
  var flatCoordinates = geometry.getFlatCoordinates();
  var context = { node: node2 };
  context["layout"] = geometry.getLayout();
  context["stride"] = geometry.getStride();
  var properties = geometry.getProperties();
  properties.coordinates = flatCoordinates;
  var parentNode = objectStack[objectStack.length - 1].node;
  var orderedKeys = PRIMITIVE_GEOMETRY_SEQUENCE[parentNode.namespaceURI];
  var values2 = makeSequence(properties, orderedKeys);
  pushSerializeAndPop(context, PRIMITIVE_GEOMETRY_SERIALIZERS, OBJECT_PROPERTY_NODE_FACTORY, values2, objectStack, orderedKeys);
}
var POLY_STYLE_SEQUENCE = makeStructureNS(NAMESPACE_URIS$3, [
  "color",
  "fill",
  "outline"
]);
var POLYGON_SERIALIZERS = makeStructureNS(NAMESPACE_URIS$3, {
  "outerBoundaryIs": makeChildAppender(writeBoundaryIs),
  "innerBoundaryIs": makeChildAppender(writeBoundaryIs)
});
var INNER_BOUNDARY_NODE_FACTORY = makeSimpleNodeFactory("innerBoundaryIs");
var OUTER_BOUNDARY_NODE_FACTORY = makeSimpleNodeFactory("outerBoundaryIs");
function writePolygon(node2, polygon, objectStack) {
  var linearRings2 = polygon.getLinearRings();
  var outerRing = linearRings2.shift();
  var context = { node: node2 };
  pushSerializeAndPop(context, POLYGON_SERIALIZERS, INNER_BOUNDARY_NODE_FACTORY, linearRings2, objectStack);
  pushSerializeAndPop(context, POLYGON_SERIALIZERS, OUTER_BOUNDARY_NODE_FACTORY, [outerRing], objectStack);
}
var POLY_STYLE_SERIALIZERS = makeStructureNS(NAMESPACE_URIS$3, {
  "color": makeChildAppender(writeColorTextNode),
  "fill": makeChildAppender(writeBooleanTextNode),
  "outline": makeChildAppender(writeBooleanTextNode)
});
function writePolyStyle(node2, style2, objectStack) {
  var context = { node: node2 };
  var fill = style2.getFill();
  var stroke = style2.getStroke();
  var properties = {
    "color": fill ? fill.getColor() : void 0,
    "fill": fill ? void 0 : false,
    "outline": stroke ? void 0 : false
  };
  var parentNode = objectStack[objectStack.length - 1].node;
  var orderedKeys = POLY_STYLE_SEQUENCE[parentNode.namespaceURI];
  var values2 = makeSequence(properties, orderedKeys);
  pushSerializeAndPop(context, POLY_STYLE_SERIALIZERS, OBJECT_PROPERTY_NODE_FACTORY, values2, objectStack, orderedKeys);
}
function writeScaleTextNode(node2, scale2) {
  writeDecimalTextNode(node2, Math.round(scale2 * 1e6) / 1e6);
}
var STYLE_SEQUENCE = makeStructureNS(NAMESPACE_URIS$3, [
  "IconStyle",
  "LabelStyle",
  "LineStyle",
  "PolyStyle"
]);
var STYLE_SERIALIZERS = makeStructureNS(NAMESPACE_URIS$3, {
  "IconStyle": makeChildAppender(writeIconStyle),
  "LabelStyle": makeChildAppender(writeLabelStyle),
  "LineStyle": makeChildAppender(writeLineStyle),
  "PolyStyle": makeChildAppender(writePolyStyle)
});
function writeStyle(node2, styles, objectStack) {
  var context = { node: node2 };
  var properties = {};
  if (styles.pointStyles.length) {
    var textStyle = styles.pointStyles[0].getText();
    if (textStyle) {
      properties["LabelStyle"] = textStyle;
    }
    var imageStyle = styles.pointStyles[0].getImage();
    if (imageStyle && typeof imageStyle.getSrc === "function") {
      properties["IconStyle"] = imageStyle;
    }
  }
  if (styles.lineStyles.length) {
    var strokeStyle = styles.lineStyles[0].getStroke();
    if (strokeStyle) {
      properties["LineStyle"] = strokeStyle;
    }
  }
  if (styles.polyStyles.length) {
    var strokeStyle = styles.polyStyles[0].getStroke();
    if (strokeStyle && !properties["LineStyle"]) {
      properties["LineStyle"] = strokeStyle;
    }
    properties["PolyStyle"] = styles.polyStyles[0];
  }
  var parentNode = objectStack[objectStack.length - 1].node;
  var orderedKeys = STYLE_SEQUENCE[parentNode.namespaceURI];
  var values2 = makeSequence(properties, orderedKeys);
  pushSerializeAndPop(context, STYLE_SERIALIZERS, OBJECT_PROPERTY_NODE_FACTORY, values2, objectStack, orderedKeys);
}
function writeVec2(node2, vec2) {
  node2.setAttribute("x", String(vec2.x));
  node2.setAttribute("y", String(vec2.y));
  node2.setAttribute("xunits", vec2.xunits);
  node2.setAttribute("yunits", vec2.yunits);
}
var KML$1 = KML;
var ieee754$1 = {};
ieee754$1.read = function(buffer2, offset2, isLE, mLen, nBytes) {
  var e2, m2;
  var eLen = nBytes * 8 - mLen - 1;
  var eMax = (1 << eLen) - 1;
  var eBias = eMax >> 1;
  var nBits = -7;
  var i2 = isLE ? nBytes - 1 : 0;
  var d2 = isLE ? -1 : 1;
  var s2 = buffer2[offset2 + i2];
  i2 += d2;
  e2 = s2 & (1 << -nBits) - 1;
  s2 >>= -nBits;
  nBits += eLen;
  for (; nBits > 0; e2 = e2 * 256 + buffer2[offset2 + i2], i2 += d2, nBits -= 8) {
  }
  m2 = e2 & (1 << -nBits) - 1;
  e2 >>= -nBits;
  nBits += mLen;
  for (; nBits > 0; m2 = m2 * 256 + buffer2[offset2 + i2], i2 += d2, nBits -= 8) {
  }
  if (e2 === 0) {
    e2 = 1 - eBias;
  } else if (e2 === eMax) {
    return m2 ? NaN : (s2 ? -1 : 1) * Infinity;
  } else {
    m2 = m2 + Math.pow(2, mLen);
    e2 = e2 - eBias;
  }
  return (s2 ? -1 : 1) * m2 * Math.pow(2, e2 - mLen);
};
ieee754$1.write = function(buffer2, value, offset2, isLE, mLen, nBytes) {
  var e2, m2, c2;
  var eLen = nBytes * 8 - mLen - 1;
  var eMax = (1 << eLen) - 1;
  var eBias = eMax >> 1;
  var rt2 = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
  var i2 = isLE ? 0 : nBytes - 1;
  var d2 = isLE ? 1 : -1;
  var s2 = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
  value = Math.abs(value);
  if (isNaN(value) || value === Infinity) {
    m2 = isNaN(value) ? 1 : 0;
    e2 = eMax;
  } else {
    e2 = Math.floor(Math.log(value) / Math.LN2);
    if (value * (c2 = Math.pow(2, -e2)) < 1) {
      e2--;
      c2 *= 2;
    }
    if (e2 + eBias >= 1) {
      value += rt2 / c2;
    } else {
      value += rt2 * Math.pow(2, 1 - eBias);
    }
    if (value * c2 >= 2) {
      e2++;
      c2 /= 2;
    }
    if (e2 + eBias >= eMax) {
      m2 = 0;
      e2 = eMax;
    } else if (e2 + eBias >= 1) {
      m2 = (value * c2 - 1) * Math.pow(2, mLen);
      e2 = e2 + eBias;
    } else {
      m2 = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
      e2 = 0;
    }
  }
  for (; mLen >= 8; buffer2[offset2 + i2] = m2 & 255, i2 += d2, m2 /= 256, mLen -= 8) {
  }
  e2 = e2 << mLen | m2;
  eLen += mLen;
  for (; eLen > 0; buffer2[offset2 + i2] = e2 & 255, i2 += d2, e2 /= 256, eLen -= 8) {
  }
  buffer2[offset2 + i2 - d2] |= s2 * 128;
};
var pbf = Pbf;
var ieee754 = ieee754$1;
function Pbf(buf) {
  this.buf = ArrayBuffer.isView && ArrayBuffer.isView(buf) ? buf : new Uint8Array(buf || 0);
  this.pos = 0;
  this.type = 0;
  this.length = this.buf.length;
}
Pbf.Varint = 0;
Pbf.Fixed64 = 1;
Pbf.Bytes = 2;
Pbf.Fixed32 = 5;
var SHIFT_LEFT_32 = (1 << 16) * (1 << 16);
var SHIFT_RIGHT_32 = 1 / SHIFT_LEFT_32;
var TEXT_DECODER_MIN_LENGTH = 12;
var utf8TextDecoder = typeof TextDecoder === "undefined" ? null : new TextDecoder("utf8");
Pbf.prototype = {
  destroy: function() {
    this.buf = null;
  },
  readFields: function(readField, result, end) {
    end = end || this.length;
    while (this.pos < end) {
      var val = this.readVarint(), tag = val >> 3, startPos = this.pos;
      this.type = val & 7;
      readField(tag, result, this);
      if (this.pos === startPos)
        this.skip(val);
    }
    return result;
  },
  readMessage: function(readField, result) {
    return this.readFields(readField, result, this.readVarint() + this.pos);
  },
  readFixed32: function() {
    var val = readUInt32(this.buf, this.pos);
    this.pos += 4;
    return val;
  },
  readSFixed32: function() {
    var val = readInt32(this.buf, this.pos);
    this.pos += 4;
    return val;
  },
  readFixed64: function() {
    var val = readUInt32(this.buf, this.pos) + readUInt32(this.buf, this.pos + 4) * SHIFT_LEFT_32;
    this.pos += 8;
    return val;
  },
  readSFixed64: function() {
    var val = readUInt32(this.buf, this.pos) + readInt32(this.buf, this.pos + 4) * SHIFT_LEFT_32;
    this.pos += 8;
    return val;
  },
  readFloat: function() {
    var val = ieee754.read(this.buf, this.pos, true, 23, 4);
    this.pos += 4;
    return val;
  },
  readDouble: function() {
    var val = ieee754.read(this.buf, this.pos, true, 52, 8);
    this.pos += 8;
    return val;
  },
  readVarint: function(isSigned) {
    var buf = this.buf, val, b2;
    b2 = buf[this.pos++];
    val = b2 & 127;
    if (b2 < 128)
      return val;
    b2 = buf[this.pos++];
    val |= (b2 & 127) << 7;
    if (b2 < 128)
      return val;
    b2 = buf[this.pos++];
    val |= (b2 & 127) << 14;
    if (b2 < 128)
      return val;
    b2 = buf[this.pos++];
    val |= (b2 & 127) << 21;
    if (b2 < 128)
      return val;
    b2 = buf[this.pos];
    val |= (b2 & 15) << 28;
    return readVarintRemainder(val, isSigned, this);
  },
  readVarint64: function() {
    return this.readVarint(true);
  },
  readSVarint: function() {
    var num = this.readVarint();
    return num % 2 === 1 ? (num + 1) / -2 : num / 2;
  },
  readBoolean: function() {
    return Boolean(this.readVarint());
  },
  readString: function() {
    var end = this.readVarint() + this.pos;
    var pos = this.pos;
    this.pos = end;
    if (end - pos >= TEXT_DECODER_MIN_LENGTH && utf8TextDecoder) {
      return readUtf8TextDecoder(this.buf, pos, end);
    }
    return readUtf8(this.buf, pos, end);
  },
  readBytes: function() {
    var end = this.readVarint() + this.pos, buffer2 = this.buf.subarray(this.pos, end);
    this.pos = end;
    return buffer2;
  },
  readPackedVarint: function(arr, isSigned) {
    if (this.type !== Pbf.Bytes)
      return arr.push(this.readVarint(isSigned));
    var end = readPackedEnd(this);
    arr = arr || [];
    while (this.pos < end)
      arr.push(this.readVarint(isSigned));
    return arr;
  },
  readPackedSVarint: function(arr) {
    if (this.type !== Pbf.Bytes)
      return arr.push(this.readSVarint());
    var end = readPackedEnd(this);
    arr = arr || [];
    while (this.pos < end)
      arr.push(this.readSVarint());
    return arr;
  },
  readPackedBoolean: function(arr) {
    if (this.type !== Pbf.Bytes)
      return arr.push(this.readBoolean());
    var end = readPackedEnd(this);
    arr = arr || [];
    while (this.pos < end)
      arr.push(this.readBoolean());
    return arr;
  },
  readPackedFloat: function(arr) {
    if (this.type !== Pbf.Bytes)
      return arr.push(this.readFloat());
    var end = readPackedEnd(this);
    arr = arr || [];
    while (this.pos < end)
      arr.push(this.readFloat());
    return arr;
  },
  readPackedDouble: function(arr) {
    if (this.type !== Pbf.Bytes)
      return arr.push(this.readDouble());
    var end = readPackedEnd(this);
    arr = arr || [];
    while (this.pos < end)
      arr.push(this.readDouble());
    return arr;
  },
  readPackedFixed32: function(arr) {
    if (this.type !== Pbf.Bytes)
      return arr.push(this.readFixed32());
    var end = readPackedEnd(this);
    arr = arr || [];
    while (this.pos < end)
      arr.push(this.readFixed32());
    return arr;
  },
  readPackedSFixed32: function(arr) {
    if (this.type !== Pbf.Bytes)
      return arr.push(this.readSFixed32());
    var end = readPackedEnd(this);
    arr = arr || [];
    while (this.pos < end)
      arr.push(this.readSFixed32());
    return arr;
  },
  readPackedFixed64: function(arr) {
    if (this.type !== Pbf.Bytes)
      return arr.push(this.readFixed64());
    var end = readPackedEnd(this);
    arr = arr || [];
    while (this.pos < end)
      arr.push(this.readFixed64());
    return arr;
  },
  readPackedSFixed64: function(arr) {
    if (this.type !== Pbf.Bytes)
      return arr.push(this.readSFixed64());
    var end = readPackedEnd(this);
    arr = arr || [];
    while (this.pos < end)
      arr.push(this.readSFixed64());
    return arr;
  },
  skip: function(val) {
    var type = val & 7;
    if (type === Pbf.Varint)
      while (this.buf[this.pos++] > 127) {
      }
    else if (type === Pbf.Bytes)
      this.pos = this.readVarint() + this.pos;
    else if (type === Pbf.Fixed32)
      this.pos += 4;
    else if (type === Pbf.Fixed64)
      this.pos += 8;
    else
      throw new Error("Unimplemented type: " + type);
  },
  writeTag: function(tag, type) {
    this.writeVarint(tag << 3 | type);
  },
  realloc: function(min2) {
    var length = this.length || 16;
    while (length < this.pos + min2)
      length *= 2;
    if (length !== this.length) {
      var buf = new Uint8Array(length);
      buf.set(this.buf);
      this.buf = buf;
      this.length = length;
    }
  },
  finish: function() {
    this.length = this.pos;
    this.pos = 0;
    return this.buf.subarray(0, this.length);
  },
  writeFixed32: function(val) {
    this.realloc(4);
    writeInt32(this.buf, val, this.pos);
    this.pos += 4;
  },
  writeSFixed32: function(val) {
    this.realloc(4);
    writeInt32(this.buf, val, this.pos);
    this.pos += 4;
  },
  writeFixed64: function(val) {
    this.realloc(8);
    writeInt32(this.buf, val & -1, this.pos);
    writeInt32(this.buf, Math.floor(val * SHIFT_RIGHT_32), this.pos + 4);
    this.pos += 8;
  },
  writeSFixed64: function(val) {
    this.realloc(8);
    writeInt32(this.buf, val & -1, this.pos);
    writeInt32(this.buf, Math.floor(val * SHIFT_RIGHT_32), this.pos + 4);
    this.pos += 8;
  },
  writeVarint: function(val) {
    val = +val || 0;
    if (val > 268435455 || val < 0) {
      writeBigVarint(val, this);
      return;
    }
    this.realloc(4);
    this.buf[this.pos++] = val & 127 | (val > 127 ? 128 : 0);
    if (val <= 127)
      return;
    this.buf[this.pos++] = (val >>>= 7) & 127 | (val > 127 ? 128 : 0);
    if (val <= 127)
      return;
    this.buf[this.pos++] = (val >>>= 7) & 127 | (val > 127 ? 128 : 0);
    if (val <= 127)
      return;
    this.buf[this.pos++] = val >>> 7 & 127;
  },
  writeSVarint: function(val) {
    this.writeVarint(val < 0 ? -val * 2 - 1 : val * 2);
  },
  writeBoolean: function(val) {
    this.writeVarint(Boolean(val));
  },
  writeString: function(str) {
    str = String(str);
    this.realloc(str.length * 4);
    this.pos++;
    var startPos = this.pos;
    this.pos = writeUtf8(this.buf, str, this.pos);
    var len = this.pos - startPos;
    if (len >= 128)
      makeRoomForExtraLength(startPos, len, this);
    this.pos = startPos - 1;
    this.writeVarint(len);
    this.pos += len;
  },
  writeFloat: function(val) {
    this.realloc(4);
    ieee754.write(this.buf, val, this.pos, true, 23, 4);
    this.pos += 4;
  },
  writeDouble: function(val) {
    this.realloc(8);
    ieee754.write(this.buf, val, this.pos, true, 52, 8);
    this.pos += 8;
  },
  writeBytes: function(buffer2) {
    var len = buffer2.length;
    this.writeVarint(len);
    this.realloc(len);
    for (var i2 = 0; i2 < len; i2++)
      this.buf[this.pos++] = buffer2[i2];
  },
  writeRawMessage: function(fn, obj) {
    this.pos++;
    var startPos = this.pos;
    fn(obj, this);
    var len = this.pos - startPos;
    if (len >= 128)
      makeRoomForExtraLength(startPos, len, this);
    this.pos = startPos - 1;
    this.writeVarint(len);
    this.pos += len;
  },
  writeMessage: function(tag, fn, obj) {
    this.writeTag(tag, Pbf.Bytes);
    this.writeRawMessage(fn, obj);
  },
  writePackedVarint: function(tag, arr) {
    if (arr.length)
      this.writeMessage(tag, writePackedVarint, arr);
  },
  writePackedSVarint: function(tag, arr) {
    if (arr.length)
      this.writeMessage(tag, writePackedSVarint, arr);
  },
  writePackedBoolean: function(tag, arr) {
    if (arr.length)
      this.writeMessage(tag, writePackedBoolean, arr);
  },
  writePackedFloat: function(tag, arr) {
    if (arr.length)
      this.writeMessage(tag, writePackedFloat, arr);
  },
  writePackedDouble: function(tag, arr) {
    if (arr.length)
      this.writeMessage(tag, writePackedDouble, arr);
  },
  writePackedFixed32: function(tag, arr) {
    if (arr.length)
      this.writeMessage(tag, writePackedFixed32, arr);
  },
  writePackedSFixed32: function(tag, arr) {
    if (arr.length)
      this.writeMessage(tag, writePackedSFixed32, arr);
  },
  writePackedFixed64: function(tag, arr) {
    if (arr.length)
      this.writeMessage(tag, writePackedFixed64, arr);
  },
  writePackedSFixed64: function(tag, arr) {
    if (arr.length)
      this.writeMessage(tag, writePackedSFixed64, arr);
  },
  writeBytesField: function(tag, buffer2) {
    this.writeTag(tag, Pbf.Bytes);
    this.writeBytes(buffer2);
  },
  writeFixed32Field: function(tag, val) {
    this.writeTag(tag, Pbf.Fixed32);
    this.writeFixed32(val);
  },
  writeSFixed32Field: function(tag, val) {
    this.writeTag(tag, Pbf.Fixed32);
    this.writeSFixed32(val);
  },
  writeFixed64Field: function(tag, val) {
    this.writeTag(tag, Pbf.Fixed64);
    this.writeFixed64(val);
  },
  writeSFixed64Field: function(tag, val) {
    this.writeTag(tag, Pbf.Fixed64);
    this.writeSFixed64(val);
  },
  writeVarintField: function(tag, val) {
    this.writeTag(tag, Pbf.Varint);
    this.writeVarint(val);
  },
  writeSVarintField: function(tag, val) {
    this.writeTag(tag, Pbf.Varint);
    this.writeSVarint(val);
  },
  writeStringField: function(tag, str) {
    this.writeTag(tag, Pbf.Bytes);
    this.writeString(str);
  },
  writeFloatField: function(tag, val) {
    this.writeTag(tag, Pbf.Fixed32);
    this.writeFloat(val);
  },
  writeDoubleField: function(tag, val) {
    this.writeTag(tag, Pbf.Fixed64);
    this.writeDouble(val);
  },
  writeBooleanField: function(tag, val) {
    this.writeVarintField(tag, Boolean(val));
  }
};
function readVarintRemainder(l2, s2, p5) {
  var buf = p5.buf, h2, b2;
  b2 = buf[p5.pos++];
  h2 = (b2 & 112) >> 4;
  if (b2 < 128)
    return toNum(l2, h2, s2);
  b2 = buf[p5.pos++];
  h2 |= (b2 & 127) << 3;
  if (b2 < 128)
    return toNum(l2, h2, s2);
  b2 = buf[p5.pos++];
  h2 |= (b2 & 127) << 10;
  if (b2 < 128)
    return toNum(l2, h2, s2);
  b2 = buf[p5.pos++];
  h2 |= (b2 & 127) << 17;
  if (b2 < 128)
    return toNum(l2, h2, s2);
  b2 = buf[p5.pos++];
  h2 |= (b2 & 127) << 24;
  if (b2 < 128)
    return toNum(l2, h2, s2);
  b2 = buf[p5.pos++];
  h2 |= (b2 & 1) << 31;
  if (b2 < 128)
    return toNum(l2, h2, s2);
  throw new Error("Expected varint not more than 10 bytes");
}
function readPackedEnd(pbf2) {
  return pbf2.type === Pbf.Bytes ? pbf2.readVarint() + pbf2.pos : pbf2.pos + 1;
}
function toNum(low, high, isSigned) {
  if (isSigned) {
    return high * 4294967296 + (low >>> 0);
  }
  return (high >>> 0) * 4294967296 + (low >>> 0);
}
function writeBigVarint(val, pbf2) {
  var low, high;
  if (val >= 0) {
    low = val % 4294967296 | 0;
    high = val / 4294967296 | 0;
  } else {
    low = ~(-val % 4294967296);
    high = ~(-val / 4294967296);
    if (low ^ 4294967295) {
      low = low + 1 | 0;
    } else {
      low = 0;
      high = high + 1 | 0;
    }
  }
  if (val >= 18446744073709552e3 || val < -18446744073709552e3) {
    throw new Error("Given varint doesn't fit into 10 bytes");
  }
  pbf2.realloc(10);
  writeBigVarintLow(low, high, pbf2);
  writeBigVarintHigh(high, pbf2);
}
function writeBigVarintLow(low, high, pbf2) {
  pbf2.buf[pbf2.pos++] = low & 127 | 128;
  low >>>= 7;
  pbf2.buf[pbf2.pos++] = low & 127 | 128;
  low >>>= 7;
  pbf2.buf[pbf2.pos++] = low & 127 | 128;
  low >>>= 7;
  pbf2.buf[pbf2.pos++] = low & 127 | 128;
  low >>>= 7;
  pbf2.buf[pbf2.pos] = low & 127;
}
function writeBigVarintHigh(high, pbf2) {
  var lsb = (high & 7) << 4;
  pbf2.buf[pbf2.pos++] |= lsb | ((high >>>= 3) ? 128 : 0);
  if (!high)
    return;
  pbf2.buf[pbf2.pos++] = high & 127 | ((high >>>= 7) ? 128 : 0);
  if (!high)
    return;
  pbf2.buf[pbf2.pos++] = high & 127 | ((high >>>= 7) ? 128 : 0);
  if (!high)
    return;
  pbf2.buf[pbf2.pos++] = high & 127 | ((high >>>= 7) ? 128 : 0);
  if (!high)
    return;
  pbf2.buf[pbf2.pos++] = high & 127 | ((high >>>= 7) ? 128 : 0);
  if (!high)
    return;
  pbf2.buf[pbf2.pos++] = high & 127;
}
function makeRoomForExtraLength(startPos, len, pbf2) {
  var extraLen = len <= 16383 ? 1 : len <= 2097151 ? 2 : len <= 268435455 ? 3 : Math.floor(Math.log(len) / (Math.LN2 * 7));
  pbf2.realloc(extraLen);
  for (var i2 = pbf2.pos - 1; i2 >= startPos; i2--)
    pbf2.buf[i2 + extraLen] = pbf2.buf[i2];
}
function writePackedVarint(arr, pbf2) {
  for (var i2 = 0; i2 < arr.length; i2++)
    pbf2.writeVarint(arr[i2]);
}
function writePackedSVarint(arr, pbf2) {
  for (var i2 = 0; i2 < arr.length; i2++)
    pbf2.writeSVarint(arr[i2]);
}
function writePackedFloat(arr, pbf2) {
  for (var i2 = 0; i2 < arr.length; i2++)
    pbf2.writeFloat(arr[i2]);
}
function writePackedDouble(arr, pbf2) {
  for (var i2 = 0; i2 < arr.length; i2++)
    pbf2.writeDouble(arr[i2]);
}
function writePackedBoolean(arr, pbf2) {
  for (var i2 = 0; i2 < arr.length; i2++)
    pbf2.writeBoolean(arr[i2]);
}
function writePackedFixed32(arr, pbf2) {
  for (var i2 = 0; i2 < arr.length; i2++)
    pbf2.writeFixed32(arr[i2]);
}
function writePackedSFixed32(arr, pbf2) {
  for (var i2 = 0; i2 < arr.length; i2++)
    pbf2.writeSFixed32(arr[i2]);
}
function writePackedFixed64(arr, pbf2) {
  for (var i2 = 0; i2 < arr.length; i2++)
    pbf2.writeFixed64(arr[i2]);
}
function writePackedSFixed64(arr, pbf2) {
  for (var i2 = 0; i2 < arr.length; i2++)
    pbf2.writeSFixed64(arr[i2]);
}
function readUInt32(buf, pos) {
  return (buf[pos] | buf[pos + 1] << 8 | buf[pos + 2] << 16) + buf[pos + 3] * 16777216;
}
function writeInt32(buf, val, pos) {
  buf[pos] = val;
  buf[pos + 1] = val >>> 8;
  buf[pos + 2] = val >>> 16;
  buf[pos + 3] = val >>> 24;
}
function readInt32(buf, pos) {
  return (buf[pos] | buf[pos + 1] << 8 | buf[pos + 2] << 16) + (buf[pos + 3] << 24);
}
function readUtf8(buf, pos, end) {
  var str = "";
  var i2 = pos;
  while (i2 < end) {
    var b0 = buf[i2];
    var c2 = null;
    var bytesPerSequence = b0 > 239 ? 4 : b0 > 223 ? 3 : b0 > 191 ? 2 : 1;
    if (i2 + bytesPerSequence > end)
      break;
    var b1, b2, b3;
    if (bytesPerSequence === 1) {
      if (b0 < 128) {
        c2 = b0;
      }
    } else if (bytesPerSequence === 2) {
      b1 = buf[i2 + 1];
      if ((b1 & 192) === 128) {
        c2 = (b0 & 31) << 6 | b1 & 63;
        if (c2 <= 127) {
          c2 = null;
        }
      }
    } else if (bytesPerSequence === 3) {
      b1 = buf[i2 + 1];
      b2 = buf[i2 + 2];
      if ((b1 & 192) === 128 && (b2 & 192) === 128) {
        c2 = (b0 & 15) << 12 | (b1 & 63) << 6 | b2 & 63;
        if (c2 <= 2047 || c2 >= 55296 && c2 <= 57343) {
          c2 = null;
        }
      }
    } else if (bytesPerSequence === 4) {
      b1 = buf[i2 + 1];
      b2 = buf[i2 + 2];
      b3 = buf[i2 + 3];
      if ((b1 & 192) === 128 && (b2 & 192) === 128 && (b3 & 192) === 128) {
        c2 = (b0 & 15) << 18 | (b1 & 63) << 12 | (b2 & 63) << 6 | b3 & 63;
        if (c2 <= 65535 || c2 >= 1114112) {
          c2 = null;
        }
      }
    }
    if (c2 === null) {
      c2 = 65533;
      bytesPerSequence = 1;
    } else if (c2 > 65535) {
      c2 -= 65536;
      str += String.fromCharCode(c2 >>> 10 & 1023 | 55296);
      c2 = 56320 | c2 & 1023;
    }
    str += String.fromCharCode(c2);
    i2 += bytesPerSequence;
  }
  return str;
}
function readUtf8TextDecoder(buf, pos, end) {
  return utf8TextDecoder.decode(buf.subarray(pos, end));
}
function writeUtf8(buf, str, pos) {
  for (var i2 = 0, c2, lead; i2 < str.length; i2++) {
    c2 = str.charCodeAt(i2);
    if (c2 > 55295 && c2 < 57344) {
      if (lead) {
        if (c2 < 56320) {
          buf[pos++] = 239;
          buf[pos++] = 191;
          buf[pos++] = 189;
          lead = c2;
          continue;
        } else {
          c2 = lead - 55296 << 10 | c2 - 56320 | 65536;
          lead = null;
        }
      } else {
        if (c2 > 56319 || i2 + 1 === str.length) {
          buf[pos++] = 239;
          buf[pos++] = 191;
          buf[pos++] = 189;
        } else {
          lead = c2;
        }
        continue;
      }
    } else if (lead) {
      buf[pos++] = 239;
      buf[pos++] = 191;
      buf[pos++] = 189;
      lead = null;
    }
    if (c2 < 128) {
      buf[pos++] = c2;
    } else {
      if (c2 < 2048) {
        buf[pos++] = c2 >> 6 | 192;
      } else {
        if (c2 < 65536) {
          buf[pos++] = c2 >> 12 | 224;
        } else {
          buf[pos++] = c2 >> 18 | 240;
          buf[pos++] = c2 >> 12 & 63 | 128;
        }
        buf[pos++] = c2 >> 6 & 63 | 128;
      }
      buf[pos++] = c2 & 63 | 128;
    }
  }
  return pos;
}
var tmpTransform = create$6();
var RenderFeature = function() {
  function RenderFeature2(type, flatCoordinates, ends, properties, id) {
    this.styleFunction;
    this.extent_;
    this.id_ = id;
    this.type_ = type;
    this.flatCoordinates_ = flatCoordinates;
    this.flatInteriorPoints_ = null;
    this.flatMidpoints_ = null;
    this.ends_ = ends;
    this.properties_ = properties;
  }
  RenderFeature2.prototype.get = function(key) {
    return this.properties_[key];
  };
  RenderFeature2.prototype.getExtent = function() {
    if (!this.extent_) {
      this.extent_ = this.type_ === GeometryType.POINT ? createOrUpdateFromCoordinate(this.flatCoordinates_) : createOrUpdateFromFlatCoordinates(this.flatCoordinates_, 0, this.flatCoordinates_.length, 2);
    }
    return this.extent_;
  };
  RenderFeature2.prototype.getFlatInteriorPoint = function() {
    if (!this.flatInteriorPoints_) {
      var flatCenter = getCenter(this.getExtent());
      this.flatInteriorPoints_ = getInteriorPointOfArray(this.flatCoordinates_, 0, this.ends_, 2, flatCenter, 0);
    }
    return this.flatInteriorPoints_;
  };
  RenderFeature2.prototype.getFlatInteriorPoints = function() {
    if (!this.flatInteriorPoints_) {
      var flatCenters = linearRingss(this.flatCoordinates_, 0, this.ends_, 2);
      this.flatInteriorPoints_ = getInteriorPointsOfMultiArray(this.flatCoordinates_, 0, this.ends_, 2, flatCenters);
    }
    return this.flatInteriorPoints_;
  };
  RenderFeature2.prototype.getFlatMidpoint = function() {
    if (!this.flatMidpoints_) {
      this.flatMidpoints_ = interpolatePoint(this.flatCoordinates_, 0, this.flatCoordinates_.length, 2, 0.5);
    }
    return this.flatMidpoints_;
  };
  RenderFeature2.prototype.getFlatMidpoints = function() {
    if (!this.flatMidpoints_) {
      this.flatMidpoints_ = [];
      var flatCoordinates = this.flatCoordinates_;
      var offset2 = 0;
      var ends = this.ends_;
      for (var i2 = 0, ii = ends.length; i2 < ii; ++i2) {
        var end = ends[i2];
        var midpoint = interpolatePoint(flatCoordinates, offset2, end, 2, 0.5);
        extend$3(this.flatMidpoints_, midpoint);
        offset2 = end;
      }
    }
    return this.flatMidpoints_;
  };
  RenderFeature2.prototype.getId = function() {
    return this.id_;
  };
  RenderFeature2.prototype.getOrientedFlatCoordinates = function() {
    return this.flatCoordinates_;
  };
  RenderFeature2.prototype.getGeometry = function() {
    return this;
  };
  RenderFeature2.prototype.getSimplifiedGeometry = function(squaredTolerance) {
    return this;
  };
  RenderFeature2.prototype.simplifyTransformed = function(squaredTolerance, opt_transform) {
    return this;
  };
  RenderFeature2.prototype.getProperties = function() {
    return this.properties_;
  };
  RenderFeature2.prototype.getStride = function() {
    return 2;
  };
  RenderFeature2.prototype.getStyleFunction = function() {
    return this.styleFunction;
  };
  RenderFeature2.prototype.getType = function() {
    return this.type_;
  };
  RenderFeature2.prototype.transform = function(projection) {
    projection = get$3(projection);
    var pixelExtent = projection.getExtent();
    var projectedExtent = projection.getWorldExtent();
    if (pixelExtent && projectedExtent) {
      var scale2 = getHeight(projectedExtent) / getHeight(pixelExtent);
      compose(tmpTransform, projectedExtent[0], projectedExtent[3], scale2, -scale2, 0, 0, 0);
      transform2D(this.flatCoordinates_, 0, this.flatCoordinates_.length, 2, tmpTransform, this.flatCoordinates_);
    }
  };
  RenderFeature2.prototype.getEnds = function() {
    return this.ends_;
  };
  return RenderFeature2;
}();
RenderFeature.prototype.getEndss = RenderFeature.prototype.getEnds;
RenderFeature.prototype.getFlatCoordinates = RenderFeature.prototype.getOrientedFlatCoordinates;
var RenderFeature$1 = RenderFeature;
var __extends$e = globalThis && globalThis.__extends || function() {
  var extendStatics2 = function(d2, b2) {
    extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {
      d3.__proto__ = b3;
    } || function(d3, b3) {
      for (var p5 in b3)
        if (Object.prototype.hasOwnProperty.call(b3, p5))
          d3[p5] = b3[p5];
    };
    return extendStatics2(d2, b2);
  };
  return function(d2, b2) {
    if (typeof b2 !== "function" && b2 !== null)
      throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
    extendStatics2(d2, b2);
    function __() {
      this.constructor = d2;
    }
    d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
  };
}();
var MVT = function(_super) {
  __extends$e(MVT2, _super);
  function MVT2(opt_options) {
    var _this = _super.call(this) || this;
    var options = opt_options ? opt_options : {};
    _this.dataProjection = new Projection$3({
      code: "",
      units: Units$2.TILE_PIXELS
    });
    _this.featureClass_ = options.featureClass ? options.featureClass : RenderFeature$1;
    _this.geometryName_ = options.geometryName;
    _this.layerName_ = options.layerName ? options.layerName : "layer";
    _this.layers_ = options.layers ? options.layers : null;
    _this.idProperty_ = options.idProperty;
    _this.supportedMediaTypes = [
      "application/vnd.mapbox-vector-tile",
      "application/x-protobuf"
    ];
    return _this;
  }
  MVT2.prototype.readRawGeometry_ = function(pbf2, feature2, flatCoordinates, ends) {
    pbf2.pos = feature2.geometry;
    var end = pbf2.readVarint() + pbf2.pos;
    var cmd = 1;
    var length = 0;
    var x2 = 0;
    var y2 = 0;
    var coordsLen = 0;
    var currentEnd = 0;
    while (pbf2.pos < end) {
      if (!length) {
        var cmdLen = pbf2.readVarint();
        cmd = cmdLen & 7;
        length = cmdLen >> 3;
      }
      length--;
      if (cmd === 1 || cmd === 2) {
        x2 += pbf2.readSVarint();
        y2 += pbf2.readSVarint();
        if (cmd === 1) {
          if (coordsLen > currentEnd) {
            ends.push(coordsLen);
            currentEnd = coordsLen;
          }
        }
        flatCoordinates.push(x2, y2);
        coordsLen += 2;
      } else if (cmd === 7) {
        if (coordsLen > currentEnd) {
          flatCoordinates.push(flatCoordinates[currentEnd], flatCoordinates[currentEnd + 1]);
          coordsLen += 2;
        }
      } else {
        assert(false, 59);
      }
    }
    if (coordsLen > currentEnd) {
      ends.push(coordsLen);
      currentEnd = coordsLen;
    }
  };
  MVT2.prototype.createFeature_ = function(pbf2, rawFeature, options) {
    var type = rawFeature.type;
    if (type === 0) {
      return null;
    }
    var feature2;
    var values2 = rawFeature.properties;
    var id;
    if (!this.idProperty_) {
      id = rawFeature.id;
    } else {
      id = values2[this.idProperty_];
      delete values2[this.idProperty_];
    }
    values2[this.layerName_] = rawFeature.layer.name;
    var flatCoordinates = [];
    var ends = [];
    this.readRawGeometry_(pbf2, rawFeature, flatCoordinates, ends);
    var geometryType = getGeometryType(type, ends.length);
    if (this.featureClass_ === RenderFeature$1) {
      feature2 = new this.featureClass_(geometryType, flatCoordinates, ends, values2, id);
      feature2.transform(options.dataProjection);
    } else {
      var geom2 = void 0;
      if (geometryType == GeometryType.POLYGON) {
        var endss = inflateEnds(flatCoordinates, ends);
        geom2 = endss.length > 1 ? new MultiPolygon$2(flatCoordinates, GeometryLayout.XY, endss) : new Polygon$2(flatCoordinates, GeometryLayout.XY, ends);
      } else {
        geom2 = geometryType === GeometryType.POINT ? new Point$4(flatCoordinates, GeometryLayout.XY) : geometryType === GeometryType.LINE_STRING ? new LineString$2(flatCoordinates, GeometryLayout.XY) : geometryType === GeometryType.POLYGON ? new Polygon$2(flatCoordinates, GeometryLayout.XY, ends) : geometryType === GeometryType.MULTI_POINT ? new MultiPoint$2(flatCoordinates, GeometryLayout.XY) : geometryType === GeometryType.MULTI_LINE_STRING ? new MultiLineString$2(flatCoordinates, GeometryLayout.XY, ends) : null;
      }
      var ctor = this.featureClass_;
      feature2 = new ctor();
      if (this.geometryName_) {
        feature2.setGeometryName(this.geometryName_);
      }
      var geometry = transformGeometryWithOptions(geom2, false, options);
      feature2.setGeometry(geometry);
      if (id !== void 0) {
        feature2.setId(id);
      }
      feature2.setProperties(values2, true);
    }
    return feature2;
  };
  MVT2.prototype.getType = function() {
    return FormatType.ARRAY_BUFFER;
  };
  MVT2.prototype.readFeatures = function(source, opt_options) {
    var layers = this.layers_;
    var options = this.adaptOptions(opt_options);
    var dataProjection = get$3(options.dataProjection);
    dataProjection.setWorldExtent(options.extent);
    options.dataProjection = dataProjection;
    var pbf$1 = new pbf(source);
    var pbfLayers = pbf$1.readFields(layersPBFReader, {});
    var features = [];
    for (var name_1 in pbfLayers) {
      if (layers && layers.indexOf(name_1) == -1) {
        continue;
      }
      var pbfLayer = pbfLayers[name_1];
      var extent2 = pbfLayer ? [0, 0, pbfLayer.extent, pbfLayer.extent] : null;
      dataProjection.setExtent(extent2);
      for (var i2 = 0, ii = pbfLayer.length; i2 < ii; ++i2) {
        var rawFeature = readRawFeature(pbf$1, pbfLayer, i2);
        var feature2 = this.createFeature_(pbf$1, rawFeature, options);
        if (feature2 !== null) {
          features.push(feature2);
        }
      }
    }
    return features;
  };
  MVT2.prototype.readProjection = function(source) {
    return this.dataProjection;
  };
  MVT2.prototype.setLayers = function(layers) {
    this.layers_ = layers;
  };
  return MVT2;
}(FeatureFormat$1);
function layersPBFReader(tag, layers, pbf2) {
  if (tag === 3) {
    var layer = {
      keys: [],
      values: [],
      features: []
    };
    var end = pbf2.readVarint() + pbf2.pos;
    pbf2.readFields(layerPBFReader, layer, end);
    layer.length = layer.features.length;
    if (layer.length) {
      layers[layer.name] = layer;
    }
  }
}
function layerPBFReader(tag, layer, pbf2) {
  if (tag === 15) {
    layer.version = pbf2.readVarint();
  } else if (tag === 1) {
    layer.name = pbf2.readString();
  } else if (tag === 5) {
    layer.extent = pbf2.readVarint();
  } else if (tag === 2) {
    layer.features.push(pbf2.pos);
  } else if (tag === 3) {
    layer.keys.push(pbf2.readString());
  } else if (tag === 4) {
    var value = null;
    var end = pbf2.readVarint() + pbf2.pos;
    while (pbf2.pos < end) {
      tag = pbf2.readVarint() >> 3;
      value = tag === 1 ? pbf2.readString() : tag === 2 ? pbf2.readFloat() : tag === 3 ? pbf2.readDouble() : tag === 4 ? pbf2.readVarint64() : tag === 5 ? pbf2.readVarint() : tag === 6 ? pbf2.readSVarint() : tag === 7 ? pbf2.readBoolean() : null;
    }
    layer.values.push(value);
  }
}
function featurePBFReader(tag, feature2, pbf2) {
  if (tag == 1) {
    feature2.id = pbf2.readVarint();
  } else if (tag == 2) {
    var end = pbf2.readVarint() + pbf2.pos;
    while (pbf2.pos < end) {
      var key = feature2.layer.keys[pbf2.readVarint()];
      var value = feature2.layer.values[pbf2.readVarint()];
      feature2.properties[key] = value;
    }
  } else if (tag == 3) {
    feature2.type = pbf2.readVarint();
  } else if (tag == 4) {
    feature2.geometry = pbf2.pos;
  }
}
function readRawFeature(pbf2, layer, i2) {
  pbf2.pos = layer.features[i2];
  var end = pbf2.readVarint() + pbf2.pos;
  var feature2 = {
    layer,
    type: 0,
    properties: {}
  };
  pbf2.readFields(featurePBFReader, feature2, end);
  return feature2;
}
function getGeometryType(type, numEnds) {
  var geometryType;
  if (type === 1) {
    geometryType = numEnds === 1 ? GeometryType.POINT : GeometryType.MULTI_POINT;
  } else if (type === 2) {
    geometryType = numEnds === 1 ? GeometryType.LINE_STRING : GeometryType.MULTI_LINE_STRING;
  } else if (type === 3) {
    geometryType = GeometryType.POLYGON;
  }
  return geometryType;
}
var MVT$1 = MVT;
var XML = function() {
  function XML2() {
  }
  XML2.prototype.read = function(source) {
    if (!source) {
      return null;
    } else if (typeof source === "string") {
      var doc = parse$1(source);
      return this.readFromDocument(doc);
    } else if (isDocument(source)) {
      return this.readFromDocument(source);
    } else {
      return this.readFromNode(source);
    }
  };
  XML2.prototype.readFromDocument = function(doc) {
    for (var n2 = doc.firstChild; n2; n2 = n2.nextSibling) {
      if (n2.nodeType == Node.ELEMENT_NODE) {
        return this.readFromNode(n2);
      }
    }
    return null;
  };
  XML2.prototype.readFromNode = function(node2) {
  };
  return XML2;
}();
var XML$1 = XML;
var NAMESPACE_URI = "http://www.w3.org/1999/xlink";
function readHref(node2) {
  return node2.getAttributeNS(NAMESPACE_URI, "href");
}
var __extends$d = globalThis && globalThis.__extends || function() {
  var extendStatics2 = function(d2, b2) {
    extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {
      d3.__proto__ = b3;
    } || function(d3, b3) {
      for (var p5 in b3)
        if (Object.prototype.hasOwnProperty.call(b3, p5))
          d3[p5] = b3[p5];
    };
    return extendStatics2(d2, b2);
  };
  return function(d2, b2) {
    if (typeof b2 !== "function" && b2 !== null)
      throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
    extendStatics2(d2, b2);
    function __() {
      this.constructor = d2;
    }
    d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
  };
}();
var NAMESPACE_URIS$2 = [null, "http://www.opengis.net/ows/1.1"];
var PARSERS$2 = makeStructureNS(NAMESPACE_URIS$2, {
  "ServiceIdentification": makeObjectPropertySetter(readServiceIdentification),
  "ServiceProvider": makeObjectPropertySetter(readServiceProvider),
  "OperationsMetadata": makeObjectPropertySetter(readOperationsMetadata)
});
var OWS = function(_super) {
  __extends$d(OWS2, _super);
  function OWS2() {
    return _super.call(this) || this;
  }
  OWS2.prototype.readFromNode = function(node2) {
    var owsObject = pushParseAndPop({}, PARSERS$2, node2, []);
    return owsObject ? owsObject : null;
  };
  return OWS2;
}(XML$1);
var ADDRESS_PARSERS = makeStructureNS(NAMESPACE_URIS$2, {
  "DeliveryPoint": makeObjectPropertySetter(readString),
  "City": makeObjectPropertySetter(readString),
  "AdministrativeArea": makeObjectPropertySetter(readString),
  "PostalCode": makeObjectPropertySetter(readString),
  "Country": makeObjectPropertySetter(readString),
  "ElectronicMailAddress": makeObjectPropertySetter(readString)
});
var ALLOWED_VALUES_PARSERS = makeStructureNS(NAMESPACE_URIS$2, {
  "Value": makeObjectPropertyPusher(readValue)
});
var CONSTRAINT_PARSERS = makeStructureNS(NAMESPACE_URIS$2, {
  "AllowedValues": makeObjectPropertySetter(readAllowedValues)
});
var CONTACT_INFO_PARSERS = makeStructureNS(NAMESPACE_URIS$2, {
  "Phone": makeObjectPropertySetter(readPhone),
  "Address": makeObjectPropertySetter(readAddress)
});
var DCP_PARSERS = makeStructureNS(NAMESPACE_URIS$2, {
  "HTTP": makeObjectPropertySetter(readHttp)
});
var HTTP_PARSERS$1 = makeStructureNS(NAMESPACE_URIS$2, {
  "Get": makeObjectPropertyPusher(readGet),
  "Post": void 0
});
var OPERATION_PARSERS = makeStructureNS(NAMESPACE_URIS$2, {
  "DCP": makeObjectPropertySetter(readDcp)
});
var OPERATIONS_METADATA_PARSERS = makeStructureNS(NAMESPACE_URIS$2, {
  "Operation": readOperation
});
var PHONE_PARSERS = makeStructureNS(NAMESPACE_URIS$2, {
  "Voice": makeObjectPropertySetter(readString),
  "Facsimile": makeObjectPropertySetter(readString)
});
var REQUEST_METHOD_PARSERS = makeStructureNS(NAMESPACE_URIS$2, {
  "Constraint": makeObjectPropertyPusher(readConstraint)
});
var SERVICE_CONTACT_PARSERS = makeStructureNS(NAMESPACE_URIS$2, {
  "IndividualName": makeObjectPropertySetter(readString),
  "PositionName": makeObjectPropertySetter(readString),
  "ContactInfo": makeObjectPropertySetter(readContactInfo)
});
var SERVICE_IDENTIFICATION_PARSERS = makeStructureNS(NAMESPACE_URIS$2, {
  "Abstract": makeObjectPropertySetter(readString),
  "AccessConstraints": makeObjectPropertySetter(readString),
  "Fees": makeObjectPropertySetter(readString),
  "Title": makeObjectPropertySetter(readString),
  "ServiceTypeVersion": makeObjectPropertySetter(readString),
  "ServiceType": makeObjectPropertySetter(readString)
});
var SERVICE_PROVIDER_PARSERS = makeStructureNS(NAMESPACE_URIS$2, {
  "ProviderName": makeObjectPropertySetter(readString),
  "ProviderSite": makeObjectPropertySetter(readHref),
  "ServiceContact": makeObjectPropertySetter(readServiceContact)
});
function readAddress(node2, objectStack) {
  return pushParseAndPop({}, ADDRESS_PARSERS, node2, objectStack);
}
function readAllowedValues(node2, objectStack) {
  return pushParseAndPop({}, ALLOWED_VALUES_PARSERS, node2, objectStack);
}
function readConstraint(node2, objectStack) {
  var name = node2.getAttribute("name");
  if (!name) {
    return void 0;
  }
  return pushParseAndPop({ "name": name }, CONSTRAINT_PARSERS, node2, objectStack);
}
function readContactInfo(node2, objectStack) {
  return pushParseAndPop({}, CONTACT_INFO_PARSERS, node2, objectStack);
}
function readDcp(node2, objectStack) {
  return pushParseAndPop({}, DCP_PARSERS, node2, objectStack);
}
function readGet(node2, objectStack) {
  var href = readHref(node2);
  if (!href) {
    return void 0;
  }
  return pushParseAndPop({ "href": href }, REQUEST_METHOD_PARSERS, node2, objectStack);
}
function readHttp(node2, objectStack) {
  return pushParseAndPop({}, HTTP_PARSERS$1, node2, objectStack);
}
function readOperation(node2, objectStack) {
  var name = node2.getAttribute("name");
  var value = pushParseAndPop({}, OPERATION_PARSERS, node2, objectStack);
  if (!value) {
    return void 0;
  }
  var object = objectStack[objectStack.length - 1];
  object[name] = value;
}
function readOperationsMetadata(node2, objectStack) {
  return pushParseAndPop({}, OPERATIONS_METADATA_PARSERS, node2, objectStack);
}
function readPhone(node2, objectStack) {
  return pushParseAndPop({}, PHONE_PARSERS, node2, objectStack);
}
function readServiceIdentification(node2, objectStack) {
  return pushParseAndPop({}, SERVICE_IDENTIFICATION_PARSERS, node2, objectStack);
}
function readServiceContact(node2, objectStack) {
  return pushParseAndPop({}, SERVICE_CONTACT_PARSERS, node2, objectStack);
}
function readServiceProvider(node2, objectStack) {
  return pushParseAndPop({}, SERVICE_PROVIDER_PARSERS, node2, objectStack);
}
function readValue(node2, objectStack) {
  return readString(node2);
}
var OWS$1 = OWS;
function flipXY(flatCoordinates, offset2, end, stride, opt_dest, opt_destOffset) {
  var dest, destOffset;
  if (opt_dest !== void 0) {
    dest = opt_dest;
    destOffset = opt_destOffset !== void 0 ? opt_destOffset : 0;
  } else {
    dest = [];
    destOffset = 0;
  }
  var j2 = offset2;
  while (j2 < end) {
    var x2 = flatCoordinates[j2++];
    dest[destOffset++] = flatCoordinates[j2++];
    dest[destOffset++] = x2;
    for (var k2 = 2; k2 < stride; ++k2) {
      dest[destOffset++] = flatCoordinates[j2++];
    }
  }
  dest.length = destOffset;
  return dest;
}
var __extends$c = globalThis && globalThis.__extends || function() {
  var extendStatics2 = function(d2, b2) {
    extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {
      d3.__proto__ = b3;
    } || function(d3, b3) {
      for (var p5 in b3)
        if (Object.prototype.hasOwnProperty.call(b3, p5))
          d3[p5] = b3[p5];
    };
    return extendStatics2(d2, b2);
  };
  return function(d2, b2) {
    if (typeof b2 !== "function" && b2 !== null)
      throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
    extendStatics2(d2, b2);
    function __() {
      this.constructor = d2;
    }
    d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
  };
}();
var Polyline = function(_super) {
  __extends$c(Polyline2, _super);
  function Polyline2(opt_options) {
    var _this = _super.call(this) || this;
    var options = opt_options ? opt_options : {};
    _this.dataProjection = get$3("EPSG:4326");
    _this.factor_ = options.factor ? options.factor : 1e5;
    _this.geometryLayout_ = options.geometryLayout ? options.geometryLayout : GeometryLayout.XY;
    return _this;
  }
  Polyline2.prototype.readFeatureFromText = function(text2, opt_options) {
    var geometry = this.readGeometryFromText(text2, opt_options);
    return new feature(geometry);
  };
  Polyline2.prototype.readFeaturesFromText = function(text2, opt_options) {
    var feature2 = this.readFeatureFromText(text2, opt_options);
    return [feature2];
  };
  Polyline2.prototype.readGeometryFromText = function(text2, opt_options) {
    var stride = getStrideForLayout(this.geometryLayout_);
    var flatCoordinates = decodeDeltas(text2, stride, this.factor_);
    flipXY(flatCoordinates, 0, flatCoordinates.length, stride, flatCoordinates);
    var coordinates2 = inflateCoordinates(flatCoordinates, 0, flatCoordinates.length, stride);
    var lineString = new LineString$2(coordinates2, this.geometryLayout_);
    return transformGeometryWithOptions(lineString, false, this.adaptOptions(opt_options));
  };
  Polyline2.prototype.writeFeatureText = function(feature2, opt_options) {
    var geometry = feature2.getGeometry();
    if (geometry) {
      return this.writeGeometryText(geometry, opt_options);
    } else {
      assert(false, 40);
      return "";
    }
  };
  Polyline2.prototype.writeFeaturesText = function(features, opt_options) {
    return this.writeFeatureText(features[0], opt_options);
  };
  Polyline2.prototype.writeGeometryText = function(geometry, opt_options) {
    geometry = transformGeometryWithOptions(geometry, true, this.adaptOptions(opt_options));
    var flatCoordinates = geometry.getFlatCoordinates();
    var stride = geometry.getStride();
    flipXY(flatCoordinates, 0, flatCoordinates.length, stride, flatCoordinates);
    return encodeDeltas(flatCoordinates, stride, this.factor_);
  };
  return Polyline2;
}(TextFeature$1);
function encodeDeltas(numbers, stride, opt_factor) {
  var factor = opt_factor ? opt_factor : 1e5;
  var d2;
  var lastNumbers = new Array(stride);
  for (d2 = 0; d2 < stride; ++d2) {
    lastNumbers[d2] = 0;
  }
  for (var i2 = 0, ii = numbers.length; i2 < ii; ) {
    for (d2 = 0; d2 < stride; ++d2, ++i2) {
      var num = numbers[i2];
      var delta = num - lastNumbers[d2];
      lastNumbers[d2] = num;
      numbers[i2] = delta;
    }
  }
  return encodeFloats(numbers, factor);
}
function decodeDeltas(encoded, stride, opt_factor) {
  var factor = opt_factor ? opt_factor : 1e5;
  var d2;
  var lastNumbers = new Array(stride);
  for (d2 = 0; d2 < stride; ++d2) {
    lastNumbers[d2] = 0;
  }
  var numbers = decodeFloats(encoded, factor);
  for (var i2 = 0, ii = numbers.length; i2 < ii; ) {
    for (d2 = 0; d2 < stride; ++d2, ++i2) {
      lastNumbers[d2] += numbers[i2];
      numbers[i2] = lastNumbers[d2];
    }
  }
  return numbers;
}
function encodeFloats(numbers, opt_factor) {
  var factor = opt_factor ? opt_factor : 1e5;
  for (var i2 = 0, ii = numbers.length; i2 < ii; ++i2) {
    numbers[i2] = Math.round(numbers[i2] * factor);
  }
  return encodeSignedIntegers(numbers);
}
function decodeFloats(encoded, opt_factor) {
  var factor = opt_factor ? opt_factor : 1e5;
  var numbers = decodeSignedIntegers(encoded);
  for (var i2 = 0, ii = numbers.length; i2 < ii; ++i2) {
    numbers[i2] /= factor;
  }
  return numbers;
}
function encodeSignedIntegers(numbers) {
  for (var i2 = 0, ii = numbers.length; i2 < ii; ++i2) {
    var num = numbers[i2];
    numbers[i2] = num < 0 ? ~(num << 1) : num << 1;
  }
  return encodeUnsignedIntegers(numbers);
}
function decodeSignedIntegers(encoded) {
  var numbers = decodeUnsignedIntegers(encoded);
  for (var i2 = 0, ii = numbers.length; i2 < ii; ++i2) {
    var num = numbers[i2];
    numbers[i2] = num & 1 ? ~(num >> 1) : num >> 1;
  }
  return numbers;
}
function encodeUnsignedIntegers(numbers) {
  var encoded = "";
  for (var i2 = 0, ii = numbers.length; i2 < ii; ++i2) {
    encoded += encodeUnsignedInteger(numbers[i2]);
  }
  return encoded;
}
function decodeUnsignedIntegers(encoded) {
  var numbers = [];
  var current = 0;
  var shift = 0;
  for (var i2 = 0, ii = encoded.length; i2 < ii; ++i2) {
    var b2 = encoded.charCodeAt(i2) - 63;
    current |= (b2 & 31) << shift;
    if (b2 < 32) {
      numbers.push(current);
      current = 0;
      shift = 0;
    } else {
      shift += 5;
    }
  }
  return numbers;
}
function encodeUnsignedInteger(num) {
  var value, encoded = "";
  while (num >= 32) {
    value = (32 | num & 31) + 63;
    encoded += String.fromCharCode(value);
    num >>= 5;
  }
  value = num + 63;
  encoded += String.fromCharCode(value);
  return encoded;
}
var Polyline$1 = Polyline;
var __extends$b = globalThis && globalThis.__extends || function() {
  var extendStatics2 = function(d2, b2) {
    extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {
      d3.__proto__ = b3;
    } || function(d3, b3) {
      for (var p5 in b3)
        if (Object.prototype.hasOwnProperty.call(b3, p5))
          d3[p5] = b3[p5];
    };
    return extendStatics2(d2, b2);
  };
  return function(d2, b2) {
    if (typeof b2 !== "function" && b2 !== null)
      throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
    extendStatics2(d2, b2);
    function __() {
      this.constructor = d2;
    }
    d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
  };
}();
var TopoJSON = function(_super) {
  __extends$b(TopoJSON2, _super);
  function TopoJSON2(opt_options) {
    var _this = _super.call(this) || this;
    var options = opt_options ? opt_options : {};
    _this.layerName_ = options.layerName;
    _this.layers_ = options.layers ? options.layers : null;
    _this.dataProjection = get$3(options.dataProjection ? options.dataProjection : "EPSG:4326");
    return _this;
  }
  TopoJSON2.prototype.readFeaturesFromObject = function(object, opt_options) {
    if (object.type == "Topology") {
      var topoJSONTopology = object;
      var transform2 = void 0, scale2 = null, translate2 = null;
      if (topoJSONTopology["transform"]) {
        transform2 = topoJSONTopology["transform"];
        scale2 = transform2["scale"];
        translate2 = transform2["translate"];
      }
      var arcs = topoJSONTopology["arcs"];
      if (transform2) {
        transformArcs(arcs, scale2, translate2);
      }
      var features = [];
      var topoJSONFeatures = topoJSONTopology["objects"];
      var property = this.layerName_;
      var feature2 = void 0;
      for (var objectName in topoJSONFeatures) {
        if (this.layers_ && this.layers_.indexOf(objectName) == -1) {
          continue;
        }
        if (topoJSONFeatures[objectName].type === "GeometryCollection") {
          feature2 = topoJSONFeatures[objectName];
          features.push.apply(features, readFeaturesFromGeometryCollection(feature2, arcs, scale2, translate2, property, objectName, opt_options));
        } else {
          feature2 = topoJSONFeatures[objectName];
          features.push(readFeatureFromGeometry(feature2, arcs, scale2, translate2, property, objectName, opt_options));
        }
      }
      return features;
    } else {
      return [];
    }
  };
  TopoJSON2.prototype.readProjectionFromObject = function(object) {
    return this.dataProjection;
  };
  return TopoJSON2;
}(JSONFeature$1);
var GEOMETRY_READERS = {
  "Point": readPointGeometry,
  "LineString": readLineStringGeometry,
  "Polygon": readPolygonGeometry,
  "MultiPoint": readMultiPointGeometry,
  "MultiLineString": readMultiLineStringGeometry,
  "MultiPolygon": readMultiPolygonGeometry
};
function concatenateArcs(indices, arcs) {
  var coordinates2 = [];
  var index2;
  for (var i2 = 0, ii = indices.length; i2 < ii; ++i2) {
    index2 = indices[i2];
    if (i2 > 0) {
      coordinates2.pop();
    }
    if (index2 >= 0) {
      var arc = arcs[index2];
      for (var j2 = 0, jj = arc.length; j2 < jj; ++j2) {
        coordinates2.push(arc[j2].slice(0));
      }
    } else {
      var arc = arcs[~index2];
      for (var j2 = arc.length - 1; j2 >= 0; --j2) {
        coordinates2.push(arc[j2].slice(0));
      }
    }
  }
  return coordinates2;
}
function readPointGeometry(object, scale2, translate2) {
  var coordinates2 = object["coordinates"];
  if (scale2 && translate2) {
    transformVertex(coordinates2, scale2, translate2);
  }
  return new Point$4(coordinates2);
}
function readMultiPointGeometry(object, scale2, translate2) {
  var coordinates2 = object["coordinates"];
  if (scale2 && translate2) {
    for (var i2 = 0, ii = coordinates2.length; i2 < ii; ++i2) {
      transformVertex(coordinates2[i2], scale2, translate2);
    }
  }
  return new MultiPoint$2(coordinates2);
}
function readLineStringGeometry(object, arcs) {
  var coordinates2 = concatenateArcs(object["arcs"], arcs);
  return new LineString$2(coordinates2);
}
function readMultiLineStringGeometry(object, arcs) {
  var coordinates2 = [];
  for (var i2 = 0, ii = object["arcs"].length; i2 < ii; ++i2) {
    coordinates2[i2] = concatenateArcs(object["arcs"][i2], arcs);
  }
  return new MultiLineString$2(coordinates2);
}
function readPolygonGeometry(object, arcs) {
  var coordinates2 = [];
  for (var i2 = 0, ii = object["arcs"].length; i2 < ii; ++i2) {
    coordinates2[i2] = concatenateArcs(object["arcs"][i2], arcs);
  }
  return new Polygon$2(coordinates2);
}
function readMultiPolygonGeometry(object, arcs) {
  var coordinates2 = [];
  for (var i2 = 0, ii = object["arcs"].length; i2 < ii; ++i2) {
    var polyArray = object["arcs"][i2];
    var ringCoords = [];
    for (var j2 = 0, jj = polyArray.length; j2 < jj; ++j2) {
      ringCoords[j2] = concatenateArcs(polyArray[j2], arcs);
    }
    coordinates2[i2] = ringCoords;
  }
  return new MultiPolygon$2(coordinates2);
}
function readFeaturesFromGeometryCollection(collection, arcs, scale2, translate2, property, name, opt_options) {
  var geometries = collection["geometries"];
  var features = [];
  for (var i2 = 0, ii = geometries.length; i2 < ii; ++i2) {
    features[i2] = readFeatureFromGeometry(geometries[i2], arcs, scale2, translate2, property, name, opt_options);
  }
  return features;
}
function readFeatureFromGeometry(object, arcs, scale2, translate2, property, name, opt_options) {
  var geometry = null;
  var type = object.type;
  if (type) {
    var geometryReader = GEOMETRY_READERS[type];
    if (type === "Point" || type === "MultiPoint") {
      geometry = geometryReader(object, scale2, translate2);
    } else {
      geometry = geometryReader(object, arcs);
    }
    geometry = transformGeometryWithOptions(geometry, false, opt_options);
  }
  var feature$1 = new feature({ geometry });
  if (object.id !== void 0) {
    feature$1.setId(object.id);
  }
  var properties = object.properties;
  if (property) {
    if (!properties) {
      properties = {};
    }
    properties[property] = name;
  }
  if (properties) {
    feature$1.setProperties(properties, true);
  }
  return feature$1;
}
function transformArcs(arcs, scale2, translate2) {
  for (var i2 = 0, ii = arcs.length; i2 < ii; ++i2) {
    transformArc(arcs[i2], scale2, translate2);
  }
}
function transformArc(arc, scale2, translate2) {
  var x2 = 0;
  var y2 = 0;
  for (var i2 = 0, ii = arc.length; i2 < ii; ++i2) {
    var vertex = arc[i2];
    x2 += vertex[0];
    y2 += vertex[1];
    vertex[0] = x2;
    vertex[1] = y2;
    transformVertex(vertex, scale2, translate2);
  }
}
function transformVertex(vertex, scale2, translate2) {
  vertex[0] = vertex[0] * scale2[0] + translate2[0];
  vertex[1] = vertex[1] * scale2[1] + translate2[1];
}
var TopoJSON$1 = TopoJSON;
var __extends$a = globalThis && globalThis.__extends || function() {
  var extendStatics2 = function(d2, b2) {
    extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {
      d3.__proto__ = b3;
    } || function(d3, b3) {
      for (var p5 in b3)
        if (Object.prototype.hasOwnProperty.call(b3, p5))
          d3[p5] = b3[p5];
    };
    return extendStatics2(d2, b2);
  };
  return function(d2, b2) {
    if (typeof b2 !== "function" && b2 !== null)
      throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
    extendStatics2(d2, b2);
    function __() {
      this.constructor = d2;
    }
    d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
  };
}();
var GML32 = function(_super) {
  __extends$a(GML322, _super);
  function GML322(opt_options) {
    var _this = this;
    var options = opt_options ? opt_options : {};
    _this = _super.call(this, options) || this;
    _this.schemaLocation = options.schemaLocation ? options.schemaLocation : _this.namespace + " http://schemas.opengis.net/gml/3.2.1/gml.xsd";
    return _this;
  }
  return GML322;
}(GML3$1);
GML32.prototype.namespace = "http://www.opengis.net/gml/3.2";
GML32.prototype.GEOMETRY_FLAT_COORDINATES_PARSERS = {
  "http://www.opengis.net/gml/3.2": {
    "pos": makeReplacer(GML3$1.prototype.readFlatPos),
    "posList": makeReplacer(GML3$1.prototype.readFlatPosList),
    "coordinates": makeReplacer(GML2$1.prototype.readFlatCoordinates)
  }
};
GML32.prototype.FLAT_LINEAR_RINGS_PARSERS = {
  "http://www.opengis.net/gml/3.2": {
    "interior": GML3$1.prototype.interiorParser,
    "exterior": GML3$1.prototype.exteriorParser
  }
};
GML32.prototype.GEOMETRY_PARSERS = {
  "http://www.opengis.net/gml/3.2": {
    "Point": makeReplacer(GMLBase$1.prototype.readPoint),
    "MultiPoint": makeReplacer(GMLBase$1.prototype.readMultiPoint),
    "LineString": makeReplacer(GMLBase$1.prototype.readLineString),
    "MultiLineString": makeReplacer(GMLBase$1.prototype.readMultiLineString),
    "LinearRing": makeReplacer(GMLBase$1.prototype.readLinearRing),
    "Polygon": makeReplacer(GMLBase$1.prototype.readPolygon),
    "MultiPolygon": makeReplacer(GMLBase$1.prototype.readMultiPolygon),
    "Surface": makeReplacer(GML32.prototype.readSurface),
    "MultiSurface": makeReplacer(GML3$1.prototype.readMultiSurface),
    "Curve": makeReplacer(GML32.prototype.readCurve),
    "MultiCurve": makeReplacer(GML3$1.prototype.readMultiCurve),
    "Envelope": makeReplacer(GML32.prototype.readEnvelope)
  }
};
GML32.prototype.MULTICURVE_PARSERS = {
  "http://www.opengis.net/gml/3.2": {
    "curveMember": makeArrayPusher(GML3$1.prototype.curveMemberParser),
    "curveMembers": makeArrayPusher(GML3$1.prototype.curveMemberParser)
  }
};
GML32.prototype.MULTISURFACE_PARSERS = {
  "http://www.opengis.net/gml/3.2": {
    "surfaceMember": makeArrayPusher(GML3$1.prototype.surfaceMemberParser),
    "surfaceMembers": makeArrayPusher(GML3$1.prototype.surfaceMemberParser)
  }
};
GML32.prototype.CURVEMEMBER_PARSERS = {
  "http://www.opengis.net/gml/3.2": {
    "LineString": makeArrayPusher(GMLBase$1.prototype.readLineString),
    "Curve": makeArrayPusher(GML3$1.prototype.readCurve)
  }
};
GML32.prototype.SURFACEMEMBER_PARSERS = {
  "http://www.opengis.net/gml/3.2": {
    "Polygon": makeArrayPusher(GMLBase$1.prototype.readPolygon),
    "Surface": makeArrayPusher(GML3$1.prototype.readSurface)
  }
};
GML32.prototype.SURFACE_PARSERS = {
  "http://www.opengis.net/gml/3.2": {
    "patches": makeReplacer(GML3$1.prototype.readPatch)
  }
};
GML32.prototype.CURVE_PARSERS = {
  "http://www.opengis.net/gml/3.2": {
    "segments": makeReplacer(GML3$1.prototype.readSegment)
  }
};
GML32.prototype.ENVELOPE_PARSERS = {
  "http://www.opengis.net/gml/3.2": {
    "lowerCorner": makeArrayPusher(GML3$1.prototype.readFlatPosList),
    "upperCorner": makeArrayPusher(GML3$1.prototype.readFlatPosList)
  }
};
GML32.prototype.PATCHES_PARSERS = {
  "http://www.opengis.net/gml/3.2": {
    "PolygonPatch": makeReplacer(GML3$1.prototype.readPolygonPatch)
  }
};
GML32.prototype.SEGMENTS_PARSERS = {
  "http://www.opengis.net/gml/3.2": {
    "LineStringSegment": makeReplacer(GML3$1.prototype.readLineStringSegment)
  }
};
GML32.prototype.MULTIPOINT_PARSERS = {
  "http://www.opengis.net/gml/3.2": {
    "pointMember": makeArrayPusher(GMLBase$1.prototype.pointMemberParser),
    "pointMembers": makeArrayPusher(GMLBase$1.prototype.pointMemberParser)
  }
};
GML32.prototype.MULTILINESTRING_PARSERS = {
  "http://www.opengis.net/gml/3.2": {
    "lineStringMember": makeArrayPusher(GMLBase$1.prototype.lineStringMemberParser),
    "lineStringMembers": makeArrayPusher(GMLBase$1.prototype.lineStringMemberParser)
  }
};
GML32.prototype.MULTIPOLYGON_PARSERS = {
  "http://www.opengis.net/gml/3.2": {
    "polygonMember": makeArrayPusher(GMLBase$1.prototype.polygonMemberParser),
    "polygonMembers": makeArrayPusher(GMLBase$1.prototype.polygonMemberParser)
  }
};
GML32.prototype.POINTMEMBER_PARSERS = {
  "http://www.opengis.net/gml/3.2": {
    "Point": makeArrayPusher(GMLBase$1.prototype.readFlatCoordinatesFromNode)
  }
};
GML32.prototype.LINESTRINGMEMBER_PARSERS = {
  "http://www.opengis.net/gml/3.2": {
    "LineString": makeArrayPusher(GMLBase$1.prototype.readLineString)
  }
};
GML32.prototype.POLYGONMEMBER_PARSERS = {
  "http://www.opengis.net/gml/3.2": {
    "Polygon": makeArrayPusher(GMLBase$1.prototype.readPolygon)
  }
};
GML32.prototype.RING_PARSERS = {
  "http://www.opengis.net/gml/3.2": {
    "LinearRing": makeReplacer(GMLBase$1.prototype.readFlatLinearRing)
  }
};
GML32.prototype.RING_SERIALIZERS = {
  "http://www.opengis.net/gml/3.2": {
    "exterior": makeChildAppender(GML3$1.prototype.writeRing),
    "interior": makeChildAppender(GML3$1.prototype.writeRing)
  }
};
GML32.prototype.ENVELOPE_SERIALIZERS = {
  "http://www.opengis.net/gml/3.2": {
    "lowerCorner": makeChildAppender(writeStringTextNode),
    "upperCorner": makeChildAppender(writeStringTextNode)
  }
};
GML32.prototype.SURFACEORPOLYGONMEMBER_SERIALIZERS = {
  "http://www.opengis.net/gml/3.2": {
    "surfaceMember": makeChildAppender(GML3$1.prototype.writeSurfaceOrPolygonMember),
    "polygonMember": makeChildAppender(GML3$1.prototype.writeSurfaceOrPolygonMember)
  }
};
GML32.prototype.POINTMEMBER_SERIALIZERS = {
  "http://www.opengis.net/gml/3.2": {
    "pointMember": makeChildAppender(GML3$1.prototype.writePointMember)
  }
};
GML32.prototype.LINESTRINGORCURVEMEMBER_SERIALIZERS = {
  "http://www.opengis.net/gml/3.2": {
    "lineStringMember": makeChildAppender(GML3$1.prototype.writeLineStringOrCurveMember),
    "curveMember": makeChildAppender(GML3$1.prototype.writeLineStringOrCurveMember)
  }
};
GML32.prototype.GEOMETRY_SERIALIZERS = {
  "http://www.opengis.net/gml/3.2": {
    "Curve": makeChildAppender(GML3$1.prototype.writeCurveOrLineString),
    "MultiCurve": makeChildAppender(GML3$1.prototype.writeMultiCurveOrLineString),
    "Point": makeChildAppender(GML32.prototype.writePoint),
    "MultiPoint": makeChildAppender(GML3$1.prototype.writeMultiPoint),
    "LineString": makeChildAppender(GML3$1.prototype.writeCurveOrLineString),
    "MultiLineString": makeChildAppender(GML3$1.prototype.writeMultiCurveOrLineString),
    "LinearRing": makeChildAppender(GML3$1.prototype.writeLinearRing),
    "Polygon": makeChildAppender(GML3$1.prototype.writeSurfaceOrPolygon),
    "MultiPolygon": makeChildAppender(GML3$1.prototype.writeMultiSurfaceOrPolygon),
    "Surface": makeChildAppender(GML3$1.prototype.writeSurfaceOrPolygon),
    "MultiSurface": makeChildAppender(GML3$1.prototype.writeMultiSurfaceOrPolygon),
    "Envelope": makeChildAppender(GML3$1.prototype.writeEnvelope)
  }
};
var GML32$1 = GML32;
var Filter = function() {
  function Filter2(tagName) {
    this.tagName_ = tagName;
  }
  Filter2.prototype.getTagName = function() {
    return this.tagName_;
  };
  return Filter2;
}();
var Filter$1 = Filter;
var __extends$9 = globalThis && globalThis.__extends || function() {
  var extendStatics2 = function(d2, b2) {
    extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {
      d3.__proto__ = b3;
    } || function(d3, b3) {
      for (var p5 in b3)
        if (Object.prototype.hasOwnProperty.call(b3, p5))
          d3[p5] = b3[p5];
    };
    return extendStatics2(d2, b2);
  };
  return function(d2, b2) {
    if (typeof b2 !== "function" && b2 !== null)
      throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
    extendStatics2(d2, b2);
    function __() {
      this.constructor = d2;
    }
    d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
  };
}();
var LogicalNary = function(_super) {
  __extends$9(LogicalNary2, _super);
  function LogicalNary2(tagName, conditions) {
    var _this = _super.call(this, tagName) || this;
    _this.conditions = conditions;
    assert(_this.conditions.length >= 2, 57);
    return _this;
  }
  return LogicalNary2;
}(Filter$1);
var LogicalNary$1 = LogicalNary;
var __extends$8 = globalThis && globalThis.__extends || function() {
  var extendStatics2 = function(d2, b2) {
    extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {
      d3.__proto__ = b3;
    } || function(d3, b3) {
      for (var p5 in b3)
        if (Object.prototype.hasOwnProperty.call(b3, p5))
          d3[p5] = b3[p5];
    };
    return extendStatics2(d2, b2);
  };
  return function(d2, b2) {
    if (typeof b2 !== "function" && b2 !== null)
      throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
    extendStatics2(d2, b2);
    function __() {
      this.constructor = d2;
    }
    d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
  };
}();
var And = function(_super) {
  __extends$8(And2, _super);
  function And2(conditions) {
    return _super.call(this, "And", Array.prototype.slice.call(arguments)) || this;
  }
  return And2;
}(LogicalNary$1);
var And$1 = And;
var __extends$7 = globalThis && globalThis.__extends || function() {
  var extendStatics2 = function(d2, b2) {
    extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {
      d3.__proto__ = b3;
    } || function(d3, b3) {
      for (var p5 in b3)
        if (Object.prototype.hasOwnProperty.call(b3, p5))
          d3[p5] = b3[p5];
    };
    return extendStatics2(d2, b2);
  };
  return function(d2, b2) {
    if (typeof b2 !== "function" && b2 !== null)
      throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
    extendStatics2(d2, b2);
    function __() {
      this.constructor = d2;
    }
    d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
  };
}();
var Bbox = function(_super) {
  __extends$7(Bbox2, _super);
  function Bbox2(geometryName, extent2, opt_srsName) {
    var _this = _super.call(this, "BBOX") || this;
    _this.geometryName = geometryName;
    _this.extent = extent2;
    if (extent2.length !== 4) {
      throw new Error("Expected an extent with four values ([minX, minY, maxX, maxY])");
    }
    _this.srsName = opt_srsName;
    return _this;
  }
  return Bbox2;
}(Filter$1);
var Bbox$1 = Bbox;
function and(conditions) {
  var params2 = [null].concat(Array.prototype.slice.call(arguments));
  return new (Function.prototype.bind.apply(And$1, params2))();
}
function bbox(geometryName, extent2, opt_srsName) {
  return new Bbox$1(geometryName, extent2, opt_srsName);
}
var __extends$6 = globalThis && globalThis.__extends || function() {
  var extendStatics2 = function(d2, b2) {
    extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {
      d3.__proto__ = b3;
    } || function(d3, b3) {
      for (var p5 in b3)
        if (Object.prototype.hasOwnProperty.call(b3, p5))
          d3[p5] = b3[p5];
    };
    return extendStatics2(d2, b2);
  };
  return function(d2, b2) {
    if (typeof b2 !== "function" && b2 !== null)
      throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
    extendStatics2(d2, b2);
    function __() {
      this.constructor = d2;
    }
    d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
  };
}();
var FEATURE_COLLECTION_PARSERS = {
  "http://www.opengis.net/gml": {
    "boundedBy": makeObjectPropertySetter(GMLBase$1.prototype.readExtentElement, "bounds")
  },
  "http://www.opengis.net/wfs/2.0": {
    "member": makeArrayPusher(GMLBase$1.prototype.readFeaturesInternal)
  }
};
var TRANSACTION_SUMMARY_PARSERS = {
  "http://www.opengis.net/wfs": {
    "totalInserted": makeObjectPropertySetter(readPositiveInteger),
    "totalUpdated": makeObjectPropertySetter(readPositiveInteger),
    "totalDeleted": makeObjectPropertySetter(readPositiveInteger)
  },
  "http://www.opengis.net/wfs/2.0": {
    "totalInserted": makeObjectPropertySetter(readPositiveInteger),
    "totalUpdated": makeObjectPropertySetter(readPositiveInteger),
    "totalDeleted": makeObjectPropertySetter(readPositiveInteger)
  }
};
var TRANSACTION_RESPONSE_PARSERS = {
  "http://www.opengis.net/wfs": {
    "TransactionSummary": makeObjectPropertySetter(readTransactionSummary, "transactionSummary"),
    "InsertResults": makeObjectPropertySetter(readInsertResults, "insertIds")
  },
  "http://www.opengis.net/wfs/2.0": {
    "TransactionSummary": makeObjectPropertySetter(readTransactionSummary, "transactionSummary"),
    "InsertResults": makeObjectPropertySetter(readInsertResults, "insertIds")
  }
};
var QUERY_SERIALIZERS = {
  "http://www.opengis.net/wfs": {
    "PropertyName": makeChildAppender(writeStringTextNode)
  },
  "http://www.opengis.net/wfs/2.0": {
    "PropertyName": makeChildAppender(writeStringTextNode)
  }
};
var TRANSACTION_SERIALIZERS = {
  "http://www.opengis.net/wfs": {
    "Insert": makeChildAppender(writeFeature),
    "Update": makeChildAppender(writeUpdate),
    "Delete": makeChildAppender(writeDelete),
    "Property": makeChildAppender(writeProperty),
    "Native": makeChildAppender(writeNative)
  },
  "http://www.opengis.net/wfs/2.0": {
    "Insert": makeChildAppender(writeFeature),
    "Update": makeChildAppender(writeUpdate),
    "Delete": makeChildAppender(writeDelete),
    "Property": makeChildAppender(writeProperty),
    "Native": makeChildAppender(writeNative)
  }
};
var FEATURE_PREFIX = "feature";
var XMLNS = "http://www.w3.org/2000/xmlns/";
var OGCNS = {
  "2.0.0": "http://www.opengis.net/ogc/1.1",
  "1.1.0": "http://www.opengis.net/ogc",
  "1.0.0": "http://www.opengis.net/ogc"
};
var WFSNS = {
  "2.0.0": "http://www.opengis.net/wfs/2.0",
  "1.1.0": "http://www.opengis.net/wfs",
  "1.0.0": "http://www.opengis.net/wfs"
};
var FESNS = {
  "2.0.0": "http://www.opengis.net/fes/2.0",
  "1.1.0": "http://www.opengis.net/fes",
  "1.0.0": "http://www.opengis.net/fes"
};
var SCHEMA_LOCATIONS = {
  "2.0.0": "http://www.opengis.net/wfs/2.0 http://schemas.opengis.net/wfs/2.0/wfs.xsd",
  "1.1.0": "http://www.opengis.net/wfs http://schemas.opengis.net/wfs/1.1.0/wfs.xsd",
  "1.0.0": "http://www.opengis.net/wfs http://schemas.opengis.net/wfs/1.0.0/wfs.xsd"
};
var GML_FORMATS = {
  "2.0.0": GML32$1,
  "1.1.0": GML3$1,
  "1.0.0": GML2$1
};
var DEFAULT_VERSION = "1.1.0";
var WFS = function(_super) {
  __extends$6(WFS2, _super);
  function WFS2(opt_options) {
    var _this = _super.call(this) || this;
    var options = opt_options ? opt_options : {};
    _this.version_ = options.version ? options.version : DEFAULT_VERSION;
    _this.featureType_ = options.featureType;
    _this.featureNS_ = options.featureNS;
    _this.gmlFormat_ = options.gmlFormat ? options.gmlFormat : new GML_FORMATS[_this.version_]();
    _this.schemaLocation_ = options.schemaLocation ? options.schemaLocation : SCHEMA_LOCATIONS[_this.version_];
    return _this;
  }
  WFS2.prototype.getFeatureType = function() {
    return this.featureType_;
  };
  WFS2.prototype.setFeatureType = function(featureType) {
    this.featureType_ = featureType;
  };
  WFS2.prototype.readFeaturesFromNode = function(node2, opt_options) {
    var context = {
      node: node2
    };
    assign(context, {
      "featureType": this.featureType_,
      "featureNS": this.featureNS_
    });
    assign(context, this.getReadOptions(node2, opt_options ? opt_options : {}));
    var objectStack = [context];
    var featuresNS;
    if (this.version_ === "2.0.0") {
      featuresNS = FEATURE_COLLECTION_PARSERS;
    } else {
      featuresNS = this.gmlFormat_.FEATURE_COLLECTION_PARSERS;
    }
    var features = pushParseAndPop([], featuresNS, node2, objectStack, this.gmlFormat_);
    if (!features) {
      features = [];
    }
    return features;
  };
  WFS2.prototype.readTransactionResponse = function(source) {
    if (!source) {
      return void 0;
    } else if (typeof source === "string") {
      var doc = parse$1(source);
      return this.readTransactionResponseFromDocument(doc);
    } else if (isDocument(source)) {
      return this.readTransactionResponseFromDocument(source);
    } else {
      return this.readTransactionResponseFromNode(source);
    }
  };
  WFS2.prototype.readFeatureCollectionMetadata = function(source) {
    if (!source) {
      return void 0;
    } else if (typeof source === "string") {
      var doc = parse$1(source);
      return this.readFeatureCollectionMetadataFromDocument(doc);
    } else if (isDocument(source)) {
      return this.readFeatureCollectionMetadataFromDocument(source);
    } else {
      return this.readFeatureCollectionMetadataFromNode(source);
    }
  };
  WFS2.prototype.readFeatureCollectionMetadataFromDocument = function(doc) {
    for (var n2 = doc.firstChild; n2; n2 = n2.nextSibling) {
      if (n2.nodeType == Node.ELEMENT_NODE) {
        return this.readFeatureCollectionMetadataFromNode(n2);
      }
    }
    return void 0;
  };
  WFS2.prototype.readFeatureCollectionMetadataFromNode = function(node2) {
    var result = {};
    var value = readNonNegativeIntegerString(node2.getAttribute("numberOfFeatures"));
    result["numberOfFeatures"] = value;
    return pushParseAndPop(result, FEATURE_COLLECTION_PARSERS, node2, [], this.gmlFormat_);
  };
  WFS2.prototype.readTransactionResponseFromDocument = function(doc) {
    for (var n2 = doc.firstChild; n2; n2 = n2.nextSibling) {
      if (n2.nodeType == Node.ELEMENT_NODE) {
        return this.readTransactionResponseFromNode(n2);
      }
    }
    return void 0;
  };
  WFS2.prototype.readTransactionResponseFromNode = function(node2) {
    return pushParseAndPop({}, TRANSACTION_RESPONSE_PARSERS, node2, []);
  };
  WFS2.prototype.writeGetFeature = function(options) {
    var _this = this;
    var node2 = createElementNS(WFSNS[this.version_], "GetFeature");
    node2.setAttribute("service", "WFS");
    node2.setAttribute("version", this.version_);
    if (options.handle) {
      node2.setAttribute("handle", options.handle);
    }
    if (options.outputFormat) {
      node2.setAttribute("outputFormat", options.outputFormat);
    }
    if (options.maxFeatures !== void 0) {
      node2.setAttribute("maxFeatures", String(options.maxFeatures));
    }
    if (options.resultType) {
      node2.setAttribute("resultType", options.resultType);
    }
    if (options.startIndex !== void 0) {
      node2.setAttribute("startIndex", String(options.startIndex));
    }
    if (options.count !== void 0) {
      node2.setAttribute("count", String(options.count));
    }
    if (options.viewParams !== void 0) {
      node2.setAttribute("viewParams", options.viewParams);
    }
    node2.setAttributeNS(XML_SCHEMA_INSTANCE_URI, "xsi:schemaLocation", this.schemaLocation_);
    var context = {
      node: node2
    };
    assign(context, {
      "version": this.version_,
      "srsName": options.srsName,
      "featureNS": options.featureNS ? options.featureNS : this.featureNS_,
      "featurePrefix": options.featurePrefix,
      "propertyNames": options.propertyNames ? options.propertyNames : []
    });
    assert(Array.isArray(options.featureTypes), 11);
    if (typeof options.featureTypes[0] === "string") {
      var filter = options.filter;
      if (options.bbox) {
        assert(options.geometryName, 12);
        filter = this.combineBboxAndFilter(options.geometryName, options.bbox, options.srsName, filter);
      }
      assign(context, {
        "geometryName": options.geometryName,
        "filter": filter
      });
      writeGetFeature(node2, options.featureTypes, [context]);
    } else {
      options.featureTypes.forEach(function(featureType) {
        var completeFilter = _this.combineBboxAndFilter(featureType.geometryName, featureType.bbox, options.srsName, options.filter);
        assign(context, {
          "geometryName": featureType.geometryName,
          "filter": completeFilter
        });
        writeGetFeature(node2, [featureType.name], [context]);
      });
    }
    return node2;
  };
  WFS2.prototype.combineBboxAndFilter = function(geometryName, extent2, opt_srsName, opt_filter) {
    var bboxFilter = bbox(geometryName, extent2, opt_srsName);
    if (opt_filter) {
      return and(opt_filter, bboxFilter);
    }
    return bboxFilter;
  };
  WFS2.prototype.writeTransaction = function(inserts, updates, deletes, options) {
    var objectStack = [];
    var version2 = options.version ? options.version : this.version_;
    var node2 = createElementNS(WFSNS[version2], "Transaction");
    node2.setAttribute("service", "WFS");
    node2.setAttribute("version", version2);
    var baseObj;
    if (options) {
      baseObj = options.gmlOptions ? options.gmlOptions : {};
      if (options.handle) {
        node2.setAttribute("handle", options.handle);
      }
    }
    node2.setAttributeNS(XML_SCHEMA_INSTANCE_URI, "xsi:schemaLocation", SCHEMA_LOCATIONS[version2]);
    var request = createTransactionRequest(node2, baseObj, version2, options);
    if (inserts) {
      serializeTransactionRequest("Insert", inserts, objectStack, request);
    }
    if (updates) {
      serializeTransactionRequest("Update", updates, objectStack, request);
    }
    if (deletes) {
      serializeTransactionRequest("Delete", deletes, objectStack, request);
    }
    if (options.nativeElements) {
      serializeTransactionRequest("Native", options.nativeElements, objectStack, request);
    }
    return node2;
  };
  WFS2.prototype.readProjectionFromDocument = function(doc) {
    for (var n2 = doc.firstChild; n2; n2 = n2.nextSibling) {
      if (n2.nodeType == Node.ELEMENT_NODE) {
        return this.readProjectionFromNode(n2);
      }
    }
    return null;
  };
  WFS2.prototype.readProjectionFromNode = function(node2) {
    if (node2.firstElementChild && node2.firstElementChild.firstElementChild) {
      node2 = node2.firstElementChild.firstElementChild;
      for (var n2 = node2.firstElementChild; n2; n2 = n2.nextElementSibling) {
        if (!(n2.childNodes.length === 0 || n2.childNodes.length === 1 && n2.firstChild.nodeType === 3)) {
          var objectStack = [{}];
          this.gmlFormat_.readGeometryElement(n2, objectStack);
          return get$3(objectStack.pop().srsName);
        }
      }
    }
    return null;
  };
  return WFS2;
}(XMLFeature$1);
function createTransactionRequest(node2, baseObj, version2, options) {
  var featurePrefix = options.featurePrefix ? options.featurePrefix : FEATURE_PREFIX;
  var gmlVersion;
  if (version2 === "1.0.0") {
    gmlVersion = 2;
  } else if (version2 === "1.1.0") {
    gmlVersion = 3;
  } else if (version2 === "2.0.0") {
    gmlVersion = 3.2;
  }
  var obj = assign({ node: node2 }, {
    version: version2,
    "featureNS": options.featureNS,
    "featureType": options.featureType,
    "featurePrefix": featurePrefix,
    "gmlVersion": gmlVersion,
    "hasZ": options.hasZ,
    "srsName": options.srsName
  }, baseObj);
  return obj;
}
function serializeTransactionRequest(type, features, objectStack, request) {
  pushSerializeAndPop(request, TRANSACTION_SERIALIZERS, makeSimpleNodeFactory(type), features, objectStack);
}
function readTransactionSummary(node2, objectStack) {
  return pushParseAndPop({}, TRANSACTION_SUMMARY_PARSERS, node2, objectStack);
}
var OGC_FID_PARSERS = {
  "http://www.opengis.net/ogc": {
    "FeatureId": makeArrayPusher(function(node2, objectStack) {
      return node2.getAttribute("fid");
    })
  },
  "http://www.opengis.net/ogc/1.1": {
    "FeatureId": makeArrayPusher(function(node2, objectStack) {
      return node2.getAttribute("fid");
    })
  }
};
function fidParser(node2, objectStack) {
  parseNode(OGC_FID_PARSERS, node2, objectStack);
}
var INSERT_RESULTS_PARSERS = {
  "http://www.opengis.net/wfs": {
    "Feature": fidParser
  },
  "http://www.opengis.net/wfs/2.0": {
    "Feature": fidParser
  }
};
function readInsertResults(node2, objectStack) {
  return pushParseAndPop([], INSERT_RESULTS_PARSERS, node2, objectStack);
}
function writeFeature(node2, feature2, objectStack) {
  var context = objectStack[objectStack.length - 1];
  var featureType = context["featureType"];
  var featureNS = context["featureNS"];
  var gmlVersion = context["gmlVersion"];
  var child = createElementNS(featureNS, featureType);
  node2.appendChild(child);
  if (gmlVersion === 2) {
    GML2$1.prototype.writeFeatureElement(child, feature2, objectStack);
  } else if (gmlVersion === 3) {
    GML3$1.prototype.writeFeatureElement(child, feature2, objectStack);
  } else {
    GML32$1.prototype.writeFeatureElement(child, feature2, objectStack);
  }
}
function writeOgcFidFilter(node2, fid, objectStack) {
  var context = objectStack[objectStack.length - 1];
  var version2 = context["version"];
  var ns = OGCNS[version2];
  var filter = createElementNS(ns, "Filter");
  var child = createElementNS(ns, "FeatureId");
  filter.appendChild(child);
  child.setAttribute("fid", fid);
  node2.appendChild(filter);
}
function getTypeName(featurePrefix, featureType) {
  featurePrefix = featurePrefix ? featurePrefix : FEATURE_PREFIX;
  var prefix = featurePrefix + ":";
  if (featureType.indexOf(prefix) === 0) {
    return featureType;
  } else {
    return prefix + featureType;
  }
}
function writeDelete(node2, feature2, objectStack) {
  var context = objectStack[objectStack.length - 1];
  assert(feature2.getId() !== void 0, 26);
  var featureType = context["featureType"];
  var featurePrefix = context["featurePrefix"];
  var featureNS = context["featureNS"];
  var typeName = getTypeName(featurePrefix, featureType);
  node2.setAttribute("typeName", typeName);
  node2.setAttributeNS(XMLNS, "xmlns:" + featurePrefix, featureNS);
  var fid = feature2.getId();
  if (fid !== void 0) {
    writeOgcFidFilter(node2, fid, objectStack);
  }
}
function writeUpdate(node2, feature2, objectStack) {
  var context = objectStack[objectStack.length - 1];
  assert(feature2.getId() !== void 0, 27);
  var version2 = context["version"];
  var featureType = context["featureType"];
  var featurePrefix = context["featurePrefix"];
  var featureNS = context["featureNS"];
  var typeName = getTypeName(featurePrefix, featureType);
  var geometryName = feature2.getGeometryName();
  node2.setAttribute("typeName", typeName);
  node2.setAttributeNS(XMLNS, "xmlns:" + featurePrefix, featureNS);
  var fid = feature2.getId();
  if (fid !== void 0) {
    var keys3 = feature2.getKeys();
    var values2 = [];
    for (var i2 = 0, ii = keys3.length; i2 < ii; i2++) {
      var value = feature2.get(keys3[i2]);
      if (value !== void 0) {
        var name_1 = keys3[i2];
        if (value && typeof value.getSimplifiedGeometry === "function") {
          name_1 = geometryName;
        }
        values2.push({ name: name_1, value });
      }
    }
    pushSerializeAndPop({
      version: version2,
      "gmlVersion": context["gmlVersion"],
      node: node2,
      "hasZ": context["hasZ"],
      "srsName": context["srsName"]
    }, TRANSACTION_SERIALIZERS, makeSimpleNodeFactory("Property"), values2, objectStack);
    writeOgcFidFilter(node2, fid, objectStack);
  }
}
function writeProperty(node2, pair, objectStack) {
  var context = objectStack[objectStack.length - 1];
  var version2 = context["version"];
  var ns = WFSNS[version2];
  var name = createElementNS(ns, "Name");
  var gmlVersion = context["gmlVersion"];
  node2.appendChild(name);
  writeStringTextNode(name, pair.name);
  if (pair.value !== void 0 && pair.value !== null) {
    var value = createElementNS(ns, "Value");
    node2.appendChild(value);
    if (pair.value && typeof pair.value.getSimplifiedGeometry === "function") {
      if (gmlVersion === 2) {
        GML2$1.prototype.writeGeometryElement(value, pair.value, objectStack);
      } else if (gmlVersion === 3) {
        GML3$1.prototype.writeGeometryElement(value, pair.value, objectStack);
      } else {
        GML32$1.prototype.writeGeometryElement(value, pair.value, objectStack);
      }
    } else {
      writeStringTextNode(value, pair.value);
    }
  }
}
function writeNative(node2, nativeElement, objectStack) {
  if (nativeElement.vendorId) {
    node2.setAttribute("vendorId", nativeElement.vendorId);
  }
  if (nativeElement.safeToIgnore !== void 0) {
    node2.setAttribute("safeToIgnore", String(nativeElement.safeToIgnore));
  }
  if (nativeElement.value !== void 0) {
    writeStringTextNode(node2, nativeElement.value);
  }
}
var GETFEATURE_SERIALIZERS = {
  "http://www.opengis.net/wfs": {
    "Query": makeChildAppender(writeQuery)
  },
  "http://www.opengis.net/wfs/2.0": {
    "Query": makeChildAppender(writeQuery)
  },
  "http://www.opengis.net/ogc": {
    "During": makeChildAppender(writeDuringFilter),
    "And": makeChildAppender(writeLogicalFilter),
    "Or": makeChildAppender(writeLogicalFilter),
    "Not": makeChildAppender(writeNotFilter),
    "BBOX": makeChildAppender(writeBboxFilter),
    "Contains": makeChildAppender(writeSpatialFilter),
    "Intersects": makeChildAppender(writeSpatialFilter),
    "Within": makeChildAppender(writeSpatialFilter),
    "DWithin": makeChildAppender(writeDWithinFilter),
    "PropertyIsEqualTo": makeChildAppender(writeComparisonFilter),
    "PropertyIsNotEqualTo": makeChildAppender(writeComparisonFilter),
    "PropertyIsLessThan": makeChildAppender(writeComparisonFilter),
    "PropertyIsLessThanOrEqualTo": makeChildAppender(writeComparisonFilter),
    "PropertyIsGreaterThan": makeChildAppender(writeComparisonFilter),
    "PropertyIsGreaterThanOrEqualTo": makeChildAppender(writeComparisonFilter),
    "PropertyIsNull": makeChildAppender(writeIsNullFilter),
    "PropertyIsBetween": makeChildAppender(writeIsBetweenFilter),
    "PropertyIsLike": makeChildAppender(writeIsLikeFilter)
  },
  "http://www.opengis.net/fes/2.0": {
    "During": makeChildAppender(writeDuringFilter),
    "And": makeChildAppender(writeLogicalFilter),
    "Or": makeChildAppender(writeLogicalFilter),
    "Not": makeChildAppender(writeNotFilter),
    "BBOX": makeChildAppender(writeBboxFilter),
    "Contains": makeChildAppender(writeSpatialFilter),
    "Disjoint": makeChildAppender(writeSpatialFilter),
    "Intersects": makeChildAppender(writeSpatialFilter),
    "ResourceId": makeChildAppender(writeResourceIdFilter),
    "Within": makeChildAppender(writeSpatialFilter),
    "DWithin": makeChildAppender(writeDWithinFilter),
    "PropertyIsEqualTo": makeChildAppender(writeComparisonFilter),
    "PropertyIsNotEqualTo": makeChildAppender(writeComparisonFilter),
    "PropertyIsLessThan": makeChildAppender(writeComparisonFilter),
    "PropertyIsLessThanOrEqualTo": makeChildAppender(writeComparisonFilter),
    "PropertyIsGreaterThan": makeChildAppender(writeComparisonFilter),
    "PropertyIsGreaterThanOrEqualTo": makeChildAppender(writeComparisonFilter),
    "PropertyIsNull": makeChildAppender(writeIsNullFilter),
    "PropertyIsBetween": makeChildAppender(writeIsBetweenFilter),
    "PropertyIsLike": makeChildAppender(writeIsLikeFilter)
  }
};
function writeQuery(node2, featureType, objectStack) {
  var context = objectStack[objectStack.length - 1];
  var version2 = context["version"];
  var featurePrefix = context["featurePrefix"];
  var featureNS = context["featureNS"];
  var propertyNames = context["propertyNames"];
  var srsName = context["srsName"];
  var typeName;
  if (featurePrefix) {
    typeName = getTypeName(featurePrefix, featureType);
  } else {
    typeName = featureType;
  }
  var typeNameAttr;
  if (version2 === "2.0.0") {
    typeNameAttr = "typeNames";
  } else {
    typeNameAttr = "typeName";
  }
  node2.setAttribute(typeNameAttr, typeName);
  if (srsName) {
    node2.setAttribute("srsName", srsName);
  }
  if (featureNS) {
    node2.setAttributeNS(XMLNS, "xmlns:" + featurePrefix, featureNS);
  }
  var item = assign({}, context);
  item.node = node2;
  pushSerializeAndPop(item, QUERY_SERIALIZERS, makeSimpleNodeFactory("PropertyName"), propertyNames, objectStack);
  var filter = context["filter"];
  if (filter) {
    var child = createElementNS(getFilterNS(version2), "Filter");
    node2.appendChild(child);
    writeFilterCondition(child, filter, objectStack);
  }
}
function writeFilterCondition(node2, filter, objectStack) {
  var context = objectStack[objectStack.length - 1];
  var item = { node: node2 };
  assign(item, { context });
  pushSerializeAndPop(item, GETFEATURE_SERIALIZERS, makeSimpleNodeFactory(filter.getTagName()), [filter], objectStack);
}
function writeBboxFilter(node2, filter, objectStack) {
  var parent = objectStack[objectStack.length - 1];
  var context = parent["context"];
  var version2 = context["version"];
  parent["srsName"] = filter.srsName;
  var format2 = GML_FORMATS[version2];
  writePropertyName(version2, node2, filter.geometryName);
  format2.prototype.writeGeometryElement(node2, filter.extent, objectStack);
}
function writeResourceIdFilter(node2, filter, objectStack) {
  node2.setAttribute("rid", filter.rid);
}
function writeSpatialFilter(node2, filter, objectStack) {
  var parent = objectStack[objectStack.length - 1];
  var context = parent["context"];
  var version2 = context["version"];
  parent["srsName"] = filter.srsName;
  var format2 = GML_FORMATS[version2];
  writePropertyName(version2, node2, filter.geometryName);
  format2.prototype.writeGeometryElement(node2, filter.geometry, objectStack);
}
function writeDWithinFilter(node2, filter, objectStack) {
  var parent = objectStack[objectStack.length - 1];
  var context = parent["context"];
  var version2 = context["version"];
  writeSpatialFilter(node2, filter, objectStack);
  var distance2 = createElementNS(getFilterNS(version2), "Distance");
  writeStringTextNode(distance2, filter.distance.toString());
  if (version2 === "2.0.0") {
    distance2.setAttribute("uom", filter.unit);
  } else {
    distance2.setAttribute("units", filter.unit);
  }
  node2.appendChild(distance2);
}
function writeDuringFilter(node2, filter, objectStack) {
  var parent = objectStack[objectStack.length - 1];
  var context = parent["context"];
  var version2 = context["version"];
  writeExpression(FESNS[version2], "ValueReference", node2, filter.propertyName);
  var timePeriod = createElementNS(GMLNS, "TimePeriod");
  node2.appendChild(timePeriod);
  var begin = createElementNS(GMLNS, "begin");
  timePeriod.appendChild(begin);
  writeTimeInstant(begin, filter.begin);
  var end = createElementNS(GMLNS, "end");
  timePeriod.appendChild(end);
  writeTimeInstant(end, filter.end);
}
function writeLogicalFilter(node2, filter, objectStack) {
  var parent = objectStack[objectStack.length - 1];
  var context = parent["context"];
  var item = { node: node2 };
  assign(item, { context });
  var conditions = filter.conditions;
  for (var i2 = 0, ii = conditions.length; i2 < ii; ++i2) {
    var condition = conditions[i2];
    pushSerializeAndPop(item, GETFEATURE_SERIALIZERS, makeSimpleNodeFactory(condition.getTagName()), [condition], objectStack);
  }
}
function writeNotFilter(node2, filter, objectStack) {
  var parent = objectStack[objectStack.length - 1];
  var context = parent["context"];
  var item = { node: node2 };
  assign(item, { context });
  var condition = filter.condition;
  pushSerializeAndPop(item, GETFEATURE_SERIALIZERS, makeSimpleNodeFactory(condition.getTagName()), [condition], objectStack);
}
function writeComparisonFilter(node2, filter, objectStack) {
  var parent = objectStack[objectStack.length - 1];
  var context = parent["context"];
  var version2 = context["version"];
  if (filter.matchCase !== void 0) {
    node2.setAttribute("matchCase", filter.matchCase.toString());
  }
  writePropertyName(version2, node2, filter.propertyName);
  writeLiteral(version2, node2, "" + filter.expression);
}
function writeIsNullFilter(node2, filter, objectStack) {
  var parent = objectStack[objectStack.length - 1];
  var context = parent["context"];
  var version2 = context["version"];
  writePropertyName(version2, node2, filter.propertyName);
}
function writeIsBetweenFilter(node2, filter, objectStack) {
  var parent = objectStack[objectStack.length - 1];
  var context = parent["context"];
  var version2 = context["version"];
  var ns = getFilterNS(version2);
  writePropertyName(version2, node2, filter.propertyName);
  var lowerBoundary = createElementNS(ns, "LowerBoundary");
  node2.appendChild(lowerBoundary);
  writeLiteral(version2, lowerBoundary, "" + filter.lowerBoundary);
  var upperBoundary = createElementNS(ns, "UpperBoundary");
  node2.appendChild(upperBoundary);
  writeLiteral(version2, upperBoundary, "" + filter.upperBoundary);
}
function writeIsLikeFilter(node2, filter, objectStack) {
  var parent = objectStack[objectStack.length - 1];
  var context = parent["context"];
  var version2 = context["version"];
  node2.setAttribute("wildCard", filter.wildCard);
  node2.setAttribute("singleChar", filter.singleChar);
  node2.setAttribute("escapeChar", filter.escapeChar);
  if (filter.matchCase !== void 0) {
    node2.setAttribute("matchCase", filter.matchCase.toString());
  }
  writePropertyName(version2, node2, filter.propertyName);
  writeLiteral(version2, node2, "" + filter.pattern);
}
function writeExpression(ns, tagName, node2, value) {
  var property = createElementNS(ns, tagName);
  writeStringTextNode(property, value);
  node2.appendChild(property);
}
function writeLiteral(version2, node2, value) {
  writeExpression(getFilterNS(version2), "Literal", node2, value);
}
function writePropertyName(version2, node2, value) {
  if (version2 === "2.0.0") {
    writeExpression(FESNS[version2], "ValueReference", node2, value);
  } else {
    writeExpression(OGCNS[version2], "PropertyName", node2, value);
  }
}
function writeTimeInstant(node2, time2) {
  var timeInstant = createElementNS(GMLNS, "TimeInstant");
  node2.appendChild(timeInstant);
  var timePosition = createElementNS(GMLNS, "timePosition");
  timeInstant.appendChild(timePosition);
  writeStringTextNode(timePosition, time2);
}
function writeGetFeature(node2, featureTypes, objectStack) {
  var context = objectStack[objectStack.length - 1];
  var item = assign({}, context);
  item.node = node2;
  pushSerializeAndPop(item, GETFEATURE_SERIALIZERS, makeSimpleNodeFactory("Query"), featureTypes, objectStack);
}
function getFilterNS(version2) {
  var ns;
  if (version2 === "2.0.0") {
    ns = FESNS[version2];
  } else {
    ns = OGCNS[version2];
  }
  return ns;
}
var WFS$1 = WFS;
var __extends$5 = globalThis && globalThis.__extends || function() {
  var extendStatics2 = function(d2, b2) {
    extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {
      d3.__proto__ = b3;
    } || function(d3, b3) {
      for (var p5 in b3)
        if (Object.prototype.hasOwnProperty.call(b3, p5))
          d3[p5] = b3[p5];
    };
    return extendStatics2(d2, b2);
  };
  return function(d2, b2) {
    if (typeof b2 !== "function" && b2 !== null)
      throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
    extendStatics2(d2, b2);
    function __() {
      this.constructor = d2;
    }
    d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
  };
}();
var WKBGeometryType = {
  POINT: 1,
  LINE_STRING: 2,
  POLYGON: 3,
  MULTI_POINT: 4,
  MULTI_LINE_STRING: 5,
  MULTI_POLYGON: 6,
  GEOMETRY_COLLECTION: 7,
  POLYHEDRAL_SURFACE: 15,
  TIN: 16,
  TRIANGLE: 17
};
var WkbReader = function() {
  function WkbReader2(view) {
    this.view_ = view;
    this.pos_ = 0;
    this.initialized_ = false;
    this.isLittleEndian_ = false;
    this.hasZ_ = false;
    this.hasM_ = false;
    this.srid_ = null;
    this.layout_ = GeometryLayout.XY;
  }
  WkbReader2.prototype.readUint8 = function() {
    return this.view_.getUint8(this.pos_++);
  };
  WkbReader2.prototype.readUint32 = function(isLittleEndian) {
    return this.view_.getUint32((this.pos_ += 4) - 4, isLittleEndian !== void 0 ? isLittleEndian : this.isLittleEndian_);
  };
  WkbReader2.prototype.readDouble = function(isLittleEndian) {
    return this.view_.getFloat64((this.pos_ += 8) - 8, isLittleEndian !== void 0 ? isLittleEndian : this.isLittleEndian_);
  };
  WkbReader2.prototype.readPoint = function() {
    var coords = [];
    coords.push(this.readDouble());
    coords.push(this.readDouble());
    if (this.hasZ_) {
      coords.push(this.readDouble());
    }
    if (this.hasM_) {
      coords.push(this.readDouble());
    }
    return coords;
  };
  WkbReader2.prototype.readLineString = function() {
    var numPoints = this.readUint32();
    var coords = [];
    for (var i2 = 0; i2 < numPoints; i2++) {
      coords.push(this.readPoint());
    }
    return coords;
  };
  WkbReader2.prototype.readPolygon = function() {
    var numRings = this.readUint32();
    var rings = [];
    for (var i2 = 0; i2 < numRings; i2++) {
      rings.push(this.readLineString());
    }
    return rings;
  };
  WkbReader2.prototype.readWkbHeader = function(expectedTypeId) {
    var byteOrder = this.readUint8();
    var isLittleEndian = byteOrder > 0;
    var wkbType = this.readUint32(isLittleEndian);
    var wkbTypeThousandth = Math.floor((wkbType & 268435455) / 1e3);
    var hasZ = Boolean(wkbType & 2147483648) || wkbTypeThousandth === 1 || wkbTypeThousandth === 3;
    var hasM = Boolean(wkbType & 1073741824) || wkbTypeThousandth === 2 || wkbTypeThousandth === 3;
    var hasSRID = Boolean(wkbType & 536870912);
    var typeId = (wkbType & 268435455) % 1e3;
    var layout = ["XY", hasZ ? "Z" : "", hasM ? "M" : ""].join("");
    var srid = hasSRID ? this.readUint32(isLittleEndian) : null;
    if (expectedTypeId !== void 0 && expectedTypeId !== typeId) {
      throw new Error("Unexpected WKB geometry type " + typeId);
    }
    if (this.initialized_) {
      if (this.isLittleEndian_ !== isLittleEndian) {
        throw new Error("Inconsistent endian");
      }
      if (this.layout_ !== layout) {
        throw new Error("Inconsistent geometry layout");
      }
      if (srid && this.srid_ !== srid) {
        throw new Error("Inconsistent coordinate system (SRID)");
      }
    } else {
      this.isLittleEndian_ = isLittleEndian;
      this.hasZ_ = hasZ;
      this.hasM_ = hasM;
      this.layout_ = layout;
      this.srid_ = srid;
      this.initialized_ = true;
    }
    return typeId;
  };
  WkbReader2.prototype.readWkbPayload = function(typeId) {
    switch (typeId) {
      case WKBGeometryType.POINT:
        return this.readPoint();
      case WKBGeometryType.LINE_STRING:
        return this.readLineString();
      case WKBGeometryType.POLYGON:
      case WKBGeometryType.TRIANGLE:
        return this.readPolygon();
      case WKBGeometryType.MULTI_POINT:
        return this.readMultiPoint();
      case WKBGeometryType.MULTI_LINE_STRING:
        return this.readMultiLineString();
      case WKBGeometryType.MULTI_POLYGON:
      case WKBGeometryType.POLYHEDRAL_SURFACE:
      case WKBGeometryType.TIN:
        return this.readMultiPolygon();
      case WKBGeometryType.GEOMETRY_COLLECTION:
        return this.readGeometryCollection();
      default:
        throw new Error("Unsupported WKB geometry type " + typeId + " is found");
    }
  };
  WkbReader2.prototype.readWkbBlock = function(expectedTypeId) {
    return this.readWkbPayload(this.readWkbHeader(expectedTypeId));
  };
  WkbReader2.prototype.readWkbCollection = function(reader, expectedTypeId) {
    var num = this.readUint32();
    var items = [];
    for (var i2 = 0; i2 < num; i2++) {
      var result = reader.call(this, expectedTypeId);
      if (result) {
        items.push(result);
      }
    }
    return items;
  };
  WkbReader2.prototype.readMultiPoint = function() {
    return this.readWkbCollection(this.readWkbBlock, WKBGeometryType.POINT);
  };
  WkbReader2.prototype.readMultiLineString = function() {
    return this.readWkbCollection(this.readWkbBlock, WKBGeometryType.LINE_STRING);
  };
  WkbReader2.prototype.readMultiPolygon = function() {
    return this.readWkbCollection(this.readWkbBlock, WKBGeometryType.POLYGON);
  };
  WkbReader2.prototype.readGeometryCollection = function() {
    return this.readWkbCollection(this.readGeometry);
  };
  WkbReader2.prototype.readGeometry = function() {
    var typeId = this.readWkbHeader();
    var result = this.readWkbPayload(typeId);
    switch (typeId) {
      case WKBGeometryType.POINT:
        return new Point$4(result, this.layout_);
      case WKBGeometryType.LINE_STRING:
        return new LineString$2(result, this.layout_);
      case WKBGeometryType.POLYGON:
      case WKBGeometryType.TRIANGLE:
        return new Polygon$2(result, this.layout_);
      case WKBGeometryType.MULTI_POINT:
        return new MultiPoint$2(result, this.layout_);
      case WKBGeometryType.MULTI_LINE_STRING:
        return new MultiLineString$2(result, this.layout_);
      case WKBGeometryType.MULTI_POLYGON:
      case WKBGeometryType.POLYHEDRAL_SURFACE:
      case WKBGeometryType.TIN:
        return new MultiPolygon$2(result, this.layout_);
      case WKBGeometryType.GEOMETRY_COLLECTION:
        return new GeometryCollection$1(result);
      default:
        return null;
    }
  };
  WkbReader2.prototype.getSrid = function() {
    return this.srid_;
  };
  return WkbReader2;
}();
var WkbWriter = function() {
  function WkbWriter2(opts) {
    opts = opts || {};
    this.layout_ = opts.layout;
    this.isLittleEndian_ = opts.littleEndian !== false;
    this.isEWKB_ = opts.ewkb !== false;
    this.writeQueue_ = [];
    this.nodata_ = assign({ X: 0, Y: 0, Z: 0, M: 0 }, opts.nodata);
  }
  WkbWriter2.prototype.writeUint8 = function(value) {
    this.writeQueue_.push([1, value]);
  };
  WkbWriter2.prototype.writeUint32 = function(value) {
    this.writeQueue_.push([4, value]);
  };
  WkbWriter2.prototype.writeDouble = function(value) {
    this.writeQueue_.push([8, value]);
  };
  WkbWriter2.prototype.writePoint = function(coords, layout) {
    var coordsObj = assign.apply(null, layout.split("").map(function(axis2, idx) {
      var _a3;
      return _a3 = {}, _a3[axis2] = coords[idx], _a3;
    }));
    for (var _i = 0, _a2 = this.layout_; _i < _a2.length; _i++) {
      var axis = _a2[_i];
      this.writeDouble(axis in coordsObj ? coordsObj[axis] : this.nodata_[axis]);
    }
  };
  WkbWriter2.prototype.writeLineString = function(coords, layout) {
    this.writeUint32(coords.length);
    for (var i2 = 0; i2 < coords.length; i2++) {
      this.writePoint(coords[i2], layout);
    }
  };
  WkbWriter2.prototype.writePolygon = function(rings, layout) {
    this.writeUint32(rings.length);
    for (var i2 = 0; i2 < rings.length; i2++) {
      this.writeLineString(rings[i2], layout);
    }
  };
  WkbWriter2.prototype.writeWkbHeader = function(wkbType, srid) {
    wkbType %= 1e3;
    if (this.layout_.indexOf("Z") >= 0) {
      wkbType += this.isEWKB_ ? 2147483648 : 1e3;
    }
    if (this.layout_.indexOf("M") >= 0) {
      wkbType += this.isEWKB_ ? 1073741824 : 2e3;
    }
    if (this.isEWKB_ && Number.isInteger(srid)) {
      wkbType |= 536870912;
    }
    this.writeUint8(this.isLittleEndian_ ? 1 : 0);
    this.writeUint32(wkbType);
    if (this.isEWKB_ && Number.isInteger(srid)) {
      this.writeUint32(srid);
    }
  };
  WkbWriter2.prototype.writeMultiPoint = function(coords, layout) {
    this.writeUint32(coords.length);
    for (var i2 = 0; i2 < coords.length; i2++) {
      this.writeWkbHeader(1);
      this.writePoint(coords[i2], layout);
    }
  };
  WkbWriter2.prototype.writeMultiLineString = function(coords, layout) {
    this.writeUint32(coords.length);
    for (var i2 = 0; i2 < coords.length; i2++) {
      this.writeWkbHeader(2);
      this.writeLineString(coords[i2], layout);
    }
  };
  WkbWriter2.prototype.writeMultiPolygon = function(coords, layout) {
    this.writeUint32(coords.length);
    for (var i2 = 0; i2 < coords.length; i2++) {
      this.writeWkbHeader(3);
      this.writePolygon(coords[i2], layout);
    }
  };
  WkbWriter2.prototype.writeGeometryCollection = function(geometries) {
    this.writeUint32(geometries.length);
    for (var i2 = 0; i2 < geometries.length; i2++) {
      this.writeGeometry(geometries[i2]);
    }
  };
  WkbWriter2.prototype.findMinimumLayout = function(geom2, layout) {
    if (layout === void 0) {
      layout = GeometryLayout.XYZM;
    }
    var GeometryLayout_min = function(a2, b2) {
      if (a2 === b2) {
        return a2;
      }
      if (a2 === GeometryLayout.XYZM) {
        return b2;
      }
      if (b2 === GeometryLayout.XYZM) {
        return a2;
      }
      return GeometryLayout.XY;
    };
    if (geom2 instanceof SimpleGeometry$1) {
      return GeometryLayout_min(geom2.getLayout(), layout);
    }
    if (geom2 instanceof GeometryCollection$1) {
      var geoms = geom2.getGeometriesArray();
      for (var i2 = 0; i2 < geoms.length && layout !== GeometryLayout.XY; i2++) {
        layout = this.findMinimumLayout(geoms[i2], layout);
      }
    }
    return layout;
  };
  WkbWriter2.prototype.writeGeometry = function(geom2, srid) {
    var _a2, _b2;
    var wkblut = (_a2 = {}, _a2[GeometryType.POINT] = WKBGeometryType.POINT, _a2[GeometryType.LINE_STRING] = WKBGeometryType.LINE_STRING, _a2[GeometryType.POLYGON] = WKBGeometryType.POLYGON, _a2[GeometryType.MULTI_POINT] = WKBGeometryType.MULTI_POINT, _a2[GeometryType.MULTI_LINE_STRING] = WKBGeometryType.MULTI_LINE_STRING, _a2[GeometryType.MULTI_POLYGON] = WKBGeometryType.MULTI_POLYGON, _a2[GeometryType.GEOMETRY_COLLECTION] = WKBGeometryType.GEOMETRY_COLLECTION, _a2);
    var geomType = geom2.getType();
    var typeId = wkblut[geomType];
    if (!typeId) {
      throw new Error("GeometryType " + geomType + " is not supported");
    }
    if (!this.layout_) {
      this.layout_ = this.findMinimumLayout(geom2);
    }
    this.writeWkbHeader(typeId, srid);
    if (geom2 instanceof SimpleGeometry$1) {
      var writerLUT = (_b2 = {}, _b2[GeometryType.POINT] = this.writePoint, _b2[GeometryType.LINE_STRING] = this.writeLineString, _b2[GeometryType.POLYGON] = this.writePolygon, _b2[GeometryType.MULTI_POINT] = this.writeMultiPoint, _b2[GeometryType.MULTI_LINE_STRING] = this.writeMultiLineString, _b2[GeometryType.MULTI_POLYGON] = this.writeMultiPolygon, _b2);
      writerLUT[geomType].call(this, geom2.getCoordinates(), geom2.getLayout());
    } else if (geom2 instanceof GeometryCollection$1) {
      this.writeGeometryCollection(geom2.getGeometriesArray());
    }
  };
  WkbWriter2.prototype.getBuffer = function() {
    var _this = this;
    var byteLength = this.writeQueue_.reduce(function(acc, item) {
      return acc + item[0];
    }, 0);
    var buffer2 = new ArrayBuffer(byteLength);
    var view = new DataView(buffer2);
    var pos = 0;
    this.writeQueue_.forEach(function(item) {
      switch (item[0]) {
        case 1:
          view.setUint8(pos, item[1]);
          break;
        case 4:
          view.setUint32(pos, item[1], _this.isLittleEndian_);
          break;
        case 8:
          view.setFloat64(pos, item[1], _this.isLittleEndian_);
          break;
      }
      pos += item[0];
    });
    return buffer2;
  };
  return WkbWriter2;
}();
var WKB = function(_super) {
  __extends$5(WKB2, _super);
  function WKB2(opt_options) {
    var _this = _super.call(this) || this;
    var options = opt_options ? opt_options : {};
    _this.splitCollection = Boolean(options.splitCollection);
    _this.viewCache_ = null;
    _this.hex_ = options.hex !== false;
    _this.littleEndian_ = options.littleEndian !== false;
    _this.ewkb_ = options.ewkb !== false;
    _this.layout_ = options.geometryLayout;
    _this.nodataZ_ = options.nodataZ || 0;
    _this.nodataM_ = options.nodataM || 0;
    _this.srid_ = options.srid;
    return _this;
  }
  WKB2.prototype.getType = function() {
    return this.hex_ ? FormatType.TEXT : FormatType.ARRAY_BUFFER;
  };
  WKB2.prototype.readFeature = function(source, opt_options) {
    return new feature({
      geometry: this.readGeometry(source, opt_options)
    });
  };
  WKB2.prototype.readFeatures = function(source, opt_options) {
    var geometries = [];
    var geometry = this.readGeometry(source, opt_options);
    if (this.splitCollection && geometry instanceof GeometryCollection$1) {
      geometries = geometry.getGeometriesArray();
    } else {
      geometries = [geometry];
    }
    return geometries.map(function(geometry2) {
      return new feature({ geometry: geometry2 });
    });
  };
  WKB2.prototype.readGeometry = function(source, opt_options) {
    var view = getDataView(source);
    if (!view) {
      return null;
    }
    var reader = new WkbReader(view);
    var geometry = reader.readGeometry();
    this.viewCache_ = view;
    var options = this.getReadOptions(source, opt_options);
    this.viewCache_ = null;
    return transformGeometryWithOptions(geometry, false, options);
  };
  WKB2.prototype.readProjection = function(source) {
    var view = this.viewCache_ || getDataView(source);
    if (!view) {
      return void 0;
    }
    var reader = new WkbReader(view);
    reader.readWkbHeader();
    return reader.getSrid() && get$3("EPSG:" + reader.getSrid()) || void 0;
  };
  WKB2.prototype.writeFeature = function(feature2, opt_options) {
    return this.writeGeometry(feature2.getGeometry(), opt_options);
  };
  WKB2.prototype.writeFeatures = function(features, opt_options) {
    return this.writeGeometry(new GeometryCollection$1(features.map(function(f2) {
      return f2.getGeometry();
    })), opt_options);
  };
  WKB2.prototype.writeGeometry = function(geometry, opt_options) {
    var options = this.adaptOptions(opt_options);
    var writer = new WkbWriter({
      layout: this.layout_,
      littleEndian: this.littleEndian_,
      ewkb: this.ewkb_,
      nodata: {
        Z: this.nodataZ_,
        M: this.nodataM_
      }
    });
    var srid = Number.isInteger(this.srid_) ? Number(this.srid_) : null;
    if (this.srid_ !== false && !Number.isInteger(this.srid_)) {
      var dataProjection = options.dataProjection && get$3(options.dataProjection);
      if (dataProjection) {
        var code = dataProjection.getCode();
        if (code.indexOf("EPSG:") === 0) {
          srid = Number(code.substring(5));
        }
      }
    }
    writer.writeGeometry(transformGeometryWithOptions(geometry, true, options), srid);
    var buffer2 = writer.getBuffer();
    return this.hex_ ? encodeHexString(buffer2) : buffer2;
  };
  return WKB2;
}(FeatureFormat$1);
function encodeHexString(buffer2) {
  var view = new Uint8Array(buffer2);
  return Array.from(view.values()).map(function(x2) {
    return (x2 < 16 ? "0" : "") + Number(x2).toString(16).toUpperCase();
  }).join("");
}
function decodeHexString(text2) {
  var buffer2 = new Uint8Array(text2.length / 2);
  for (var i2 = 0; i2 < text2.length / 2; i2++) {
    buffer2[i2] = parseInt(text2.substr(i2 * 2, 2), 16);
  }
  return new DataView(buffer2.buffer);
}
function getDataView(source) {
  if (typeof source === "string") {
    return decodeHexString(source);
  } else if (ArrayBuffer.isView(source)) {
    if (source instanceof DataView) {
      return source;
    }
    return new DataView(source.buffer, source.byteOffset, source.byteLength);
  } else if (source instanceof ArrayBuffer) {
    return new DataView(source);
  } else {
    return null;
  }
}
var WKB$1 = WKB;
var __extends$4 = globalThis && globalThis.__extends || function() {
  var extendStatics2 = function(d2, b2) {
    extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {
      d3.__proto__ = b3;
    } || function(d3, b3) {
      for (var p5 in b3)
        if (Object.prototype.hasOwnProperty.call(b3, p5))
          d3[p5] = b3[p5];
    };
    return extendStatics2(d2, b2);
  };
  return function(d2, b2) {
    if (typeof b2 !== "function" && b2 !== null)
      throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
    extendStatics2(d2, b2);
    function __() {
      this.constructor = d2;
    }
    d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
  };
}();
var GeometryConstructor = {
  "POINT": Point$4,
  "LINESTRING": LineString$2,
  "POLYGON": Polygon$2,
  "MULTIPOINT": MultiPoint$2,
  "MULTILINESTRING": MultiLineString$2,
  "MULTIPOLYGON": MultiPolygon$2
};
var EMPTY = "EMPTY";
var Z$1 = "Z";
var M = "M";
var ZM = "ZM";
var TokenType = {
  START: 0,
  TEXT: 1,
  LEFT_PAREN: 2,
  RIGHT_PAREN: 3,
  NUMBER: 4,
  COMMA: 5,
  EOF: 6
};
for (type in GeometryType) {
  GeometryType[type].toUpperCase();
}
var type;
var Lexer = function() {
  function Lexer2(wkt2) {
    this.wkt = wkt2;
    this.index_ = -1;
  }
  Lexer2.prototype.isAlpha_ = function(c2) {
    return c2 >= "a" && c2 <= "z" || c2 >= "A" && c2 <= "Z";
  };
  Lexer2.prototype.isNumeric_ = function(c2, opt_decimal) {
    var decimal = opt_decimal !== void 0 ? opt_decimal : false;
    return c2 >= "0" && c2 <= "9" || c2 == "." && !decimal;
  };
  Lexer2.prototype.isWhiteSpace_ = function(c2) {
    return c2 == " " || c2 == "	" || c2 == "\r" || c2 == "\n";
  };
  Lexer2.prototype.nextChar_ = function() {
    return this.wkt.charAt(++this.index_);
  };
  Lexer2.prototype.nextToken = function() {
    var c2 = this.nextChar_();
    var position2 = this.index_;
    var value = c2;
    var type;
    if (c2 == "(") {
      type = TokenType.LEFT_PAREN;
    } else if (c2 == ",") {
      type = TokenType.COMMA;
    } else if (c2 == ")") {
      type = TokenType.RIGHT_PAREN;
    } else if (this.isNumeric_(c2) || c2 == "-") {
      type = TokenType.NUMBER;
      value = this.readNumber_();
    } else if (this.isAlpha_(c2)) {
      type = TokenType.TEXT;
      value = this.readText_();
    } else if (this.isWhiteSpace_(c2)) {
      return this.nextToken();
    } else if (c2 === "") {
      type = TokenType.EOF;
    } else {
      throw new Error("Unexpected character: " + c2);
    }
    return { position: position2, value, type };
  };
  Lexer2.prototype.readNumber_ = function() {
    var c2;
    var index2 = this.index_;
    var decimal = false;
    var scientificNotation = false;
    do {
      if (c2 == ".") {
        decimal = true;
      } else if (c2 == "e" || c2 == "E") {
        scientificNotation = true;
      }
      c2 = this.nextChar_();
    } while (this.isNumeric_(c2, decimal) || !scientificNotation && (c2 == "e" || c2 == "E") || scientificNotation && (c2 == "-" || c2 == "+"));
    return parseFloat(this.wkt.substring(index2, this.index_--));
  };
  Lexer2.prototype.readText_ = function() {
    var c2;
    var index2 = this.index_;
    do {
      c2 = this.nextChar_();
    } while (this.isAlpha_(c2));
    return this.wkt.substring(index2, this.index_--).toUpperCase();
  };
  return Lexer2;
}();
var Parser$2 = function() {
  function Parser2(lexer) {
    this.lexer_ = lexer;
    this.token_ = {
      position: 0,
      type: TokenType.START
    };
    this.layout_ = GeometryLayout.XY;
  }
  Parser2.prototype.consume_ = function() {
    this.token_ = this.lexer_.nextToken();
  };
  Parser2.prototype.isTokenType = function(type) {
    return this.token_.type == type;
  };
  Parser2.prototype.match = function(type) {
    var isMatch = this.isTokenType(type);
    if (isMatch) {
      this.consume_();
    }
    return isMatch;
  };
  Parser2.prototype.parse = function() {
    this.consume_();
    return this.parseGeometry_();
  };
  Parser2.prototype.parseGeometryLayout_ = function() {
    var layout = GeometryLayout.XY;
    var dimToken = this.token_;
    if (this.isTokenType(TokenType.TEXT)) {
      var dimInfo = dimToken.value;
      if (dimInfo === Z$1) {
        layout = GeometryLayout.XYZ;
      } else if (dimInfo === M) {
        layout = GeometryLayout.XYM;
      } else if (dimInfo === ZM) {
        layout = GeometryLayout.XYZM;
      }
      if (layout !== GeometryLayout.XY) {
        this.consume_();
      }
    }
    return layout;
  };
  Parser2.prototype.parseGeometryCollectionText_ = function() {
    if (this.match(TokenType.LEFT_PAREN)) {
      var geometries = [];
      do {
        geometries.push(this.parseGeometry_());
      } while (this.match(TokenType.COMMA));
      if (this.match(TokenType.RIGHT_PAREN)) {
        return geometries;
      }
    }
    throw new Error(this.formatErrorMessage_());
  };
  Parser2.prototype.parsePointText_ = function() {
    if (this.match(TokenType.LEFT_PAREN)) {
      var coordinates2 = this.parsePoint_();
      if (this.match(TokenType.RIGHT_PAREN)) {
        return coordinates2;
      }
    }
    throw new Error(this.formatErrorMessage_());
  };
  Parser2.prototype.parseLineStringText_ = function() {
    if (this.match(TokenType.LEFT_PAREN)) {
      var coordinates2 = this.parsePointList_();
      if (this.match(TokenType.RIGHT_PAREN)) {
        return coordinates2;
      }
    }
    throw new Error(this.formatErrorMessage_());
  };
  Parser2.prototype.parsePolygonText_ = function() {
    if (this.match(TokenType.LEFT_PAREN)) {
      var coordinates2 = this.parseLineStringTextList_();
      if (this.match(TokenType.RIGHT_PAREN)) {
        return coordinates2;
      }
    }
    throw new Error(this.formatErrorMessage_());
  };
  Parser2.prototype.parseMultiPointText_ = function() {
    if (this.match(TokenType.LEFT_PAREN)) {
      var coordinates2 = void 0;
      if (this.token_.type == TokenType.LEFT_PAREN) {
        coordinates2 = this.parsePointTextList_();
      } else {
        coordinates2 = this.parsePointList_();
      }
      if (this.match(TokenType.RIGHT_PAREN)) {
        return coordinates2;
      }
    }
    throw new Error(this.formatErrorMessage_());
  };
  Parser2.prototype.parseMultiLineStringText_ = function() {
    if (this.match(TokenType.LEFT_PAREN)) {
      var coordinates2 = this.parseLineStringTextList_();
      if (this.match(TokenType.RIGHT_PAREN)) {
        return coordinates2;
      }
    }
    throw new Error(this.formatErrorMessage_());
  };
  Parser2.prototype.parseMultiPolygonText_ = function() {
    if (this.match(TokenType.LEFT_PAREN)) {
      var coordinates2 = this.parsePolygonTextList_();
      if (this.match(TokenType.RIGHT_PAREN)) {
        return coordinates2;
      }
    }
    throw new Error(this.formatErrorMessage_());
  };
  Parser2.prototype.parsePoint_ = function() {
    var coordinates2 = [];
    var dimensions = this.layout_.length;
    for (var i2 = 0; i2 < dimensions; ++i2) {
      var token = this.token_;
      if (this.match(TokenType.NUMBER)) {
        coordinates2.push(token.value);
      } else {
        break;
      }
    }
    if (coordinates2.length == dimensions) {
      return coordinates2;
    }
    throw new Error(this.formatErrorMessage_());
  };
  Parser2.prototype.parsePointList_ = function() {
    var coordinates2 = [this.parsePoint_()];
    while (this.match(TokenType.COMMA)) {
      coordinates2.push(this.parsePoint_());
    }
    return coordinates2;
  };
  Parser2.prototype.parsePointTextList_ = function() {
    var coordinates2 = [this.parsePointText_()];
    while (this.match(TokenType.COMMA)) {
      coordinates2.push(this.parsePointText_());
    }
    return coordinates2;
  };
  Parser2.prototype.parseLineStringTextList_ = function() {
    var coordinates2 = [this.parseLineStringText_()];
    while (this.match(TokenType.COMMA)) {
      coordinates2.push(this.parseLineStringText_());
    }
    return coordinates2;
  };
  Parser2.prototype.parsePolygonTextList_ = function() {
    var coordinates2 = [this.parsePolygonText_()];
    while (this.match(TokenType.COMMA)) {
      coordinates2.push(this.parsePolygonText_());
    }
    return coordinates2;
  };
  Parser2.prototype.isEmptyGeometry_ = function() {
    var isEmpty2 = this.isTokenType(TokenType.TEXT) && this.token_.value == EMPTY;
    if (isEmpty2) {
      this.consume_();
    }
    return isEmpty2;
  };
  Parser2.prototype.formatErrorMessage_ = function() {
    return "Unexpected `" + this.token_.value + "` at position " + this.token_.position + " in `" + this.lexer_.wkt + "`";
  };
  Parser2.prototype.parseGeometry_ = function() {
    var token = this.token_;
    if (this.match(TokenType.TEXT)) {
      var geomType = token.value;
      this.layout_ = this.parseGeometryLayout_();
      var isEmpty2 = this.isEmptyGeometry_();
      if (geomType == "GEOMETRYCOLLECTION") {
        if (isEmpty2) {
          return new GeometryCollection$1([]);
        }
        var geometries = this.parseGeometryCollectionText_();
        return new GeometryCollection$1(geometries);
      } else {
        var ctor = GeometryConstructor[geomType];
        if (!ctor) {
          throw new Error("Invalid geometry type: " + geomType);
        }
        var coordinates2 = void 0;
        if (isEmpty2) {
          if (geomType == "POINT") {
            coordinates2 = [NaN, NaN];
          } else {
            coordinates2 = [];
          }
        } else {
          switch (geomType) {
            case "POINT": {
              coordinates2 = this.parsePointText_();
              break;
            }
            case "LINESTRING": {
              coordinates2 = this.parseLineStringText_();
              break;
            }
            case "POLYGON": {
              coordinates2 = this.parsePolygonText_();
              break;
            }
            case "MULTIPOINT": {
              coordinates2 = this.parseMultiPointText_();
              break;
            }
            case "MULTILINESTRING": {
              coordinates2 = this.parseMultiLineStringText_();
              break;
            }
            case "MULTIPOLYGON": {
              coordinates2 = this.parseMultiPolygonText_();
              break;
            }
          }
        }
        return new ctor(coordinates2, this.layout_);
      }
    }
    throw new Error(this.formatErrorMessage_());
  };
  return Parser2;
}();
var WKT = function(_super) {
  __extends$4(WKT2, _super);
  function WKT2(opt_options) {
    var _this = _super.call(this) || this;
    var options = opt_options ? opt_options : {};
    _this.splitCollection_ = options.splitCollection !== void 0 ? options.splitCollection : false;
    return _this;
  }
  WKT2.prototype.parse_ = function(wkt2) {
    var lexer = new Lexer(wkt2);
    var parser = new Parser$2(lexer);
    return parser.parse();
  };
  WKT2.prototype.readFeatureFromText = function(text2, opt_options) {
    var geom2 = this.readGeometryFromText(text2, opt_options);
    var feature$1 = new feature();
    feature$1.setGeometry(geom2);
    return feature$1;
  };
  WKT2.prototype.readFeaturesFromText = function(text2, opt_options) {
    var geometries = [];
    var geometry = this.readGeometryFromText(text2, opt_options);
    if (this.splitCollection_ && geometry.getType() == GeometryType.GEOMETRY_COLLECTION) {
      geometries = geometry.getGeometriesArray();
    } else {
      geometries = [geometry];
    }
    var features = [];
    for (var i2 = 0, ii = geometries.length; i2 < ii; ++i2) {
      var feature$1 = new feature();
      feature$1.setGeometry(geometries[i2]);
      features.push(feature$1);
    }
    return features;
  };
  WKT2.prototype.readGeometryFromText = function(text2, opt_options) {
    var geometry = this.parse_(text2);
    return transformGeometryWithOptions(geometry, false, opt_options);
  };
  WKT2.prototype.writeFeatureText = function(feature2, opt_options) {
    var geometry = feature2.getGeometry();
    if (geometry) {
      return this.writeGeometryText(geometry, opt_options);
    }
    return "";
  };
  WKT2.prototype.writeFeaturesText = function(features, opt_options) {
    if (features.length == 1) {
      return this.writeFeatureText(features[0], opt_options);
    }
    var geometries = [];
    for (var i2 = 0, ii = features.length; i2 < ii; ++i2) {
      geometries.push(features[i2].getGeometry());
    }
    var collection = new GeometryCollection$1(geometries);
    return this.writeGeometryText(collection, opt_options);
  };
  WKT2.prototype.writeGeometryText = function(geometry, opt_options) {
    return encode(transformGeometryWithOptions(geometry, true, opt_options));
  };
  return WKT2;
}(TextFeature$1);
function encodePointGeometry(geom2) {
  var coordinates2 = geom2.getCoordinates();
  if (coordinates2.length === 0) {
    return "";
  }
  return coordinates2.join(" ");
}
function encodeMultiPointGeometry(geom2) {
  var array = [];
  var components = geom2.getPoints();
  for (var i2 = 0, ii = components.length; i2 < ii; ++i2) {
    array.push("(" + encodePointGeometry(components[i2]) + ")");
  }
  return array.join(",");
}
function encodeGeometryCollectionGeometry(geom2) {
  var array = [];
  var geoms = geom2.getGeometries();
  for (var i2 = 0, ii = geoms.length; i2 < ii; ++i2) {
    array.push(encode(geoms[i2]));
  }
  return array.join(",");
}
function encodeLineStringGeometry(geom2) {
  var coordinates2 = geom2.getCoordinates();
  var array = [];
  for (var i2 = 0, ii = coordinates2.length; i2 < ii; ++i2) {
    array.push(coordinates2[i2].join(" "));
  }
  return array.join(",");
}
function encodeMultiLineStringGeometry(geom2) {
  var array = [];
  var components = geom2.getLineStrings();
  for (var i2 = 0, ii = components.length; i2 < ii; ++i2) {
    array.push("(" + encodeLineStringGeometry(components[i2]) + ")");
  }
  return array.join(",");
}
function encodePolygonGeometry(geom2) {
  var array = [];
  var rings = geom2.getLinearRings();
  for (var i2 = 0, ii = rings.length; i2 < ii; ++i2) {
    array.push("(" + encodeLineStringGeometry(rings[i2]) + ")");
  }
  return array.join(",");
}
function encodeMultiPolygonGeometry(geom2) {
  var array = [];
  var components = geom2.getPolygons();
  for (var i2 = 0, ii = components.length; i2 < ii; ++i2) {
    array.push("(" + encodePolygonGeometry(components[i2]) + ")");
  }
  return array.join(",");
}
function encodeGeometryLayout(geom2) {
  var layout = geom2.getLayout();
  var dimInfo = "";
  if (layout === GeometryLayout.XYZ || layout === GeometryLayout.XYZM) {
    dimInfo += Z$1;
  }
  if (layout === GeometryLayout.XYM || layout === GeometryLayout.XYZM) {
    dimInfo += M;
  }
  return dimInfo;
}
var GeometryEncoder = {
  "Point": encodePointGeometry,
  "LineString": encodeLineStringGeometry,
  "Polygon": encodePolygonGeometry,
  "MultiPoint": encodeMultiPointGeometry,
  "MultiLineString": encodeMultiLineStringGeometry,
  "MultiPolygon": encodeMultiPolygonGeometry,
  "GeometryCollection": encodeGeometryCollectionGeometry
};
function encode(geom2) {
  var type = geom2.getType();
  var geometryEncoder = GeometryEncoder[type];
  var enc = geometryEncoder(geom2);
  type = type.toUpperCase();
  if (typeof geom2.getFlatCoordinates === "function") {
    var dimInfo = encodeGeometryLayout(geom2);
    if (dimInfo.length > 0) {
      type += " " + dimInfo;
    }
  }
  if (enc.length === 0) {
    return type + " " + EMPTY;
  }
  return type + "(" + enc + ")";
}
var WKT$1 = WKT;
var __extends$3 = globalThis && globalThis.__extends || function() {
  var extendStatics2 = function(d2, b2) {
    extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {
      d3.__proto__ = b3;
    } || function(d3, b3) {
      for (var p5 in b3)
        if (Object.prototype.hasOwnProperty.call(b3, p5))
          d3[p5] = b3[p5];
    };
    return extendStatics2(d2, b2);
  };
  return function(d2, b2) {
    if (typeof b2 !== "function" && b2 !== null)
      throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
    extendStatics2(d2, b2);
    function __() {
      this.constructor = d2;
    }
    d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
  };
}();
var NAMESPACE_URIS$1 = [null, "http://www.opengis.net/wms"];
var PARSERS$1 = makeStructureNS(NAMESPACE_URIS$1, {
  "Service": makeObjectPropertySetter(readService),
  "Capability": makeObjectPropertySetter(readCapability)
});
var CAPABILITY_PARSERS = makeStructureNS(NAMESPACE_URIS$1, {
  "Request": makeObjectPropertySetter(readRequest),
  "Exception": makeObjectPropertySetter(readException),
  "Layer": makeObjectPropertySetter(readCapabilityLayer)
});
var WMSCapabilities = function(_super) {
  __extends$3(WMSCapabilities2, _super);
  function WMSCapabilities2() {
    var _this = _super.call(this) || this;
    _this.version = void 0;
    return _this;
  }
  WMSCapabilities2.prototype.readFromNode = function(node2) {
    this.version = node2.getAttribute("version").trim();
    var wmsCapabilityObject = pushParseAndPop({
      "version": this.version
    }, PARSERS$1, node2, []);
    return wmsCapabilityObject ? wmsCapabilityObject : null;
  };
  return WMSCapabilities2;
}(XML$1);
var SERVICE_PARSERS = makeStructureNS(NAMESPACE_URIS$1, {
  "Name": makeObjectPropertySetter(readString),
  "Title": makeObjectPropertySetter(readString),
  "Abstract": makeObjectPropertySetter(readString),
  "KeywordList": makeObjectPropertySetter(readKeywordList),
  "OnlineResource": makeObjectPropertySetter(readHref),
  "ContactInformation": makeObjectPropertySetter(readContactInformation),
  "Fees": makeObjectPropertySetter(readString),
  "AccessConstraints": makeObjectPropertySetter(readString),
  "LayerLimit": makeObjectPropertySetter(readPositiveInteger),
  "MaxWidth": makeObjectPropertySetter(readPositiveInteger),
  "MaxHeight": makeObjectPropertySetter(readPositiveInteger)
});
var CONTACT_INFORMATION_PARSERS = makeStructureNS(NAMESPACE_URIS$1, {
  "ContactPersonPrimary": makeObjectPropertySetter(readContactPersonPrimary),
  "ContactPosition": makeObjectPropertySetter(readString),
  "ContactAddress": makeObjectPropertySetter(readContactAddress),
  "ContactVoiceTelephone": makeObjectPropertySetter(readString),
  "ContactFacsimileTelephone": makeObjectPropertySetter(readString),
  "ContactElectronicMailAddress": makeObjectPropertySetter(readString)
});
var CONTACT_PERSON_PARSERS = makeStructureNS(NAMESPACE_URIS$1, {
  "ContactPerson": makeObjectPropertySetter(readString),
  "ContactOrganization": makeObjectPropertySetter(readString)
});
var CONTACT_ADDRESS_PARSERS = makeStructureNS(NAMESPACE_URIS$1, {
  "AddressType": makeObjectPropertySetter(readString),
  "Address": makeObjectPropertySetter(readString),
  "City": makeObjectPropertySetter(readString),
  "StateOrProvince": makeObjectPropertySetter(readString),
  "PostCode": makeObjectPropertySetter(readString),
  "Country": makeObjectPropertySetter(readString)
});
var EXCEPTION_PARSERS = makeStructureNS(NAMESPACE_URIS$1, {
  "Format": makeArrayPusher(readString)
});
var LAYER_PARSERS$1 = makeStructureNS(NAMESPACE_URIS$1, {
  "Name": makeObjectPropertySetter(readString),
  "Title": makeObjectPropertySetter(readString),
  "Abstract": makeObjectPropertySetter(readString),
  "KeywordList": makeObjectPropertySetter(readKeywordList),
  "CRS": makeObjectPropertyPusher(readString),
  "EX_GeographicBoundingBox": makeObjectPropertySetter(readEXGeographicBoundingBox),
  "BoundingBox": makeObjectPropertyPusher(readBoundingBox$1),
  "Dimension": makeObjectPropertyPusher(readDimension),
  "Attribution": makeObjectPropertySetter(readAttribution),
  "AuthorityURL": makeObjectPropertyPusher(readAuthorityURL),
  "Identifier": makeObjectPropertyPusher(readString),
  "MetadataURL": makeObjectPropertyPusher(readMetadataURL),
  "DataURL": makeObjectPropertyPusher(readFormatOnlineresource),
  "FeatureListURL": makeObjectPropertyPusher(readFormatOnlineresource),
  "Style": makeObjectPropertyPusher(readStyle$1),
  "MinScaleDenominator": makeObjectPropertySetter(readDecimal),
  "MaxScaleDenominator": makeObjectPropertySetter(readDecimal),
  "Layer": makeObjectPropertyPusher(readLayer$1)
});
var ATTRIBUTION_PARSERS = makeStructureNS(NAMESPACE_URIS$1, {
  "Title": makeObjectPropertySetter(readString),
  "OnlineResource": makeObjectPropertySetter(readHref),
  "LogoURL": makeObjectPropertySetter(readSizedFormatOnlineresource)
});
var EX_GEOGRAPHIC_BOUNDING_BOX_PARSERS = makeStructureNS(NAMESPACE_URIS$1, {
  "westBoundLongitude": makeObjectPropertySetter(readDecimal),
  "eastBoundLongitude": makeObjectPropertySetter(readDecimal),
  "southBoundLatitude": makeObjectPropertySetter(readDecimal),
  "northBoundLatitude": makeObjectPropertySetter(readDecimal)
});
var REQUEST_PARSERS = makeStructureNS(NAMESPACE_URIS$1, {
  "GetCapabilities": makeObjectPropertySetter(readOperationType),
  "GetMap": makeObjectPropertySetter(readOperationType),
  "GetFeatureInfo": makeObjectPropertySetter(readOperationType)
});
var OPERATIONTYPE_PARSERS = makeStructureNS(NAMESPACE_URIS$1, {
  "Format": makeObjectPropertyPusher(readString),
  "DCPType": makeObjectPropertyPusher(readDCPType)
});
var DCPTYPE_PARSERS = makeStructureNS(NAMESPACE_URIS$1, {
  "HTTP": makeObjectPropertySetter(readHTTP)
});
var HTTP_PARSERS = makeStructureNS(NAMESPACE_URIS$1, {
  "Get": makeObjectPropertySetter(readFormatOnlineresource),
  "Post": makeObjectPropertySetter(readFormatOnlineresource)
});
var STYLE_PARSERS$1 = makeStructureNS(NAMESPACE_URIS$1, {
  "Name": makeObjectPropertySetter(readString),
  "Title": makeObjectPropertySetter(readString),
  "Abstract": makeObjectPropertySetter(readString),
  "LegendURL": makeObjectPropertyPusher(readSizedFormatOnlineresource),
  "StyleSheetURL": makeObjectPropertySetter(readFormatOnlineresource),
  "StyleURL": makeObjectPropertySetter(readFormatOnlineresource)
});
var FORMAT_ONLINERESOURCE_PARSERS = makeStructureNS(NAMESPACE_URIS$1, {
  "Format": makeObjectPropertySetter(readString),
  "OnlineResource": makeObjectPropertySetter(readHref)
});
var KEYWORDLIST_PARSERS = makeStructureNS(NAMESPACE_URIS$1, {
  "Keyword": makeArrayPusher(readString)
});
function readAttribution(node2, objectStack) {
  return pushParseAndPop({}, ATTRIBUTION_PARSERS, node2, objectStack);
}
function readBoundingBox$1(node2, objectStack) {
  var extent2 = [
    readDecimalString(node2.getAttribute("minx")),
    readDecimalString(node2.getAttribute("miny")),
    readDecimalString(node2.getAttribute("maxx")),
    readDecimalString(node2.getAttribute("maxy"))
  ];
  var resolutions = [
    readDecimalString(node2.getAttribute("resx")),
    readDecimalString(node2.getAttribute("resy"))
  ];
  return {
    "crs": node2.getAttribute("CRS"),
    "extent": extent2,
    "res": resolutions
  };
}
function readEXGeographicBoundingBox(node2, objectStack) {
  var geographicBoundingBox = pushParseAndPop({}, EX_GEOGRAPHIC_BOUNDING_BOX_PARSERS, node2, objectStack);
  if (!geographicBoundingBox) {
    return void 0;
  }
  var westBoundLongitude = geographicBoundingBox["westBoundLongitude"];
  var southBoundLatitude = geographicBoundingBox["southBoundLatitude"];
  var eastBoundLongitude = geographicBoundingBox["eastBoundLongitude"];
  var northBoundLatitude = geographicBoundingBox["northBoundLatitude"];
  if (westBoundLongitude === void 0 || southBoundLatitude === void 0 || eastBoundLongitude === void 0 || northBoundLatitude === void 0) {
    return void 0;
  }
  return [
    westBoundLongitude,
    southBoundLatitude,
    eastBoundLongitude,
    northBoundLatitude
  ];
}
function readCapability(node2, objectStack) {
  return pushParseAndPop({}, CAPABILITY_PARSERS, node2, objectStack);
}
function readService(node2, objectStack) {
  return pushParseAndPop({}, SERVICE_PARSERS, node2, objectStack);
}
function readContactInformation(node2, objectStack) {
  return pushParseAndPop({}, CONTACT_INFORMATION_PARSERS, node2, objectStack);
}
function readContactPersonPrimary(node2, objectStack) {
  return pushParseAndPop({}, CONTACT_PERSON_PARSERS, node2, objectStack);
}
function readContactAddress(node2, objectStack) {
  return pushParseAndPop({}, CONTACT_ADDRESS_PARSERS, node2, objectStack);
}
function readException(node2, objectStack) {
  return pushParseAndPop([], EXCEPTION_PARSERS, node2, objectStack);
}
function readCapabilityLayer(node2, objectStack) {
  var layerObject = pushParseAndPop({}, LAYER_PARSERS$1, node2, objectStack);
  if (layerObject["Layer"] === void 0) {
    return Object.assign(layerObject, readLayer$1(node2, objectStack));
  }
  return layerObject;
}
function readLayer$1(node2, objectStack) {
  var parentLayerObject = objectStack[objectStack.length - 1];
  var layerObject = pushParseAndPop({}, LAYER_PARSERS$1, node2, objectStack);
  if (!layerObject) {
    return void 0;
  }
  var queryable = readBooleanString(node2.getAttribute("queryable"));
  if (queryable === void 0) {
    queryable = parentLayerObject["queryable"];
  }
  layerObject["queryable"] = queryable !== void 0 ? queryable : false;
  var cascaded = readNonNegativeIntegerString(node2.getAttribute("cascaded"));
  if (cascaded === void 0) {
    cascaded = parentLayerObject["cascaded"];
  }
  layerObject["cascaded"] = cascaded;
  var opaque = readBooleanString(node2.getAttribute("opaque"));
  if (opaque === void 0) {
    opaque = parentLayerObject["opaque"];
  }
  layerObject["opaque"] = opaque !== void 0 ? opaque : false;
  var noSubsets = readBooleanString(node2.getAttribute("noSubsets"));
  if (noSubsets === void 0) {
    noSubsets = parentLayerObject["noSubsets"];
  }
  layerObject["noSubsets"] = noSubsets !== void 0 ? noSubsets : false;
  var fixedWidth = readDecimalString(node2.getAttribute("fixedWidth"));
  if (!fixedWidth) {
    fixedWidth = parentLayerObject["fixedWidth"];
  }
  layerObject["fixedWidth"] = fixedWidth;
  var fixedHeight = readDecimalString(node2.getAttribute("fixedHeight"));
  if (!fixedHeight) {
    fixedHeight = parentLayerObject["fixedHeight"];
  }
  layerObject["fixedHeight"] = fixedHeight;
  var addKeys = ["Style", "CRS", "AuthorityURL"];
  addKeys.forEach(function(key) {
    if (key in parentLayerObject) {
      var childValue = layerObject[key] || [];
      layerObject[key] = childValue.concat(parentLayerObject[key]);
    }
  });
  var replaceKeys = [
    "EX_GeographicBoundingBox",
    "BoundingBox",
    "Dimension",
    "Attribution",
    "MinScaleDenominator",
    "MaxScaleDenominator"
  ];
  replaceKeys.forEach(function(key) {
    if (!(key in layerObject)) {
      var parentValue = parentLayerObject[key];
      layerObject[key] = parentValue;
    }
  });
  return layerObject;
}
function readDimension(node2, objectStack) {
  var dimensionObject = {
    "name": node2.getAttribute("name"),
    "units": node2.getAttribute("units"),
    "unitSymbol": node2.getAttribute("unitSymbol"),
    "default": node2.getAttribute("default"),
    "multipleValues": readBooleanString(node2.getAttribute("multipleValues")),
    "nearestValue": readBooleanString(node2.getAttribute("nearestValue")),
    "current": readBooleanString(node2.getAttribute("current")),
    "values": readString(node2)
  };
  return dimensionObject;
}
function readFormatOnlineresource(node2, objectStack) {
  return pushParseAndPop({}, FORMAT_ONLINERESOURCE_PARSERS, node2, objectStack);
}
function readRequest(node2, objectStack) {
  return pushParseAndPop({}, REQUEST_PARSERS, node2, objectStack);
}
function readDCPType(node2, objectStack) {
  return pushParseAndPop({}, DCPTYPE_PARSERS, node2, objectStack);
}
function readHTTP(node2, objectStack) {
  return pushParseAndPop({}, HTTP_PARSERS, node2, objectStack);
}
function readOperationType(node2, objectStack) {
  return pushParseAndPop({}, OPERATIONTYPE_PARSERS, node2, objectStack);
}
function readSizedFormatOnlineresource(node2, objectStack) {
  var formatOnlineresource = readFormatOnlineresource(node2, objectStack);
  if (formatOnlineresource) {
    var size = [
      readNonNegativeIntegerString(node2.getAttribute("width")),
      readNonNegativeIntegerString(node2.getAttribute("height"))
    ];
    formatOnlineresource["size"] = size;
    return formatOnlineresource;
  }
  return void 0;
}
function readAuthorityURL(node2, objectStack) {
  var authorityObject = readFormatOnlineresource(node2, objectStack);
  if (authorityObject) {
    authorityObject["name"] = node2.getAttribute("name");
    return authorityObject;
  }
  return void 0;
}
function readMetadataURL(node2, objectStack) {
  var metadataObject = readFormatOnlineresource(node2, objectStack);
  if (metadataObject) {
    metadataObject["type"] = node2.getAttribute("type");
    return metadataObject;
  }
  return void 0;
}
function readStyle$1(node2, objectStack) {
  return pushParseAndPop({}, STYLE_PARSERS$1, node2, objectStack);
}
function readKeywordList(node2, objectStack) {
  return pushParseAndPop([], KEYWORDLIST_PARSERS, node2, objectStack);
}
var WMSCapabilities$1 = WMSCapabilities;
var __extends$2 = globalThis && globalThis.__extends || function() {
  var extendStatics2 = function(d2, b2) {
    extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {
      d3.__proto__ = b3;
    } || function(d3, b3) {
      for (var p5 in b3)
        if (Object.prototype.hasOwnProperty.call(b3, p5))
          d3[p5] = b3[p5];
    };
    return extendStatics2(d2, b2);
  };
  return function(d2, b2) {
    if (typeof b2 !== "function" && b2 !== null)
      throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
    extendStatics2(d2, b2);
    function __() {
      this.constructor = d2;
    }
    d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
  };
}();
var featureIdentifier = "_feature";
var layerIdentifier = "_layer";
var WMSGetFeatureInfo = function(_super) {
  __extends$2(WMSGetFeatureInfo2, _super);
  function WMSGetFeatureInfo2(opt_options) {
    var _this = _super.call(this) || this;
    var options = opt_options ? opt_options : {};
    _this.featureNS_ = "http://mapserver.gis.umn.edu/mapserver";
    _this.gmlFormat_ = new GML2$1();
    _this.layers_ = options.layers ? options.layers : null;
    return _this;
  }
  WMSGetFeatureInfo2.prototype.getLayers = function() {
    return this.layers_;
  };
  WMSGetFeatureInfo2.prototype.setLayers = function(layers) {
    this.layers_ = layers;
  };
  WMSGetFeatureInfo2.prototype.readFeatures_ = function(node2, objectStack) {
    node2.setAttribute("namespaceURI", this.featureNS_);
    var localName = node2.localName;
    var features = [];
    if (node2.childNodes.length === 0) {
      return features;
    }
    if (localName == "msGMLOutput") {
      for (var i2 = 0, ii = node2.childNodes.length; i2 < ii; i2++) {
        var layer = node2.childNodes[i2];
        if (layer.nodeType !== Node.ELEMENT_NODE) {
          continue;
        }
        var layerElement = layer;
        var context = objectStack[0];
        var toRemove = layerIdentifier;
        var layerName = layerElement.localName.replace(toRemove, "");
        if (this.layers_ && !includes(this.layers_, layerName)) {
          continue;
        }
        var featureType = layerName + featureIdentifier;
        context["featureType"] = featureType;
        context["featureNS"] = this.featureNS_;
        var parsers = {};
        parsers[featureType] = makeArrayPusher(this.gmlFormat_.readFeatureElement, this.gmlFormat_);
        var parsersNS = makeStructureNS([context["featureNS"], null], parsers);
        layerElement.setAttribute("namespaceURI", this.featureNS_);
        var layerFeatures = pushParseAndPop([], parsersNS, layerElement, objectStack, this.gmlFormat_);
        if (layerFeatures) {
          extend$3(features, layerFeatures);
        }
      }
    }
    if (localName == "FeatureCollection") {
      var gmlFeatures = pushParseAndPop([], this.gmlFormat_.FEATURE_COLLECTION_PARSERS, node2, [{}], this.gmlFormat_);
      if (gmlFeatures) {
        features = gmlFeatures;
      }
    }
    return features;
  };
  WMSGetFeatureInfo2.prototype.readFeaturesFromNode = function(node2, opt_options) {
    var options = {};
    if (opt_options) {
      assign(options, this.getReadOptions(node2, opt_options));
    }
    return this.readFeatures_(node2, [options]);
  };
  return WMSGetFeatureInfo2;
}(XMLFeature$1);
var WMSGetFeatureInfo$1 = WMSGetFeatureInfo;
var __extends$1 = globalThis && globalThis.__extends || function() {
  var extendStatics2 = function(d2, b2) {
    extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {
      d3.__proto__ = b3;
    } || function(d3, b3) {
      for (var p5 in b3)
        if (Object.prototype.hasOwnProperty.call(b3, p5))
          d3[p5] = b3[p5];
    };
    return extendStatics2(d2, b2);
  };
  return function(d2, b2) {
    if (typeof b2 !== "function" && b2 !== null)
      throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
    extendStatics2(d2, b2);
    function __() {
      this.constructor = d2;
    }
    d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
  };
}();
var NAMESPACE_URIS = [null, "http://www.opengis.net/wmts/1.0"];
var OWS_NAMESPACE_URIS = [null, "http://www.opengis.net/ows/1.1"];
var PARSERS = makeStructureNS(NAMESPACE_URIS, {
  "Contents": makeObjectPropertySetter(readContents)
});
var WMTSCapabilities = function(_super) {
  __extends$1(WMTSCapabilities2, _super);
  function WMTSCapabilities2() {
    var _this = _super.call(this) || this;
    _this.owsParser_ = new OWS$1();
    return _this;
  }
  WMTSCapabilities2.prototype.readFromNode = function(node2) {
    var version2 = node2.getAttribute("version");
    if (version2) {
      version2 = version2.trim();
    }
    var WMTSCapabilityObject = this.owsParser_.readFromNode(node2);
    if (!WMTSCapabilityObject) {
      return null;
    }
    WMTSCapabilityObject["version"] = version2;
    WMTSCapabilityObject = pushParseAndPop(WMTSCapabilityObject, PARSERS, node2, []);
    return WMTSCapabilityObject ? WMTSCapabilityObject : null;
  };
  return WMTSCapabilities2;
}(XML$1);
var CONTENTS_PARSERS = makeStructureNS(NAMESPACE_URIS, {
  "Layer": makeObjectPropertyPusher(readLayer),
  "TileMatrixSet": makeObjectPropertyPusher(readTileMatrixSet)
});
var LAYER_PARSERS = makeStructureNS(NAMESPACE_URIS, {
  "Style": makeObjectPropertyPusher(readStyle),
  "Format": makeObjectPropertyPusher(readString),
  "TileMatrixSetLink": makeObjectPropertyPusher(readTileMatrixSetLink),
  "Dimension": makeObjectPropertyPusher(readDimensions),
  "ResourceURL": makeObjectPropertyPusher(readResourceUrl)
}, makeStructureNS(OWS_NAMESPACE_URIS, {
  "Title": makeObjectPropertySetter(readString),
  "Abstract": makeObjectPropertySetter(readString),
  "WGS84BoundingBox": makeObjectPropertySetter(readBoundingBox),
  "Identifier": makeObjectPropertySetter(readString)
}));
var STYLE_PARSERS = makeStructureNS(NAMESPACE_URIS, {
  "LegendURL": makeObjectPropertyPusher(readLegendUrl)
}, makeStructureNS(OWS_NAMESPACE_URIS, {
  "Title": makeObjectPropertySetter(readString),
  "Identifier": makeObjectPropertySetter(readString)
}));
var TMS_LINKS_PARSERS = makeStructureNS(NAMESPACE_URIS, {
  "TileMatrixSet": makeObjectPropertySetter(readString),
  "TileMatrixSetLimits": makeObjectPropertySetter(readTileMatrixLimitsList)
});
var TMS_LIMITS_LIST_PARSERS = makeStructureNS(NAMESPACE_URIS, {
  "TileMatrixLimits": makeArrayPusher(readTileMatrixLimits)
});
var TMS_LIMITS_PARSERS = makeStructureNS(NAMESPACE_URIS, {
  "TileMatrix": makeObjectPropertySetter(readString),
  "MinTileRow": makeObjectPropertySetter(readPositiveInteger),
  "MaxTileRow": makeObjectPropertySetter(readPositiveInteger),
  "MinTileCol": makeObjectPropertySetter(readPositiveInteger),
  "MaxTileCol": makeObjectPropertySetter(readPositiveInteger)
});
var DIMENSION_PARSERS = makeStructureNS(NAMESPACE_URIS, {
  "Default": makeObjectPropertySetter(readString),
  "Value": makeObjectPropertyPusher(readString)
}, makeStructureNS(OWS_NAMESPACE_URIS, {
  "Identifier": makeObjectPropertySetter(readString)
}));
var WGS84_BBOX_READERS = makeStructureNS(OWS_NAMESPACE_URIS, {
  "LowerCorner": makeArrayPusher(readCoordinates),
  "UpperCorner": makeArrayPusher(readCoordinates)
});
var TMS_PARSERS = makeStructureNS(NAMESPACE_URIS, {
  "WellKnownScaleSet": makeObjectPropertySetter(readString),
  "TileMatrix": makeObjectPropertyPusher(readTileMatrix)
}, makeStructureNS(OWS_NAMESPACE_URIS, {
  "SupportedCRS": makeObjectPropertySetter(readString),
  "Identifier": makeObjectPropertySetter(readString),
  "BoundingBox": makeObjectPropertySetter(readBoundingBox)
}));
var TM_PARSERS = makeStructureNS(NAMESPACE_URIS, {
  "TopLeftCorner": makeObjectPropertySetter(readCoordinates),
  "ScaleDenominator": makeObjectPropertySetter(readDecimal),
  "TileWidth": makeObjectPropertySetter(readPositiveInteger),
  "TileHeight": makeObjectPropertySetter(readPositiveInteger),
  "MatrixWidth": makeObjectPropertySetter(readPositiveInteger),
  "MatrixHeight": makeObjectPropertySetter(readPositiveInteger)
}, makeStructureNS(OWS_NAMESPACE_URIS, {
  "Identifier": makeObjectPropertySetter(readString)
}));
function readContents(node2, objectStack) {
  return pushParseAndPop({}, CONTENTS_PARSERS, node2, objectStack);
}
function readLayer(node2, objectStack) {
  return pushParseAndPop({}, LAYER_PARSERS, node2, objectStack);
}
function readTileMatrixSet(node2, objectStack) {
  return pushParseAndPop({}, TMS_PARSERS, node2, objectStack);
}
function readStyle(node2, objectStack) {
  var style2 = pushParseAndPop({}, STYLE_PARSERS, node2, objectStack);
  if (!style2) {
    return void 0;
  }
  var isDefault = node2.getAttribute("isDefault") === "true";
  style2["isDefault"] = isDefault;
  return style2;
}
function readTileMatrixSetLink(node2, objectStack) {
  return pushParseAndPop({}, TMS_LINKS_PARSERS, node2, objectStack);
}
function readDimensions(node2, objectStack) {
  return pushParseAndPop({}, DIMENSION_PARSERS, node2, objectStack);
}
function readResourceUrl(node2, objectStack) {
  var format2 = node2.getAttribute("format");
  var template = node2.getAttribute("template");
  var resourceType = node2.getAttribute("resourceType");
  var resource = {};
  if (format2) {
    resource["format"] = format2;
  }
  if (template) {
    resource["template"] = template;
  }
  if (resourceType) {
    resource["resourceType"] = resourceType;
  }
  return resource;
}
function readBoundingBox(node2, objectStack) {
  var coordinates2 = pushParseAndPop([], WGS84_BBOX_READERS, node2, objectStack);
  if (coordinates2.length != 2) {
    return void 0;
  }
  return boundingExtent(coordinates2);
}
function readLegendUrl(node2, objectStack) {
  var legend = {};
  legend["format"] = node2.getAttribute("format");
  legend["href"] = readHref(node2);
  return legend;
}
function readCoordinates(node2, objectStack) {
  var coordinates2 = readString(node2).split(/\s+/);
  if (!coordinates2 || coordinates2.length != 2) {
    return void 0;
  }
  var x2 = +coordinates2[0];
  var y2 = +coordinates2[1];
  if (isNaN(x2) || isNaN(y2)) {
    return void 0;
  }
  return [x2, y2];
}
function readTileMatrix(node2, objectStack) {
  return pushParseAndPop({}, TM_PARSERS, node2, objectStack);
}
function readTileMatrixLimitsList(node2, objectStack) {
  return pushParseAndPop([], TMS_LIMITS_LIST_PARSERS, node2, objectStack);
}
function readTileMatrixLimits(node2, objectStack) {
  return pushParseAndPop({}, TMS_LIMITS_PARSERS, node2, objectStack);
}
var WMTSCapabilities$1 = WMTSCapabilities;
var format = Object.freeze(Object.defineProperty({
  __proto__: null,
  EsriJSON: EsriJSON$1,
  GeoJSON: GeoJSON$1,
  GML: GML$1,
  GPX: GPX$1,
  IGC: IGC$1,
  IIIFInfo: IIIFInfo$1,
  KML: KML$1,
  MVT: MVT$1,
  OWS: OWS$1,
  Polyline: Polyline$1,
  TopoJSON: TopoJSON$1,
  WFS: WFS$1,
  WKB: WKB$1,
  WKT: WKT$1,
  WMSCapabilities: WMSCapabilities$1,
  WMSGetFeatureInfo: WMSGetFeatureInfo$1,
  WMTSCapabilities: WMTSCapabilities$1
}, Symbol.toStringTag, { value: "Module" }));
function install(app) {
  if (install.installed) {
    console.error("OPENLAYERS MAP ALREADY INSTALLED");
    return;
  }
  install.installed = true;
  app.use(Map$1);
  app.use(Layers);
  app.use(Sources);
  app.use(MapControls);
  app.use(Geometries);
  app.use(Styles);
  app.use(Interactions);
  app.use(Animations);
  app.provide("ol-feature", feature);
  app.provide("ol-geom", geom);
  app.provide("ol-animations", animations);
  app.provide("ol-format", format);
  app.provide("ol-loadingstrategy", loadingstrategy);
  app.provide("ol-selectconditions", selectconditions);
  app.provide("ol-extent", extent);
}
var extendStatics = function(d2, b2) {
  extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {
    d3.__proto__ = b3;
  } || function(d3, b3) {
    for (var p5 in b3)
      if (Object.prototype.hasOwnProperty.call(b3, p5))
        d3[p5] = b3[p5];
  };
  return extendStatics(d2, b2);
};
function __extends(d2, b2) {
  if (typeof b2 !== "function" && b2 !== null)
    throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
  extendStatics(d2, b2);
  function __() {
    this.constructor = d2;
  }
  d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
}
var __assign = function() {
  __assign = Object.assign || function __assign2(t3) {
    for (var s2, i2 = 1, n2 = arguments.length; i2 < n2; i2++) {
      s2 = arguments[i2];
      for (var p5 in s2)
        if (Object.prototype.hasOwnProperty.call(s2, p5))
          t3[p5] = s2[p5];
    }
    return t3;
  };
  return __assign.apply(this, arguments);
};
function __awaiter(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve2) {
      resolve2(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve2, reject2) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e2) {
        reject2(e2);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e2) {
        reject2(e2);
      }
    }
    function step(result) {
      result.done ? resolve2(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
}
function __generator(thisArg, body) {
  var _2 = { label: 0, sent: function() {
    if (t3[0] & 1)
      throw t3[1];
    return t3[1];
  }, trys: [], ops: [] }, f2, y2, t3, g2;
  return g2 = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g2[Symbol.iterator] = function() {
    return this;
  }), g2;
  function verb(n2) {
    return function(v2) {
      return step([n2, v2]);
    };
  }
  function step(op) {
    if (f2)
      throw new TypeError("Generator is already executing.");
    while (_2)
      try {
        if (f2 = 1, y2 && (t3 = op[0] & 2 ? y2["return"] : op[0] ? y2["throw"] || ((t3 = y2["return"]) && t3.call(y2), 0) : y2.next) && !(t3 = t3.call(y2, op[1])).done)
          return t3;
        if (y2 = 0, t3)
          op = [op[0] & 2, t3.value];
        switch (op[0]) {
          case 0:
          case 1:
            t3 = op;
            break;
          case 4:
            _2.label++;
            return { value: op[1], done: false };
          case 5:
            _2.label++;
            y2 = op[1];
            op = [0];
            continue;
          case 7:
            op = _2.ops.pop();
            _2.trys.pop();
            continue;
          default:
            if (!(t3 = _2.trys, t3 = t3.length > 0 && t3[t3.length - 1]) && (op[0] === 6 || op[0] === 2)) {
              _2 = 0;
              continue;
            }
            if (op[0] === 3 && (!t3 || op[1] > t3[0] && op[1] < t3[3])) {
              _2.label = op[1];
              break;
            }
            if (op[0] === 6 && _2.label < t3[1]) {
              _2.label = t3[1];
              t3 = op;
              break;
            }
            if (t3 && _2.label < t3[2]) {
              _2.label = t3[2];
              _2.ops.push(op);
              break;
            }
            if (t3[2])
              _2.ops.pop();
            _2.trys.pop();
            continue;
        }
        op = body.call(thisArg, _2);
      } catch (e2) {
        op = [6, e2];
        y2 = 0;
      } finally {
        f2 = t3 = 0;
      }
    if (op[0] & 5)
      throw op[1];
    return { value: op[0] ? op[1] : void 0, done: true };
  }
}
function __spreadArray(to, from, pack2) {
  if (pack2 || arguments.length === 2)
    for (var i2 = 0, l2 = from.length, ar; i2 < l2; i2++) {
      if (ar || !(i2 in from)) {
        if (!ar)
          ar = Array.prototype.slice.call(from, 0, i2);
        ar[i2] = from[i2];
      }
    }
  return to.concat(ar || from);
}
var Bounds = function() {
  function Bounds2(left, top, width, height) {
    this.left = left;
    this.top = top;
    this.width = width;
    this.height = height;
  }
  Bounds2.prototype.add = function(x2, y2, w2, h2) {
    return new Bounds2(this.left + x2, this.top + y2, this.width + w2, this.height + h2);
  };
  Bounds2.fromClientRect = function(context, clientRect) {
    return new Bounds2(clientRect.left + context.windowBounds.left, clientRect.top + context.windowBounds.top, clientRect.width, clientRect.height);
  };
  Bounds2.fromDOMRectList = function(context, domRectList) {
    var domRect = Array.from(domRectList).find(function(rect) {
      return rect.width !== 0;
    });
    return domRect ? new Bounds2(domRect.left + context.windowBounds.left, domRect.top + context.windowBounds.top, domRect.width, domRect.height) : Bounds2.EMPTY;
  };
  Bounds2.EMPTY = new Bounds2(0, 0, 0, 0);
  return Bounds2;
}();
var parseBounds = function(context, node2) {
  return Bounds.fromClientRect(context, node2.getBoundingClientRect());
};
var parseDocumentSize = function(document2) {
  var body = document2.body;
  var documentElement = document2.documentElement;
  if (!body || !documentElement) {
    throw new Error("Unable to get document size");
  }
  var width = Math.max(Math.max(body.scrollWidth, documentElement.scrollWidth), Math.max(body.offsetWidth, documentElement.offsetWidth), Math.max(body.clientWidth, documentElement.clientWidth));
  var height = Math.max(Math.max(body.scrollHeight, documentElement.scrollHeight), Math.max(body.offsetHeight, documentElement.offsetHeight), Math.max(body.clientHeight, documentElement.clientHeight));
  return new Bounds(0, 0, width, height);
};
var toCodePoints$1 = function(str) {
  var codePoints = [];
  var i2 = 0;
  var length = str.length;
  while (i2 < length) {
    var value = str.charCodeAt(i2++);
    if (value >= 55296 && value <= 56319 && i2 < length) {
      var extra = str.charCodeAt(i2++);
      if ((extra & 64512) === 56320) {
        codePoints.push(((value & 1023) << 10) + (extra & 1023) + 65536);
      } else {
        codePoints.push(value);
        i2--;
      }
    } else {
      codePoints.push(value);
    }
  }
  return codePoints;
};
var fromCodePoint$1 = function() {
  var codePoints = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    codePoints[_i] = arguments[_i];
  }
  if (String.fromCodePoint) {
    return String.fromCodePoint.apply(String, codePoints);
  }
  var length = codePoints.length;
  if (!length) {
    return "";
  }
  var codeUnits = [];
  var index2 = -1;
  var result = "";
  while (++index2 < length) {
    var codePoint = codePoints[index2];
    if (codePoint <= 65535) {
      codeUnits.push(codePoint);
    } else {
      codePoint -= 65536;
      codeUnits.push((codePoint >> 10) + 55296, codePoint % 1024 + 56320);
    }
    if (index2 + 1 === length || codeUnits.length > 16384) {
      result += String.fromCharCode.apply(String, codeUnits);
      codeUnits.length = 0;
    }
  }
  return result;
};
var chars$2 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
var lookup$2 = typeof Uint8Array === "undefined" ? [] : new Uint8Array(256);
for (i$2 = 0; i$2 < chars$2.length; i$2++) {
  lookup$2[chars$2.charCodeAt(i$2)] = i$2;
}
var i$2;
var chars$1$1 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
var lookup$1$1 = typeof Uint8Array === "undefined" ? [] : new Uint8Array(256);
for (i$1$1 = 0; i$1$1 < chars$1$1.length; i$1$1++) {
  lookup$1$1[chars$1$1.charCodeAt(i$1$1)] = i$1$1;
}
var i$1$1;
var decode$1 = function(base642) {
  var bufferLength = base642.length * 0.75, len = base642.length, i2, p5 = 0, encoded1, encoded2, encoded3, encoded4;
  if (base642[base642.length - 1] === "=") {
    bufferLength--;
    if (base642[base642.length - 2] === "=") {
      bufferLength--;
    }
  }
  var buffer2 = typeof ArrayBuffer !== "undefined" && typeof Uint8Array !== "undefined" && typeof Uint8Array.prototype.slice !== "undefined" ? new ArrayBuffer(bufferLength) : new Array(bufferLength);
  var bytes = Array.isArray(buffer2) ? buffer2 : new Uint8Array(buffer2);
  for (i2 = 0; i2 < len; i2 += 4) {
    encoded1 = lookup$1$1[base642.charCodeAt(i2)];
    encoded2 = lookup$1$1[base642.charCodeAt(i2 + 1)];
    encoded3 = lookup$1$1[base642.charCodeAt(i2 + 2)];
    encoded4 = lookup$1$1[base642.charCodeAt(i2 + 3)];
    bytes[p5++] = encoded1 << 2 | encoded2 >> 4;
    bytes[p5++] = (encoded2 & 15) << 4 | encoded3 >> 2;
    bytes[p5++] = (encoded3 & 3) << 6 | encoded4 & 63;
  }
  return buffer2;
};
var polyUint16Array$1 = function(buffer2) {
  var length = buffer2.length;
  var bytes = [];
  for (var i2 = 0; i2 < length; i2 += 2) {
    bytes.push(buffer2[i2 + 1] << 8 | buffer2[i2]);
  }
  return bytes;
};
var polyUint32Array$1 = function(buffer2) {
  var length = buffer2.length;
  var bytes = [];
  for (var i2 = 0; i2 < length; i2 += 4) {
    bytes.push(buffer2[i2 + 3] << 24 | buffer2[i2 + 2] << 16 | buffer2[i2 + 1] << 8 | buffer2[i2]);
  }
  return bytes;
};
var UTRIE2_SHIFT_2$1 = 5;
var UTRIE2_SHIFT_1$1 = 6 + 5;
var UTRIE2_INDEX_SHIFT$1 = 2;
var UTRIE2_SHIFT_1_2$1 = UTRIE2_SHIFT_1$1 - UTRIE2_SHIFT_2$1;
var UTRIE2_LSCP_INDEX_2_OFFSET$1 = 65536 >> UTRIE2_SHIFT_2$1;
var UTRIE2_DATA_BLOCK_LENGTH$1 = 1 << UTRIE2_SHIFT_2$1;
var UTRIE2_DATA_MASK$1 = UTRIE2_DATA_BLOCK_LENGTH$1 - 1;
var UTRIE2_LSCP_INDEX_2_LENGTH$1 = 1024 >> UTRIE2_SHIFT_2$1;
var UTRIE2_INDEX_2_BMP_LENGTH$1 = UTRIE2_LSCP_INDEX_2_OFFSET$1 + UTRIE2_LSCP_INDEX_2_LENGTH$1;
var UTRIE2_UTF8_2B_INDEX_2_OFFSET$1 = UTRIE2_INDEX_2_BMP_LENGTH$1;
var UTRIE2_UTF8_2B_INDEX_2_LENGTH$1 = 2048 >> 6;
var UTRIE2_INDEX_1_OFFSET$1 = UTRIE2_UTF8_2B_INDEX_2_OFFSET$1 + UTRIE2_UTF8_2B_INDEX_2_LENGTH$1;
var UTRIE2_OMITTED_BMP_INDEX_1_LENGTH$1 = 65536 >> UTRIE2_SHIFT_1$1;
var UTRIE2_INDEX_2_BLOCK_LENGTH$1 = 1 << UTRIE2_SHIFT_1_2$1;
var UTRIE2_INDEX_2_MASK$1 = UTRIE2_INDEX_2_BLOCK_LENGTH$1 - 1;
var slice16$1 = function(view, start2, end) {
  if (view.slice) {
    return view.slice(start2, end);
  }
  return new Uint16Array(Array.prototype.slice.call(view, start2, end));
};
var slice32$1 = function(view, start2, end) {
  if (view.slice) {
    return view.slice(start2, end);
  }
  return new Uint32Array(Array.prototype.slice.call(view, start2, end));
};
var createTrieFromBase64$1 = function(base642, _byteLength) {
  var buffer2 = decode$1(base642);
  var view32 = Array.isArray(buffer2) ? polyUint32Array$1(buffer2) : new Uint32Array(buffer2);
  var view16 = Array.isArray(buffer2) ? polyUint16Array$1(buffer2) : new Uint16Array(buffer2);
  var headerLength = 24;
  var index2 = slice16$1(view16, headerLength / 2, view32[4] / 2);
  var data2 = view32[5] === 2 ? slice16$1(view16, (headerLength + view32[4]) / 2) : slice32$1(view32, Math.ceil((headerLength + view32[4]) / 4));
  return new Trie$1(view32[0], view32[1], view32[2], view32[3], index2, data2);
};
var Trie$1 = function() {
  function Trie2(initialValue, errorValue, highStart, highValueIndex, index2, data2) {
    this.initialValue = initialValue;
    this.errorValue = errorValue;
    this.highStart = highStart;
    this.highValueIndex = highValueIndex;
    this.index = index2;
    this.data = data2;
  }
  Trie2.prototype.get = function(codePoint) {
    var ix;
    if (codePoint >= 0) {
      if (codePoint < 55296 || codePoint > 56319 && codePoint <= 65535) {
        ix = this.index[codePoint >> UTRIE2_SHIFT_2$1];
        ix = (ix << UTRIE2_INDEX_SHIFT$1) + (codePoint & UTRIE2_DATA_MASK$1);
        return this.data[ix];
      }
      if (codePoint <= 65535) {
        ix = this.index[UTRIE2_LSCP_INDEX_2_OFFSET$1 + (codePoint - 55296 >> UTRIE2_SHIFT_2$1)];
        ix = (ix << UTRIE2_INDEX_SHIFT$1) + (codePoint & UTRIE2_DATA_MASK$1);
        return this.data[ix];
      }
      if (codePoint < this.highStart) {
        ix = UTRIE2_INDEX_1_OFFSET$1 - UTRIE2_OMITTED_BMP_INDEX_1_LENGTH$1 + (codePoint >> UTRIE2_SHIFT_1$1);
        ix = this.index[ix];
        ix += codePoint >> UTRIE2_SHIFT_2$1 & UTRIE2_INDEX_2_MASK$1;
        ix = this.index[ix];
        ix = (ix << UTRIE2_INDEX_SHIFT$1) + (codePoint & UTRIE2_DATA_MASK$1);
        return this.data[ix];
      }
      if (codePoint <= 1114111) {
        return this.data[this.highValueIndex];
      }
    }
    return this.errorValue;
  };
  return Trie2;
}();
var chars$3 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
var lookup$3 = typeof Uint8Array === "undefined" ? [] : new Uint8Array(256);
for (i$3 = 0; i$3 < chars$3.length; i$3++) {
  lookup$3[chars$3.charCodeAt(i$3)] = i$3;
}
var i$3;
var base64$1 = "KwAAAAAAAAAACA4AUD0AADAgAAACAAAAAAAIABAAGABAAEgAUABYAGAAaABgAGgAYgBqAF8AZwBgAGgAcQB5AHUAfQCFAI0AlQCdAKIAqgCyALoAYABoAGAAaABgAGgAwgDKAGAAaADGAM4A0wDbAOEA6QDxAPkAAQEJAQ8BFwF1AH0AHAEkASwBNAE6AUIBQQFJAVEBWQFhAWgBcAF4ATAAgAGGAY4BlQGXAZ8BpwGvAbUBvQHFAc0B0wHbAeMB6wHxAfkBAQIJAvEBEQIZAiECKQIxAjgCQAJGAk4CVgJeAmQCbAJ0AnwCgQKJApECmQKgAqgCsAK4ArwCxAIwAMwC0wLbAjAA4wLrAvMC+AIAAwcDDwMwABcDHQMlAy0DNQN1AD0DQQNJA0kDSQNRA1EDVwNZA1kDdQB1AGEDdQBpA20DdQN1AHsDdQCBA4kDkQN1AHUAmQOhA3UAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AKYDrgN1AHUAtgO+A8YDzgPWAxcD3gPjA+sD8wN1AHUA+wMDBAkEdQANBBUEHQQlBCoEFwMyBDgEYABABBcDSARQBFgEYARoBDAAcAQzAXgEgASIBJAEdQCXBHUAnwSnBK4EtgS6BMIEyAR1AHUAdQB1AHUAdQCVANAEYABgAGAAYABgAGAAYABgANgEYADcBOQEYADsBPQE/AQEBQwFFAUcBSQFLAU0BWQEPAVEBUsFUwVbBWAAYgVgAGoFcgV6BYIFigWRBWAAmQWfBaYFYABgAGAAYABgAKoFYACxBbAFuQW6BcEFwQXHBcEFwQXPBdMF2wXjBeoF8gX6BQIGCgYSBhoGIgYqBjIGOgZgAD4GRgZMBmAAUwZaBmAAYABgAGAAYABgAGAAYABgAGAAYABgAGIGYABpBnAGYABgAGAAYABgAGAAYABgAGAAYAB4Bn8GhQZgAGAAYAB1AHcDFQSLBmAAYABgAJMGdQA9A3UAmwajBqsGqwaVALMGuwbDBjAAywbSBtIG1QbSBtIG0gbSBtIG0gbdBuMG6wbzBvsGAwcLBxMHAwcbByMHJwcsBywHMQcsB9IGOAdAB0gHTgfSBkgHVgfSBtIG0gbSBtIG0gbSBtIG0gbSBiwHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAdgAGAALAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAdbB2MHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsB2kH0gZwB64EdQB1AHUAdQB1AHUAdQB1AHUHfQdgAIUHjQd1AHUAlQedB2AAYAClB6sHYACzB7YHvgfGB3UAzgfWBzMB3gfmB1EB7gf1B/0HlQENAQUIDQh1ABUIHQglCBcDLQg1CD0IRQhNCEEDUwh1AHUAdQBbCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIcAh3CHoIMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwAIIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIgggwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAALAcsBywHLAcsBywHLAcsBywHLAcsB4oILAcsB44I0gaWCJ4Ipgh1AHUAqgiyCHUAdQB1AHUAdQB1AHUAdQB1AHUAtwh8AXUAvwh1AMUIyQjRCNkI4AjoCHUAdQB1AO4I9gj+CAYJDgkTCS0HGwkjCYIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIggiAAIAAAAFAAYABgAGIAXwBgAHEAdQBFAJUAogCyAKAAYABgAEIA4ABGANMA4QDxAMEBDwE1AFwBLAE6AQEBUQF4QkhCmEKoQrhCgAHIQsAB0MLAAcABwAHAAeDC6ABoAHDCwMMAAcABwAHAAdDDGMMAAcAB6MM4wwjDWMNow3jDaABoAGgAaABoAGgAaABoAGgAaABoAGgAaABoAGgAaABoAGgAaABoAEjDqABWw6bDqABpg6gAaABoAHcDvwOPA+gAaABfA/8DvwO/A78DvwO/A78DvwO/A78DvwO/A78DvwO/A78DvwO/A78DvwO/A78DvwO/A78DvwO/A78DpcPAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcAB9cPKwkyCToJMAB1AHUAdQBCCUoJTQl1AFUJXAljCWcJawkwADAAMAAwAHMJdQB2CX4JdQCECYoJjgmWCXUAngkwAGAAYABxAHUApgn3A64JtAl1ALkJdQDACTAAMAAwADAAdQB1AHUAdQB1AHUAdQB1AHUAowYNBMUIMAAwADAAMADICcsJ0wnZCRUE4QkwAOkJ8An4CTAAMAB1AAAKvwh1AAgKDwoXCh8KdQAwACcKLgp1ADYKqAmICT4KRgowADAAdQB1AE4KMAB1AFYKdQBeCnUAZQowADAAMAAwADAAMAAwADAAMAAVBHUAbQowADAAdQC5CXUKMAAwAHwBxAijBogEMgF9CoQKiASMCpQKmgqIBKIKqgquCogEDQG2Cr4KxgrLCjAAMADTCtsKCgHjCusK8Qr5CgELMAAwADAAMAB1AIsECQsRC3UANAEZCzAAMAAwADAAMAB1ACELKQswAHUANAExCzkLdQBBC0kLMABRC1kLMAAwADAAMAAwADAAdQBhCzAAMAAwAGAAYABpC3ELdwt/CzAAMACHC4sLkwubC58Lpwt1AK4Ltgt1APsDMAAwADAAMAAwADAAMAAwAL4LwwvLC9IL1wvdCzAAMADlC+kL8Qv5C/8LSQswADAAMAAwADAAMAAwADAAMAAHDDAAMAAwADAAMAAODBYMHgx1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1ACYMMAAwADAAdQB1AHUALgx1AHUAdQB1AHUAdQA2DDAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwAHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AD4MdQBGDHUAdQB1AHUAdQB1AEkMdQB1AHUAdQB1AFAMMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwAHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQBYDHUAdQB1AF8MMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAB1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AHUA+wMVBGcMMAAwAHwBbwx1AHcMfwyHDI8MMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAYABgAJcMMAAwADAAdQB1AJ8MlQClDDAAMACtDCwHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsB7UMLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHdQB1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AA0EMAC9DDAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAsBywHLAcsBywHLAcsBywHLQcwAMEMyAwsBywHLAcsBywHLAcsBywHLAcsBywHzAwwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwAHUAdQB1ANQM2QzhDDAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMABgAGAAYABgAGAAYABgAOkMYADxDGAA+AwADQYNYABhCWAAYAAODTAAMAAwADAAFg1gAGAAHg37AzAAMAAwADAAYABgACYNYAAsDTQNPA1gAEMNPg1LDWAAYABgAGAAYABgAGAAYABgAGAAUg1aDYsGVglhDV0NcQBnDW0NdQ15DWAAYABgAGAAYABgAGAAYABgAGAAYABgAGAAYABgAGAAlQCBDZUAiA2PDZcNMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAnw2nDTAAMAAwADAAMAAwAHUArw23DTAAMAAwADAAMAAwADAAMAAwADAAMAB1AL8NMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAB1AHUAdQB1AHUAdQDHDTAAYABgAM8NMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAA1w11ANwNMAAwAD0B5A0wADAAMAAwADAAMADsDfQN/A0EDgwOFA4wABsOMAAwADAAMAAwADAAMAAwANIG0gbSBtIG0gbSBtIG0gYjDigOwQUuDsEFMw7SBjoO0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIGQg5KDlIOVg7SBtIGXg5lDm0OdQ7SBtIGfQ6EDooOjQ6UDtIGmg6hDtIG0gaoDqwO0ga0DrwO0gZgAGAAYADEDmAAYAAkBtIGzA5gANIOYADaDokO0gbSBt8O5w7SBu8O0gb1DvwO0gZgAGAAxA7SBtIG0gbSBtIGYABgAGAAYAAED2AAsAUMD9IG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIGFA8sBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAccD9IGLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHJA8sBywHLAcsBywHLAccDywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywPLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAc0D9IG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIGLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAccD9IG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIGFA8sBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHPA/SBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gYUD0QPlQCVAJUAMAAwADAAMACVAJUAlQCVAJUAlQCVAEwPMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAA//8EAAQABAAEAAQABAAEAAQABAANAAMAAQABAAIABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQACgATABcAHgAbABoAHgAXABYAEgAeABsAGAAPABgAHABLAEsASwBLAEsASwBLAEsASwBLABgAGAAeAB4AHgATAB4AUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQABYAGwASAB4AHgAeAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAWAA0AEQAeAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAAQABAAEAAQABAAFAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAJABYAGgAbABsAGwAeAB0AHQAeAE8AFwAeAA0AHgAeABoAGwBPAE8ADgBQAB0AHQAdAE8ATwAXAE8ATwBPABYAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAB0AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAdAFAAUABQAFAAUABQAFAAUAAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAFAAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAeAB4AHgAeAFAATwBAAE8ATwBPAEAATwBQAFAATwBQAB4AHgAeAB4AHgAeAB0AHQAdAB0AHgAdAB4ADgBQAFAAUABQAFAAHgAeAB4AHgAeAB4AHgBQAB4AUAAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4ABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAJAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAkACQAJAAkACQAJAAkABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAeAB4AHgAeAFAAHgAeAB4AKwArAFAAUABQAFAAGABQACsAKwArACsAHgAeAFAAHgBQAFAAUAArAFAAKwAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AKwAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4ABAAEAAQABAAEAAQABAAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAUAAeAB4AHgAeAB4AHgBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAYAA0AKwArAB4AHgAbACsABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQADQAEAB4ABAAEAB4ABAAEABMABAArACsAKwArACsAKwArACsAVgBWAFYAVgBWAFYAVgBWAFYAVgBWAFYAVgBWAFYAVgBWAFYAVgBWAFYAVgBWAFYAVgBWAFYAKwArACsAKwBWAFYAVgBWAB4AHgArACsAKwArACsAKwArACsAKwArACsAHgAeAB4AHgAeAB4AHgAeAB4AGgAaABoAGAAYAB4AHgAEAAQABAAEAAQABAAEAAQABAAEAAQAEwAEACsAEwATAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABABLAEsASwBLAEsASwBLAEsASwBLABoAGQAZAB4AUABQAAQAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQABMAUAAEAAQABAAEAAQABAAEAB4AHgAEAAQABAAEAAQABABQAFAABAAEAB4ABAAEAAQABABQAFAASwBLAEsASwBLAEsASwBLAEsASwBQAFAAUAAeAB4AUAAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AKwAeAFAABABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAABAAEAAQABAAEAAQABAAEAAQABAAEAFAAKwArACsAKwArACsAKwArACsAKwArACsAKwArAEsASwBLAEsASwBLAEsASwBLAEsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAABAAEAAQABAAEAAQABAAEAAQAUABQAB4AHgAYABMAUAArACsABAAbABsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAFAABAAEAAQABAAEAFAABAAEAAQAUAAEAAQABAAEAAQAKwArAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAArACsAHgArAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArAFAAUABQAFAAUABQAFAAUABQAFAAKwArACsAKwArACsAKwArACsAKwArAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAB4ABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAQABAAEAFAABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQAUAAEAAQABAAEAAQABAAEAFAAUABQAFAAUABQAFAAUABQAFAABAAEAA0ADQBLAEsASwBLAEsASwBLAEsASwBLAB4AUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAArAFAAUABQAFAAUABQAFAAUAArACsAUABQACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwBQAFAAUABQAFAAUABQACsAUAArACsAKwBQAFAAUABQACsAKwAEAFAABAAEAAQABAAEAAQABAArACsABAAEACsAKwAEAAQABABQACsAKwArACsAKwArACsAKwAEACsAKwArACsAUABQACsAUABQAFAABAAEACsAKwBLAEsASwBLAEsASwBLAEsASwBLAFAAUAAaABoAUABQAFAAUABQAEwAHgAbAFAAHgAEACsAKwAEAAQABAArAFAAUABQAFAAUABQACsAKwArACsAUABQACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwBQAFAAUABQAFAAUABQACsAUABQACsAUABQACsAUABQACsAKwAEACsABAAEAAQABAAEACsAKwArACsABAAEACsAKwAEAAQABAArACsAKwAEACsAKwArACsAKwArACsAUABQAFAAUAArAFAAKwArACsAKwArACsAKwBLAEsASwBLAEsASwBLAEsASwBLAAQABABQAFAAUAAEAB4AKwArACsAKwArACsAKwArACsAKwAEAAQABAArAFAAUABQAFAAUABQAFAAUABQACsAUABQAFAAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwBQAFAAUABQAFAAUABQACsAUABQACsAUABQAFAAUABQACsAKwAEAFAABAAEAAQABAAEAAQABAAEACsABAAEAAQAKwAEAAQABAArACsAUAArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwBQAFAABAAEACsAKwBLAEsASwBLAEsASwBLAEsASwBLAB4AGwArACsAKwArACsAKwArAFAABAAEAAQABAAEAAQAKwAEAAQABAArAFAAUABQAFAAUABQAFAAUAArACsAUABQACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAQABAAEAAQABAArACsABAAEACsAKwAEAAQABAArACsAKwArACsAKwArAAQABAAEACsAKwArACsAUABQACsAUABQAFAABAAEACsAKwBLAEsASwBLAEsASwBLAEsASwBLAB4AUABQAFAAUABQAFAAUAArACsAKwArACsAKwArACsAKwArAAQAUAArAFAAUABQAFAAUABQACsAKwArAFAAUABQACsAUABQAFAAUAArACsAKwBQAFAAKwBQACsAUABQACsAKwArAFAAUAArACsAKwBQAFAAUAArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArAAQABAAEAAQABAArACsAKwAEAAQABAArAAQABAAEAAQAKwArAFAAKwArACsAKwArACsABAArACsAKwArACsAKwArACsAKwArAEsASwBLAEsASwBLAEsASwBLAEsAUABQAFAAHgAeAB4AHgAeAB4AGwAeACsAKwArACsAKwAEAAQABAAEAAQAUABQAFAAUABQAFAAUABQACsAUABQAFAAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArACsAUAAEAAQABAAEAAQABAAEACsABAAEAAQAKwAEAAQABAAEACsAKwArACsAKwArACsABAAEACsAUABQAFAAKwArACsAKwArAFAAUAAEAAQAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArACsAKwAOAFAAUABQAFAAUABQAFAAHgBQAAQABAAEAA4AUABQAFAAUABQAFAAUABQACsAUABQAFAAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArAFAAUABQAFAAUABQAFAAUABQAFAAKwBQAFAAUABQAFAAKwArAAQAUAAEAAQABAAEAAQABAAEACsABAAEAAQAKwAEAAQABAAEACsAKwArACsAKwArACsABAAEACsAKwArACsAKwArACsAUAArAFAAUAAEAAQAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwBQAFAAKwArACsAKwArACsAKwArACsAKwArACsAKwAEAAQABAAEAFAAUABQAFAAUABQAFAAUABQACsAUABQAFAAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAABAAEAFAABAAEAAQABAAEAAQABAArAAQABAAEACsABAAEAAQABABQAB4AKwArACsAKwBQAFAAUAAEAFAAUABQAFAAUABQAFAAUABQAFAABAAEACsAKwBLAEsASwBLAEsASwBLAEsASwBLAFAAUABQAFAAUABQAFAAUABQABoAUABQAFAAUABQAFAAKwAEAAQABAArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArAFAAUABQAFAAUABQAFAAUABQACsAUAArACsAUABQAFAAUABQAFAAUAArACsAKwAEACsAKwArACsABAAEAAQABAAEAAQAKwAEACsABAAEAAQABAAEAAQABAAEACsAKwArACsAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArAAQABAAeACsAKwArACsAKwArACsAKwArACsAKwArAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXAAqAFwAXAAqACoAKgAqACoAKgAqACsAKwArACsAGwBcAFwAXABcAFwAXABcACoAKgAqACoAKgAqACoAKgAeAEsASwBLAEsASwBLAEsASwBLAEsADQANACsAKwArACsAKwBcAFwAKwBcACsAXABcAFwAXABcACsAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcACsAXAArAFwAXABcAFwAXABcAFwAXABcAFwAKgBcAFwAKgAqACoAKgAqACoAKgAqACoAXAArACsAXABcAFwAXABcACsAXAArACoAKgAqACoAKgAqACsAKwBLAEsASwBLAEsASwBLAEsASwBLACsAKwBcAFwAXABcAFAADgAOAA4ADgAeAA4ADgAJAA4ADgANAAkAEwATABMAEwATAAkAHgATAB4AHgAeAAQABAAeAB4AHgAeAB4AHgBLAEsASwBLAEsASwBLAEsASwBLAFAAUABQAFAAUABQAFAAUABQAFAADQAEAB4ABAAeAAQAFgARABYAEQAEAAQAUABQAFAAUABQAFAAUABQACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArACsAKwAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQADQAEAAQABAAEAAQADQAEAAQAUABQAFAAUABQAAQABAAEAAQABAAEAAQABAAEAAQABAArAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAArAA0ADQAeAB4AHgAeAB4AHgAEAB4AHgAeAB4AHgAeACsAHgAeAA4ADgANAA4AHgAeAB4AHgAeAAkACQArACsAKwArACsAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgBcAEsASwBLAEsASwBLAEsASwBLAEsADQANAB4AHgAeAB4AXABcAFwAXABcAFwAKgAqACoAKgBcAFwAXABcACoAKgAqAFwAKgAqACoAXABcACoAKgAqACoAKgAqACoAXABcAFwAKgAqACoAKgBcAFwAXABcAFwAXABcAFwAXABcAFwAXABcACoAKgAqACoAKgAqACoAKgAqACoAKgAqAFwAKgBLAEsASwBLAEsASwBLAEsASwBLACoAKgAqACoAKgAqAFAAUABQAFAAUABQACsAUAArACsAKwArACsAUAArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAHgBQAFAAUABQAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABZAFkAWQBZAFkAWQBZAFkAWQBZAFkAWQBZAFkAWQBZAFkAWQBZAFkAWQBZAFkAWQBZAFkAWQBZAFkAWQBZAFkAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFAAUABQAFAAUABQAFAAUABQACsAUABQAFAAUAArACsAUABQAFAAUABQAFAAUAArAFAAKwBQAFAAUABQACsAKwBQAFAAUABQAFAAUABQAFAAUAArAFAAUABQAFAAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArAFAAUABQAFAAKwArAFAAUABQAFAAUABQAFAAKwBQACsAUABQAFAAUAArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwBQAFAAUABQACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsABAAEAAQAHgANAB4AHgAeAB4AHgAeAB4AUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAHgAeAB4AHgAeAB4AHgAeAB4AHgArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwBQAFAAUABQAFAAUAArACsADQBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAHgAeAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAANAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAWABEAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAA0ADQANAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwBQAFAAUABQAAQABAAEACsAKwArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAANAA0AKwArACsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAABAAEACsAKwArACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwBQAFAAUAArAAQABAArACsAKwArACsAKwArACsAKwArACsAKwBcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqAA0ADQAVAFwADQAeAA0AGwBcACoAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwAeAB4AEwATAA0ADQAOAB4AEwATAB4ABAAEAAQACQArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArAFAAUABQAFAAUAAEAAQAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAQAUAArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwAEAAQABAAEAAQABAAEAAQABAAEAAQABAArACsAKwArAAQABAAEAAQABAAEAAQABAAEAAQABAAEACsAKwArACsAHgArACsAKwATABMASwBLAEsASwBLAEsASwBLAEsASwBcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXAArACsAXABcAFwAXABcACsAKwArACsAKwArACsAKwArACsAKwBcAFwAXABcAFwAXABcAFwAXABcAFwAXAArACsAKwArAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcACsAKwArACsAKwArAEsASwBLAEsASwBLAEsASwBLAEsAXAArACsAKwAqACoAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAQABAAEAAQABAArACsAHgAeAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcACoAKgAqACoAKgAqACoAKgAqACoAKwAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKwArAAQASwBLAEsASwBLAEsASwBLAEsASwArACsAKwArACsAKwBLAEsASwBLAEsASwBLAEsASwBLACsAKwArACsAKwArACoAKgAqACoAKgAqACoAXAAqACoAKgAqACoAKgArACsABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsABAAEAAQABAAEAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAQABAAEAAQABABQAFAAUABQAFAAUABQACsAKwArACsASwBLAEsASwBLAEsASwBLAEsASwANAA0AHgANAA0ADQANAB4AHgAeAB4AHgAeAB4AHgAeAB4ABAAEAAQABAAEAAQABAAEAAQAHgAeAB4AHgAeAB4AHgAeAB4AKwArACsABAAEAAQAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAABAAEAAQABAAEAAQABAAEAAQABAAEAAQABABQAFAASwBLAEsASwBLAEsASwBLAEsASwBQAFAAUABQAFAAUABQAFAABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEACsAKwArACsAKwArACsAKwAeAB4AHgAeAFAAUABQAFAABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEACsAKwArAA0ADQANAA0ADQBLAEsASwBLAEsASwBLAEsASwBLACsAKwArAFAAUABQAEsASwBLAEsASwBLAEsASwBLAEsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAA0ADQBQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwBQAFAAUAAeAB4AHgAeAB4AHgAeAB4AKwArACsAKwArACsAKwArAAQABAAEAB4ABAAEAAQABAAEAAQABAAEAAQABAAEAAQABABQAFAAUABQAAQAUABQAFAAUABQAFAABABQAFAABAAEAAQAUAArACsAKwArACsABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEACsABAAEAAQABAAEAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AKwArAFAAUABQAFAAUABQACsAKwBQAFAAUABQAFAAUABQAFAAKwBQACsAUAArAFAAKwAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeACsAKwAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgArAB4AHgAeAB4AHgAeAB4AHgBQAB4AHgAeAFAAUABQACsAHgAeAB4AHgAeAB4AHgAeAB4AHgBQAFAAUABQACsAKwAeAB4AHgAeAB4AHgArAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AKwArAFAAUABQACsAHgAeAB4AHgAeAB4AHgAOAB4AKwANAA0ADQANAA0ADQANAAkADQANAA0ACAAEAAsABAAEAA0ACQANAA0ADAAdAB0AHgAXABcAFgAXABcAFwAWABcAHQAdAB4AHgAUABQAFAANAAEAAQAEAAQABAAEAAQACQAaABoAGgAaABoAGgAaABoAHgAXABcAHQAVABUAHgAeAB4AHgAeAB4AGAAWABEAFQAVABUAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4ADQAeAA0ADQANAA0AHgANAA0ADQAHAB4AHgAeAB4AKwAEAAQABAAEAAQABAAEAAQABAAEAFAAUAArACsATwBQAFAAUABQAFAAHgAeAB4AFgARAE8AUABPAE8ATwBPAFAAUABQAFAAUAAeAB4AHgAWABEAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArABsAGwAbABsAGwAbABsAGgAbABsAGwAbABsAGwAbABsAGwAbABsAGwAbABsAGgAbABsAGwAbABoAGwAbABoAGwAbABsAGwAbABsAGwAbABsAGwAbABsAGwAbABsAGwAbAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQAHgAeAFAAGgAeAB0AHgBQAB4AGgAeAB4AHgAeAB4AHgAeAB4AHgBPAB4AUAAbAB4AHgBQAFAAUABQAFAAHgAeAB4AHQAdAB4AUAAeAFAAHgBQAB4AUABPAFAAUAAeAB4AHgAeAB4AHgAeAFAAUABQAFAAUAAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAFAAHgBQAFAAUABQAE8ATwBQAFAAUABQAFAATwBQAFAATwBQAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAFAAUABQAFAATwBPAE8ATwBPAE8ATwBPAE8ATwBQAFAAUABQAFAAUABQAFAAUAAeAB4AUABQAFAAUABPAB4AHgArACsAKwArAB0AHQAdAB0AHQAdAB0AHQAdAB0AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB0AHgAdAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAdAB4AHQAdAB4AHgAeAB0AHQAeAB4AHQAeAB4AHgAdAB4AHQAbABsAHgAdAB4AHgAeAB4AHQAeAB4AHQAdAB0AHQAeAB4AHQAeAB0AHgAdAB0AHQAdAB0AHQAeAB0AHgAeAB4AHgAeAB0AHQAdAB0AHgAeAB4AHgAdAB0AHgAeAB4AHgAeAB4AHgAeAB4AHgAdAB4AHgAeAB0AHgAeAB4AHgAeAB0AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAdAB0AHgAeAB0AHQAdAB0AHgAeAB0AHQAeAB4AHQAdAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB0AHQAeAB4AHQAdAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHQAeAB4AHgAdAB4AHgAeAB4AHgAeAB4AHQAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB0AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AFAAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeABYAEQAWABEAHgAeAB4AHgAeAB4AHQAeAB4AHgAeAB4AHgAeACUAJQAeAB4AHgAeAB4AHgAeAB4AHgAWABEAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AJQAlACUAJQAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAFAAHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHgAeAB4AHgAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAeAB4AHQAdAB0AHQAeAB4AHgAeAB4AHgAeAB4AHgAeAB0AHQAeAB0AHQAdAB0AHQAdAB0AHgAeAB4AHgAeAB4AHgAeAB0AHQAeAB4AHQAdAB4AHgAeAB4AHQAdAB4AHgAeAB4AHQAdAB0AHgAeAB0AHgAeAB0AHQAdAB0AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAdAB0AHQAdAB4AHgAeAB4AHgAeAB4AHgAeAB0AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAlACUAJQAlAB4AHQAdAB4AHgAdAB4AHgAeAB4AHQAdAB4AHgAeAB4AJQAlAB0AHQAlAB4AJQAlACUAIAAlACUAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAlACUAJQAeAB4AHgAeAB0AHgAdAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAdAB0AHgAdAB0AHQAeAB0AJQAdAB0AHgAdAB0AHgAdAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeACUAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHQAdAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAlACUAJQAlACUAJQAlACUAJQAlACUAJQAdAB0AHQAdACUAHgAlACUAJQAdACUAJQAdAB0AHQAlACUAHQAdACUAHQAdACUAJQAlAB4AHQAeAB4AHgAeAB0AHQAlAB0AHQAdAB0AHQAdACUAJQAlACUAJQAdACUAJQAgACUAHQAdACUAJQAlACUAJQAlACUAJQAeAB4AHgAlACUAIAAgACAAIAAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB0AHgAeAB4AFwAXABcAFwAXABcAHgATABMAJQAeAB4AHgAWABEAFgARABYAEQAWABEAFgARABYAEQAWABEATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeABYAEQAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAWABEAFgARABYAEQAWABEAFgARAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AFgARABYAEQAWABEAFgARABYAEQAWABEAFgARABYAEQAWABEAFgARABYAEQAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAWABEAFgARAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AFgARAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAdAB0AHQAdAB0AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgArACsAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AKwAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AUABQAFAAUAAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAEAAQABAAeAB4AKwArACsAKwArABMADQANAA0AUAATAA0AUABQAFAAUABQAFAAUABQACsAKwArACsAKwArACsAUAANACsAKwArACsAKwArACsAKwArACsAKwArACsAKwAEAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQACsAUABQAFAAUABQAFAAUAArAFAAUABQAFAAUABQAFAAKwBQAFAAUABQAFAAUABQACsAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXAA0ADQANAA0ADQANAA0ADQAeAA0AFgANAB4AHgAXABcAHgAeABcAFwAWABEAFgARABYAEQAWABEADQANAA0ADQATAFAADQANAB4ADQANAB4AHgAeAB4AHgAMAAwADQANAA0AHgANAA0AFgANAA0ADQANAA0ADQANAA0AHgANAB4ADQANAB4AHgAeACsAKwArACsAKwArACsAKwArACsAKwArACsAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACsAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAKwArACsAKwArACsAKwArACsAKwArACsAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwAlACUAJQAlACUAJQAlACUAJQAlACUAJQArACsAKwArAA0AEQARACUAJQBHAFcAVwAWABEAFgARABYAEQAWABEAFgARACUAJQAWABEAFgARABYAEQAWABEAFQAWABEAEQAlAFcAVwBXAFcAVwBXAFcAVwBXAAQABAAEAAQABAAEACUAVwBXAFcAVwA2ACUAJQBXAFcAVwBHAEcAJQAlACUAKwBRAFcAUQBXAFEAVwBRAFcAUQBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFEAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBRAFcAUQBXAFEAVwBXAFcAVwBXAFcAUQBXAFcAVwBXAFcAVwBRAFEAKwArAAQABAAVABUARwBHAFcAFQBRAFcAUQBXAFEAVwBRAFcAUQBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFEAVwBRAFcAUQBXAFcAVwBXAFcAVwBRAFcAVwBXAFcAVwBXAFEAUQBXAFcAVwBXABUAUQBHAEcAVwArACsAKwArACsAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAKwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAKwAlACUAVwBXAFcAVwAlACUAJQAlACUAJQAlACUAJQAlACsAKwArACsAKwArACsAKwArACsAKwArAFEAUQBRAFEAUQBRAFEAUQBRAFEAUQBRAFEAUQBRAFEAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQArAFcAVwBXAFcAVwBXAFcAVwBXAFcAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQBPAE8ATwBPAE8ATwBPAE8AJQBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXACUAJQAlAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAEcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAKwArACsAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAADQATAA0AUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABLAEsASwBLAEsASwBLAEsASwBLAFAAUAArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAFAABAAEAAQABAAeAAQABAAEAAQABAAEAAQABAAEAAQAHgBQAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AUABQAAQABABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAQABAAeAA0ADQANAA0ADQArACsAKwArACsAKwArACsAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAFAAUABQAFAAUABQAFAAUABQAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AUAAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgBQAB4AHgAeAB4AHgAeAFAAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgArACsAHgAeAB4AHgAeAB4AHgAeAB4AKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwAeAB4AUABQAFAAUABQAFAAUABQAFAAUABQAAQAUABQAFAABABQAFAAUABQAAQAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAQABAAEAAQABAAeAB4AHgAeAAQAKwArACsAUABQAFAAUABQAFAAHgAeABoAHgArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAADgAOABMAEwArACsAKwArACsAKwArACsABAAEAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAQABAAEAAQABAAEACsAKwArACsAKwArACsAKwANAA0ASwBLAEsASwBLAEsASwBLAEsASwArACsAKwArACsAKwAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABABQAFAAUABQAFAAUAAeAB4AHgBQAA4AUABQAAQAUABQAFAAUABQAFAABAAEAAQABAAEAAQABAAEAA0ADQBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQAKwArACsAKwArACsAKwArACsAKwArAB4AWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYACsAKwArAAQAHgAeAB4AHgAeAB4ADQANAA0AHgAeAB4AHgArAFAASwBLAEsASwBLAEsASwBLAEsASwArACsAKwArAB4AHgBcAFwAXABcAFwAKgBcAFwAXABcAFwAXABcAFwAXABcAEsASwBLAEsASwBLAEsASwBLAEsAXABcAFwAXABcACsAUABQAFAAUABQAFAAUABQAFAABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEACsAKwArACsAKwArACsAKwArAFAAUABQAAQAUABQAFAAUABQAFAAUABQAAQABAArACsASwBLAEsASwBLAEsASwBLAEsASwArACsAHgANAA0ADQBcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAKgAqACoAXAAqACoAKgBcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXAAqAFwAKgAqACoAXABcACoAKgBcAFwAXABcAFwAKgAqAFwAKgBcACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAFwAXABcACoAKgBQAFAAUABQAFAAUABQAFAAUABQAFAABAAEAAQABAAEAA0ADQBQAFAAUAAEAAQAKwArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUAArACsAUABQAFAAUABQAFAAKwArAFAAUABQAFAAUABQACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAKwBQAFAAUABQAFAAUABQACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAHgAeACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQABAAEAAQADQAEAAQAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArACsAVABVAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBUAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBVACsAKwArACsAKwArACsAKwArACsAKwArAFkAWQBZAFkAWQBZAFkAWQBZAFkAWQBZAFkAWQBZAFkAWQBZAFkAKwArACsAKwBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAKwArACsAKwAGAAYABgAGAAYABgAGAAYABgAGAAYABgAGAAYABgAGAAYABgAGAAYABgAGAAYABgAGAAYABgAGAAYABgAGAAYAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXACUAJQBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAJQAlACUAJQAlACUAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAKwArACsAKwArAFYABABWAFYAVgBWAFYAVgBWAFYAVgBWAB4AVgBWAFYAVgBWAFYAVgBWAFYAVgBWAFYAVgArAFYAVgBWAFYAVgArAFYAKwBWAFYAKwBWAFYAKwBWAFYAVgBWAFYAVgBWAFYAVgBWAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAEQAWAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUAAaAB4AKwArAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQAGAARABEAGAAYABMAEwAWABEAFAArACsAKwArACsAKwAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEACUAJQAlACUAJQAWABEAFgARABYAEQAWABEAFgARABYAEQAlACUAFgARACUAJQAlACUAJQAlACUAEQAlABEAKwAVABUAEwATACUAFgARABYAEQAWABEAJQAlACUAJQAlACUAJQAlACsAJQAbABoAJQArACsAKwArAFAAUABQAFAAUAArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArAAcAKwATACUAJQAbABoAJQAlABYAEQAlACUAEQAlABEAJQBXAFcAVwBXAFcAVwBXAFcAVwBXABUAFQAlACUAJQATACUAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXABYAJQARACUAJQAlAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwAWACUAEQAlABYAEQARABYAEQARABUAVwBRAFEAUQBRAFEAUQBRAFEAUQBRAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAEcARwArACsAVwBXAFcAVwBXAFcAKwArAFcAVwBXAFcAVwBXACsAKwBXAFcAVwBXAFcAVwArACsAVwBXAFcAKwArACsAGgAbACUAJQAlABsAGwArAB4AHgAeAB4AHgAeAB4AKwArACsAKwArACsAKwArACsAKwAEAAQABAAQAB0AKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwBQAFAAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsADQANAA0AKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArAB4AHgAeAB4AHgAeAB4AHgAeAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgBQAFAAHgAeAB4AKwAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAAQAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwAEAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAABAAEAAQABAAEACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArAA0AUABQAFAAUAArACsAKwArAFAAUABQAFAAUABQAFAAUAANAFAAUABQAFAAUAArACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArACsAKwArACsAKwArACsAKwAeACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAUABQAFAAUABQAFAAKwArAFAAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArAFAAUAArACsAKwBQACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwANAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAeAB4AUABQAFAAUABQAFAAUAArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArAFAAUAArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArAA0AUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArACsAKwAeAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArACsAUABQAFAAUABQAAQABAAEACsABAAEACsAKwArACsAKwAEAAQABAAEAFAAUABQAFAAKwBQAFAAUAArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArAAQABAAEACsAKwArACsABABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArAA0ADQANAA0ADQANAA0ADQAeACsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAeAFAAUABQAFAAUABQAFAAUAAeAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAQABAArACsAKwArAFAAUABQAFAAUAANAA0ADQANAA0ADQAUACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArACsADQANAA0ADQANAA0ADQBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArAB4AHgAeAB4AKwArACsAKwArACsAKwArACsAKwArACsAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArACsAKwArACsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArAFAAUABQAFAAUABQAAQABAAEAAQAKwArACsAKwArACsAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUAArAAQABAANACsAKwBQAFAAKwArACsAKwArACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAAQABAAEAAQABAAEAAQABAAEAAQABABQAFAAUABQAB4AHgAeAB4AHgArACsAKwArACsAKwAEAAQABAAEAAQABAAEAA0ADQAeAB4AHgAeAB4AKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsABABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAQABAAEAAQABAAEAAQABAAEAAQABAAeAB4AHgANAA0ADQANACsAKwArACsAKwArACsAKwArACsAKwAeACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArACsAKwArACsAKwBLAEsASwBLAEsASwBLAEsASwBLACsAKwArACsAKwArAFAAUABQAFAAUABQAFAABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEACsASwBLAEsASwBLAEsASwBLAEsASwANAA0ADQANAFAABAAEAFAAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAABAAeAA4AUAArACsAKwArACsAKwArACsAKwAEAFAAUABQAFAADQANAB4ADQAEAAQABAAEAB4ABAAEAEsASwBLAEsASwBLAEsASwBLAEsAUAAOAFAADQANAA0AKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQABAAEAAQABAAEAAQABAANAA0AHgANAA0AHgAEACsAUABQAFAAUABQAFAAUAArAFAAKwBQAFAAUABQACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwBQAFAAUABQAFAAUABQAFAAUABQAA0AKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQABAAEAAQABAAEAAQAKwArACsAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArACsABAAEAAQABAArAFAAUABQAFAAUABQAFAAUAArACsAUABQACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwBQAFAAUABQAFAAUABQACsAUABQACsAUABQAFAAUABQACsABAAEAFAABAAEAAQABAAEAAQABAArACsABAAEACsAKwAEAAQABAArACsAUAArACsAKwArACsAKwAEACsAKwArACsAKwBQAFAAUABQAFAABAAEACsAKwAEAAQABAAEAAQABAAEACsAKwArAAQABAAEAAQABAArACsAKwArACsAKwArACsAKwArACsABAAEAAQABAAEAAQABABQAFAAUABQAA0ADQANAA0AHgBLAEsASwBLAEsASwBLAEsASwBLAA0ADQArAB4ABABQAFAAUAArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwAEAAQABAAEAFAAUAAeAFAAKwArACsAKwArACsAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAABAAEAAQABAAEAAQABAArACsABAAEAAQABAAEAAQABAAEAAQADgANAA0AEwATAB4AHgAeAA0ADQANAA0ADQANAA0ADQANAA0ADQANAA0ADQANAFAAUABQAFAABAAEACsAKwAEAA0ADQAeAFAAKwArACsAKwArACsAKwArACsAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArACsADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAFAAKwArACsAKwArACsAKwBLAEsASwBLAEsASwBLAEsASwBLACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAKwArACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqACsAKwArACsASwBLAEsASwBLAEsASwBLAEsASwBcAFwADQANAA0AKgBQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAeACsAKwArACsASwBLAEsASwBLAEsASwBLAEsASwBQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAKwArAFAAKwArAFAAUABQAFAAUABQAFAAUAArAFAAUAArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAABAAEAAQABAAEAAQAKwAEAAQAKwArAAQABAAEAAQAUAAEAFAABAAEAA0ADQANACsAKwArACsAKwArACsAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAABAAEAAQABAAEAAQABAArACsABAAEAAQABAAEAAQABABQAA4AUAAEACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAFAABAAEAAQABAAEAAQABAAEAAQABABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQABAAEAFAABAAEAAQABAAOAB4ADQANAA0ADQAOAB4ABAArACsAKwArACsAKwArACsAUAAEAAQABAAEAAQABAAEAAQABAAEAAQAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAA0ADQANAFAADgAOAA4ADQANACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUAArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAABAAEAAQABAAEAAQABAAEACsABAAEAAQABAAEAAQABAAEAFAADQANAA0ADQANACsAKwArACsAKwArACsAKwArACsASwBLAEsASwBLAEsASwBLAEsASwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwAOABMAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAArAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQACsAUABQACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQABAArACsAKwAEACsABAAEACsABAAEAAQABAAEAAQABABQAAQAKwArACsAKwArACsAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArACsAUABQAFAAUABQAFAAKwBQAFAAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQAKwAEAAQAKwAEAAQABAAEAAQAUAArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAABAAEAAQABAAeAB4AKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwBQACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAB4AHgAeAB4AHgAeAB4AHgAaABoAGgAaAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgArACsAKwArACsAKwArACsAKwArACsAKwArAA0AUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsADQANAA0ADQANACsAKwArACsAKwArACsAKwArACsAKwBQAFAAUABQACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAASABIAEgAQwBDAEMAUABQAFAAUABDAFAAUABQAEgAQwBIAEMAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAASABDAEMAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwAJAAkACQAJAAkACQAJABYAEQArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABIAEMAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwANAA0AKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArAAQABAAEAAQABAANACsAKwArACsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQABAAEAA0ADQANAB4AHgAeAB4AHgAeAFAAUABQAFAADQAeACsAKwArACsAKwArACsAKwArACsASwBLAEsASwBLAEsASwBLAEsASwArAFAAUABQAFAAUABQAFAAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAANAA0AHgAeACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAKwArACsAKwAEAFAABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQAKwArACsAKwArACsAKwAEAAQABAAEAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAARwBHABUARwAJACsAKwArACsAKwArACsAKwArACsAKwAEAAQAKwArACsAKwArACsAKwArACsAKwArACsAKwArAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXACsAKwArACsAKwArACsAKwBXAFcAVwBXAFcAVwBXAFcAVwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAUQBRAFEAKwArACsAKwArACsAKwArACsAKwArACsAKwBRAFEAUQBRACsAKwArACsAKwArACsAKwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUAArACsAHgAEAAQADQAEAAQABAAEACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgArACsAKwArACsAKwArACsAKwArAB4AHgAeAB4AHgAeAB4AKwArAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAAQABAAEAAQABAAeAB4AHgAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAB4AHgAEAAQABAAEAAQABAAEAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4ABAAEAAQABAAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4ABAAEAAQAHgArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArACsAKwArACsAKwArACsAKwArAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgArACsAKwArACsAKwArACsAKwAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgArAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AKwBQAFAAKwArAFAAKwArAFAAUAArACsAUABQAFAAUAArAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeACsAUAArAFAAUABQAFAAUABQAFAAKwAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AKwBQAFAAUABQACsAKwBQAFAAUABQAFAAUABQAFAAKwBQAFAAUABQAFAAUABQACsAHgAeAFAAUABQAFAAUAArAFAAKwArACsAUABQAFAAUABQAFAAUAArAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAHgBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgBQAFAAUABQAFAAUABQAFAAUABQAFAAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAB4AHgAeAB4AHgAeAB4AHgAeACsAKwBLAEsASwBLAEsASwBLAEsASwBLAEsASwBLAEsASwBLAEsASwBLAEsASwBLAEsASwBLAEsASwBLAEsASwBLAEsASwBLAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAeAB4AHgAeAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAeAB4AHgAeAB4AHgAeAB4ABAAeAB4AHgAeAB4AHgAeAB4AHgAeAAQAHgAeAA0ADQANAA0AHgArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwAEAAQABAAEAAQAKwAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAAQABAAEAAQABAAEAAQAKwAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQAKwArAAQABAAEAAQABAAEAAQAKwAEAAQAKwAEAAQABAAEAAQAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwAEAAQABAAEAAQABAAEAFAAUABQAFAAUABQAFAAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwBQAB4AKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArABsAUABQAFAAUABQACsAKwBQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQABAAEACsAKwArACsAKwArACsAKwArAB4AHgAeAB4ABAAEAAQABAAEAAQABABQACsAKwArACsASwBLAEsASwBLAEsASwBLAEsASwArACsAKwArABYAFgArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAGgBQAFAAUAAaAFAAUABQAFAAKwArACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAeAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwBQAFAAUABQACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwBQAFAAKwBQACsAKwBQACsAUABQAFAAUABQAFAAUABQAFAAUAArAFAAUABQAFAAKwBQACsAUAArACsAKwArACsAKwBQACsAKwArACsAUAArAFAAKwBQACsAUABQAFAAKwBQAFAAKwBQACsAKwBQACsAUAArAFAAKwBQACsAUAArAFAAUAArAFAAKwArAFAAUABQAFAAKwBQAFAAUABQAFAAUABQACsAUABQAFAAUAArAFAAUABQAFAAKwBQACsAUABQAFAAUABQAFAAUABQAFAAUAArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAUABQAFAAKwBQAFAAUABQAFAAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwAeAB4AKwArACsAKwArACsAKwArACsAKwArACsAKwArAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8AJQAlACUAHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHgAeAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB4AHgAeACUAJQAlAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQApACkAKQApACkAKQApACkAKQApACkAKQApACkAKQApACkAKQApACkAKQApACkAKQApACkAJQAlACUAJQAlACAAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAeAB4AJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlAB4AHgAlACUAJQAlACUAHgAlACUAJQAlACUAIAAgACAAJQAlACAAJQAlACAAIAAgACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACEAIQAhACEAIQAlACUAIAAgACUAJQAgACAAIAAgACAAIAAgACAAIAAgACAAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAJQAlACUAIAAlACUAJQAlACAAIAAgACUAIAAgACAAJQAlACUAJQAlACUAJQAgACUAIAAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAHgAlAB4AJQAeACUAJQAlACUAJQAgACUAJQAlACUAHgAlAB4AHgAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlAB4AHgAeAB4AHgAeAB4AJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAeAB4AHgAeAB4AHgAeAB4AHgAeACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACAAIAAlACUAJQAlACAAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACAAJQAlACUAJQAgACAAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAHgAeAB4AHgAeAB4AHgAeACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAeAB4AHgAeAB4AHgAlACUAJQAlACUAJQAlACAAIAAgACUAJQAlACAAIAAgACAAIAAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeABcAFwAXABUAFQAVAB4AHgAeAB4AJQAlACUAIAAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACAAIAAgACUAJQAlACUAJQAlACUAJQAlACAAJQAlACUAJQAlACUAJQAlACUAJQAlACAAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AJQAlACUAJQAlACUAJQAlACUAJQAlACUAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AJQAlACUAJQAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeACUAJQAlACUAJQAlACUAJQAeAB4AHgAeAB4AHgAeAB4AHgAeACUAJQAlACUAJQAlAB4AHgAeAB4AHgAeAB4AHgAlACUAJQAlACUAJQAlACUAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAgACUAJQAgACUAJQAlACUAJQAlACUAJQAgACAAIAAgACAAIAAgACAAJQAlACUAJQAlACUAIAAlACUAJQAlACUAJQAlACUAJQAgACAAIAAgACAAIAAgACAAIAAgACUAJQAgACAAIAAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAgACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACAAIAAlACAAIAAlACAAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAgACAAIAAlACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAJQAlAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AKwAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArACsAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAKwArAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXACUAJQBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwAlACUAJQAlACUAJQAlACUAJQAlACUAVwBXACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAKwAEACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAA==";
var LETTER_NUMBER_MODIFIER = 50;
var BK = 1;
var CR$1 = 2;
var LF$1 = 3;
var CM = 4;
var NL = 5;
var WJ = 7;
var ZW = 8;
var GL = 9;
var SP = 10;
var ZWJ$1 = 11;
var B2 = 12;
var BA = 13;
var BB = 14;
var HY = 15;
var CB = 16;
var CL = 17;
var CP = 18;
var EX = 19;
var IN = 20;
var NS = 21;
var OP = 22;
var QU = 23;
var IS = 24;
var NU = 25;
var PO = 26;
var PR = 27;
var SY = 28;
var AI = 29;
var AL = 30;
var CJ = 31;
var EB = 32;
var EM = 33;
var H2 = 34;
var H3 = 35;
var HL = 36;
var ID = 37;
var JL = 38;
var JV = 39;
var JT = 40;
var RI$1 = 41;
var SA = 42;
var XX = 43;
var ea_OP = [9001, 65288];
var BREAK_MANDATORY = "!";
var BREAK_NOT_ALLOWED$1 = "\xD7";
var BREAK_ALLOWED$1 = "\xF7";
var UnicodeTrie$1 = createTrieFromBase64$1(base64$1);
var ALPHABETICS = [AL, HL];
var HARD_LINE_BREAKS = [BK, CR$1, LF$1, NL];
var SPACE$1 = [SP, ZW];
var PREFIX_POSTFIX = [PR, PO];
var LINE_BREAKS = HARD_LINE_BREAKS.concat(SPACE$1);
var KOREAN_SYLLABLE_BLOCK = [JL, JV, JT, H2, H3];
var HYPHEN = [HY, BA];
var codePointsToCharacterClasses = function(codePoints, lineBreak2) {
  if (lineBreak2 === void 0) {
    lineBreak2 = "strict";
  }
  var types = [];
  var indices = [];
  var categories = [];
  codePoints.forEach(function(codePoint, index2) {
    var classType = UnicodeTrie$1.get(codePoint);
    if (classType > LETTER_NUMBER_MODIFIER) {
      categories.push(true);
      classType -= LETTER_NUMBER_MODIFIER;
    } else {
      categories.push(false);
    }
    if (["normal", "auto", "loose"].indexOf(lineBreak2) !== -1) {
      if ([8208, 8211, 12316, 12448].indexOf(codePoint) !== -1) {
        indices.push(index2);
        return types.push(CB);
      }
    }
    if (classType === CM || classType === ZWJ$1) {
      if (index2 === 0) {
        indices.push(index2);
        return types.push(AL);
      }
      var prev = types[index2 - 1];
      if (LINE_BREAKS.indexOf(prev) === -1) {
        indices.push(indices[index2 - 1]);
        return types.push(prev);
      }
      indices.push(index2);
      return types.push(AL);
    }
    indices.push(index2);
    if (classType === CJ) {
      return types.push(lineBreak2 === "strict" ? NS : ID);
    }
    if (classType === SA) {
      return types.push(AL);
    }
    if (classType === AI) {
      return types.push(AL);
    }
    if (classType === XX) {
      if (codePoint >= 131072 && codePoint <= 196605 || codePoint >= 196608 && codePoint <= 262141) {
        return types.push(ID);
      } else {
        return types.push(AL);
      }
    }
    types.push(classType);
  });
  return [indices, types, categories];
};
var isAdjacentWithSpaceIgnored = function(a2, b2, currentIndex, classTypes) {
  var current = classTypes[currentIndex];
  if (Array.isArray(a2) ? a2.indexOf(current) !== -1 : a2 === current) {
    var i2 = currentIndex;
    while (i2 <= classTypes.length) {
      i2++;
      var next = classTypes[i2];
      if (next === b2) {
        return true;
      }
      if (next !== SP) {
        break;
      }
    }
  }
  if (current === SP) {
    var i2 = currentIndex;
    while (i2 > 0) {
      i2--;
      var prev = classTypes[i2];
      if (Array.isArray(a2) ? a2.indexOf(prev) !== -1 : a2 === prev) {
        var n2 = currentIndex;
        while (n2 <= classTypes.length) {
          n2++;
          var next = classTypes[n2];
          if (next === b2) {
            return true;
          }
          if (next !== SP) {
            break;
          }
        }
      }
      if (prev !== SP) {
        break;
      }
    }
  }
  return false;
};
var previousNonSpaceClassType = function(currentIndex, classTypes) {
  var i2 = currentIndex;
  while (i2 >= 0) {
    var type = classTypes[i2];
    if (type === SP) {
      i2--;
    } else {
      return type;
    }
  }
  return 0;
};
var _lineBreakAtIndex = function(codePoints, classTypes, indicies, index2, forbiddenBreaks) {
  if (indicies[index2] === 0) {
    return BREAK_NOT_ALLOWED$1;
  }
  var currentIndex = index2 - 1;
  if (Array.isArray(forbiddenBreaks) && forbiddenBreaks[currentIndex] === true) {
    return BREAK_NOT_ALLOWED$1;
  }
  var beforeIndex = currentIndex - 1;
  var afterIndex = currentIndex + 1;
  var current = classTypes[currentIndex];
  var before = beforeIndex >= 0 ? classTypes[beforeIndex] : 0;
  var next = classTypes[afterIndex];
  if (current === CR$1 && next === LF$1) {
    return BREAK_NOT_ALLOWED$1;
  }
  if (HARD_LINE_BREAKS.indexOf(current) !== -1) {
    return BREAK_MANDATORY;
  }
  if (HARD_LINE_BREAKS.indexOf(next) !== -1) {
    return BREAK_NOT_ALLOWED$1;
  }
  if (SPACE$1.indexOf(next) !== -1) {
    return BREAK_NOT_ALLOWED$1;
  }
  if (previousNonSpaceClassType(currentIndex, classTypes) === ZW) {
    return BREAK_ALLOWED$1;
  }
  if (UnicodeTrie$1.get(codePoints[currentIndex]) === ZWJ$1) {
    return BREAK_NOT_ALLOWED$1;
  }
  if ((current === EB || current === EM) && UnicodeTrie$1.get(codePoints[afterIndex]) === ZWJ$1) {
    return BREAK_NOT_ALLOWED$1;
  }
  if (current === WJ || next === WJ) {
    return BREAK_NOT_ALLOWED$1;
  }
  if (current === GL) {
    return BREAK_NOT_ALLOWED$1;
  }
  if ([SP, BA, HY].indexOf(current) === -1 && next === GL) {
    return BREAK_NOT_ALLOWED$1;
  }
  if ([CL, CP, EX, IS, SY].indexOf(next) !== -1) {
    return BREAK_NOT_ALLOWED$1;
  }
  if (previousNonSpaceClassType(currentIndex, classTypes) === OP) {
    return BREAK_NOT_ALLOWED$1;
  }
  if (isAdjacentWithSpaceIgnored(QU, OP, currentIndex, classTypes)) {
    return BREAK_NOT_ALLOWED$1;
  }
  if (isAdjacentWithSpaceIgnored([CL, CP], NS, currentIndex, classTypes)) {
    return BREAK_NOT_ALLOWED$1;
  }
  if (isAdjacentWithSpaceIgnored(B2, B2, currentIndex, classTypes)) {
    return BREAK_NOT_ALLOWED$1;
  }
  if (current === SP) {
    return BREAK_ALLOWED$1;
  }
  if (current === QU || next === QU) {
    return BREAK_NOT_ALLOWED$1;
  }
  if (next === CB || current === CB) {
    return BREAK_ALLOWED$1;
  }
  if ([BA, HY, NS].indexOf(next) !== -1 || current === BB) {
    return BREAK_NOT_ALLOWED$1;
  }
  if (before === HL && HYPHEN.indexOf(current) !== -1) {
    return BREAK_NOT_ALLOWED$1;
  }
  if (current === SY && next === HL) {
    return BREAK_NOT_ALLOWED$1;
  }
  if (next === IN) {
    return BREAK_NOT_ALLOWED$1;
  }
  if (ALPHABETICS.indexOf(next) !== -1 && current === NU || ALPHABETICS.indexOf(current) !== -1 && next === NU) {
    return BREAK_NOT_ALLOWED$1;
  }
  if (current === PR && [ID, EB, EM].indexOf(next) !== -1 || [ID, EB, EM].indexOf(current) !== -1 && next === PO) {
    return BREAK_NOT_ALLOWED$1;
  }
  if (ALPHABETICS.indexOf(current) !== -1 && PREFIX_POSTFIX.indexOf(next) !== -1 || PREFIX_POSTFIX.indexOf(current) !== -1 && ALPHABETICS.indexOf(next) !== -1) {
    return BREAK_NOT_ALLOWED$1;
  }
  if ([PR, PO].indexOf(current) !== -1 && (next === NU || [OP, HY].indexOf(next) !== -1 && classTypes[afterIndex + 1] === NU) || [OP, HY].indexOf(current) !== -1 && next === NU || current === NU && [NU, SY, IS].indexOf(next) !== -1) {
    return BREAK_NOT_ALLOWED$1;
  }
  if ([NU, SY, IS, CL, CP].indexOf(next) !== -1) {
    var prevIndex = currentIndex;
    while (prevIndex >= 0) {
      var type = classTypes[prevIndex];
      if (type === NU) {
        return BREAK_NOT_ALLOWED$1;
      } else if ([SY, IS].indexOf(type) !== -1) {
        prevIndex--;
      } else {
        break;
      }
    }
  }
  if ([PR, PO].indexOf(next) !== -1) {
    var prevIndex = [CL, CP].indexOf(current) !== -1 ? beforeIndex : currentIndex;
    while (prevIndex >= 0) {
      var type = classTypes[prevIndex];
      if (type === NU) {
        return BREAK_NOT_ALLOWED$1;
      } else if ([SY, IS].indexOf(type) !== -1) {
        prevIndex--;
      } else {
        break;
      }
    }
  }
  if (JL === current && [JL, JV, H2, H3].indexOf(next) !== -1 || [JV, H2].indexOf(current) !== -1 && [JV, JT].indexOf(next) !== -1 || [JT, H3].indexOf(current) !== -1 && next === JT) {
    return BREAK_NOT_ALLOWED$1;
  }
  if (KOREAN_SYLLABLE_BLOCK.indexOf(current) !== -1 && [IN, PO].indexOf(next) !== -1 || KOREAN_SYLLABLE_BLOCK.indexOf(next) !== -1 && current === PR) {
    return BREAK_NOT_ALLOWED$1;
  }
  if (ALPHABETICS.indexOf(current) !== -1 && ALPHABETICS.indexOf(next) !== -1) {
    return BREAK_NOT_ALLOWED$1;
  }
  if (current === IS && ALPHABETICS.indexOf(next) !== -1) {
    return BREAK_NOT_ALLOWED$1;
  }
  if (ALPHABETICS.concat(NU).indexOf(current) !== -1 && next === OP && ea_OP.indexOf(codePoints[afterIndex]) === -1 || ALPHABETICS.concat(NU).indexOf(next) !== -1 && current === CP) {
    return BREAK_NOT_ALLOWED$1;
  }
  if (current === RI$1 && next === RI$1) {
    var i2 = indicies[currentIndex];
    var count = 1;
    while (i2 > 0) {
      i2--;
      if (classTypes[i2] === RI$1) {
        count++;
      } else {
        break;
      }
    }
    if (count % 2 !== 0) {
      return BREAK_NOT_ALLOWED$1;
    }
  }
  if (current === EB && next === EM) {
    return BREAK_NOT_ALLOWED$1;
  }
  return BREAK_ALLOWED$1;
};
var cssFormattedClasses = function(codePoints, options) {
  if (!options) {
    options = { lineBreak: "normal", wordBreak: "normal" };
  }
  var _a2 = codePointsToCharacterClasses(codePoints, options.lineBreak), indicies = _a2[0], classTypes = _a2[1], isLetterNumber = _a2[2];
  if (options.wordBreak === "break-all" || options.wordBreak === "break-word") {
    classTypes = classTypes.map(function(type) {
      return [NU, AL, SA].indexOf(type) !== -1 ? ID : type;
    });
  }
  var forbiddenBreakpoints = options.wordBreak === "keep-all" ? isLetterNumber.map(function(letterNumber, i2) {
    return letterNumber && codePoints[i2] >= 19968 && codePoints[i2] <= 40959;
  }) : void 0;
  return [indicies, classTypes, forbiddenBreakpoints];
};
var Break = function() {
  function Break2(codePoints, lineBreak2, start2, end) {
    this.codePoints = codePoints;
    this.required = lineBreak2 === BREAK_MANDATORY;
    this.start = start2;
    this.end = end;
  }
  Break2.prototype.slice = function() {
    return fromCodePoint$1.apply(void 0, this.codePoints.slice(this.start, this.end));
  };
  return Break2;
}();
var LineBreaker = function(str, options) {
  var codePoints = toCodePoints$1(str);
  var _a2 = cssFormattedClasses(codePoints, options), indicies = _a2[0], classTypes = _a2[1], forbiddenBreakpoints = _a2[2];
  var length = codePoints.length;
  var lastEnd = 0;
  var nextIndex = 0;
  return {
    next: function() {
      if (nextIndex >= length) {
        return { done: true, value: null };
      }
      var lineBreak2 = BREAK_NOT_ALLOWED$1;
      while (nextIndex < length && (lineBreak2 = _lineBreakAtIndex(codePoints, classTypes, indicies, ++nextIndex, forbiddenBreakpoints)) === BREAK_NOT_ALLOWED$1) {
      }
      if (lineBreak2 !== BREAK_NOT_ALLOWED$1 || nextIndex === length) {
        var value = new Break(codePoints, lineBreak2, lastEnd, nextIndex);
        lastEnd = nextIndex;
        return { value, done: false };
      }
      return { done: true, value: null };
    }
  };
};
var FLAG_UNRESTRICTED = 1 << 0;
var FLAG_ID = 1 << 1;
var FLAG_INTEGER = 1 << 2;
var FLAG_NUMBER = 1 << 3;
var LINE_FEED = 10;
var SOLIDUS = 47;
var REVERSE_SOLIDUS = 92;
var CHARACTER_TABULATION = 9;
var SPACE = 32;
var QUOTATION_MARK = 34;
var EQUALS_SIGN = 61;
var NUMBER_SIGN = 35;
var DOLLAR_SIGN = 36;
var PERCENTAGE_SIGN = 37;
var APOSTROPHE = 39;
var LEFT_PARENTHESIS = 40;
var RIGHT_PARENTHESIS = 41;
var LOW_LINE = 95;
var HYPHEN_MINUS = 45;
var EXCLAMATION_MARK = 33;
var LESS_THAN_SIGN = 60;
var GREATER_THAN_SIGN = 62;
var COMMERCIAL_AT = 64;
var LEFT_SQUARE_BRACKET = 91;
var RIGHT_SQUARE_BRACKET = 93;
var CIRCUMFLEX_ACCENT = 61;
var LEFT_CURLY_BRACKET = 123;
var QUESTION_MARK = 63;
var RIGHT_CURLY_BRACKET = 125;
var VERTICAL_LINE = 124;
var TILDE = 126;
var CONTROL = 128;
var REPLACEMENT_CHARACTER = 65533;
var ASTERISK = 42;
var PLUS_SIGN = 43;
var COMMA = 44;
var COLON = 58;
var SEMICOLON = 59;
var FULL_STOP = 46;
var NULL = 0;
var BACKSPACE = 8;
var LINE_TABULATION = 11;
var SHIFT_OUT = 14;
var INFORMATION_SEPARATOR_ONE = 31;
var DELETE = 127;
var EOF = -1;
var ZERO = 48;
var a$1 = 97;
var e$1 = 101;
var f$1 = 102;
var u$1 = 117;
var z = 122;
var A = 65;
var E = 69;
var F = 70;
var U = 85;
var Z = 90;
var isDigit = function(codePoint) {
  return codePoint >= ZERO && codePoint <= 57;
};
var isSurrogateCodePoint = function(codePoint) {
  return codePoint >= 55296 && codePoint <= 57343;
};
var isHex = function(codePoint) {
  return isDigit(codePoint) || codePoint >= A && codePoint <= F || codePoint >= a$1 && codePoint <= f$1;
};
var isLowerCaseLetter = function(codePoint) {
  return codePoint >= a$1 && codePoint <= z;
};
var isUpperCaseLetter = function(codePoint) {
  return codePoint >= A && codePoint <= Z;
};
var isLetter = function(codePoint) {
  return isLowerCaseLetter(codePoint) || isUpperCaseLetter(codePoint);
};
var isNonASCIICodePoint = function(codePoint) {
  return codePoint >= CONTROL;
};
var isWhiteSpace = function(codePoint) {
  return codePoint === LINE_FEED || codePoint === CHARACTER_TABULATION || codePoint === SPACE;
};
var isNameStartCodePoint = function(codePoint) {
  return isLetter(codePoint) || isNonASCIICodePoint(codePoint) || codePoint === LOW_LINE;
};
var isNameCodePoint = function(codePoint) {
  return isNameStartCodePoint(codePoint) || isDigit(codePoint) || codePoint === HYPHEN_MINUS;
};
var isNonPrintableCodePoint = function(codePoint) {
  return codePoint >= NULL && codePoint <= BACKSPACE || codePoint === LINE_TABULATION || codePoint >= SHIFT_OUT && codePoint <= INFORMATION_SEPARATOR_ONE || codePoint === DELETE;
};
var isValidEscape = function(c1, c2) {
  if (c1 !== REVERSE_SOLIDUS) {
    return false;
  }
  return c2 !== LINE_FEED;
};
var isIdentifierStart = function(c1, c2, c3) {
  if (c1 === HYPHEN_MINUS) {
    return isNameStartCodePoint(c2) || isValidEscape(c2, c3);
  } else if (isNameStartCodePoint(c1)) {
    return true;
  } else if (c1 === REVERSE_SOLIDUS && isValidEscape(c1, c2)) {
    return true;
  }
  return false;
};
var isNumberStart = function(c1, c2, c3) {
  if (c1 === PLUS_SIGN || c1 === HYPHEN_MINUS) {
    if (isDigit(c2)) {
      return true;
    }
    return c2 === FULL_STOP && isDigit(c3);
  }
  if (c1 === FULL_STOP) {
    return isDigit(c2);
  }
  return isDigit(c1);
};
var stringToNumber = function(codePoints) {
  var c2 = 0;
  var sign2 = 1;
  if (codePoints[c2] === PLUS_SIGN || codePoints[c2] === HYPHEN_MINUS) {
    if (codePoints[c2] === HYPHEN_MINUS) {
      sign2 = -1;
    }
    c2++;
  }
  var integers = [];
  while (isDigit(codePoints[c2])) {
    integers.push(codePoints[c2++]);
  }
  var int = integers.length ? parseInt(fromCodePoint$1.apply(void 0, integers), 10) : 0;
  if (codePoints[c2] === FULL_STOP) {
    c2++;
  }
  var fraction = [];
  while (isDigit(codePoints[c2])) {
    fraction.push(codePoints[c2++]);
  }
  var fracd = fraction.length;
  var frac = fracd ? parseInt(fromCodePoint$1.apply(void 0, fraction), 10) : 0;
  if (codePoints[c2] === E || codePoints[c2] === e$1) {
    c2++;
  }
  var expsign = 1;
  if (codePoints[c2] === PLUS_SIGN || codePoints[c2] === HYPHEN_MINUS) {
    if (codePoints[c2] === HYPHEN_MINUS) {
      expsign = -1;
    }
    c2++;
  }
  var exponent = [];
  while (isDigit(codePoints[c2])) {
    exponent.push(codePoints[c2++]);
  }
  var exp = exponent.length ? parseInt(fromCodePoint$1.apply(void 0, exponent), 10) : 0;
  return sign2 * (int + frac * Math.pow(10, -fracd)) * Math.pow(10, expsign * exp);
};
var LEFT_PARENTHESIS_TOKEN = {
  type: 2
};
var RIGHT_PARENTHESIS_TOKEN = {
  type: 3
};
var COMMA_TOKEN = { type: 4 };
var SUFFIX_MATCH_TOKEN = { type: 13 };
var PREFIX_MATCH_TOKEN = { type: 8 };
var COLUMN_TOKEN = { type: 21 };
var DASH_MATCH_TOKEN = { type: 9 };
var INCLUDE_MATCH_TOKEN = { type: 10 };
var LEFT_CURLY_BRACKET_TOKEN = {
  type: 11
};
var RIGHT_CURLY_BRACKET_TOKEN = {
  type: 12
};
var SUBSTRING_MATCH_TOKEN = { type: 14 };
var BAD_URL_TOKEN = { type: 23 };
var BAD_STRING_TOKEN = { type: 1 };
var CDO_TOKEN = { type: 25 };
var CDC_TOKEN = { type: 24 };
var COLON_TOKEN = { type: 26 };
var SEMICOLON_TOKEN = { type: 27 };
var LEFT_SQUARE_BRACKET_TOKEN = {
  type: 28
};
var RIGHT_SQUARE_BRACKET_TOKEN = {
  type: 29
};
var WHITESPACE_TOKEN = { type: 31 };
var EOF_TOKEN = { type: 32 };
var Tokenizer = function() {
  function Tokenizer2() {
    this._value = [];
  }
  Tokenizer2.prototype.write = function(chunk) {
    this._value = this._value.concat(toCodePoints$1(chunk));
  };
  Tokenizer2.prototype.read = function() {
    var tokens = [];
    var token = this.consumeToken();
    while (token !== EOF_TOKEN) {
      tokens.push(token);
      token = this.consumeToken();
    }
    return tokens;
  };
  Tokenizer2.prototype.consumeToken = function() {
    var codePoint = this.consumeCodePoint();
    switch (codePoint) {
      case QUOTATION_MARK:
        return this.consumeStringToken(QUOTATION_MARK);
      case NUMBER_SIGN:
        var c1 = this.peekCodePoint(0);
        var c2 = this.peekCodePoint(1);
        var c3 = this.peekCodePoint(2);
        if (isNameCodePoint(c1) || isValidEscape(c2, c3)) {
          var flags = isIdentifierStart(c1, c2, c3) ? FLAG_ID : FLAG_UNRESTRICTED;
          var value = this.consumeName();
          return { type: 5, value, flags };
        }
        break;
      case DOLLAR_SIGN:
        if (this.peekCodePoint(0) === EQUALS_SIGN) {
          this.consumeCodePoint();
          return SUFFIX_MATCH_TOKEN;
        }
        break;
      case APOSTROPHE:
        return this.consumeStringToken(APOSTROPHE);
      case LEFT_PARENTHESIS:
        return LEFT_PARENTHESIS_TOKEN;
      case RIGHT_PARENTHESIS:
        return RIGHT_PARENTHESIS_TOKEN;
      case ASTERISK:
        if (this.peekCodePoint(0) === EQUALS_SIGN) {
          this.consumeCodePoint();
          return SUBSTRING_MATCH_TOKEN;
        }
        break;
      case PLUS_SIGN:
        if (isNumberStart(codePoint, this.peekCodePoint(0), this.peekCodePoint(1))) {
          this.reconsumeCodePoint(codePoint);
          return this.consumeNumericToken();
        }
        break;
      case COMMA:
        return COMMA_TOKEN;
      case HYPHEN_MINUS:
        var e1 = codePoint;
        var e2 = this.peekCodePoint(0);
        var e3 = this.peekCodePoint(1);
        if (isNumberStart(e1, e2, e3)) {
          this.reconsumeCodePoint(codePoint);
          return this.consumeNumericToken();
        }
        if (isIdentifierStart(e1, e2, e3)) {
          this.reconsumeCodePoint(codePoint);
          return this.consumeIdentLikeToken();
        }
        if (e2 === HYPHEN_MINUS && e3 === GREATER_THAN_SIGN) {
          this.consumeCodePoint();
          this.consumeCodePoint();
          return CDC_TOKEN;
        }
        break;
      case FULL_STOP:
        if (isNumberStart(codePoint, this.peekCodePoint(0), this.peekCodePoint(1))) {
          this.reconsumeCodePoint(codePoint);
          return this.consumeNumericToken();
        }
        break;
      case SOLIDUS:
        if (this.peekCodePoint(0) === ASTERISK) {
          this.consumeCodePoint();
          while (true) {
            var c4 = this.consumeCodePoint();
            if (c4 === ASTERISK) {
              c4 = this.consumeCodePoint();
              if (c4 === SOLIDUS) {
                return this.consumeToken();
              }
            }
            if (c4 === EOF) {
              return this.consumeToken();
            }
          }
        }
        break;
      case COLON:
        return COLON_TOKEN;
      case SEMICOLON:
        return SEMICOLON_TOKEN;
      case LESS_THAN_SIGN:
        if (this.peekCodePoint(0) === EXCLAMATION_MARK && this.peekCodePoint(1) === HYPHEN_MINUS && this.peekCodePoint(2) === HYPHEN_MINUS) {
          this.consumeCodePoint();
          this.consumeCodePoint();
          return CDO_TOKEN;
        }
        break;
      case COMMERCIAL_AT:
        var a1 = this.peekCodePoint(0);
        var a2 = this.peekCodePoint(1);
        var a3 = this.peekCodePoint(2);
        if (isIdentifierStart(a1, a2, a3)) {
          var value = this.consumeName();
          return { type: 7, value };
        }
        break;
      case LEFT_SQUARE_BRACKET:
        return LEFT_SQUARE_BRACKET_TOKEN;
      case REVERSE_SOLIDUS:
        if (isValidEscape(codePoint, this.peekCodePoint(0))) {
          this.reconsumeCodePoint(codePoint);
          return this.consumeIdentLikeToken();
        }
        break;
      case RIGHT_SQUARE_BRACKET:
        return RIGHT_SQUARE_BRACKET_TOKEN;
      case CIRCUMFLEX_ACCENT:
        if (this.peekCodePoint(0) === EQUALS_SIGN) {
          this.consumeCodePoint();
          return PREFIX_MATCH_TOKEN;
        }
        break;
      case LEFT_CURLY_BRACKET:
        return LEFT_CURLY_BRACKET_TOKEN;
      case RIGHT_CURLY_BRACKET:
        return RIGHT_CURLY_BRACKET_TOKEN;
      case u$1:
      case U:
        var u1 = this.peekCodePoint(0);
        var u2 = this.peekCodePoint(1);
        if (u1 === PLUS_SIGN && (isHex(u2) || u2 === QUESTION_MARK)) {
          this.consumeCodePoint();
          this.consumeUnicodeRangeToken();
        }
        this.reconsumeCodePoint(codePoint);
        return this.consumeIdentLikeToken();
      case VERTICAL_LINE:
        if (this.peekCodePoint(0) === EQUALS_SIGN) {
          this.consumeCodePoint();
          return DASH_MATCH_TOKEN;
        }
        if (this.peekCodePoint(0) === VERTICAL_LINE) {
          this.consumeCodePoint();
          return COLUMN_TOKEN;
        }
        break;
      case TILDE:
        if (this.peekCodePoint(0) === EQUALS_SIGN) {
          this.consumeCodePoint();
          return INCLUDE_MATCH_TOKEN;
        }
        break;
      case EOF:
        return EOF_TOKEN;
    }
    if (isWhiteSpace(codePoint)) {
      this.consumeWhiteSpace();
      return WHITESPACE_TOKEN;
    }
    if (isDigit(codePoint)) {
      this.reconsumeCodePoint(codePoint);
      return this.consumeNumericToken();
    }
    if (isNameStartCodePoint(codePoint)) {
      this.reconsumeCodePoint(codePoint);
      return this.consumeIdentLikeToken();
    }
    return { type: 6, value: fromCodePoint$1(codePoint) };
  };
  Tokenizer2.prototype.consumeCodePoint = function() {
    var value = this._value.shift();
    return typeof value === "undefined" ? -1 : value;
  };
  Tokenizer2.prototype.reconsumeCodePoint = function(codePoint) {
    this._value.unshift(codePoint);
  };
  Tokenizer2.prototype.peekCodePoint = function(delta) {
    if (delta >= this._value.length) {
      return -1;
    }
    return this._value[delta];
  };
  Tokenizer2.prototype.consumeUnicodeRangeToken = function() {
    var digits = [];
    var codePoint = this.consumeCodePoint();
    while (isHex(codePoint) && digits.length < 6) {
      digits.push(codePoint);
      codePoint = this.consumeCodePoint();
    }
    var questionMarks = false;
    while (codePoint === QUESTION_MARK && digits.length < 6) {
      digits.push(codePoint);
      codePoint = this.consumeCodePoint();
      questionMarks = true;
    }
    if (questionMarks) {
      var start_1 = parseInt(fromCodePoint$1.apply(void 0, digits.map(function(digit) {
        return digit === QUESTION_MARK ? ZERO : digit;
      })), 16);
      var end = parseInt(fromCodePoint$1.apply(void 0, digits.map(function(digit) {
        return digit === QUESTION_MARK ? F : digit;
      })), 16);
      return { type: 30, start: start_1, end };
    }
    var start2 = parseInt(fromCodePoint$1.apply(void 0, digits), 16);
    if (this.peekCodePoint(0) === HYPHEN_MINUS && isHex(this.peekCodePoint(1))) {
      this.consumeCodePoint();
      codePoint = this.consumeCodePoint();
      var endDigits = [];
      while (isHex(codePoint) && endDigits.length < 6) {
        endDigits.push(codePoint);
        codePoint = this.consumeCodePoint();
      }
      var end = parseInt(fromCodePoint$1.apply(void 0, endDigits), 16);
      return { type: 30, start: start2, end };
    } else {
      return { type: 30, start: start2, end: start2 };
    }
  };
  Tokenizer2.prototype.consumeIdentLikeToken = function() {
    var value = this.consumeName();
    if (value.toLowerCase() === "url" && this.peekCodePoint(0) === LEFT_PARENTHESIS) {
      this.consumeCodePoint();
      return this.consumeUrlToken();
    } else if (this.peekCodePoint(0) === LEFT_PARENTHESIS) {
      this.consumeCodePoint();
      return { type: 19, value };
    }
    return { type: 20, value };
  };
  Tokenizer2.prototype.consumeUrlToken = function() {
    var value = [];
    this.consumeWhiteSpace();
    if (this.peekCodePoint(0) === EOF) {
      return { type: 22, value: "" };
    }
    var next = this.peekCodePoint(0);
    if (next === APOSTROPHE || next === QUOTATION_MARK) {
      var stringToken = this.consumeStringToken(this.consumeCodePoint());
      if (stringToken.type === 0) {
        this.consumeWhiteSpace();
        if (this.peekCodePoint(0) === EOF || this.peekCodePoint(0) === RIGHT_PARENTHESIS) {
          this.consumeCodePoint();
          return { type: 22, value: stringToken.value };
        }
      }
      this.consumeBadUrlRemnants();
      return BAD_URL_TOKEN;
    }
    while (true) {
      var codePoint = this.consumeCodePoint();
      if (codePoint === EOF || codePoint === RIGHT_PARENTHESIS) {
        return { type: 22, value: fromCodePoint$1.apply(void 0, value) };
      } else if (isWhiteSpace(codePoint)) {
        this.consumeWhiteSpace();
        if (this.peekCodePoint(0) === EOF || this.peekCodePoint(0) === RIGHT_PARENTHESIS) {
          this.consumeCodePoint();
          return { type: 22, value: fromCodePoint$1.apply(void 0, value) };
        }
        this.consumeBadUrlRemnants();
        return BAD_URL_TOKEN;
      } else if (codePoint === QUOTATION_MARK || codePoint === APOSTROPHE || codePoint === LEFT_PARENTHESIS || isNonPrintableCodePoint(codePoint)) {
        this.consumeBadUrlRemnants();
        return BAD_URL_TOKEN;
      } else if (codePoint === REVERSE_SOLIDUS) {
        if (isValidEscape(codePoint, this.peekCodePoint(0))) {
          value.push(this.consumeEscapedCodePoint());
        } else {
          this.consumeBadUrlRemnants();
          return BAD_URL_TOKEN;
        }
      } else {
        value.push(codePoint);
      }
    }
  };
  Tokenizer2.prototype.consumeWhiteSpace = function() {
    while (isWhiteSpace(this.peekCodePoint(0))) {
      this.consumeCodePoint();
    }
  };
  Tokenizer2.prototype.consumeBadUrlRemnants = function() {
    while (true) {
      var codePoint = this.consumeCodePoint();
      if (codePoint === RIGHT_PARENTHESIS || codePoint === EOF) {
        return;
      }
      if (isValidEscape(codePoint, this.peekCodePoint(0))) {
        this.consumeEscapedCodePoint();
      }
    }
  };
  Tokenizer2.prototype.consumeStringSlice = function(count) {
    var SLICE_STACK_SIZE = 5e4;
    var value = "";
    while (count > 0) {
      var amount = Math.min(SLICE_STACK_SIZE, count);
      value += fromCodePoint$1.apply(void 0, this._value.splice(0, amount));
      count -= amount;
    }
    this._value.shift();
    return value;
  };
  Tokenizer2.prototype.consumeStringToken = function(endingCodePoint) {
    var value = "";
    var i2 = 0;
    do {
      var codePoint = this._value[i2];
      if (codePoint === EOF || codePoint === void 0 || codePoint === endingCodePoint) {
        value += this.consumeStringSlice(i2);
        return { type: 0, value };
      }
      if (codePoint === LINE_FEED) {
        this._value.splice(0, i2);
        return BAD_STRING_TOKEN;
      }
      if (codePoint === REVERSE_SOLIDUS) {
        var next = this._value[i2 + 1];
        if (next !== EOF && next !== void 0) {
          if (next === LINE_FEED) {
            value += this.consumeStringSlice(i2);
            i2 = -1;
            this._value.shift();
          } else if (isValidEscape(codePoint, next)) {
            value += this.consumeStringSlice(i2);
            value += fromCodePoint$1(this.consumeEscapedCodePoint());
            i2 = -1;
          }
        }
      }
      i2++;
    } while (true);
  };
  Tokenizer2.prototype.consumeNumber = function() {
    var repr = [];
    var type = FLAG_INTEGER;
    var c1 = this.peekCodePoint(0);
    if (c1 === PLUS_SIGN || c1 === HYPHEN_MINUS) {
      repr.push(this.consumeCodePoint());
    }
    while (isDigit(this.peekCodePoint(0))) {
      repr.push(this.consumeCodePoint());
    }
    c1 = this.peekCodePoint(0);
    var c2 = this.peekCodePoint(1);
    if (c1 === FULL_STOP && isDigit(c2)) {
      repr.push(this.consumeCodePoint(), this.consumeCodePoint());
      type = FLAG_NUMBER;
      while (isDigit(this.peekCodePoint(0))) {
        repr.push(this.consumeCodePoint());
      }
    }
    c1 = this.peekCodePoint(0);
    c2 = this.peekCodePoint(1);
    var c3 = this.peekCodePoint(2);
    if ((c1 === E || c1 === e$1) && ((c2 === PLUS_SIGN || c2 === HYPHEN_MINUS) && isDigit(c3) || isDigit(c2))) {
      repr.push(this.consumeCodePoint(), this.consumeCodePoint());
      type = FLAG_NUMBER;
      while (isDigit(this.peekCodePoint(0))) {
        repr.push(this.consumeCodePoint());
      }
    }
    return [stringToNumber(repr), type];
  };
  Tokenizer2.prototype.consumeNumericToken = function() {
    var _a2 = this.consumeNumber(), number = _a2[0], flags = _a2[1];
    var c1 = this.peekCodePoint(0);
    var c2 = this.peekCodePoint(1);
    var c3 = this.peekCodePoint(2);
    if (isIdentifierStart(c1, c2, c3)) {
      var unit = this.consumeName();
      return { type: 15, number, flags, unit };
    }
    if (c1 === PERCENTAGE_SIGN) {
      this.consumeCodePoint();
      return { type: 16, number, flags };
    }
    return { type: 17, number, flags };
  };
  Tokenizer2.prototype.consumeEscapedCodePoint = function() {
    var codePoint = this.consumeCodePoint();
    if (isHex(codePoint)) {
      var hex = fromCodePoint$1(codePoint);
      while (isHex(this.peekCodePoint(0)) && hex.length < 6) {
        hex += fromCodePoint$1(this.consumeCodePoint());
      }
      if (isWhiteSpace(this.peekCodePoint(0))) {
        this.consumeCodePoint();
      }
      var hexCodePoint = parseInt(hex, 16);
      if (hexCodePoint === 0 || isSurrogateCodePoint(hexCodePoint) || hexCodePoint > 1114111) {
        return REPLACEMENT_CHARACTER;
      }
      return hexCodePoint;
    }
    if (codePoint === EOF) {
      return REPLACEMENT_CHARACTER;
    }
    return codePoint;
  };
  Tokenizer2.prototype.consumeName = function() {
    var result = "";
    while (true) {
      var codePoint = this.consumeCodePoint();
      if (isNameCodePoint(codePoint)) {
        result += fromCodePoint$1(codePoint);
      } else if (isValidEscape(codePoint, this.peekCodePoint(0))) {
        result += fromCodePoint$1(this.consumeEscapedCodePoint());
      } else {
        this.reconsumeCodePoint(codePoint);
        return result;
      }
    }
  };
  return Tokenizer2;
}();
var Parser$1 = function() {
  function Parser2(tokens) {
    this._tokens = tokens;
  }
  Parser2.create = function(value) {
    var tokenizer = new Tokenizer();
    tokenizer.write(value);
    return new Parser2(tokenizer.read());
  };
  Parser2.parseValue = function(value) {
    return Parser2.create(value).parseComponentValue();
  };
  Parser2.parseValues = function(value) {
    return Parser2.create(value).parseComponentValues();
  };
  Parser2.prototype.parseComponentValue = function() {
    var token = this.consumeToken();
    while (token.type === 31) {
      token = this.consumeToken();
    }
    if (token.type === 32) {
      throw new SyntaxError("Error parsing CSS component value, unexpected EOF");
    }
    this.reconsumeToken(token);
    var value = this.consumeComponentValue();
    do {
      token = this.consumeToken();
    } while (token.type === 31);
    if (token.type === 32) {
      return value;
    }
    throw new SyntaxError("Error parsing CSS component value, multiple values found when expecting only one");
  };
  Parser2.prototype.parseComponentValues = function() {
    var values2 = [];
    while (true) {
      var value = this.consumeComponentValue();
      if (value.type === 32) {
        return values2;
      }
      values2.push(value);
      values2.push();
    }
  };
  Parser2.prototype.consumeComponentValue = function() {
    var token = this.consumeToken();
    switch (token.type) {
      case 11:
      case 28:
      case 2:
        return this.consumeSimpleBlock(token.type);
      case 19:
        return this.consumeFunction(token);
    }
    return token;
  };
  Parser2.prototype.consumeSimpleBlock = function(type) {
    var block = { type, values: [] };
    var token = this.consumeToken();
    while (true) {
      if (token.type === 32 || isEndingTokenFor(token, type)) {
        return block;
      }
      this.reconsumeToken(token);
      block.values.push(this.consumeComponentValue());
      token = this.consumeToken();
    }
  };
  Parser2.prototype.consumeFunction = function(functionToken) {
    var cssFunction = {
      name: functionToken.value,
      values: [],
      type: 18
    };
    while (true) {
      var token = this.consumeToken();
      if (token.type === 32 || token.type === 3) {
        return cssFunction;
      }
      this.reconsumeToken(token);
      cssFunction.values.push(this.consumeComponentValue());
    }
  };
  Parser2.prototype.consumeToken = function() {
    var token = this._tokens.shift();
    return typeof token === "undefined" ? EOF_TOKEN : token;
  };
  Parser2.prototype.reconsumeToken = function(token) {
    this._tokens.unshift(token);
  };
  return Parser2;
}();
var isDimensionToken = function(token) {
  return token.type === 15;
};
var isNumberToken = function(token) {
  return token.type === 17;
};
var isIdentToken = function(token) {
  return token.type === 20;
};
var isStringToken = function(token) {
  return token.type === 0;
};
var isIdentWithValue = function(token, value) {
  return isIdentToken(token) && token.value === value;
};
var nonWhiteSpace = function(token) {
  return token.type !== 31;
};
var nonFunctionArgSeparator = function(token) {
  return token.type !== 31 && token.type !== 4;
};
var parseFunctionArgs = function(tokens) {
  var args = [];
  var arg = [];
  tokens.forEach(function(token) {
    if (token.type === 4) {
      if (arg.length === 0) {
        throw new Error("Error parsing function args, zero tokens for arg");
      }
      args.push(arg);
      arg = [];
      return;
    }
    if (token.type !== 31) {
      arg.push(token);
    }
  });
  if (arg.length) {
    args.push(arg);
  }
  return args;
};
var isEndingTokenFor = function(token, type) {
  if (type === 11 && token.type === 12) {
    return true;
  }
  if (type === 28 && token.type === 29) {
    return true;
  }
  return type === 2 && token.type === 3;
};
var isLength = function(token) {
  return token.type === 17 || token.type === 15;
};
var isLengthPercentage = function(token) {
  return token.type === 16 || isLength(token);
};
var parseLengthPercentageTuple = function(tokens) {
  return tokens.length > 1 ? [tokens[0], tokens[1]] : [tokens[0]];
};
var ZERO_LENGTH = {
  type: 17,
  number: 0,
  flags: FLAG_INTEGER
};
var FIFTY_PERCENT = {
  type: 16,
  number: 50,
  flags: FLAG_INTEGER
};
var HUNDRED_PERCENT = {
  type: 16,
  number: 100,
  flags: FLAG_INTEGER
};
var getAbsoluteValueForTuple = function(tuple, width, height) {
  var x2 = tuple[0], y2 = tuple[1];
  return [getAbsoluteValue(x2, width), getAbsoluteValue(typeof y2 !== "undefined" ? y2 : x2, height)];
};
var getAbsoluteValue = function(token, parent) {
  if (token.type === 16) {
    return token.number / 100 * parent;
  }
  if (isDimensionToken(token)) {
    switch (token.unit) {
      case "rem":
      case "em":
        return 16 * token.number;
      case "px":
      default:
        return token.number;
    }
  }
  return token.number;
};
var DEG = "deg";
var GRAD = "grad";
var RAD = "rad";
var TURN = "turn";
var angle = {
  name: "angle",
  parse: function(_context, value) {
    if (value.type === 15) {
      switch (value.unit) {
        case DEG:
          return Math.PI * value.number / 180;
        case GRAD:
          return Math.PI / 200 * value.number;
        case RAD:
          return value.number;
        case TURN:
          return Math.PI * 2 * value.number;
      }
    }
    throw new Error("Unsupported angle type");
  }
};
var isAngle = function(value) {
  if (value.type === 15) {
    if (value.unit === DEG || value.unit === GRAD || value.unit === RAD || value.unit === TURN) {
      return true;
    }
  }
  return false;
};
var parseNamedSide = function(tokens) {
  var sideOrCorner = tokens.filter(isIdentToken).map(function(ident) {
    return ident.value;
  }).join(" ");
  switch (sideOrCorner) {
    case "to bottom right":
    case "to right bottom":
    case "left top":
    case "top left":
      return [ZERO_LENGTH, ZERO_LENGTH];
    case "to top":
    case "bottom":
      return deg(0);
    case "to bottom left":
    case "to left bottom":
    case "right top":
    case "top right":
      return [ZERO_LENGTH, HUNDRED_PERCENT];
    case "to right":
    case "left":
      return deg(90);
    case "to top left":
    case "to left top":
    case "right bottom":
    case "bottom right":
      return [HUNDRED_PERCENT, HUNDRED_PERCENT];
    case "to bottom":
    case "top":
      return deg(180);
    case "to top right":
    case "to right top":
    case "left bottom":
    case "bottom left":
      return [HUNDRED_PERCENT, ZERO_LENGTH];
    case "to left":
    case "right":
      return deg(270);
  }
  return 0;
};
var deg = function(deg2) {
  return Math.PI * deg2 / 180;
};
var color$1 = {
  name: "color",
  parse: function(context, value) {
    if (value.type === 18) {
      var colorFunction = SUPPORTED_COLOR_FUNCTIONS[value.name];
      if (typeof colorFunction === "undefined") {
        throw new Error('Attempting to parse an unsupported color function "' + value.name + '"');
      }
      return colorFunction(context, value.values);
    }
    if (value.type === 5) {
      if (value.value.length === 3) {
        var r2 = value.value.substring(0, 1);
        var g2 = value.value.substring(1, 2);
        var b2 = value.value.substring(2, 3);
        return pack(parseInt(r2 + r2, 16), parseInt(g2 + g2, 16), parseInt(b2 + b2, 16), 1);
      }
      if (value.value.length === 4) {
        var r2 = value.value.substring(0, 1);
        var g2 = value.value.substring(1, 2);
        var b2 = value.value.substring(2, 3);
        var a2 = value.value.substring(3, 4);
        return pack(parseInt(r2 + r2, 16), parseInt(g2 + g2, 16), parseInt(b2 + b2, 16), parseInt(a2 + a2, 16) / 255);
      }
      if (value.value.length === 6) {
        var r2 = value.value.substring(0, 2);
        var g2 = value.value.substring(2, 4);
        var b2 = value.value.substring(4, 6);
        return pack(parseInt(r2, 16), parseInt(g2, 16), parseInt(b2, 16), 1);
      }
      if (value.value.length === 8) {
        var r2 = value.value.substring(0, 2);
        var g2 = value.value.substring(2, 4);
        var b2 = value.value.substring(4, 6);
        var a2 = value.value.substring(6, 8);
        return pack(parseInt(r2, 16), parseInt(g2, 16), parseInt(b2, 16), parseInt(a2, 16) / 255);
      }
    }
    if (value.type === 20) {
      var namedColor = COLORS[value.value.toUpperCase()];
      if (typeof namedColor !== "undefined") {
        return namedColor;
      }
    }
    return COLORS.TRANSPARENT;
  }
};
var isTransparent = function(color2) {
  return (255 & color2) === 0;
};
var asString = function(color2) {
  var alpha = 255 & color2;
  var blue = 255 & color2 >> 8;
  var green = 255 & color2 >> 16;
  var red = 255 & color2 >> 24;
  return alpha < 255 ? "rgba(" + red + "," + green + "," + blue + "," + alpha / 255 + ")" : "rgb(" + red + "," + green + "," + blue + ")";
};
var pack = function(r2, g2, b2, a2) {
  return (r2 << 24 | g2 << 16 | b2 << 8 | Math.round(a2 * 255) << 0) >>> 0;
};
var getTokenColorValue = function(token, i2) {
  if (token.type === 17) {
    return token.number;
  }
  if (token.type === 16) {
    var max2 = i2 === 3 ? 1 : 255;
    return i2 === 3 ? token.number / 100 * max2 : Math.round(token.number / 100 * max2);
  }
  return 0;
};
var rgb = function(_context, args) {
  var tokens = args.filter(nonFunctionArgSeparator);
  if (tokens.length === 3) {
    var _a2 = tokens.map(getTokenColorValue), r2 = _a2[0], g2 = _a2[1], b2 = _a2[2];
    return pack(r2, g2, b2, 1);
  }
  if (tokens.length === 4) {
    var _b2 = tokens.map(getTokenColorValue), r2 = _b2[0], g2 = _b2[1], b2 = _b2[2], a2 = _b2[3];
    return pack(r2, g2, b2, a2);
  }
  return 0;
};
function hue2rgb(t1, t22, hue) {
  if (hue < 0) {
    hue += 1;
  }
  if (hue >= 1) {
    hue -= 1;
  }
  if (hue < 1 / 6) {
    return (t22 - t1) * hue * 6 + t1;
  } else if (hue < 1 / 2) {
    return t22;
  } else if (hue < 2 / 3) {
    return (t22 - t1) * 6 * (2 / 3 - hue) + t1;
  } else {
    return t1;
  }
}
var hsl = function(context, args) {
  var tokens = args.filter(nonFunctionArgSeparator);
  var hue = tokens[0], saturation = tokens[1], lightness = tokens[2], alpha = tokens[3];
  var h2 = (hue.type === 17 ? deg(hue.number) : angle.parse(context, hue)) / (Math.PI * 2);
  var s2 = isLengthPercentage(saturation) ? saturation.number / 100 : 0;
  var l2 = isLengthPercentage(lightness) ? lightness.number / 100 : 0;
  var a2 = typeof alpha !== "undefined" && isLengthPercentage(alpha) ? getAbsoluteValue(alpha, 1) : 1;
  if (s2 === 0) {
    return pack(l2 * 255, l2 * 255, l2 * 255, 1);
  }
  var t22 = l2 <= 0.5 ? l2 * (s2 + 1) : l2 + s2 - l2 * s2;
  var t1 = l2 * 2 - t22;
  var r2 = hue2rgb(t1, t22, h2 + 1 / 3);
  var g2 = hue2rgb(t1, t22, h2);
  var b2 = hue2rgb(t1, t22, h2 - 1 / 3);
  return pack(r2 * 255, g2 * 255, b2 * 255, a2);
};
var SUPPORTED_COLOR_FUNCTIONS = {
  hsl,
  hsla: hsl,
  rgb,
  rgba: rgb
};
var parseColor = function(context, value) {
  return color$1.parse(context, Parser$1.create(value).parseComponentValue());
};
var COLORS = {
  ALICEBLUE: 4042850303,
  ANTIQUEWHITE: 4209760255,
  AQUA: 16777215,
  AQUAMARINE: 2147472639,
  AZURE: 4043309055,
  BEIGE: 4126530815,
  BISQUE: 4293182719,
  BLACK: 255,
  BLANCHEDALMOND: 4293643775,
  BLUE: 65535,
  BLUEVIOLET: 2318131967,
  BROWN: 2771004159,
  BURLYWOOD: 3736635391,
  CADETBLUE: 1604231423,
  CHARTREUSE: 2147418367,
  CHOCOLATE: 3530104575,
  CORAL: 4286533887,
  CORNFLOWERBLUE: 1687547391,
  CORNSILK: 4294499583,
  CRIMSON: 3692313855,
  CYAN: 16777215,
  DARKBLUE: 35839,
  DARKCYAN: 9145343,
  DARKGOLDENROD: 3095837695,
  DARKGRAY: 2846468607,
  DARKGREEN: 6553855,
  DARKGREY: 2846468607,
  DARKKHAKI: 3182914559,
  DARKMAGENTA: 2332068863,
  DARKOLIVEGREEN: 1433087999,
  DARKORANGE: 4287365375,
  DARKORCHID: 2570243327,
  DARKRED: 2332033279,
  DARKSALMON: 3918953215,
  DARKSEAGREEN: 2411499519,
  DARKSLATEBLUE: 1211993087,
  DARKSLATEGRAY: 793726975,
  DARKSLATEGREY: 793726975,
  DARKTURQUOISE: 13554175,
  DARKVIOLET: 2483082239,
  DEEPPINK: 4279538687,
  DEEPSKYBLUE: 12582911,
  DIMGRAY: 1768516095,
  DIMGREY: 1768516095,
  DODGERBLUE: 512819199,
  FIREBRICK: 2988581631,
  FLORALWHITE: 4294635775,
  FORESTGREEN: 579543807,
  FUCHSIA: 4278255615,
  GAINSBORO: 3705462015,
  GHOSTWHITE: 4177068031,
  GOLD: 4292280575,
  GOLDENROD: 3668254975,
  GRAY: 2155905279,
  GREEN: 8388863,
  GREENYELLOW: 2919182335,
  GREY: 2155905279,
  HONEYDEW: 4043305215,
  HOTPINK: 4285117695,
  INDIANRED: 3445382399,
  INDIGO: 1258324735,
  IVORY: 4294963455,
  KHAKI: 4041641215,
  LAVENDER: 3873897215,
  LAVENDERBLUSH: 4293981695,
  LAWNGREEN: 2096890111,
  LEMONCHIFFON: 4294626815,
  LIGHTBLUE: 2916673279,
  LIGHTCORAL: 4034953471,
  LIGHTCYAN: 3774873599,
  LIGHTGOLDENRODYELLOW: 4210742015,
  LIGHTGRAY: 3553874943,
  LIGHTGREEN: 2431553791,
  LIGHTGREY: 3553874943,
  LIGHTPINK: 4290167295,
  LIGHTSALMON: 4288707327,
  LIGHTSEAGREEN: 548580095,
  LIGHTSKYBLUE: 2278488831,
  LIGHTSLATEGRAY: 2005441023,
  LIGHTSLATEGREY: 2005441023,
  LIGHTSTEELBLUE: 2965692159,
  LIGHTYELLOW: 4294959359,
  LIME: 16711935,
  LIMEGREEN: 852308735,
  LINEN: 4210091775,
  MAGENTA: 4278255615,
  MAROON: 2147483903,
  MEDIUMAQUAMARINE: 1724754687,
  MEDIUMBLUE: 52735,
  MEDIUMORCHID: 3126187007,
  MEDIUMPURPLE: 2473647103,
  MEDIUMSEAGREEN: 1018393087,
  MEDIUMSLATEBLUE: 2070474495,
  MEDIUMSPRINGGREEN: 16423679,
  MEDIUMTURQUOISE: 1221709055,
  MEDIUMVIOLETRED: 3340076543,
  MIDNIGHTBLUE: 421097727,
  MINTCREAM: 4127193855,
  MISTYROSE: 4293190143,
  MOCCASIN: 4293178879,
  NAVAJOWHITE: 4292783615,
  NAVY: 33023,
  OLDLACE: 4260751103,
  OLIVE: 2155872511,
  OLIVEDRAB: 1804477439,
  ORANGE: 4289003775,
  ORANGERED: 4282712319,
  ORCHID: 3664828159,
  PALEGOLDENROD: 4008225535,
  PALEGREEN: 2566625535,
  PALETURQUOISE: 2951671551,
  PALEVIOLETRED: 3681588223,
  PAPAYAWHIP: 4293907967,
  PEACHPUFF: 4292524543,
  PERU: 3448061951,
  PINK: 4290825215,
  PLUM: 3718307327,
  POWDERBLUE: 2967529215,
  PURPLE: 2147516671,
  REBECCAPURPLE: 1714657791,
  RED: 4278190335,
  ROSYBROWN: 3163525119,
  ROYALBLUE: 1097458175,
  SADDLEBROWN: 2336560127,
  SALMON: 4202722047,
  SANDYBROWN: 4104413439,
  SEAGREEN: 780883967,
  SEASHELL: 4294307583,
  SIENNA: 2689740287,
  SILVER: 3233857791,
  SKYBLUE: 2278484991,
  SLATEBLUE: 1784335871,
  SLATEGRAY: 1887473919,
  SLATEGREY: 1887473919,
  SNOW: 4294638335,
  SPRINGGREEN: 16744447,
  STEELBLUE: 1182971135,
  TAN: 3535047935,
  TEAL: 8421631,
  THISTLE: 3636451583,
  TOMATO: 4284696575,
  TRANSPARENT: 0,
  TURQUOISE: 1088475391,
  VIOLET: 4001558271,
  WHEAT: 4125012991,
  WHITE: 4294967295,
  WHITESMOKE: 4126537215,
  YELLOW: 4294902015,
  YELLOWGREEN: 2597139199
};
var backgroundClip = {
  name: "background-clip",
  initialValue: "border-box",
  prefix: false,
  type: 1,
  parse: function(_context, tokens) {
    return tokens.map(function(token) {
      if (isIdentToken(token)) {
        switch (token.value) {
          case "padding-box":
            return 1;
          case "content-box":
            return 2;
        }
      }
      return 0;
    });
  }
};
var backgroundColor = {
  name: "background-color",
  initialValue: "transparent",
  prefix: false,
  type: 3,
  format: "color"
};
var parseColorStop = function(context, args) {
  var color2 = color$1.parse(context, args[0]);
  var stop = args[1];
  return stop && isLengthPercentage(stop) ? { color: color2, stop } : { color: color2, stop: null };
};
var processColorStops = function(stops, lineLength) {
  var first = stops[0];
  var last = stops[stops.length - 1];
  if (first.stop === null) {
    first.stop = ZERO_LENGTH;
  }
  if (last.stop === null) {
    last.stop = HUNDRED_PERCENT;
  }
  var processStops = [];
  var previous = 0;
  for (var i2 = 0; i2 < stops.length; i2++) {
    var stop_1 = stops[i2].stop;
    if (stop_1 !== null) {
      var absoluteValue = getAbsoluteValue(stop_1, lineLength);
      if (absoluteValue > previous) {
        processStops.push(absoluteValue);
      } else {
        processStops.push(previous);
      }
      previous = absoluteValue;
    } else {
      processStops.push(null);
    }
  }
  var gapBegin = null;
  for (var i2 = 0; i2 < processStops.length; i2++) {
    var stop_2 = processStops[i2];
    if (stop_2 === null) {
      if (gapBegin === null) {
        gapBegin = i2;
      }
    } else if (gapBegin !== null) {
      var gapLength = i2 - gapBegin;
      var beforeGap = processStops[gapBegin - 1];
      var gapValue = (stop_2 - beforeGap) / (gapLength + 1);
      for (var g2 = 1; g2 <= gapLength; g2++) {
        processStops[gapBegin + g2 - 1] = gapValue * g2;
      }
      gapBegin = null;
    }
  }
  return stops.map(function(_a2, i3) {
    var color2 = _a2.color;
    return { color: color2, stop: Math.max(Math.min(1, processStops[i3] / lineLength), 0) };
  });
};
var getAngleFromCorner = function(corner, width, height) {
  var centerX = width / 2;
  var centerY = height / 2;
  var x2 = getAbsoluteValue(corner[0], width) - centerX;
  var y2 = centerY - getAbsoluteValue(corner[1], height);
  return (Math.atan2(y2, x2) + Math.PI * 2) % (Math.PI * 2);
};
var calculateGradientDirection = function(angle2, width, height) {
  var radian = typeof angle2 === "number" ? angle2 : getAngleFromCorner(angle2, width, height);
  var lineLength = Math.abs(width * Math.sin(radian)) + Math.abs(height * Math.cos(radian));
  var halfWidth = width / 2;
  var halfHeight = height / 2;
  var halfLineLength = lineLength / 2;
  var yDiff = Math.sin(radian - Math.PI / 2) * halfLineLength;
  var xDiff = Math.cos(radian - Math.PI / 2) * halfLineLength;
  return [lineLength, halfWidth - xDiff, halfWidth + xDiff, halfHeight - yDiff, halfHeight + yDiff];
};
var distance = function(a2, b2) {
  return Math.sqrt(a2 * a2 + b2 * b2);
};
var findCorner = function(width, height, x2, y2, closest) {
  var corners = [
    [0, 0],
    [0, height],
    [width, 0],
    [width, height]
  ];
  return corners.reduce(function(stat, corner) {
    var cx = corner[0], cy = corner[1];
    var d2 = distance(x2 - cx, y2 - cy);
    if (closest ? d2 < stat.optimumDistance : d2 > stat.optimumDistance) {
      return {
        optimumCorner: corner,
        optimumDistance: d2
      };
    }
    return stat;
  }, {
    optimumDistance: closest ? Infinity : -Infinity,
    optimumCorner: null
  }).optimumCorner;
};
var calculateRadius = function(gradient, x2, y2, width, height) {
  var rx = 0;
  var ry = 0;
  switch (gradient.size) {
    case 0:
      if (gradient.shape === 0) {
        rx = ry = Math.min(Math.abs(x2), Math.abs(x2 - width), Math.abs(y2), Math.abs(y2 - height));
      } else if (gradient.shape === 1) {
        rx = Math.min(Math.abs(x2), Math.abs(x2 - width));
        ry = Math.min(Math.abs(y2), Math.abs(y2 - height));
      }
      break;
    case 2:
      if (gradient.shape === 0) {
        rx = ry = Math.min(distance(x2, y2), distance(x2, y2 - height), distance(x2 - width, y2), distance(x2 - width, y2 - height));
      } else if (gradient.shape === 1) {
        var c2 = Math.min(Math.abs(y2), Math.abs(y2 - height)) / Math.min(Math.abs(x2), Math.abs(x2 - width));
        var _a2 = findCorner(width, height, x2, y2, true), cx = _a2[0], cy = _a2[1];
        rx = distance(cx - x2, (cy - y2) / c2);
        ry = c2 * rx;
      }
      break;
    case 1:
      if (gradient.shape === 0) {
        rx = ry = Math.max(Math.abs(x2), Math.abs(x2 - width), Math.abs(y2), Math.abs(y2 - height));
      } else if (gradient.shape === 1) {
        rx = Math.max(Math.abs(x2), Math.abs(x2 - width));
        ry = Math.max(Math.abs(y2), Math.abs(y2 - height));
      }
      break;
    case 3:
      if (gradient.shape === 0) {
        rx = ry = Math.max(distance(x2, y2), distance(x2, y2 - height), distance(x2 - width, y2), distance(x2 - width, y2 - height));
      } else if (gradient.shape === 1) {
        var c2 = Math.max(Math.abs(y2), Math.abs(y2 - height)) / Math.max(Math.abs(x2), Math.abs(x2 - width));
        var _b2 = findCorner(width, height, x2, y2, false), cx = _b2[0], cy = _b2[1];
        rx = distance(cx - x2, (cy - y2) / c2);
        ry = c2 * rx;
      }
      break;
  }
  if (Array.isArray(gradient.size)) {
    rx = getAbsoluteValue(gradient.size[0], width);
    ry = gradient.size.length === 2 ? getAbsoluteValue(gradient.size[1], height) : rx;
  }
  return [rx, ry];
};
var linearGradient = function(context, tokens) {
  var angle$1 = deg(180);
  var stops = [];
  parseFunctionArgs(tokens).forEach(function(arg, i2) {
    if (i2 === 0) {
      var firstToken = arg[0];
      if (firstToken.type === 20 && firstToken.value === "to") {
        angle$1 = parseNamedSide(arg);
        return;
      } else if (isAngle(firstToken)) {
        angle$1 = angle.parse(context, firstToken);
        return;
      }
    }
    var colorStop = parseColorStop(context, arg);
    stops.push(colorStop);
  });
  return { angle: angle$1, stops, type: 1 };
};
var prefixLinearGradient = function(context, tokens) {
  var angle$1 = deg(180);
  var stops = [];
  parseFunctionArgs(tokens).forEach(function(arg, i2) {
    if (i2 === 0) {
      var firstToken = arg[0];
      if (firstToken.type === 20 && ["top", "left", "right", "bottom"].indexOf(firstToken.value) !== -1) {
        angle$1 = parseNamedSide(arg);
        return;
      } else if (isAngle(firstToken)) {
        angle$1 = (angle.parse(context, firstToken) + deg(270)) % deg(360);
        return;
      }
    }
    var colorStop = parseColorStop(context, arg);
    stops.push(colorStop);
  });
  return {
    angle: angle$1,
    stops,
    type: 1
  };
};
var webkitGradient = function(context, tokens) {
  var angle2 = deg(180);
  var stops = [];
  var type = 1;
  var shape = 0;
  var size = 3;
  var position2 = [];
  parseFunctionArgs(tokens).forEach(function(arg, i2) {
    var firstToken = arg[0];
    if (i2 === 0) {
      if (isIdentToken(firstToken) && firstToken.value === "linear") {
        type = 1;
        return;
      } else if (isIdentToken(firstToken) && firstToken.value === "radial") {
        type = 2;
        return;
      }
    }
    if (firstToken.type === 18) {
      if (firstToken.name === "from") {
        var color2 = color$1.parse(context, firstToken.values[0]);
        stops.push({ stop: ZERO_LENGTH, color: color2 });
      } else if (firstToken.name === "to") {
        var color2 = color$1.parse(context, firstToken.values[0]);
        stops.push({ stop: HUNDRED_PERCENT, color: color2 });
      } else if (firstToken.name === "color-stop") {
        var values2 = firstToken.values.filter(nonFunctionArgSeparator);
        if (values2.length === 2) {
          var color2 = color$1.parse(context, values2[1]);
          var stop_1 = values2[0];
          if (isNumberToken(stop_1)) {
            stops.push({
              stop: { type: 16, number: stop_1.number * 100, flags: stop_1.flags },
              color: color2
            });
          }
        }
      }
    }
  });
  return type === 1 ? {
    angle: (angle2 + deg(180)) % deg(360),
    stops,
    type
  } : { size, shape, stops, position: position2, type };
};
var CLOSEST_SIDE = "closest-side";
var FARTHEST_SIDE = "farthest-side";
var CLOSEST_CORNER = "closest-corner";
var FARTHEST_CORNER = "farthest-corner";
var CIRCLE = "circle";
var ELLIPSE = "ellipse";
var COVER = "cover";
var CONTAIN = "contain";
var radialGradient = function(context, tokens) {
  var shape = 0;
  var size = 3;
  var stops = [];
  var position2 = [];
  parseFunctionArgs(tokens).forEach(function(arg, i2) {
    var isColorStop = true;
    if (i2 === 0) {
      var isAtPosition_1 = false;
      isColorStop = arg.reduce(function(acc, token) {
        if (isAtPosition_1) {
          if (isIdentToken(token)) {
            switch (token.value) {
              case "center":
                position2.push(FIFTY_PERCENT);
                return acc;
              case "top":
              case "left":
                position2.push(ZERO_LENGTH);
                return acc;
              case "right":
              case "bottom":
                position2.push(HUNDRED_PERCENT);
                return acc;
            }
          } else if (isLengthPercentage(token) || isLength(token)) {
            position2.push(token);
          }
        } else if (isIdentToken(token)) {
          switch (token.value) {
            case CIRCLE:
              shape = 0;
              return false;
            case ELLIPSE:
              shape = 1;
              return false;
            case "at":
              isAtPosition_1 = true;
              return false;
            case CLOSEST_SIDE:
              size = 0;
              return false;
            case COVER:
            case FARTHEST_SIDE:
              size = 1;
              return false;
            case CONTAIN:
            case CLOSEST_CORNER:
              size = 2;
              return false;
            case FARTHEST_CORNER:
              size = 3;
              return false;
          }
        } else if (isLength(token) || isLengthPercentage(token)) {
          if (!Array.isArray(size)) {
            size = [];
          }
          size.push(token);
          return false;
        }
        return acc;
      }, isColorStop);
    }
    if (isColorStop) {
      var colorStop = parseColorStop(context, arg);
      stops.push(colorStop);
    }
  });
  return { size, shape, stops, position: position2, type: 2 };
};
var prefixRadialGradient = function(context, tokens) {
  var shape = 0;
  var size = 3;
  var stops = [];
  var position2 = [];
  parseFunctionArgs(tokens).forEach(function(arg, i2) {
    var isColorStop = true;
    if (i2 === 0) {
      isColorStop = arg.reduce(function(acc, token) {
        if (isIdentToken(token)) {
          switch (token.value) {
            case "center":
              position2.push(FIFTY_PERCENT);
              return false;
            case "top":
            case "left":
              position2.push(ZERO_LENGTH);
              return false;
            case "right":
            case "bottom":
              position2.push(HUNDRED_PERCENT);
              return false;
          }
        } else if (isLengthPercentage(token) || isLength(token)) {
          position2.push(token);
          return false;
        }
        return acc;
      }, isColorStop);
    } else if (i2 === 1) {
      isColorStop = arg.reduce(function(acc, token) {
        if (isIdentToken(token)) {
          switch (token.value) {
            case CIRCLE:
              shape = 0;
              return false;
            case ELLIPSE:
              shape = 1;
              return false;
            case CONTAIN:
            case CLOSEST_SIDE:
              size = 0;
              return false;
            case FARTHEST_SIDE:
              size = 1;
              return false;
            case CLOSEST_CORNER:
              size = 2;
              return false;
            case COVER:
            case FARTHEST_CORNER:
              size = 3;
              return false;
          }
        } else if (isLength(token) || isLengthPercentage(token)) {
          if (!Array.isArray(size)) {
            size = [];
          }
          size.push(token);
          return false;
        }
        return acc;
      }, isColorStop);
    }
    if (isColorStop) {
      var colorStop = parseColorStop(context, arg);
      stops.push(colorStop);
    }
  });
  return { size, shape, stops, position: position2, type: 2 };
};
var isLinearGradient = function(background) {
  return background.type === 1;
};
var isRadialGradient = function(background) {
  return background.type === 2;
};
var image = {
  name: "image",
  parse: function(context, value) {
    if (value.type === 22) {
      var image_1 = { url: value.value, type: 0 };
      context.cache.addImage(value.value);
      return image_1;
    }
    if (value.type === 18) {
      var imageFunction = SUPPORTED_IMAGE_FUNCTIONS[value.name];
      if (typeof imageFunction === "undefined") {
        throw new Error('Attempting to parse an unsupported image function "' + value.name + '"');
      }
      return imageFunction(context, value.values);
    }
    throw new Error("Unsupported image type " + value.type);
  }
};
function isSupportedImage(value) {
  return !(value.type === 20 && value.value === "none") && (value.type !== 18 || !!SUPPORTED_IMAGE_FUNCTIONS[value.name]);
}
var SUPPORTED_IMAGE_FUNCTIONS = {
  "linear-gradient": linearGradient,
  "-moz-linear-gradient": prefixLinearGradient,
  "-ms-linear-gradient": prefixLinearGradient,
  "-o-linear-gradient": prefixLinearGradient,
  "-webkit-linear-gradient": prefixLinearGradient,
  "radial-gradient": radialGradient,
  "-moz-radial-gradient": prefixRadialGradient,
  "-ms-radial-gradient": prefixRadialGradient,
  "-o-radial-gradient": prefixRadialGradient,
  "-webkit-radial-gradient": prefixRadialGradient,
  "-webkit-gradient": webkitGradient
};
var backgroundImage = {
  name: "background-image",
  initialValue: "none",
  type: 1,
  prefix: false,
  parse: function(context, tokens) {
    if (tokens.length === 0) {
      return [];
    }
    var first = tokens[0];
    if (first.type === 20 && first.value === "none") {
      return [];
    }
    return tokens.filter(function(value) {
      return nonFunctionArgSeparator(value) && isSupportedImage(value);
    }).map(function(value) {
      return image.parse(context, value);
    });
  }
};
var backgroundOrigin = {
  name: "background-origin",
  initialValue: "border-box",
  prefix: false,
  type: 1,
  parse: function(_context, tokens) {
    return tokens.map(function(token) {
      if (isIdentToken(token)) {
        switch (token.value) {
          case "padding-box":
            return 1;
          case "content-box":
            return 2;
        }
      }
      return 0;
    });
  }
};
var backgroundPosition = {
  name: "background-position",
  initialValue: "0% 0%",
  type: 1,
  prefix: false,
  parse: function(_context, tokens) {
    return parseFunctionArgs(tokens).map(function(values2) {
      return values2.filter(isLengthPercentage);
    }).map(parseLengthPercentageTuple);
  }
};
var backgroundRepeat = {
  name: "background-repeat",
  initialValue: "repeat",
  prefix: false,
  type: 1,
  parse: function(_context, tokens) {
    return parseFunctionArgs(tokens).map(function(values2) {
      return values2.filter(isIdentToken).map(function(token) {
        return token.value;
      }).join(" ");
    }).map(parseBackgroundRepeat);
  }
};
var parseBackgroundRepeat = function(value) {
  switch (value) {
    case "no-repeat":
      return 1;
    case "repeat-x":
    case "repeat no-repeat":
      return 2;
    case "repeat-y":
    case "no-repeat repeat":
      return 3;
    case "repeat":
    default:
      return 0;
  }
};
var BACKGROUND_SIZE;
(function(BACKGROUND_SIZE2) {
  BACKGROUND_SIZE2["AUTO"] = "auto";
  BACKGROUND_SIZE2["CONTAIN"] = "contain";
  BACKGROUND_SIZE2["COVER"] = "cover";
})(BACKGROUND_SIZE || (BACKGROUND_SIZE = {}));
var backgroundSize = {
  name: "background-size",
  initialValue: "0",
  prefix: false,
  type: 1,
  parse: function(_context, tokens) {
    return parseFunctionArgs(tokens).map(function(values2) {
      return values2.filter(isBackgroundSizeInfoToken);
    });
  }
};
var isBackgroundSizeInfoToken = function(value) {
  return isIdentToken(value) || isLengthPercentage(value);
};
var borderColorForSide = function(side) {
  return {
    name: "border-" + side + "-color",
    initialValue: "transparent",
    prefix: false,
    type: 3,
    format: "color"
  };
};
var borderTopColor = borderColorForSide("top");
var borderRightColor = borderColorForSide("right");
var borderBottomColor = borderColorForSide("bottom");
var borderLeftColor = borderColorForSide("left");
var borderRadiusForSide = function(side) {
  return {
    name: "border-radius-" + side,
    initialValue: "0 0",
    prefix: false,
    type: 1,
    parse: function(_context, tokens) {
      return parseLengthPercentageTuple(tokens.filter(isLengthPercentage));
    }
  };
};
var borderTopLeftRadius = borderRadiusForSide("top-left");
var borderTopRightRadius = borderRadiusForSide("top-right");
var borderBottomRightRadius = borderRadiusForSide("bottom-right");
var borderBottomLeftRadius = borderRadiusForSide("bottom-left");
var borderStyleForSide = function(side) {
  return {
    name: "border-" + side + "-style",
    initialValue: "solid",
    prefix: false,
    type: 2,
    parse: function(_context, style2) {
      switch (style2) {
        case "none":
          return 0;
        case "dashed":
          return 2;
        case "dotted":
          return 3;
        case "double":
          return 4;
      }
      return 1;
    }
  };
};
var borderTopStyle = borderStyleForSide("top");
var borderRightStyle = borderStyleForSide("right");
var borderBottomStyle = borderStyleForSide("bottom");
var borderLeftStyle = borderStyleForSide("left");
var borderWidthForSide = function(side) {
  return {
    name: "border-" + side + "-width",
    initialValue: "0",
    type: 0,
    prefix: false,
    parse: function(_context, token) {
      if (isDimensionToken(token)) {
        return token.number;
      }
      return 0;
    }
  };
};
var borderTopWidth = borderWidthForSide("top");
var borderRightWidth = borderWidthForSide("right");
var borderBottomWidth = borderWidthForSide("bottom");
var borderLeftWidth = borderWidthForSide("left");
var color = {
  name: "color",
  initialValue: "transparent",
  prefix: false,
  type: 3,
  format: "color"
};
var direction = {
  name: "direction",
  initialValue: "ltr",
  prefix: false,
  type: 2,
  parse: function(_context, direction2) {
    switch (direction2) {
      case "rtl":
        return 1;
      case "ltr":
      default:
        return 0;
    }
  }
};
var display = {
  name: "display",
  initialValue: "inline-block",
  prefix: false,
  type: 1,
  parse: function(_context, tokens) {
    return tokens.filter(isIdentToken).reduce(function(bit, token) {
      return bit | parseDisplayValue(token.value);
    }, 0);
  }
};
var parseDisplayValue = function(display2) {
  switch (display2) {
    case "block":
    case "-webkit-box":
      return 2;
    case "inline":
      return 4;
    case "run-in":
      return 8;
    case "flow":
      return 16;
    case "flow-root":
      return 32;
    case "table":
      return 64;
    case "flex":
    case "-webkit-flex":
      return 128;
    case "grid":
    case "-ms-grid":
      return 256;
    case "ruby":
      return 512;
    case "subgrid":
      return 1024;
    case "list-item":
      return 2048;
    case "table-row-group":
      return 4096;
    case "table-header-group":
      return 8192;
    case "table-footer-group":
      return 16384;
    case "table-row":
      return 32768;
    case "table-cell":
      return 65536;
    case "table-column-group":
      return 131072;
    case "table-column":
      return 262144;
    case "table-caption":
      return 524288;
    case "ruby-base":
      return 1048576;
    case "ruby-text":
      return 2097152;
    case "ruby-base-container":
      return 4194304;
    case "ruby-text-container":
      return 8388608;
    case "contents":
      return 16777216;
    case "inline-block":
      return 33554432;
    case "inline-list-item":
      return 67108864;
    case "inline-table":
      return 134217728;
    case "inline-flex":
      return 268435456;
    case "inline-grid":
      return 536870912;
  }
  return 0;
};
var float = {
  name: "float",
  initialValue: "none",
  prefix: false,
  type: 2,
  parse: function(_context, float2) {
    switch (float2) {
      case "left":
        return 1;
      case "right":
        return 2;
      case "inline-start":
        return 3;
      case "inline-end":
        return 4;
    }
    return 0;
  }
};
var letterSpacing = {
  name: "letter-spacing",
  initialValue: "0",
  prefix: false,
  type: 0,
  parse: function(_context, token) {
    if (token.type === 20 && token.value === "normal") {
      return 0;
    }
    if (token.type === 17) {
      return token.number;
    }
    if (token.type === 15) {
      return token.number;
    }
    return 0;
  }
};
var LINE_BREAK;
(function(LINE_BREAK2) {
  LINE_BREAK2["NORMAL"] = "normal";
  LINE_BREAK2["STRICT"] = "strict";
})(LINE_BREAK || (LINE_BREAK = {}));
var lineBreak = {
  name: "line-break",
  initialValue: "normal",
  prefix: false,
  type: 2,
  parse: function(_context, lineBreak2) {
    switch (lineBreak2) {
      case "strict":
        return LINE_BREAK.STRICT;
      case "normal":
      default:
        return LINE_BREAK.NORMAL;
    }
  }
};
var lineHeight = {
  name: "line-height",
  initialValue: "normal",
  prefix: false,
  type: 4
};
var computeLineHeight = function(token, fontSize2) {
  if (isIdentToken(token) && token.value === "normal") {
    return 1.2 * fontSize2;
  } else if (token.type === 17) {
    return fontSize2 * token.number;
  } else if (isLengthPercentage(token)) {
    return getAbsoluteValue(token, fontSize2);
  }
  return fontSize2;
};
var listStyleImage = {
  name: "list-style-image",
  initialValue: "none",
  type: 0,
  prefix: false,
  parse: function(context, token) {
    if (token.type === 20 && token.value === "none") {
      return null;
    }
    return image.parse(context, token);
  }
};
var listStylePosition = {
  name: "list-style-position",
  initialValue: "outside",
  prefix: false,
  type: 2,
  parse: function(_context, position2) {
    switch (position2) {
      case "inside":
        return 0;
      case "outside":
      default:
        return 1;
    }
  }
};
var listStyleType = {
  name: "list-style-type",
  initialValue: "none",
  prefix: false,
  type: 2,
  parse: function(_context, type) {
    switch (type) {
      case "disc":
        return 0;
      case "circle":
        return 1;
      case "square":
        return 2;
      case "decimal":
        return 3;
      case "cjk-decimal":
        return 4;
      case "decimal-leading-zero":
        return 5;
      case "lower-roman":
        return 6;
      case "upper-roman":
        return 7;
      case "lower-greek":
        return 8;
      case "lower-alpha":
        return 9;
      case "upper-alpha":
        return 10;
      case "arabic-indic":
        return 11;
      case "armenian":
        return 12;
      case "bengali":
        return 13;
      case "cambodian":
        return 14;
      case "cjk-earthly-branch":
        return 15;
      case "cjk-heavenly-stem":
        return 16;
      case "cjk-ideographic":
        return 17;
      case "devanagari":
        return 18;
      case "ethiopic-numeric":
        return 19;
      case "georgian":
        return 20;
      case "gujarati":
        return 21;
      case "gurmukhi":
        return 22;
      case "hebrew":
        return 22;
      case "hiragana":
        return 23;
      case "hiragana-iroha":
        return 24;
      case "japanese-formal":
        return 25;
      case "japanese-informal":
        return 26;
      case "kannada":
        return 27;
      case "katakana":
        return 28;
      case "katakana-iroha":
        return 29;
      case "khmer":
        return 30;
      case "korean-hangul-formal":
        return 31;
      case "korean-hanja-formal":
        return 32;
      case "korean-hanja-informal":
        return 33;
      case "lao":
        return 34;
      case "lower-armenian":
        return 35;
      case "malayalam":
        return 36;
      case "mongolian":
        return 37;
      case "myanmar":
        return 38;
      case "oriya":
        return 39;
      case "persian":
        return 40;
      case "simp-chinese-formal":
        return 41;
      case "simp-chinese-informal":
        return 42;
      case "tamil":
        return 43;
      case "telugu":
        return 44;
      case "thai":
        return 45;
      case "tibetan":
        return 46;
      case "trad-chinese-formal":
        return 47;
      case "trad-chinese-informal":
        return 48;
      case "upper-armenian":
        return 49;
      case "disclosure-open":
        return 50;
      case "disclosure-closed":
        return 51;
      case "none":
      default:
        return -1;
    }
  }
};
var marginForSide = function(side) {
  return {
    name: "margin-" + side,
    initialValue: "0",
    prefix: false,
    type: 4
  };
};
var marginTop = marginForSide("top");
var marginRight = marginForSide("right");
var marginBottom = marginForSide("bottom");
var marginLeft = marginForSide("left");
var overflow = {
  name: "overflow",
  initialValue: "visible",
  prefix: false,
  type: 1,
  parse: function(_context, tokens) {
    return tokens.filter(isIdentToken).map(function(overflow2) {
      switch (overflow2.value) {
        case "hidden":
          return 1;
        case "scroll":
          return 2;
        case "clip":
          return 3;
        case "auto":
          return 4;
        case "visible":
        default:
          return 0;
      }
    });
  }
};
var overflowWrap = {
  name: "overflow-wrap",
  initialValue: "normal",
  prefix: false,
  type: 2,
  parse: function(_context, overflow2) {
    switch (overflow2) {
      case "break-word":
        return "break-word";
      case "normal":
      default:
        return "normal";
    }
  }
};
var paddingForSide = function(side) {
  return {
    name: "padding-" + side,
    initialValue: "0",
    prefix: false,
    type: 3,
    format: "length-percentage"
  };
};
var paddingTop = paddingForSide("top");
var paddingRight = paddingForSide("right");
var paddingBottom = paddingForSide("bottom");
var paddingLeft = paddingForSide("left");
var textAlign = {
  name: "text-align",
  initialValue: "left",
  prefix: false,
  type: 2,
  parse: function(_context, textAlign2) {
    switch (textAlign2) {
      case "right":
        return 2;
      case "center":
      case "justify":
        return 1;
      case "left":
      default:
        return 0;
    }
  }
};
var position = {
  name: "position",
  initialValue: "static",
  prefix: false,
  type: 2,
  parse: function(_context, position2) {
    switch (position2) {
      case "relative":
        return 1;
      case "absolute":
        return 2;
      case "fixed":
        return 3;
      case "sticky":
        return 4;
    }
    return 0;
  }
};
var textShadow = {
  name: "text-shadow",
  initialValue: "none",
  type: 1,
  prefix: false,
  parse: function(context, tokens) {
    if (tokens.length === 1 && isIdentWithValue(tokens[0], "none")) {
      return [];
    }
    return parseFunctionArgs(tokens).map(function(values2) {
      var shadow = {
        color: COLORS.TRANSPARENT,
        offsetX: ZERO_LENGTH,
        offsetY: ZERO_LENGTH,
        blur: ZERO_LENGTH
      };
      var c2 = 0;
      for (var i2 = 0; i2 < values2.length; i2++) {
        var token = values2[i2];
        if (isLength(token)) {
          if (c2 === 0) {
            shadow.offsetX = token;
          } else if (c2 === 1) {
            shadow.offsetY = token;
          } else {
            shadow.blur = token;
          }
          c2++;
        } else {
          shadow.color = color$1.parse(context, token);
        }
      }
      return shadow;
    });
  }
};
var textTransform = {
  name: "text-transform",
  initialValue: "none",
  prefix: false,
  type: 2,
  parse: function(_context, textTransform2) {
    switch (textTransform2) {
      case "uppercase":
        return 2;
      case "lowercase":
        return 1;
      case "capitalize":
        return 3;
    }
    return 0;
  }
};
var transform$1 = {
  name: "transform",
  initialValue: "none",
  prefix: true,
  type: 0,
  parse: function(_context, token) {
    if (token.type === 20 && token.value === "none") {
      return null;
    }
    if (token.type === 18) {
      var transformFunction = SUPPORTED_TRANSFORM_FUNCTIONS[token.name];
      if (typeof transformFunction === "undefined") {
        throw new Error('Attempting to parse an unsupported transform function "' + token.name + '"');
      }
      return transformFunction(token.values);
    }
    return null;
  }
};
var matrix = function(args) {
  var values2 = args.filter(function(arg) {
    return arg.type === 17;
  }).map(function(arg) {
    return arg.number;
  });
  return values2.length === 6 ? values2 : null;
};
var matrix3d = function(args) {
  var values2 = args.filter(function(arg) {
    return arg.type === 17;
  }).map(function(arg) {
    return arg.number;
  });
  var a1 = values2[0], b1 = values2[1];
  values2[2];
  values2[3];
  var a2 = values2[4], b2 = values2[5];
  values2[6];
  values2[7];
  values2[8];
  values2[9];
  values2[10];
  values2[11];
  var a4 = values2[12], b4 = values2[13];
  values2[14];
  values2[15];
  return values2.length === 16 ? [a1, b1, a2, b2, a4, b4] : null;
};
var SUPPORTED_TRANSFORM_FUNCTIONS = {
  matrix,
  matrix3d
};
var DEFAULT_VALUE = {
  type: 16,
  number: 50,
  flags: FLAG_INTEGER
};
var DEFAULT = [DEFAULT_VALUE, DEFAULT_VALUE];
var transformOrigin = {
  name: "transform-origin",
  initialValue: "50% 50%",
  prefix: true,
  type: 1,
  parse: function(_context, tokens) {
    var origins = tokens.filter(isLengthPercentage);
    if (origins.length !== 2) {
      return DEFAULT;
    }
    return [origins[0], origins[1]];
  }
};
var visibility = {
  name: "visible",
  initialValue: "none",
  prefix: false,
  type: 2,
  parse: function(_context, visibility2) {
    switch (visibility2) {
      case "hidden":
        return 1;
      case "collapse":
        return 2;
      case "visible":
      default:
        return 0;
    }
  }
};
var WORD_BREAK;
(function(WORD_BREAK2) {
  WORD_BREAK2["NORMAL"] = "normal";
  WORD_BREAK2["BREAK_ALL"] = "break-all";
  WORD_BREAK2["KEEP_ALL"] = "keep-all";
})(WORD_BREAK || (WORD_BREAK = {}));
var wordBreak = {
  name: "word-break",
  initialValue: "normal",
  prefix: false,
  type: 2,
  parse: function(_context, wordBreak2) {
    switch (wordBreak2) {
      case "break-all":
        return WORD_BREAK.BREAK_ALL;
      case "keep-all":
        return WORD_BREAK.KEEP_ALL;
      case "normal":
      default:
        return WORD_BREAK.NORMAL;
    }
  }
};
var zIndex = {
  name: "z-index",
  initialValue: "auto",
  prefix: false,
  type: 0,
  parse: function(_context, token) {
    if (token.type === 20) {
      return { auto: true, order: 0 };
    }
    if (isNumberToken(token)) {
      return { auto: false, order: token.number };
    }
    throw new Error("Invalid z-index number parsed");
  }
};
var time = {
  name: "time",
  parse: function(_context, value) {
    if (value.type === 15) {
      switch (value.unit.toLowerCase()) {
        case "s":
          return 1e3 * value.number;
        case "ms":
          return value.number;
      }
    }
    throw new Error("Unsupported time type");
  }
};
var opacity = {
  name: "opacity",
  initialValue: "1",
  type: 0,
  prefix: false,
  parse: function(_context, token) {
    if (isNumberToken(token)) {
      return token.number;
    }
    return 1;
  }
};
var textDecorationColor = {
  name: "text-decoration-color",
  initialValue: "transparent",
  prefix: false,
  type: 3,
  format: "color"
};
var textDecorationLine = {
  name: "text-decoration-line",
  initialValue: "none",
  prefix: false,
  type: 1,
  parse: function(_context, tokens) {
    return tokens.filter(isIdentToken).map(function(token) {
      switch (token.value) {
        case "underline":
          return 1;
        case "overline":
          return 2;
        case "line-through":
          return 3;
        case "none":
          return 4;
      }
      return 0;
    }).filter(function(line) {
      return line !== 0;
    });
  }
};
var fontFamily = {
  name: "font-family",
  initialValue: "",
  prefix: false,
  type: 1,
  parse: function(_context, tokens) {
    var accumulator = [];
    var results = [];
    tokens.forEach(function(token) {
      switch (token.type) {
        case 20:
        case 0:
          accumulator.push(token.value);
          break;
        case 17:
          accumulator.push(token.number.toString());
          break;
        case 4:
          results.push(accumulator.join(" "));
          accumulator.length = 0;
          break;
      }
    });
    if (accumulator.length) {
      results.push(accumulator.join(" "));
    }
    return results.map(function(result) {
      return result.indexOf(" ") === -1 ? result : "'" + result + "'";
    });
  }
};
var fontSize = {
  name: "font-size",
  initialValue: "0",
  prefix: false,
  type: 3,
  format: "length"
};
var fontWeight = {
  name: "font-weight",
  initialValue: "normal",
  type: 0,
  prefix: false,
  parse: function(_context, token) {
    if (isNumberToken(token)) {
      return token.number;
    }
    if (isIdentToken(token)) {
      switch (token.value) {
        case "bold":
          return 700;
        case "normal":
        default:
          return 400;
      }
    }
    return 400;
  }
};
var fontVariant = {
  name: "font-variant",
  initialValue: "none",
  type: 1,
  prefix: false,
  parse: function(_context, tokens) {
    return tokens.filter(isIdentToken).map(function(token) {
      return token.value;
    });
  }
};
var fontStyle = {
  name: "font-style",
  initialValue: "normal",
  prefix: false,
  type: 2,
  parse: function(_context, overflow2) {
    switch (overflow2) {
      case "oblique":
        return "oblique";
      case "italic":
        return "italic";
      case "normal":
      default:
        return "normal";
    }
  }
};
var contains = function(bit, value) {
  return (bit & value) !== 0;
};
var content = {
  name: "content",
  initialValue: "none",
  type: 1,
  prefix: false,
  parse: function(_context, tokens) {
    if (tokens.length === 0) {
      return [];
    }
    var first = tokens[0];
    if (first.type === 20 && first.value === "none") {
      return [];
    }
    return tokens;
  }
};
var counterIncrement = {
  name: "counter-increment",
  initialValue: "none",
  prefix: true,
  type: 1,
  parse: function(_context, tokens) {
    if (tokens.length === 0) {
      return null;
    }
    var first = tokens[0];
    if (first.type === 20 && first.value === "none") {
      return null;
    }
    var increments = [];
    var filtered = tokens.filter(nonWhiteSpace);
    for (var i2 = 0; i2 < filtered.length; i2++) {
      var counter2 = filtered[i2];
      var next = filtered[i2 + 1];
      if (counter2.type === 20) {
        var increment = next && isNumberToken(next) ? next.number : 1;
        increments.push({ counter: counter2.value, increment });
      }
    }
    return increments;
  }
};
var counterReset = {
  name: "counter-reset",
  initialValue: "none",
  prefix: true,
  type: 1,
  parse: function(_context, tokens) {
    if (tokens.length === 0) {
      return [];
    }
    var resets = [];
    var filtered = tokens.filter(nonWhiteSpace);
    for (var i2 = 0; i2 < filtered.length; i2++) {
      var counter2 = filtered[i2];
      var next = filtered[i2 + 1];
      if (isIdentToken(counter2) && counter2.value !== "none") {
        var reset2 = next && isNumberToken(next) ? next.number : 0;
        resets.push({ counter: counter2.value, reset: reset2 });
      }
    }
    return resets;
  }
};
var duration = {
  name: "duration",
  initialValue: "0s",
  prefix: false,
  type: 1,
  parse: function(context, tokens) {
    return tokens.filter(isDimensionToken).map(function(token) {
      return time.parse(context, token);
    });
  }
};
var quotes = {
  name: "quotes",
  initialValue: "none",
  prefix: true,
  type: 1,
  parse: function(_context, tokens) {
    if (tokens.length === 0) {
      return null;
    }
    var first = tokens[0];
    if (first.type === 20 && first.value === "none") {
      return null;
    }
    var quotes2 = [];
    var filtered = tokens.filter(isStringToken);
    if (filtered.length % 2 !== 0) {
      return null;
    }
    for (var i2 = 0; i2 < filtered.length; i2 += 2) {
      var open_1 = filtered[i2].value;
      var close_1 = filtered[i2 + 1].value;
      quotes2.push({ open: open_1, close: close_1 });
    }
    return quotes2;
  }
};
var getQuote = function(quotes2, depth, open2) {
  if (!quotes2) {
    return "";
  }
  var quote = quotes2[Math.min(depth, quotes2.length - 1)];
  if (!quote) {
    return "";
  }
  return open2 ? quote.open : quote.close;
};
var boxShadow = {
  name: "box-shadow",
  initialValue: "none",
  type: 1,
  prefix: false,
  parse: function(context, tokens) {
    if (tokens.length === 1 && isIdentWithValue(tokens[0], "none")) {
      return [];
    }
    return parseFunctionArgs(tokens).map(function(values2) {
      var shadow = {
        color: 255,
        offsetX: ZERO_LENGTH,
        offsetY: ZERO_LENGTH,
        blur: ZERO_LENGTH,
        spread: ZERO_LENGTH,
        inset: false
      };
      var c2 = 0;
      for (var i2 = 0; i2 < values2.length; i2++) {
        var token = values2[i2];
        if (isIdentWithValue(token, "inset")) {
          shadow.inset = true;
        } else if (isLength(token)) {
          if (c2 === 0) {
            shadow.offsetX = token;
          } else if (c2 === 1) {
            shadow.offsetY = token;
          } else if (c2 === 2) {
            shadow.blur = token;
          } else {
            shadow.spread = token;
          }
          c2++;
        } else {
          shadow.color = color$1.parse(context, token);
        }
      }
      return shadow;
    });
  }
};
var paintOrder = {
  name: "paint-order",
  initialValue: "normal",
  prefix: false,
  type: 1,
  parse: function(_context, tokens) {
    var DEFAULT_VALUE2 = [0, 1, 2];
    var layers = [];
    tokens.filter(isIdentToken).forEach(function(token) {
      switch (token.value) {
        case "stroke":
          layers.push(1);
          break;
        case "fill":
          layers.push(0);
          break;
        case "markers":
          layers.push(2);
          break;
      }
    });
    DEFAULT_VALUE2.forEach(function(value) {
      if (layers.indexOf(value) === -1) {
        layers.push(value);
      }
    });
    return layers;
  }
};
var webkitTextStrokeColor = {
  name: "-webkit-text-stroke-color",
  initialValue: "currentcolor",
  prefix: false,
  type: 3,
  format: "color"
};
var webkitTextStrokeWidth = {
  name: "-webkit-text-stroke-width",
  initialValue: "0",
  type: 0,
  prefix: false,
  parse: function(_context, token) {
    if (isDimensionToken(token)) {
      return token.number;
    }
    return 0;
  }
};
var CSSParsedDeclaration = function() {
  function CSSParsedDeclaration2(context, declaration) {
    var _a2, _b2;
    this.animationDuration = parse(context, duration, declaration.animationDuration);
    this.backgroundClip = parse(context, backgroundClip, declaration.backgroundClip);
    this.backgroundColor = parse(context, backgroundColor, declaration.backgroundColor);
    this.backgroundImage = parse(context, backgroundImage, declaration.backgroundImage);
    this.backgroundOrigin = parse(context, backgroundOrigin, declaration.backgroundOrigin);
    this.backgroundPosition = parse(context, backgroundPosition, declaration.backgroundPosition);
    this.backgroundRepeat = parse(context, backgroundRepeat, declaration.backgroundRepeat);
    this.backgroundSize = parse(context, backgroundSize, declaration.backgroundSize);
    this.borderTopColor = parse(context, borderTopColor, declaration.borderTopColor);
    this.borderRightColor = parse(context, borderRightColor, declaration.borderRightColor);
    this.borderBottomColor = parse(context, borderBottomColor, declaration.borderBottomColor);
    this.borderLeftColor = parse(context, borderLeftColor, declaration.borderLeftColor);
    this.borderTopLeftRadius = parse(context, borderTopLeftRadius, declaration.borderTopLeftRadius);
    this.borderTopRightRadius = parse(context, borderTopRightRadius, declaration.borderTopRightRadius);
    this.borderBottomRightRadius = parse(context, borderBottomRightRadius, declaration.borderBottomRightRadius);
    this.borderBottomLeftRadius = parse(context, borderBottomLeftRadius, declaration.borderBottomLeftRadius);
    this.borderTopStyle = parse(context, borderTopStyle, declaration.borderTopStyle);
    this.borderRightStyle = parse(context, borderRightStyle, declaration.borderRightStyle);
    this.borderBottomStyle = parse(context, borderBottomStyle, declaration.borderBottomStyle);
    this.borderLeftStyle = parse(context, borderLeftStyle, declaration.borderLeftStyle);
    this.borderTopWidth = parse(context, borderTopWidth, declaration.borderTopWidth);
    this.borderRightWidth = parse(context, borderRightWidth, declaration.borderRightWidth);
    this.borderBottomWidth = parse(context, borderBottomWidth, declaration.borderBottomWidth);
    this.borderLeftWidth = parse(context, borderLeftWidth, declaration.borderLeftWidth);
    this.boxShadow = parse(context, boxShadow, declaration.boxShadow);
    this.color = parse(context, color, declaration.color);
    this.direction = parse(context, direction, declaration.direction);
    this.display = parse(context, display, declaration.display);
    this.float = parse(context, float, declaration.cssFloat);
    this.fontFamily = parse(context, fontFamily, declaration.fontFamily);
    this.fontSize = parse(context, fontSize, declaration.fontSize);
    this.fontStyle = parse(context, fontStyle, declaration.fontStyle);
    this.fontVariant = parse(context, fontVariant, declaration.fontVariant);
    this.fontWeight = parse(context, fontWeight, declaration.fontWeight);
    this.letterSpacing = parse(context, letterSpacing, declaration.letterSpacing);
    this.lineBreak = parse(context, lineBreak, declaration.lineBreak);
    this.lineHeight = parse(context, lineHeight, declaration.lineHeight);
    this.listStyleImage = parse(context, listStyleImage, declaration.listStyleImage);
    this.listStylePosition = parse(context, listStylePosition, declaration.listStylePosition);
    this.listStyleType = parse(context, listStyleType, declaration.listStyleType);
    this.marginTop = parse(context, marginTop, declaration.marginTop);
    this.marginRight = parse(context, marginRight, declaration.marginRight);
    this.marginBottom = parse(context, marginBottom, declaration.marginBottom);
    this.marginLeft = parse(context, marginLeft, declaration.marginLeft);
    this.opacity = parse(context, opacity, declaration.opacity);
    var overflowTuple = parse(context, overflow, declaration.overflow);
    this.overflowX = overflowTuple[0];
    this.overflowY = overflowTuple[overflowTuple.length > 1 ? 1 : 0];
    this.overflowWrap = parse(context, overflowWrap, declaration.overflowWrap);
    this.paddingTop = parse(context, paddingTop, declaration.paddingTop);
    this.paddingRight = parse(context, paddingRight, declaration.paddingRight);
    this.paddingBottom = parse(context, paddingBottom, declaration.paddingBottom);
    this.paddingLeft = parse(context, paddingLeft, declaration.paddingLeft);
    this.paintOrder = parse(context, paintOrder, declaration.paintOrder);
    this.position = parse(context, position, declaration.position);
    this.textAlign = parse(context, textAlign, declaration.textAlign);
    this.textDecorationColor = parse(context, textDecorationColor, (_a2 = declaration.textDecorationColor) !== null && _a2 !== void 0 ? _a2 : declaration.color);
    this.textDecorationLine = parse(context, textDecorationLine, (_b2 = declaration.textDecorationLine) !== null && _b2 !== void 0 ? _b2 : declaration.textDecoration);
    this.textShadow = parse(context, textShadow, declaration.textShadow);
    this.textTransform = parse(context, textTransform, declaration.textTransform);
    this.transform = parse(context, transform$1, declaration.transform);
    this.transformOrigin = parse(context, transformOrigin, declaration.transformOrigin);
    this.visibility = parse(context, visibility, declaration.visibility);
    this.webkitTextStrokeColor = parse(context, webkitTextStrokeColor, declaration.webkitTextStrokeColor);
    this.webkitTextStrokeWidth = parse(context, webkitTextStrokeWidth, declaration.webkitTextStrokeWidth);
    this.wordBreak = parse(context, wordBreak, declaration.wordBreak);
    this.zIndex = parse(context, zIndex, declaration.zIndex);
  }
  CSSParsedDeclaration2.prototype.isVisible = function() {
    return this.display > 0 && this.opacity > 0 && this.visibility === 0;
  };
  CSSParsedDeclaration2.prototype.isTransparent = function() {
    return isTransparent(this.backgroundColor);
  };
  CSSParsedDeclaration2.prototype.isTransformed = function() {
    return this.transform !== null;
  };
  CSSParsedDeclaration2.prototype.isPositioned = function() {
    return this.position !== 0;
  };
  CSSParsedDeclaration2.prototype.isPositionedWithZIndex = function() {
    return this.isPositioned() && !this.zIndex.auto;
  };
  CSSParsedDeclaration2.prototype.isFloating = function() {
    return this.float !== 0;
  };
  CSSParsedDeclaration2.prototype.isInlineLevel = function() {
    return contains(this.display, 4) || contains(this.display, 33554432) || contains(this.display, 268435456) || contains(this.display, 536870912) || contains(this.display, 67108864) || contains(this.display, 134217728);
  };
  return CSSParsedDeclaration2;
}();
var CSSParsedPseudoDeclaration = function() {
  function CSSParsedPseudoDeclaration2(context, declaration) {
    this.content = parse(context, content, declaration.content);
    this.quotes = parse(context, quotes, declaration.quotes);
  }
  return CSSParsedPseudoDeclaration2;
}();
var CSSParsedCounterDeclaration = function() {
  function CSSParsedCounterDeclaration2(context, declaration) {
    this.counterIncrement = parse(context, counterIncrement, declaration.counterIncrement);
    this.counterReset = parse(context, counterReset, declaration.counterReset);
  }
  return CSSParsedCounterDeclaration2;
}();
var parse = function(context, descriptor, style2) {
  var tokenizer = new Tokenizer();
  var value = style2 !== null && typeof style2 !== "undefined" ? style2.toString() : descriptor.initialValue;
  tokenizer.write(value);
  var parser = new Parser$1(tokenizer.read());
  switch (descriptor.type) {
    case 2:
      var token = parser.parseComponentValue();
      return descriptor.parse(context, isIdentToken(token) ? token.value : descriptor.initialValue);
    case 0:
      return descriptor.parse(context, parser.parseComponentValue());
    case 1:
      return descriptor.parse(context, parser.parseComponentValues());
    case 4:
      return parser.parseComponentValue();
    case 3:
      switch (descriptor.format) {
        case "angle":
          return angle.parse(context, parser.parseComponentValue());
        case "color":
          return color$1.parse(context, parser.parseComponentValue());
        case "image":
          return image.parse(context, parser.parseComponentValue());
        case "length":
          var length_1 = parser.parseComponentValue();
          return isLength(length_1) ? length_1 : ZERO_LENGTH;
        case "length-percentage":
          var value_1 = parser.parseComponentValue();
          return isLengthPercentage(value_1) ? value_1 : ZERO_LENGTH;
        case "time":
          return time.parse(context, parser.parseComponentValue());
      }
      break;
  }
};
var elementDebuggerAttribute = "data-html2canvas-debug";
var getElementDebugType = function(element) {
  var attribute = element.getAttribute(elementDebuggerAttribute);
  switch (attribute) {
    case "all":
      return 1;
    case "clone":
      return 2;
    case "parse":
      return 3;
    case "render":
      return 4;
    default:
      return 0;
  }
};
var isDebugging = function(element, type) {
  var elementType = getElementDebugType(element);
  return elementType === 1 || type === elementType;
};
var ElementContainer = function() {
  function ElementContainer2(context, element) {
    this.context = context;
    this.textNodes = [];
    this.elements = [];
    this.flags = 0;
    if (isDebugging(element, 3)) {
      debugger;
    }
    this.styles = new CSSParsedDeclaration(context, window.getComputedStyle(element, null));
    if (isHTMLElementNode(element)) {
      if (this.styles.animationDuration.some(function(duration2) {
        return duration2 > 0;
      })) {
        element.style.animationDuration = "0s";
      }
      if (this.styles.transform !== null) {
        element.style.transform = "none";
      }
    }
    this.bounds = parseBounds(this.context, element);
    if (isDebugging(element, 4)) {
      this.flags |= 16;
    }
  }
  return ElementContainer2;
}();
var base64 = "AAAAAAAAAAAAEA4AGBkAAFAaAAACAAAAAAAIABAAGAAwADgACAAQAAgAEAAIABAACAAQAAgAEAAIABAACAAQAAgAEAAIABAAQABIAEQATAAIABAACAAQAAgAEAAIABAAVABcAAgAEAAIABAACAAQAGAAaABwAHgAgACIAI4AlgAIABAAmwCjAKgAsAC2AL4AvQDFAMoA0gBPAVYBWgEIAAgACACMANoAYgFkAWwBdAF8AX0BhQGNAZUBlgGeAaMBlQGWAasBswF8AbsBwwF0AcsBYwHTAQgA2wG/AOMBdAF8AekB8QF0AfkB+wHiAHQBfAEIAAMC5gQIAAsCEgIIAAgAFgIeAggAIgIpAggAMQI5AkACygEIAAgASAJQAlgCYAIIAAgACAAKBQoFCgUTBRMFGQUrBSsFCAAIAAgACAAIAAgACAAIAAgACABdAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACABoAmgCrwGvAQgAbgJ2AggAHgEIAAgACADnAXsCCAAIAAgAgwIIAAgACAAIAAgACACKAggAkQKZAggAPADJAAgAoQKkAqwCsgK6AsICCADJAggA0AIIAAgACAAIANYC3gIIAAgACAAIAAgACABAAOYCCAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAkASoB+QIEAAgACAA8AEMCCABCBQgACABJBVAFCAAIAAgACAAIAAgACAAIAAgACABTBVoFCAAIAFoFCABfBWUFCAAIAAgACAAIAAgAbQUIAAgACAAIAAgACABzBXsFfQWFBYoFigWKBZEFigWKBYoFmAWfBaYFrgWxBbkFCAAIAAgACAAIAAgACAAIAAgACAAIAMEFCAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAMgFCADQBQgACAAIAAgACAAIAAgACAAIAAgACAAIAO4CCAAIAAgAiQAIAAgACABAAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAD0AggACAD8AggACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIANYFCAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAMDvwAIAAgAJAIIAAgACAAIAAgACAAIAAgACwMTAwgACAB9BOsEGwMjAwgAKwMyAwsFYgE3A/MEPwMIAEUDTQNRAwgAWQOsAGEDCAAIAAgACAAIAAgACABpAzQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFIQUoBSwFCAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACABtAwgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACABMAEwACAAIAAgACAAIABgACAAIAAgACAC/AAgACAAyAQgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACACAAIAAwAAgACAAIAAgACAAIAAgACAAIAAAARABIAAgACAAIABQASAAIAAgAIABwAEAAjgCIABsAqAC2AL0AigDQAtwC+IJIQqVAZUBWQqVAZUBlQGVAZUBlQGrC5UBlQGVAZUBlQGVAZUBlQGVAXsKlQGVAbAK6wsrDGUMpQzlDJUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAfAKAAuZA64AtwCJALoC6ADwAAgAuACgA/oEpgO6AqsD+AAIAAgAswMIAAgACAAIAIkAuwP5AfsBwwPLAwgACAAIAAgACADRA9kDCAAIAOED6QMIAAgACAAIAAgACADuA/YDCAAIAP4DyQAIAAgABgQIAAgAXQAOBAgACAAIAAgACAAIABMECAAIAAgACAAIAAgACAD8AAQBCAAIAAgAGgQiBCoECAExBAgAEAEIAAgACAAIAAgACAAIAAgACAAIAAgACAA4BAgACABABEYECAAIAAgATAQYAQgAVAQIAAgACAAIAAgACAAIAAgACAAIAFoECAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgAOQEIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAB+BAcACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAEABhgSMBAgACAAIAAgAlAQIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAwAEAAQABAADAAMAAwADAAQABAAEAAQABAAEAAQABHATAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgAdQMIAAgACAAIAAgACAAIAMkACAAIAAgAfQMIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACACFA4kDCAAIAAgACAAIAOcBCAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAIcDCAAIAAgACAAIAAgACAAIAAgACAAIAJEDCAAIAAgACADFAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACABgBAgAZgQIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgAbAQCBXIECAAIAHkECAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACABAAJwEQACjBKoEsgQIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAC6BMIECAAIAAgACAAIAAgACABmBAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgAxwQIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAGYECAAIAAgAzgQIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgAigWKBYoFigWKBYoFigWKBd0FXwUIAOIF6gXxBYoF3gT5BQAGCAaKBYoFigWKBYoFigWKBYoFigWKBYoFigXWBIoFigWKBYoFigWKBYoFigWKBYsFEAaKBYoFigWKBYoFigWKBRQGCACKBYoFigWKBQgACAAIANEECAAIABgGigUgBggAJgYIAC4GMwaKBYoF0wQ3Bj4GigWKBYoFigWKBYoFigWKBYoFigWKBYoFigUIAAgACAAIAAgACAAIAAgAigWKBYoFigWKBYoFigWKBYoFigWKBYoFigWKBYoFigWKBYoFigWKBYoFigWKBYoFigWKBYoFigWKBYoFigWLBf///////wQABAAEAAQABAAEAAQABAAEAAQAAwAEAAQAAgAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAAAAAAAAAAAAAAAAAAAAAAAAAOAAAAAAAAAAQADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUABQAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAAAUAAAAFAAUAAAAFAAUAAAAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAAEAAQABAAEAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUABQAFAAUABQAFAAUABQAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUABQAFAAUAAQAAAAUABQAFAAUABQAFAAAAAAAFAAUAAAAFAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAUABQAFAAUABQAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAUABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAFAAAAAAAFAAUAAQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABwAFAAUABQAFAAAABwAHAAcAAAAHAAcABwAFAAEAAAAAAAAAAAAAAAAAAAAAAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHAAcABwAFAAUABQAFAAcABwAFAAUAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHAAAAAQABAAAAAAAAAAAAAAAFAAUABQAFAAAABwAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAHAAcABwAHAAcAAAAHAAcAAAAAAAUABQAHAAUAAQAHAAEABwAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUABQAFAAUABwABAAUABQAFAAUAAAAAAAAAAAAAAAEAAQABAAEAAQABAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABwAFAAUAAAAAAAAAAAAAAAAABQAFAAUABQAFAAUAAQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQABQANAAQABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQABAAEAAQABAAEAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAAEAAQABAAEAAQABAAEAAQABAAEAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAAQABAAEAAQABAAEAAQABAAAAAAAAAAAAAAAAAAAAAAABQAHAAUABQAFAAAAAAAAAAcABQAFAAUABQAFAAQABAAEAAQABAAEAAQABAAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUAAAAFAAUABQAFAAUAAAAFAAUABQAAAAUABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAAAAAAAAAAAAUABQAFAAcAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAHAAUAAAAHAAcABwAFAAUABQAFAAUABQAFAAUABwAHAAcABwAFAAcABwAAAAUABQAFAAUABQAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABwAHAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAUABwAHAAUABQAFAAUAAAAAAAcABwAAAAAABwAHAAUAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAAABQAFAAcAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAAABwAHAAcABQAFAAAAAAAAAAAABQAFAAAAAAAFAAUABQAAAAAAAAAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAAAAAAAAAFAAAAAAAAAAAAAAAAAAAAAAAAAAAABwAFAAUABQAFAAUAAAAFAAUABwAAAAcABwAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUAAAAFAAUABwAFAAUABQAFAAAAAAAHAAcAAAAAAAcABwAFAAAAAAAAAAAAAAAAAAAABQAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAcABwAAAAAAAAAHAAcABwAAAAcABwAHAAUAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAAAAAAAAAAAAAAAAAAABQAHAAcABwAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABwAHAAcABwAAAAUABQAFAAAABQAFAAUABQAAAAAAAAAAAAAAAAAAAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAcABQAHAAcABQAHAAcAAAAFAAcABwAAAAcABwAFAAUAAAAAAAAAAAAAAAAAAAAFAAUAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAcABwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAAAAUABwAAAAAAAAAAAAAAAAAAAAAAAAAAAAUAAAAAAAAAAAAFAAcABwAFAAUABQAAAAUAAAAHAAcABwAHAAcABwAHAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUAAAAHAAUABQAFAAUABQAFAAUAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAAABwAFAAUABQAFAAUABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUABQAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAUAAAAFAAAAAAAAAAAABwAHAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABwAFAAUABQAFAAUAAAAFAAUAAAAAAAAAAAAAAAUABQAFAAUABQAFAAUABQAFAAUABQAAAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUABwAFAAUABQAFAAUABQAAAAUABQAHAAcABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHAAcABQAFAAAAAAAAAAAABQAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAcABQAFAAAAAAAAAAAAAAAAAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAHAAUABQAFAAUABQAFAAUABwAHAAcABwAHAAcABwAHAAUABwAHAAUABQAFAAUABQAFAAUABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUABwAHAAcABwAFAAUABwAHAAcAAAAAAAAAAAAHAAcABQAHAAcABwAHAAcABwAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAcABwAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAcABQAHAAUABQAFAAUABQAFAAUAAAAFAAAABQAAAAAABQAFAAUABQAFAAUABQAFAAcABwAHAAcABwAHAAUABQAFAAUABQAFAAUABQAFAAUAAAAAAAUABQAFAAUABQAHAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUABQAFAAUABwAFAAcABwAHAAcABwAFAAcABwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAUABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHAAUABQAFAAUABwAHAAUABQAHAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAcABQAFAAcABwAHAAUABwAFAAUABQAHAAcAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABwAHAAcABwAHAAcABwAHAAUABQAFAAUABQAFAAUABQAHAAcABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUAAAAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAcABQAFAAUABQAFAAUABQAAAAAAAAAAAAUAAAAAAAAAAAAAAAAABQAAAAAABwAFAAUAAAAAAAAAAAAAAAAABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAAABQAFAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUABQAFAAUADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUAAAAFAAUABQAFAAUABQAFAAUABQAFAAAAAAAAAAAABQAAAAAAAAAFAAAAAAAAAAAABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABwAHAAUABQAHAAAAAAAAAAAABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAcABwAHAAcABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUAAAAAAAAAAAAAAAAABQAFAAUABQAFAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUABQAFAAUABQAFAAUABQAHAAcAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAcABwAFAAUABQAFAAcABwAFAAUABwAHAAAAAAAAAAAAAAAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUABQAFAAcABwAFAAUABwAHAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAAAAAAAAAAAAAAAAAAAAAAFAAcAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUAAAAFAAUABQAAAAAABQAFAAAAAAAAAAAAAAAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAcABQAFAAcABwAAAAAAAAAAAAAABwAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAcABwAFAAcABwAFAAcABwAAAAcABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUABQAAAAAAAAAAAAAAAAAFAAUABQAAAAUABQAAAAAAAAAAAAAABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAAAAAAAAAAAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAcABQAHAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAUABwAFAAUABQAFAAUABQAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABwAHAAcABQAFAAUABQAFAAUABQAFAAUABwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHAAcABwAFAAUABQAHAAcABQAHAAUABQAAAAAAAAAAAAAAAAAFAAAABwAHAAcABQAFAAUABQAFAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABwAHAAcABwAAAAAABwAHAAAAAAAHAAcABwAAAAAAAAAAAAAAAAAAAAAAAAAFAAAAAAAAAAAAAAAAAAAAAAAAAAAABwAHAAAAAAAFAAUABQAFAAUABQAFAAAAAAAAAAUABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHAAcABwAFAAUABQAFAAUABQAFAAUABwAHAAUABQAFAAcABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAHAAcABQAFAAUABQAFAAUABwAFAAcABwAFAAcABQAFAAcABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAHAAcABQAFAAUABQAAAAAABwAHAAcABwAFAAUABwAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAcABwAHAAUABQAFAAUABQAFAAUABQAHAAcABQAHAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABwAFAAcABwAFAAUABQAFAAUABQAHAAUAAAAAAAAAAAAAAAAAAAAAAAcABwAFAAUABQAFAAcABQAFAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHAAcABwAFAAUABQAFAAUABQAFAAUABQAHAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHAAcABwAFAAUABQAFAAAAAAAFAAUABwAHAAcABwAFAAAAAAAAAAcAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAUABQAFAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUABQAFAAUABwAHAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAcABQAFAAUABQAFAAUABQAAAAUABQAFAAUABQAFAAcABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAAAHAAUABQAFAAUABQAFAAUABwAFAAUABwAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUABQAFAAUAAAAAAAAABQAAAAUABQAAAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAHAAcABwAHAAcAAAAFAAUAAAAHAAcABQAHAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABwAHAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAAAAAAAAAAAAAAAAAAABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAcABwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAAAAUABQAFAAAAAAAFAAUABQAFAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAAAAAAAAAAABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAFAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUABQAAAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUABQAFAAUABQAAAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAAAAABQAFAAUABQAFAAUABQAAAAUABQAAAAUABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAFAAUABQAFAAUADgAOAA4ADgAOAA4ADwAPAA8ADwAPAA8ADwAPAA8ADwAPAA8ADwAPAA8ADwAPAA8ADwAPAA8ADwAPAA8ADwAPAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAcABwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABwAHAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAAAAAAAAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAKAAoACgAKAAoACgAKAAoACgAKAAoACgAKAAoACgAKAAoACgAKAAoACgAKAAoACgAMAAwADAAMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkAAAAAAAAAAAAKAAoACgAKAAoACgAKAAoACgAKAAoACgAKAAoACgAKAAoACgAKAAoACgAKAAoACgAKAAoACgAKAAoACgAKAAoACgAAAAAAAAAAAAsADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwACwAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAAAAAADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA4AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOAA4ADgAOAA4ADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA4ADgAAAAAAAAAAAAAAAAAAAAAADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAOAA4ADgAOAA4ADgAOAA4ADgAOAAAAAAAAAAAADgAOAA4AAAAAAAAAAAAAAAAAAAAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAOAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAAAAAAAAAAAAAAAAAAAAAAAAAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAOAA4ADgAAAA4ADgAOAA4ADgAOAAAADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4AAAAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4AAAAAAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAAAA4AAAAOAAAAAAAAAAAAAAAAAA4AAAAAAAAAAAAAAAAADgAAAAAAAAAAAAAAAAAAAAAAAAAAAA4ADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAAAAAADgAAAAAAAAAAAA4AAAAOAAAAAAAAAAAADgAOAA4AAAAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOAA4ADgAOAA4AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOAA4ADgAAAAAAAAAAAAAAAAAAAAAAAAAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOAA4AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA4ADgAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAAAAAAAAAAAA4AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOAAAADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOAA4ADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA4ADgAOAA4ADgAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA4ADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAAAAAADgAOAA4ADgAOAA4ADgAOAA4ADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAAAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA4AAAAAAA4ADgAOAA4ADgAOAA4ADgAOAAAADgAOAA4ADgAAAAAAAAAAAAAAAAAAAAAAAAAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4AAAAAAAAAAAAAAAAADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOAA4ADgAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAOAA4ADgAOAA4ADgAOAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAOAA4ADgAOAA4AAAAAAAAAAAAAAAAAAAAAAA4ADgAOAA4ADgAOAA4ADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4AAAAOAA4ADgAOAA4ADgAAAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4AAAAAAAAAAAA=";
var chars$1 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
var lookup$1 = typeof Uint8Array === "undefined" ? [] : new Uint8Array(256);
for (i$1$2 = 0; i$1$2 < chars$1.length; i$1$2++) {
  lookup$1[chars$1.charCodeAt(i$1$2)] = i$1$2;
}
var i$1$2;
var decode = function(base642) {
  var bufferLength = base642.length * 0.75, len = base642.length, i2, p5 = 0, encoded1, encoded2, encoded3, encoded4;
  if (base642[base642.length - 1] === "=") {
    bufferLength--;
    if (base642[base642.length - 2] === "=") {
      bufferLength--;
    }
  }
  var buffer2 = typeof ArrayBuffer !== "undefined" && typeof Uint8Array !== "undefined" && typeof Uint8Array.prototype.slice !== "undefined" ? new ArrayBuffer(bufferLength) : new Array(bufferLength);
  var bytes = Array.isArray(buffer2) ? buffer2 : new Uint8Array(buffer2);
  for (i2 = 0; i2 < len; i2 += 4) {
    encoded1 = lookup$1[base642.charCodeAt(i2)];
    encoded2 = lookup$1[base642.charCodeAt(i2 + 1)];
    encoded3 = lookup$1[base642.charCodeAt(i2 + 2)];
    encoded4 = lookup$1[base642.charCodeAt(i2 + 3)];
    bytes[p5++] = encoded1 << 2 | encoded2 >> 4;
    bytes[p5++] = (encoded2 & 15) << 4 | encoded3 >> 2;
    bytes[p5++] = (encoded3 & 3) << 6 | encoded4 & 63;
  }
  return buffer2;
};
var polyUint16Array = function(buffer2) {
  var length = buffer2.length;
  var bytes = [];
  for (var i2 = 0; i2 < length; i2 += 2) {
    bytes.push(buffer2[i2 + 1] << 8 | buffer2[i2]);
  }
  return bytes;
};
var polyUint32Array = function(buffer2) {
  var length = buffer2.length;
  var bytes = [];
  for (var i2 = 0; i2 < length; i2 += 4) {
    bytes.push(buffer2[i2 + 3] << 24 | buffer2[i2 + 2] << 16 | buffer2[i2 + 1] << 8 | buffer2[i2]);
  }
  return bytes;
};
var UTRIE2_SHIFT_2 = 5;
var UTRIE2_SHIFT_1 = 6 + 5;
var UTRIE2_INDEX_SHIFT = 2;
var UTRIE2_SHIFT_1_2 = UTRIE2_SHIFT_1 - UTRIE2_SHIFT_2;
var UTRIE2_LSCP_INDEX_2_OFFSET = 65536 >> UTRIE2_SHIFT_2;
var UTRIE2_DATA_BLOCK_LENGTH = 1 << UTRIE2_SHIFT_2;
var UTRIE2_DATA_MASK = UTRIE2_DATA_BLOCK_LENGTH - 1;
var UTRIE2_LSCP_INDEX_2_LENGTH = 1024 >> UTRIE2_SHIFT_2;
var UTRIE2_INDEX_2_BMP_LENGTH = UTRIE2_LSCP_INDEX_2_OFFSET + UTRIE2_LSCP_INDEX_2_LENGTH;
var UTRIE2_UTF8_2B_INDEX_2_OFFSET = UTRIE2_INDEX_2_BMP_LENGTH;
var UTRIE2_UTF8_2B_INDEX_2_LENGTH = 2048 >> 6;
var UTRIE2_INDEX_1_OFFSET = UTRIE2_UTF8_2B_INDEX_2_OFFSET + UTRIE2_UTF8_2B_INDEX_2_LENGTH;
var UTRIE2_OMITTED_BMP_INDEX_1_LENGTH = 65536 >> UTRIE2_SHIFT_1;
var UTRIE2_INDEX_2_BLOCK_LENGTH = 1 << UTRIE2_SHIFT_1_2;
var UTRIE2_INDEX_2_MASK = UTRIE2_INDEX_2_BLOCK_LENGTH - 1;
var slice16 = function(view, start2, end) {
  if (view.slice) {
    return view.slice(start2, end);
  }
  return new Uint16Array(Array.prototype.slice.call(view, start2, end));
};
var slice32 = function(view, start2, end) {
  if (view.slice) {
    return view.slice(start2, end);
  }
  return new Uint32Array(Array.prototype.slice.call(view, start2, end));
};
var createTrieFromBase64 = function(base642, _byteLength) {
  var buffer2 = decode(base642);
  var view32 = Array.isArray(buffer2) ? polyUint32Array(buffer2) : new Uint32Array(buffer2);
  var view16 = Array.isArray(buffer2) ? polyUint16Array(buffer2) : new Uint16Array(buffer2);
  var headerLength = 24;
  var index2 = slice16(view16, headerLength / 2, view32[4] / 2);
  var data2 = view32[5] === 2 ? slice16(view16, (headerLength + view32[4]) / 2) : slice32(view32, Math.ceil((headerLength + view32[4]) / 4));
  return new Trie(view32[0], view32[1], view32[2], view32[3], index2, data2);
};
var Trie = function() {
  function Trie2(initialValue, errorValue, highStart, highValueIndex, index2, data2) {
    this.initialValue = initialValue;
    this.errorValue = errorValue;
    this.highStart = highStart;
    this.highValueIndex = highValueIndex;
    this.index = index2;
    this.data = data2;
  }
  Trie2.prototype.get = function(codePoint) {
    var ix;
    if (codePoint >= 0) {
      if (codePoint < 55296 || codePoint > 56319 && codePoint <= 65535) {
        ix = this.index[codePoint >> UTRIE2_SHIFT_2];
        ix = (ix << UTRIE2_INDEX_SHIFT) + (codePoint & UTRIE2_DATA_MASK);
        return this.data[ix];
      }
      if (codePoint <= 65535) {
        ix = this.index[UTRIE2_LSCP_INDEX_2_OFFSET + (codePoint - 55296 >> UTRIE2_SHIFT_2)];
        ix = (ix << UTRIE2_INDEX_SHIFT) + (codePoint & UTRIE2_DATA_MASK);
        return this.data[ix];
      }
      if (codePoint < this.highStart) {
        ix = UTRIE2_INDEX_1_OFFSET - UTRIE2_OMITTED_BMP_INDEX_1_LENGTH + (codePoint >> UTRIE2_SHIFT_1);
        ix = this.index[ix];
        ix += codePoint >> UTRIE2_SHIFT_2 & UTRIE2_INDEX_2_MASK;
        ix = this.index[ix];
        ix = (ix << UTRIE2_INDEX_SHIFT) + (codePoint & UTRIE2_DATA_MASK);
        return this.data[ix];
      }
      if (codePoint <= 1114111) {
        return this.data[this.highValueIndex];
      }
    }
    return this.errorValue;
  };
  return Trie2;
}();
var chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
var lookup = typeof Uint8Array === "undefined" ? [] : new Uint8Array(256);
for (i$4 = 0; i$4 < chars.length; i$4++) {
  lookup[chars.charCodeAt(i$4)] = i$4;
}
var i$4;
var Prepend = 1;
var CR = 2;
var LF = 3;
var Control = 4;
var Extend = 5;
var SpacingMark = 7;
var L = 8;
var V = 9;
var T$1 = 10;
var LV = 11;
var LVT = 12;
var ZWJ = 13;
var Extended_Pictographic = 14;
var RI = 15;
var toCodePoints = function(str) {
  var codePoints = [];
  var i2 = 0;
  var length = str.length;
  while (i2 < length) {
    var value = str.charCodeAt(i2++);
    if (value >= 55296 && value <= 56319 && i2 < length) {
      var extra = str.charCodeAt(i2++);
      if ((extra & 64512) === 56320) {
        codePoints.push(((value & 1023) << 10) + (extra & 1023) + 65536);
      } else {
        codePoints.push(value);
        i2--;
      }
    } else {
      codePoints.push(value);
    }
  }
  return codePoints;
};
var fromCodePoint = function() {
  var codePoints = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    codePoints[_i] = arguments[_i];
  }
  if (String.fromCodePoint) {
    return String.fromCodePoint.apply(String, codePoints);
  }
  var length = codePoints.length;
  if (!length) {
    return "";
  }
  var codeUnits = [];
  var index2 = -1;
  var result = "";
  while (++index2 < length) {
    var codePoint = codePoints[index2];
    if (codePoint <= 65535) {
      codeUnits.push(codePoint);
    } else {
      codePoint -= 65536;
      codeUnits.push((codePoint >> 10) + 55296, codePoint % 1024 + 56320);
    }
    if (index2 + 1 === length || codeUnits.length > 16384) {
      result += String.fromCharCode.apply(String, codeUnits);
      codeUnits.length = 0;
    }
  }
  return result;
};
var UnicodeTrie = createTrieFromBase64(base64);
var BREAK_NOT_ALLOWED = "\xD7";
var BREAK_ALLOWED = "\xF7";
var codePointToClass = function(codePoint) {
  return UnicodeTrie.get(codePoint);
};
var _graphemeBreakAtIndex = function(_codePoints, classTypes, index2) {
  var prevIndex = index2 - 2;
  var prev = classTypes[prevIndex];
  var current = classTypes[index2 - 1];
  var next = classTypes[index2];
  if (current === CR && next === LF) {
    return BREAK_NOT_ALLOWED;
  }
  if (current === CR || current === LF || current === Control) {
    return BREAK_ALLOWED;
  }
  if (next === CR || next === LF || next === Control) {
    return BREAK_ALLOWED;
  }
  if (current === L && [L, V, LV, LVT].indexOf(next) !== -1) {
    return BREAK_NOT_ALLOWED;
  }
  if ((current === LV || current === V) && (next === V || next === T$1)) {
    return BREAK_NOT_ALLOWED;
  }
  if ((current === LVT || current === T$1) && next === T$1) {
    return BREAK_NOT_ALLOWED;
  }
  if (next === ZWJ || next === Extend) {
    return BREAK_NOT_ALLOWED;
  }
  if (next === SpacingMark) {
    return BREAK_NOT_ALLOWED;
  }
  if (current === Prepend) {
    return BREAK_NOT_ALLOWED;
  }
  if (current === ZWJ && next === Extended_Pictographic) {
    while (prev === Extend) {
      prev = classTypes[--prevIndex];
    }
    if (prev === Extended_Pictographic) {
      return BREAK_NOT_ALLOWED;
    }
  }
  if (current === RI && next === RI) {
    var countRI = 0;
    while (prev === RI) {
      countRI++;
      prev = classTypes[--prevIndex];
    }
    if (countRI % 2 === 0) {
      return BREAK_NOT_ALLOWED;
    }
  }
  return BREAK_ALLOWED;
};
var GraphemeBreaker = function(str) {
  var codePoints = toCodePoints(str);
  var length = codePoints.length;
  var index2 = 0;
  var lastEnd = 0;
  var classTypes = codePoints.map(codePointToClass);
  return {
    next: function() {
      if (index2 >= length) {
        return { done: true, value: null };
      }
      var graphemeBreak = BREAK_NOT_ALLOWED;
      while (index2 < length && (graphemeBreak = _graphemeBreakAtIndex(codePoints, classTypes, ++index2)) === BREAK_NOT_ALLOWED) {
      }
      if (graphemeBreak !== BREAK_NOT_ALLOWED || index2 === length) {
        var value = fromCodePoint.apply(null, codePoints.slice(lastEnd, index2));
        lastEnd = index2;
        return { value, done: false };
      }
      return { done: true, value: null };
    }
  };
};
var splitGraphemes = function(str) {
  var breaker = GraphemeBreaker(str);
  var graphemes = [];
  var bk;
  while (!(bk = breaker.next()).done) {
    if (bk.value) {
      graphemes.push(bk.value.slice());
    }
  }
  return graphemes;
};
var testRangeBounds = function(document2) {
  var TEST_HEIGHT = 123;
  if (document2.createRange) {
    var range = document2.createRange();
    if (range.getBoundingClientRect) {
      var testElement = document2.createElement("boundtest");
      testElement.style.height = TEST_HEIGHT + "px";
      testElement.style.display = "block";
      document2.body.appendChild(testElement);
      range.selectNode(testElement);
      var rangeBounds = range.getBoundingClientRect();
      var rangeHeight = Math.round(rangeBounds.height);
      document2.body.removeChild(testElement);
      if (rangeHeight === TEST_HEIGHT) {
        return true;
      }
    }
  }
  return false;
};
var testIOSLineBreak = function(document2) {
  var testElement = document2.createElement("boundtest");
  testElement.style.width = "50px";
  testElement.style.display = "block";
  testElement.style.fontSize = "12px";
  testElement.style.letterSpacing = "0px";
  testElement.style.wordSpacing = "0px";
  document2.body.appendChild(testElement);
  var range = document2.createRange();
  testElement.innerHTML = typeof "".repeat === "function" ? "&#128104;".repeat(10) : "";
  var node2 = testElement.firstChild;
  var textList = toCodePoints$1(node2.data).map(function(i2) {
    return fromCodePoint$1(i2);
  });
  var offset2 = 0;
  var prev = {};
  var supports = textList.every(function(text2, i2) {
    range.setStart(node2, offset2);
    range.setEnd(node2, offset2 + text2.length);
    var rect = range.getBoundingClientRect();
    offset2 += text2.length;
    var boundAhead = rect.x > prev.x || rect.y > prev.y;
    prev = rect;
    if (i2 === 0) {
      return true;
    }
    return boundAhead;
  });
  document2.body.removeChild(testElement);
  return supports;
};
var testCORS = function() {
  return typeof new Image().crossOrigin !== "undefined";
};
var testResponseType = function() {
  return typeof new XMLHttpRequest().responseType === "string";
};
var testSVG = function(document2) {
  var img = new Image();
  var canvas = document2.createElement("canvas");
  var ctx = canvas.getContext("2d");
  if (!ctx) {
    return false;
  }
  img.src = "data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg'></svg>";
  try {
    ctx.drawImage(img, 0, 0);
    canvas.toDataURL();
  } catch (e2) {
    return false;
  }
  return true;
};
var isGreenPixel = function(data2) {
  return data2[0] === 0 && data2[1] === 255 && data2[2] === 0 && data2[3] === 255;
};
var testForeignObject = function(document2) {
  var canvas = document2.createElement("canvas");
  var size = 100;
  canvas.width = size;
  canvas.height = size;
  var ctx = canvas.getContext("2d");
  if (!ctx) {
    return Promise.reject(false);
  }
  ctx.fillStyle = "rgb(0, 255, 0)";
  ctx.fillRect(0, 0, size, size);
  var img = new Image();
  var greenImageSrc = canvas.toDataURL();
  img.src = greenImageSrc;
  var svg2 = createForeignObjectSVG(size, size, 0, 0, img);
  ctx.fillStyle = "red";
  ctx.fillRect(0, 0, size, size);
  return loadSerializedSVG$1(svg2).then(function(img2) {
    ctx.drawImage(img2, 0, 0);
    var data2 = ctx.getImageData(0, 0, size, size).data;
    ctx.fillStyle = "red";
    ctx.fillRect(0, 0, size, size);
    var node2 = document2.createElement("div");
    node2.style.backgroundImage = "url(" + greenImageSrc + ")";
    node2.style.height = size + "px";
    return isGreenPixel(data2) ? loadSerializedSVG$1(createForeignObjectSVG(size, size, 0, 0, node2)) : Promise.reject(false);
  }).then(function(img2) {
    ctx.drawImage(img2, 0, 0);
    return isGreenPixel(ctx.getImageData(0, 0, size, size).data);
  }).catch(function() {
    return false;
  });
};
var createForeignObjectSVG = function(width, height, x2, y2, node2) {
  var xmlns = "http://www.w3.org/2000/svg";
  var svg2 = document.createElementNS(xmlns, "svg");
  var foreignObject = document.createElementNS(xmlns, "foreignObject");
  svg2.setAttributeNS(null, "width", width.toString());
  svg2.setAttributeNS(null, "height", height.toString());
  foreignObject.setAttributeNS(null, "width", "100%");
  foreignObject.setAttributeNS(null, "height", "100%");
  foreignObject.setAttributeNS(null, "x", x2.toString());
  foreignObject.setAttributeNS(null, "y", y2.toString());
  foreignObject.setAttributeNS(null, "externalResourcesRequired", "true");
  svg2.appendChild(foreignObject);
  foreignObject.appendChild(node2);
  return svg2;
};
var loadSerializedSVG$1 = function(svg2) {
  return new Promise(function(resolve2, reject2) {
    var img = new Image();
    img.onload = function() {
      return resolve2(img);
    };
    img.onerror = reject2;
    img.src = "data:image/svg+xml;charset=utf-8," + encodeURIComponent(new XMLSerializer().serializeToString(svg2));
  });
};
var FEATURES = {
  get SUPPORT_RANGE_BOUNDS() {
    var value = testRangeBounds(document);
    Object.defineProperty(FEATURES, "SUPPORT_RANGE_BOUNDS", { value });
    return value;
  },
  get SUPPORT_WORD_BREAKING() {
    var value = FEATURES.SUPPORT_RANGE_BOUNDS && testIOSLineBreak(document);
    Object.defineProperty(FEATURES, "SUPPORT_WORD_BREAKING", { value });
    return value;
  },
  get SUPPORT_SVG_DRAWING() {
    var value = testSVG(document);
    Object.defineProperty(FEATURES, "SUPPORT_SVG_DRAWING", { value });
    return value;
  },
  get SUPPORT_FOREIGNOBJECT_DRAWING() {
    var value = typeof Array.from === "function" && typeof window.fetch === "function" ? testForeignObject(document) : Promise.resolve(false);
    Object.defineProperty(FEATURES, "SUPPORT_FOREIGNOBJECT_DRAWING", { value });
    return value;
  },
  get SUPPORT_CORS_IMAGES() {
    var value = testCORS();
    Object.defineProperty(FEATURES, "SUPPORT_CORS_IMAGES", { value });
    return value;
  },
  get SUPPORT_RESPONSE_TYPE() {
    var value = testResponseType();
    Object.defineProperty(FEATURES, "SUPPORT_RESPONSE_TYPE", { value });
    return value;
  },
  get SUPPORT_CORS_XHR() {
    var value = "withCredentials" in new XMLHttpRequest();
    Object.defineProperty(FEATURES, "SUPPORT_CORS_XHR", { value });
    return value;
  },
  get SUPPORT_NATIVE_TEXT_SEGMENTATION() {
    var value = !!(typeof Intl !== "undefined" && Intl.Segmenter);
    Object.defineProperty(FEATURES, "SUPPORT_NATIVE_TEXT_SEGMENTATION", { value });
    return value;
  }
};
var TextBounds = function() {
  function TextBounds2(text2, bounds) {
    this.text = text2;
    this.bounds = bounds;
  }
  return TextBounds2;
}();
var parseTextBounds = function(context, value, styles, node2) {
  var textList = breakText(value, styles);
  var textBounds = [];
  var offset2 = 0;
  textList.forEach(function(text2) {
    if (styles.textDecorationLine.length || text2.trim().length > 0) {
      if (FEATURES.SUPPORT_RANGE_BOUNDS) {
        var clientRects = createRange(node2, offset2, text2.length).getClientRects();
        if (clientRects.length > 1) {
          var subSegments = segmentGraphemes(text2);
          var subOffset_1 = 0;
          subSegments.forEach(function(subSegment) {
            textBounds.push(new TextBounds(subSegment, Bounds.fromDOMRectList(context, createRange(node2, subOffset_1 + offset2, subSegment.length).getClientRects())));
            subOffset_1 += subSegment.length;
          });
        } else {
          textBounds.push(new TextBounds(text2, Bounds.fromDOMRectList(context, clientRects)));
        }
      } else {
        var replacementNode = node2.splitText(text2.length);
        textBounds.push(new TextBounds(text2, getWrapperBounds(context, node2)));
        node2 = replacementNode;
      }
    } else if (!FEATURES.SUPPORT_RANGE_BOUNDS) {
      node2 = node2.splitText(text2.length);
    }
    offset2 += text2.length;
  });
  return textBounds;
};
var getWrapperBounds = function(context, node2) {
  var ownerDocument = node2.ownerDocument;
  if (ownerDocument) {
    var wrapper = ownerDocument.createElement("html2canvaswrapper");
    wrapper.appendChild(node2.cloneNode(true));
    var parentNode = node2.parentNode;
    if (parentNode) {
      parentNode.replaceChild(wrapper, node2);
      var bounds = parseBounds(context, wrapper);
      if (wrapper.firstChild) {
        parentNode.replaceChild(wrapper.firstChild, wrapper);
      }
      return bounds;
    }
  }
  return Bounds.EMPTY;
};
var createRange = function(node2, offset2, length) {
  var ownerDocument = node2.ownerDocument;
  if (!ownerDocument) {
    throw new Error("Node has no owner document");
  }
  var range = ownerDocument.createRange();
  range.setStart(node2, offset2);
  range.setEnd(node2, offset2 + length);
  return range;
};
var segmentGraphemes = function(value) {
  if (FEATURES.SUPPORT_NATIVE_TEXT_SEGMENTATION) {
    var segmenter = new Intl.Segmenter(void 0, { granularity: "grapheme" });
    return Array.from(segmenter.segment(value)).map(function(segment) {
      return segment.segment;
    });
  }
  return splitGraphemes(value);
};
var segmentWords = function(value, styles) {
  if (FEATURES.SUPPORT_NATIVE_TEXT_SEGMENTATION) {
    var segmenter = new Intl.Segmenter(void 0, {
      granularity: "word"
    });
    return Array.from(segmenter.segment(value)).map(function(segment) {
      return segment.segment;
    });
  }
  return breakWords(value, styles);
};
var breakText = function(value, styles) {
  return styles.letterSpacing !== 0 ? segmentGraphemes(value) : segmentWords(value, styles);
};
var wordSeparators = [32, 160, 4961, 65792, 65793, 4153, 4241];
var breakWords = function(str, styles) {
  var breaker = LineBreaker(str, {
    lineBreak: styles.lineBreak,
    wordBreak: styles.overflowWrap === "break-word" ? "break-word" : styles.wordBreak
  });
  var words = [];
  var bk;
  var _loop_1 = function() {
    if (bk.value) {
      var value = bk.value.slice();
      var codePoints = toCodePoints$1(value);
      var word_1 = "";
      codePoints.forEach(function(codePoint) {
        if (wordSeparators.indexOf(codePoint) === -1) {
          word_1 += fromCodePoint$1(codePoint);
        } else {
          if (word_1.length) {
            words.push(word_1);
          }
          words.push(fromCodePoint$1(codePoint));
          word_1 = "";
        }
      });
      if (word_1.length) {
        words.push(word_1);
      }
    }
  };
  while (!(bk = breaker.next()).done) {
    _loop_1();
  }
  return words;
};
var TextContainer = function() {
  function TextContainer2(context, node2, styles) {
    this.text = transform(node2.data, styles.textTransform);
    this.textBounds = parseTextBounds(context, this.text, styles, node2);
  }
  return TextContainer2;
}();
var transform = function(text2, transform2) {
  switch (transform2) {
    case 1:
      return text2.toLowerCase();
    case 3:
      return text2.replace(CAPITALIZE, capitalize);
    case 2:
      return text2.toUpperCase();
    default:
      return text2;
  }
};
var CAPITALIZE = /(^|\s|:|-|\(|\))([a-z])/g;
var capitalize = function(m2, p12, p22) {
  if (m2.length > 0) {
    return p12 + p22.toUpperCase();
  }
  return m2;
};
var ImageElementContainer = function(_super) {
  __extends(ImageElementContainer2, _super);
  function ImageElementContainer2(context, img) {
    var _this = _super.call(this, context, img) || this;
    _this.src = img.currentSrc || img.src;
    _this.intrinsicWidth = img.naturalWidth;
    _this.intrinsicHeight = img.naturalHeight;
    _this.context.cache.addImage(_this.src);
    return _this;
  }
  return ImageElementContainer2;
}(ElementContainer);
var CanvasElementContainer = function(_super) {
  __extends(CanvasElementContainer2, _super);
  function CanvasElementContainer2(context, canvas) {
    var _this = _super.call(this, context, canvas) || this;
    _this.canvas = canvas;
    _this.intrinsicWidth = canvas.width;
    _this.intrinsicHeight = canvas.height;
    return _this;
  }
  return CanvasElementContainer2;
}(ElementContainer);
var SVGElementContainer = function(_super) {
  __extends(SVGElementContainer2, _super);
  function SVGElementContainer2(context, img) {
    var _this = _super.call(this, context, img) || this;
    var s2 = new XMLSerializer();
    var bounds = parseBounds(context, img);
    img.setAttribute("width", bounds.width + "px");
    img.setAttribute("height", bounds.height + "px");
    _this.svg = "data:image/svg+xml," + encodeURIComponent(s2.serializeToString(img));
    _this.intrinsicWidth = img.width.baseVal.value;
    _this.intrinsicHeight = img.height.baseVal.value;
    _this.context.cache.addImage(_this.svg);
    return _this;
  }
  return SVGElementContainer2;
}(ElementContainer);
var LIElementContainer = function(_super) {
  __extends(LIElementContainer2, _super);
  function LIElementContainer2(context, element) {
    var _this = _super.call(this, context, element) || this;
    _this.value = element.value;
    return _this;
  }
  return LIElementContainer2;
}(ElementContainer);
var OLElementContainer = function(_super) {
  __extends(OLElementContainer2, _super);
  function OLElementContainer2(context, element) {
    var _this = _super.call(this, context, element) || this;
    _this.start = element.start;
    _this.reversed = typeof element.reversed === "boolean" && element.reversed === true;
    return _this;
  }
  return OLElementContainer2;
}(ElementContainer);
var CHECKBOX_BORDER_RADIUS = [
  {
    type: 15,
    flags: 0,
    unit: "px",
    number: 3
  }
];
var RADIO_BORDER_RADIUS = [
  {
    type: 16,
    flags: 0,
    number: 50
  }
];
var reformatInputBounds = function(bounds) {
  if (bounds.width > bounds.height) {
    return new Bounds(bounds.left + (bounds.width - bounds.height) / 2, bounds.top, bounds.height, bounds.height);
  } else if (bounds.width < bounds.height) {
    return new Bounds(bounds.left, bounds.top + (bounds.height - bounds.width) / 2, bounds.width, bounds.width);
  }
  return bounds;
};
var getInputValue = function(node2) {
  var value = node2.type === PASSWORD ? new Array(node2.value.length + 1).join("\u2022") : node2.value;
  return value.length === 0 ? node2.placeholder || "" : value;
};
var CHECKBOX = "checkbox";
var RADIO = "radio";
var PASSWORD = "password";
var INPUT_COLOR = 707406591;
var InputElementContainer = function(_super) {
  __extends(InputElementContainer2, _super);
  function InputElementContainer2(context, input) {
    var _this = _super.call(this, context, input) || this;
    _this.type = input.type.toLowerCase();
    _this.checked = input.checked;
    _this.value = getInputValue(input);
    if (_this.type === CHECKBOX || _this.type === RADIO) {
      _this.styles.backgroundColor = 3739148031;
      _this.styles.borderTopColor = _this.styles.borderRightColor = _this.styles.borderBottomColor = _this.styles.borderLeftColor = 2779096575;
      _this.styles.borderTopWidth = _this.styles.borderRightWidth = _this.styles.borderBottomWidth = _this.styles.borderLeftWidth = 1;
      _this.styles.borderTopStyle = _this.styles.borderRightStyle = _this.styles.borderBottomStyle = _this.styles.borderLeftStyle = 1;
      _this.styles.backgroundClip = [0];
      _this.styles.backgroundOrigin = [0];
      _this.bounds = reformatInputBounds(_this.bounds);
    }
    switch (_this.type) {
      case CHECKBOX:
        _this.styles.borderTopRightRadius = _this.styles.borderTopLeftRadius = _this.styles.borderBottomRightRadius = _this.styles.borderBottomLeftRadius = CHECKBOX_BORDER_RADIUS;
        break;
      case RADIO:
        _this.styles.borderTopRightRadius = _this.styles.borderTopLeftRadius = _this.styles.borderBottomRightRadius = _this.styles.borderBottomLeftRadius = RADIO_BORDER_RADIUS;
        break;
    }
    return _this;
  }
  return InputElementContainer2;
}(ElementContainer);
var SelectElementContainer = function(_super) {
  __extends(SelectElementContainer2, _super);
  function SelectElementContainer2(context, element) {
    var _this = _super.call(this, context, element) || this;
    var option = element.options[element.selectedIndex || 0];
    _this.value = option ? option.text || "" : "";
    return _this;
  }
  return SelectElementContainer2;
}(ElementContainer);
var TextareaElementContainer = function(_super) {
  __extends(TextareaElementContainer2, _super);
  function TextareaElementContainer2(context, element) {
    var _this = _super.call(this, context, element) || this;
    _this.value = element.value;
    return _this;
  }
  return TextareaElementContainer2;
}(ElementContainer);
var IFrameElementContainer = function(_super) {
  __extends(IFrameElementContainer2, _super);
  function IFrameElementContainer2(context, iframe) {
    var _this = _super.call(this, context, iframe) || this;
    _this.src = iframe.src;
    _this.width = parseInt(iframe.width, 10) || 0;
    _this.height = parseInt(iframe.height, 10) || 0;
    _this.backgroundColor = _this.styles.backgroundColor;
    try {
      if (iframe.contentWindow && iframe.contentWindow.document && iframe.contentWindow.document.documentElement) {
        _this.tree = parseTree(context, iframe.contentWindow.document.documentElement);
        var documentBackgroundColor = iframe.contentWindow.document.documentElement ? parseColor(context, getComputedStyle(iframe.contentWindow.document.documentElement).backgroundColor) : COLORS.TRANSPARENT;
        var bodyBackgroundColor = iframe.contentWindow.document.body ? parseColor(context, getComputedStyle(iframe.contentWindow.document.body).backgroundColor) : COLORS.TRANSPARENT;
        _this.backgroundColor = isTransparent(documentBackgroundColor) ? isTransparent(bodyBackgroundColor) ? _this.styles.backgroundColor : bodyBackgroundColor : documentBackgroundColor;
      }
    } catch (e2) {
    }
    return _this;
  }
  return IFrameElementContainer2;
}(ElementContainer);
var LIST_OWNERS = ["OL", "UL", "MENU"];
var parseNodeTree = function(context, node2, parent, root2) {
  for (var childNode = node2.firstChild, nextNode = void 0; childNode; childNode = nextNode) {
    nextNode = childNode.nextSibling;
    if (isTextNode(childNode) && childNode.data.trim().length > 0) {
      parent.textNodes.push(new TextContainer(context, childNode, parent.styles));
    } else if (isElementNode(childNode)) {
      if (isSlotElement(childNode) && childNode.assignedNodes) {
        childNode.assignedNodes().forEach(function(childNode2) {
          return parseNodeTree(context, childNode2, parent, root2);
        });
      } else {
        var container = createContainer(context, childNode);
        if (container.styles.isVisible()) {
          if (createsRealStackingContext(childNode, container, root2)) {
            container.flags |= 4;
          } else if (createsStackingContext(container.styles)) {
            container.flags |= 2;
          }
          if (LIST_OWNERS.indexOf(childNode.tagName) !== -1) {
            container.flags |= 8;
          }
          parent.elements.push(container);
          childNode.slot;
          if (childNode.shadowRoot) {
            parseNodeTree(context, childNode.shadowRoot, container, root2);
          } else if (!isTextareaElement(childNode) && !isSVGElement(childNode) && !isSelectElement(childNode)) {
            parseNodeTree(context, childNode, container, root2);
          }
        }
      }
    }
  }
};
var createContainer = function(context, element) {
  if (isImageElement(element)) {
    return new ImageElementContainer(context, element);
  }
  if (isCanvasElement(element)) {
    return new CanvasElementContainer(context, element);
  }
  if (isSVGElement(element)) {
    return new SVGElementContainer(context, element);
  }
  if (isLIElement(element)) {
    return new LIElementContainer(context, element);
  }
  if (isOLElement(element)) {
    return new OLElementContainer(context, element);
  }
  if (isInputElement(element)) {
    return new InputElementContainer(context, element);
  }
  if (isSelectElement(element)) {
    return new SelectElementContainer(context, element);
  }
  if (isTextareaElement(element)) {
    return new TextareaElementContainer(context, element);
  }
  if (isIFrameElement(element)) {
    return new IFrameElementContainer(context, element);
  }
  return new ElementContainer(context, element);
};
var parseTree = function(context, element) {
  var container = createContainer(context, element);
  container.flags |= 4;
  parseNodeTree(context, element, container, container);
  return container;
};
var createsRealStackingContext = function(node2, container, root2) {
  return container.styles.isPositionedWithZIndex() || container.styles.opacity < 1 || container.styles.isTransformed() || isBodyElement(node2) && root2.styles.isTransparent();
};
var createsStackingContext = function(styles) {
  return styles.isPositioned() || styles.isFloating();
};
var isTextNode = function(node2) {
  return node2.nodeType === Node.TEXT_NODE;
};
var isElementNode = function(node2) {
  return node2.nodeType === Node.ELEMENT_NODE;
};
var isHTMLElementNode = function(node2) {
  return isElementNode(node2) && typeof node2.style !== "undefined" && !isSVGElementNode(node2);
};
var isSVGElementNode = function(element) {
  return typeof element.className === "object";
};
var isLIElement = function(node2) {
  return node2.tagName === "LI";
};
var isOLElement = function(node2) {
  return node2.tagName === "OL";
};
var isInputElement = function(node2) {
  return node2.tagName === "INPUT";
};
var isHTMLElement = function(node2) {
  return node2.tagName === "HTML";
};
var isSVGElement = function(node2) {
  return node2.tagName === "svg";
};
var isBodyElement = function(node2) {
  return node2.tagName === "BODY";
};
var isCanvasElement = function(node2) {
  return node2.tagName === "CANVAS";
};
var isVideoElement = function(node2) {
  return node2.tagName === "VIDEO";
};
var isImageElement = function(node2) {
  return node2.tagName === "IMG";
};
var isIFrameElement = function(node2) {
  return node2.tagName === "IFRAME";
};
var isStyleElement = function(node2) {
  return node2.tagName === "STYLE";
};
var isScriptElement = function(node2) {
  return node2.tagName === "SCRIPT";
};
var isTextareaElement = function(node2) {
  return node2.tagName === "TEXTAREA";
};
var isSelectElement = function(node2) {
  return node2.tagName === "SELECT";
};
var isSlotElement = function(node2) {
  return node2.tagName === "SLOT";
};
var isCustomElement = function(node2) {
  return node2.tagName.indexOf("-") > 0;
};
var CounterState = function() {
  function CounterState2() {
    this.counters = {};
  }
  CounterState2.prototype.getCounterValue = function(name) {
    var counter2 = this.counters[name];
    if (counter2 && counter2.length) {
      return counter2[counter2.length - 1];
    }
    return 1;
  };
  CounterState2.prototype.getCounterValues = function(name) {
    var counter2 = this.counters[name];
    return counter2 ? counter2 : [];
  };
  CounterState2.prototype.pop = function(counters) {
    var _this = this;
    counters.forEach(function(counter2) {
      return _this.counters[counter2].pop();
    });
  };
  CounterState2.prototype.parse = function(style2) {
    var _this = this;
    var counterIncrement2 = style2.counterIncrement;
    var counterReset2 = style2.counterReset;
    var canReset = true;
    if (counterIncrement2 !== null) {
      counterIncrement2.forEach(function(entry) {
        var counter2 = _this.counters[entry.counter];
        if (counter2 && entry.increment !== 0) {
          canReset = false;
          if (!counter2.length) {
            counter2.push(1);
          }
          counter2[Math.max(0, counter2.length - 1)] += entry.increment;
        }
      });
    }
    var counterNames = [];
    if (canReset) {
      counterReset2.forEach(function(entry) {
        var counter2 = _this.counters[entry.counter];
        counterNames.push(entry.counter);
        if (!counter2) {
          counter2 = _this.counters[entry.counter] = [];
        }
        counter2.push(entry.reset);
      });
    }
    return counterNames;
  };
  return CounterState2;
}();
var ROMAN_UPPER = {
  integers: [1e3, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1],
  values: ["M", "CM", "D", "CD", "C", "XC", "L", "XL", "X", "IX", "V", "IV", "I"]
};
var ARMENIAN = {
  integers: [
    9e3,
    8e3,
    7e3,
    6e3,
    5e3,
    4e3,
    3e3,
    2e3,
    1e3,
    900,
    800,
    700,
    600,
    500,
    400,
    300,
    200,
    100,
    90,
    80,
    70,
    60,
    50,
    40,
    30,
    20,
    10,
    9,
    8,
    7,
    6,
    5,
    4,
    3,
    2,
    1
  ],
  values: [
    "\u0554",
    "\u0553",
    "\u0552",
    "\u0551",
    "\u0550",
    "\u054F",
    "\u054E",
    "\u054D",
    "\u054C",
    "\u054B",
    "\u054A",
    "\u0549",
    "\u0548",
    "\u0547",
    "\u0546",
    "\u0545",
    "\u0544",
    "\u0543",
    "\u0542",
    "\u0541",
    "\u0540",
    "\u053F",
    "\u053E",
    "\u053D",
    "\u053C",
    "\u053B",
    "\u053A",
    "\u0539",
    "\u0538",
    "\u0537",
    "\u0536",
    "\u0535",
    "\u0534",
    "\u0533",
    "\u0532",
    "\u0531"
  ]
};
var HEBREW = {
  integers: [
    1e4,
    9e3,
    8e3,
    7e3,
    6e3,
    5e3,
    4e3,
    3e3,
    2e3,
    1e3,
    400,
    300,
    200,
    100,
    90,
    80,
    70,
    60,
    50,
    40,
    30,
    20,
    19,
    18,
    17,
    16,
    15,
    10,
    9,
    8,
    7,
    6,
    5,
    4,
    3,
    2,
    1
  ],
  values: [
    "\u05D9\u05F3",
    "\u05D8\u05F3",
    "\u05D7\u05F3",
    "\u05D6\u05F3",
    "\u05D5\u05F3",
    "\u05D4\u05F3",
    "\u05D3\u05F3",
    "\u05D2\u05F3",
    "\u05D1\u05F3",
    "\u05D0\u05F3",
    "\u05EA",
    "\u05E9",
    "\u05E8",
    "\u05E7",
    "\u05E6",
    "\u05E4",
    "\u05E2",
    "\u05E1",
    "\u05E0",
    "\u05DE",
    "\u05DC",
    "\u05DB",
    "\u05D9\u05D8",
    "\u05D9\u05D7",
    "\u05D9\u05D6",
    "\u05D8\u05D6",
    "\u05D8\u05D5",
    "\u05D9",
    "\u05D8",
    "\u05D7",
    "\u05D6",
    "\u05D5",
    "\u05D4",
    "\u05D3",
    "\u05D2",
    "\u05D1",
    "\u05D0"
  ]
};
var GEORGIAN = {
  integers: [
    1e4,
    9e3,
    8e3,
    7e3,
    6e3,
    5e3,
    4e3,
    3e3,
    2e3,
    1e3,
    900,
    800,
    700,
    600,
    500,
    400,
    300,
    200,
    100,
    90,
    80,
    70,
    60,
    50,
    40,
    30,
    20,
    10,
    9,
    8,
    7,
    6,
    5,
    4,
    3,
    2,
    1
  ],
  values: [
    "\u10F5",
    "\u10F0",
    "\u10EF",
    "\u10F4",
    "\u10EE",
    "\u10ED",
    "\u10EC",
    "\u10EB",
    "\u10EA",
    "\u10E9",
    "\u10E8",
    "\u10E7",
    "\u10E6",
    "\u10E5",
    "\u10E4",
    "\u10F3",
    "\u10E2",
    "\u10E1",
    "\u10E0",
    "\u10DF",
    "\u10DE",
    "\u10DD",
    "\u10F2",
    "\u10DC",
    "\u10DB",
    "\u10DA",
    "\u10D9",
    "\u10D8",
    "\u10D7",
    "\u10F1",
    "\u10D6",
    "\u10D5",
    "\u10D4",
    "\u10D3",
    "\u10D2",
    "\u10D1",
    "\u10D0"
  ]
};
var createAdditiveCounter = function(value, min2, max2, symbols, fallback, suffix2) {
  if (value < min2 || value > max2) {
    return createCounterText(value, fallback, suffix2.length > 0);
  }
  return symbols.integers.reduce(function(string, integer, index2) {
    while (value >= integer) {
      value -= integer;
      string += symbols.values[index2];
    }
    return string;
  }, "") + suffix2;
};
var createCounterStyleWithSymbolResolver = function(value, codePointRangeLength, isNumeric, resolver) {
  var string = "";
  do {
    if (!isNumeric) {
      value--;
    }
    string = resolver(value) + string;
    value /= codePointRangeLength;
  } while (value * codePointRangeLength >= codePointRangeLength);
  return string;
};
var createCounterStyleFromRange = function(value, codePointRangeStart, codePointRangeEnd, isNumeric, suffix2) {
  var codePointRangeLength = codePointRangeEnd - codePointRangeStart + 1;
  return (value < 0 ? "-" : "") + (createCounterStyleWithSymbolResolver(Math.abs(value), codePointRangeLength, isNumeric, function(codePoint) {
    return fromCodePoint$1(Math.floor(codePoint % codePointRangeLength) + codePointRangeStart);
  }) + suffix2);
};
var createCounterStyleFromSymbols = function(value, symbols, suffix2) {
  if (suffix2 === void 0) {
    suffix2 = ". ";
  }
  var codePointRangeLength = symbols.length;
  return createCounterStyleWithSymbolResolver(Math.abs(value), codePointRangeLength, false, function(codePoint) {
    return symbols[Math.floor(codePoint % codePointRangeLength)];
  }) + suffix2;
};
var CJK_ZEROS = 1 << 0;
var CJK_TEN_COEFFICIENTS = 1 << 1;
var CJK_TEN_HIGH_COEFFICIENTS = 1 << 2;
var CJK_HUNDRED_COEFFICIENTS = 1 << 3;
var createCJKCounter = function(value, numbers, multipliers, negativeSign, suffix2, flags) {
  if (value < -9999 || value > 9999) {
    return createCounterText(value, 4, suffix2.length > 0);
  }
  var tmp = Math.abs(value);
  var string = suffix2;
  if (tmp === 0) {
    return numbers[0] + string;
  }
  for (var digit = 0; tmp > 0 && digit <= 4; digit++) {
    var coefficient = tmp % 10;
    if (coefficient === 0 && contains(flags, CJK_ZEROS) && string !== "") {
      string = numbers[coefficient] + string;
    } else if (coefficient > 1 || coefficient === 1 && digit === 0 || coefficient === 1 && digit === 1 && contains(flags, CJK_TEN_COEFFICIENTS) || coefficient === 1 && digit === 1 && contains(flags, CJK_TEN_HIGH_COEFFICIENTS) && value > 100 || coefficient === 1 && digit > 1 && contains(flags, CJK_HUNDRED_COEFFICIENTS)) {
      string = numbers[coefficient] + (digit > 0 ? multipliers[digit - 1] : "") + string;
    } else if (coefficient === 1 && digit > 0) {
      string = multipliers[digit - 1] + string;
    }
    tmp = Math.floor(tmp / 10);
  }
  return (value < 0 ? negativeSign : "") + string;
};
var CHINESE_INFORMAL_MULTIPLIERS = "\u5341\u767E\u5343\u842C";
var CHINESE_FORMAL_MULTIPLIERS = "\u62FE\u4F70\u4EDF\u842C";
var JAPANESE_NEGATIVE = "\u30DE\u30A4\u30CA\u30B9";
var KOREAN_NEGATIVE = "\uB9C8\uC774\uB108\uC2A4";
var createCounterText = function(value, type, appendSuffix) {
  var defaultSuffix = appendSuffix ? ". " : "";
  var cjkSuffix = appendSuffix ? "\u3001" : "";
  var koreanSuffix = appendSuffix ? ", " : "";
  var spaceSuffix = appendSuffix ? " " : "";
  switch (type) {
    case 0:
      return "\u2022" + spaceSuffix;
    case 1:
      return "\u25E6" + spaceSuffix;
    case 2:
      return "\u25FE" + spaceSuffix;
    case 5:
      var string = createCounterStyleFromRange(value, 48, 57, true, defaultSuffix);
      return string.length < 4 ? "0" + string : string;
    case 4:
      return createCounterStyleFromSymbols(value, "\u3007\u4E00\u4E8C\u4E09\u56DB\u4E94\u516D\u4E03\u516B\u4E5D", cjkSuffix);
    case 6:
      return createAdditiveCounter(value, 1, 3999, ROMAN_UPPER, 3, defaultSuffix).toLowerCase();
    case 7:
      return createAdditiveCounter(value, 1, 3999, ROMAN_UPPER, 3, defaultSuffix);
    case 8:
      return createCounterStyleFromRange(value, 945, 969, false, defaultSuffix);
    case 9:
      return createCounterStyleFromRange(value, 97, 122, false, defaultSuffix);
    case 10:
      return createCounterStyleFromRange(value, 65, 90, false, defaultSuffix);
    case 11:
      return createCounterStyleFromRange(value, 1632, 1641, true, defaultSuffix);
    case 12:
    case 49:
      return createAdditiveCounter(value, 1, 9999, ARMENIAN, 3, defaultSuffix);
    case 35:
      return createAdditiveCounter(value, 1, 9999, ARMENIAN, 3, defaultSuffix).toLowerCase();
    case 13:
      return createCounterStyleFromRange(value, 2534, 2543, true, defaultSuffix);
    case 14:
    case 30:
      return createCounterStyleFromRange(value, 6112, 6121, true, defaultSuffix);
    case 15:
      return createCounterStyleFromSymbols(value, "\u5B50\u4E11\u5BC5\u536F\u8FB0\u5DF3\u5348\u672A\u7533\u9149\u620C\u4EA5", cjkSuffix);
    case 16:
      return createCounterStyleFromSymbols(value, "\u7532\u4E59\u4E19\u4E01\u620A\u5DF1\u5E9A\u8F9B\u58EC\u7678", cjkSuffix);
    case 17:
    case 48:
      return createCJKCounter(value, "\u96F6\u4E00\u4E8C\u4E09\u56DB\u4E94\u516D\u4E03\u516B\u4E5D", CHINESE_INFORMAL_MULTIPLIERS, "\u8CA0", cjkSuffix, CJK_TEN_COEFFICIENTS | CJK_TEN_HIGH_COEFFICIENTS | CJK_HUNDRED_COEFFICIENTS);
    case 47:
      return createCJKCounter(value, "\u96F6\u58F9\u8CB3\u53C3\u8086\u4F0D\u9678\u67D2\u634C\u7396", CHINESE_FORMAL_MULTIPLIERS, "\u8CA0", cjkSuffix, CJK_ZEROS | CJK_TEN_COEFFICIENTS | CJK_TEN_HIGH_COEFFICIENTS | CJK_HUNDRED_COEFFICIENTS);
    case 42:
      return createCJKCounter(value, "\u96F6\u4E00\u4E8C\u4E09\u56DB\u4E94\u516D\u4E03\u516B\u4E5D", CHINESE_INFORMAL_MULTIPLIERS, "\u8D1F", cjkSuffix, CJK_TEN_COEFFICIENTS | CJK_TEN_HIGH_COEFFICIENTS | CJK_HUNDRED_COEFFICIENTS);
    case 41:
      return createCJKCounter(value, "\u96F6\u58F9\u8D30\u53C1\u8086\u4F0D\u9646\u67D2\u634C\u7396", CHINESE_FORMAL_MULTIPLIERS, "\u8D1F", cjkSuffix, CJK_ZEROS | CJK_TEN_COEFFICIENTS | CJK_TEN_HIGH_COEFFICIENTS | CJK_HUNDRED_COEFFICIENTS);
    case 26:
      return createCJKCounter(value, "\u3007\u4E00\u4E8C\u4E09\u56DB\u4E94\u516D\u4E03\u516B\u4E5D", "\u5341\u767E\u5343\u4E07", JAPANESE_NEGATIVE, cjkSuffix, 0);
    case 25:
      return createCJKCounter(value, "\u96F6\u58F1\u5F10\u53C2\u56DB\u4F0D\u516D\u4E03\u516B\u4E5D", "\u62FE\u767E\u5343\u4E07", JAPANESE_NEGATIVE, cjkSuffix, CJK_ZEROS | CJK_TEN_COEFFICIENTS | CJK_TEN_HIGH_COEFFICIENTS);
    case 31:
      return createCJKCounter(value, "\uC601\uC77C\uC774\uC0BC\uC0AC\uC624\uC721\uCE60\uD314\uAD6C", "\uC2ED\uBC31\uCC9C\uB9CC", KOREAN_NEGATIVE, koreanSuffix, CJK_ZEROS | CJK_TEN_COEFFICIENTS | CJK_TEN_HIGH_COEFFICIENTS);
    case 33:
      return createCJKCounter(value, "\u96F6\u4E00\u4E8C\u4E09\u56DB\u4E94\u516D\u4E03\u516B\u4E5D", "\u5341\u767E\u5343\u842C", KOREAN_NEGATIVE, koreanSuffix, 0);
    case 32:
      return createCJKCounter(value, "\u96F6\u58F9\u8CB3\u53C3\u56DB\u4E94\u516D\u4E03\u516B\u4E5D", "\u62FE\u767E\u5343", KOREAN_NEGATIVE, koreanSuffix, CJK_ZEROS | CJK_TEN_COEFFICIENTS | CJK_TEN_HIGH_COEFFICIENTS);
    case 18:
      return createCounterStyleFromRange(value, 2406, 2415, true, defaultSuffix);
    case 20:
      return createAdditiveCounter(value, 1, 19999, GEORGIAN, 3, defaultSuffix);
    case 21:
      return createCounterStyleFromRange(value, 2790, 2799, true, defaultSuffix);
    case 22:
      return createCounterStyleFromRange(value, 2662, 2671, true, defaultSuffix);
    case 22:
      return createAdditiveCounter(value, 1, 10999, HEBREW, 3, defaultSuffix);
    case 23:
      return createCounterStyleFromSymbols(value, "\u3042\u3044\u3046\u3048\u304A\u304B\u304D\u304F\u3051\u3053\u3055\u3057\u3059\u305B\u305D\u305F\u3061\u3064\u3066\u3068\u306A\u306B\u306C\u306D\u306E\u306F\u3072\u3075\u3078\u307B\u307E\u307F\u3080\u3081\u3082\u3084\u3086\u3088\u3089\u308A\u308B\u308C\u308D\u308F\u3090\u3091\u3092\u3093");
    case 24:
      return createCounterStyleFromSymbols(value, "\u3044\u308D\u306F\u306B\u307B\u3078\u3068\u3061\u308A\u306C\u308B\u3092\u308F\u304B\u3088\u305F\u308C\u305D\u3064\u306D\u306A\u3089\u3080\u3046\u3090\u306E\u304A\u304F\u3084\u307E\u3051\u3075\u3053\u3048\u3066\u3042\u3055\u304D\u3086\u3081\u307F\u3057\u3091\u3072\u3082\u305B\u3059");
    case 27:
      return createCounterStyleFromRange(value, 3302, 3311, true, defaultSuffix);
    case 28:
      return createCounterStyleFromSymbols(value, "\u30A2\u30A4\u30A6\u30A8\u30AA\u30AB\u30AD\u30AF\u30B1\u30B3\u30B5\u30B7\u30B9\u30BB\u30BD\u30BF\u30C1\u30C4\u30C6\u30C8\u30CA\u30CB\u30CC\u30CD\u30CE\u30CF\u30D2\u30D5\u30D8\u30DB\u30DE\u30DF\u30E0\u30E1\u30E2\u30E4\u30E6\u30E8\u30E9\u30EA\u30EB\u30EC\u30ED\u30EF\u30F0\u30F1\u30F2\u30F3", cjkSuffix);
    case 29:
      return createCounterStyleFromSymbols(value, "\u30A4\u30ED\u30CF\u30CB\u30DB\u30D8\u30C8\u30C1\u30EA\u30CC\u30EB\u30F2\u30EF\u30AB\u30E8\u30BF\u30EC\u30BD\u30C4\u30CD\u30CA\u30E9\u30E0\u30A6\u30F0\u30CE\u30AA\u30AF\u30E4\u30DE\u30B1\u30D5\u30B3\u30A8\u30C6\u30A2\u30B5\u30AD\u30E6\u30E1\u30DF\u30B7\u30F1\u30D2\u30E2\u30BB\u30B9", cjkSuffix);
    case 34:
      return createCounterStyleFromRange(value, 3792, 3801, true, defaultSuffix);
    case 37:
      return createCounterStyleFromRange(value, 6160, 6169, true, defaultSuffix);
    case 38:
      return createCounterStyleFromRange(value, 4160, 4169, true, defaultSuffix);
    case 39:
      return createCounterStyleFromRange(value, 2918, 2927, true, defaultSuffix);
    case 40:
      return createCounterStyleFromRange(value, 1776, 1785, true, defaultSuffix);
    case 43:
      return createCounterStyleFromRange(value, 3046, 3055, true, defaultSuffix);
    case 44:
      return createCounterStyleFromRange(value, 3174, 3183, true, defaultSuffix);
    case 45:
      return createCounterStyleFromRange(value, 3664, 3673, true, defaultSuffix);
    case 46:
      return createCounterStyleFromRange(value, 3872, 3881, true, defaultSuffix);
    case 3:
    default:
      return createCounterStyleFromRange(value, 48, 57, true, defaultSuffix);
  }
};
var IGNORE_ATTRIBUTE = "data-html2canvas-ignore";
var DocumentCloner = function() {
  function DocumentCloner2(context, element, options) {
    this.context = context;
    this.options = options;
    this.scrolledElements = [];
    this.referenceElement = element;
    this.counters = new CounterState();
    this.quoteDepth = 0;
    if (!element.ownerDocument) {
      throw new Error("Cloned element does not have an owner document");
    }
    this.documentElement = this.cloneNode(element.ownerDocument.documentElement, false);
  }
  DocumentCloner2.prototype.toIFrame = function(ownerDocument, windowSize) {
    var _this = this;
    var iframe = createIFrameContainer(ownerDocument, windowSize);
    if (!iframe.contentWindow) {
      return Promise.reject("Unable to find iframe window");
    }
    var scrollX = ownerDocument.defaultView.pageXOffset;
    var scrollY = ownerDocument.defaultView.pageYOffset;
    var cloneWindow = iframe.contentWindow;
    var documentClone = cloneWindow.document;
    var iframeLoad = iframeLoader(iframe).then(function() {
      return __awaiter(_this, void 0, void 0, function() {
        var onclone, referenceElement;
        return __generator(this, function(_a2) {
          switch (_a2.label) {
            case 0:
              this.scrolledElements.forEach(restoreNodeScroll);
              if (cloneWindow) {
                cloneWindow.scrollTo(windowSize.left, windowSize.top);
                if (/(iPad|iPhone|iPod)/g.test(navigator.userAgent) && (cloneWindow.scrollY !== windowSize.top || cloneWindow.scrollX !== windowSize.left)) {
                  this.context.logger.warn("Unable to restore scroll position for cloned document");
                  this.context.windowBounds = this.context.windowBounds.add(cloneWindow.scrollX - windowSize.left, cloneWindow.scrollY - windowSize.top, 0, 0);
                }
              }
              onclone = this.options.onclone;
              referenceElement = this.clonedReferenceElement;
              if (typeof referenceElement === "undefined") {
                return [2, Promise.reject("Error finding the " + this.referenceElement.nodeName + " in the cloned document")];
              }
              if (!(documentClone.fonts && documentClone.fonts.ready))
                return [3, 2];
              return [4, documentClone.fonts.ready];
            case 1:
              _a2.sent();
              _a2.label = 2;
            case 2:
              if (!/(AppleWebKit)/g.test(navigator.userAgent))
                return [3, 4];
              return [4, imagesReady(documentClone)];
            case 3:
              _a2.sent();
              _a2.label = 4;
            case 4:
              if (typeof onclone === "function") {
                return [2, Promise.resolve().then(function() {
                  return onclone(documentClone, referenceElement);
                }).then(function() {
                  return iframe;
                })];
              }
              return [2, iframe];
          }
        });
      });
    });
    documentClone.open();
    documentClone.write(serializeDoctype(document.doctype) + "<html></html>");
    restoreOwnerScroll(this.referenceElement.ownerDocument, scrollX, scrollY);
    documentClone.replaceChild(documentClone.adoptNode(this.documentElement), documentClone.documentElement);
    documentClone.close();
    return iframeLoad;
  };
  DocumentCloner2.prototype.createElementClone = function(node2) {
    if (isDebugging(node2, 2)) {
      debugger;
    }
    if (isCanvasElement(node2)) {
      return this.createCanvasClone(node2);
    }
    if (isVideoElement(node2)) {
      return this.createVideoClone(node2);
    }
    if (isStyleElement(node2)) {
      return this.createStyleClone(node2);
    }
    var clone2 = node2.cloneNode(false);
    if (isImageElement(clone2)) {
      if (isImageElement(node2) && node2.currentSrc && node2.currentSrc !== node2.src) {
        clone2.src = node2.currentSrc;
        clone2.srcset = "";
      }
      if (clone2.loading === "lazy") {
        clone2.loading = "eager";
      }
    }
    if (isCustomElement(clone2)) {
      return this.createCustomElementClone(clone2);
    }
    return clone2;
  };
  DocumentCloner2.prototype.createCustomElementClone = function(node2) {
    var clone2 = document.createElement("html2canvascustomelement");
    copyCSSStyles(node2.style, clone2);
    return clone2;
  };
  DocumentCloner2.prototype.createStyleClone = function(node2) {
    try {
      var sheet = node2.sheet;
      if (sheet && sheet.cssRules) {
        var css = [].slice.call(sheet.cssRules, 0).reduce(function(css2, rule) {
          if (rule && typeof rule.cssText === "string") {
            return css2 + rule.cssText;
          }
          return css2;
        }, "");
        var style2 = node2.cloneNode(false);
        style2.textContent = css;
        return style2;
      }
    } catch (e2) {
      this.context.logger.error("Unable to access cssRules property", e2);
      if (e2.name !== "SecurityError") {
        throw e2;
      }
    }
    return node2.cloneNode(false);
  };
  DocumentCloner2.prototype.createCanvasClone = function(canvas) {
    var _a2;
    if (this.options.inlineImages && canvas.ownerDocument) {
      var img = canvas.ownerDocument.createElement("img");
      try {
        img.src = canvas.toDataURL();
        return img;
      } catch (e2) {
        this.context.logger.info("Unable to inline canvas contents, canvas is tainted", canvas);
      }
    }
    var clonedCanvas = canvas.cloneNode(false);
    try {
      clonedCanvas.width = canvas.width;
      clonedCanvas.height = canvas.height;
      var ctx = canvas.getContext("2d");
      var clonedCtx = clonedCanvas.getContext("2d");
      if (clonedCtx) {
        if (!this.options.allowTaint && ctx) {
          clonedCtx.putImageData(ctx.getImageData(0, 0, canvas.width, canvas.height), 0, 0);
        } else {
          var gl = (_a2 = canvas.getContext("webgl2")) !== null && _a2 !== void 0 ? _a2 : canvas.getContext("webgl");
          if (gl) {
            var attribs = gl.getContextAttributes();
            if ((attribs === null || attribs === void 0 ? void 0 : attribs.preserveDrawingBuffer) === false) {
              this.context.logger.warn("Unable to clone WebGL context as it has preserveDrawingBuffer=false", canvas);
            }
          }
          clonedCtx.drawImage(canvas, 0, 0);
        }
      }
      return clonedCanvas;
    } catch (e2) {
      this.context.logger.info("Unable to clone canvas as it is tainted", canvas);
    }
    return clonedCanvas;
  };
  DocumentCloner2.prototype.createVideoClone = function(video) {
    var canvas = video.ownerDocument.createElement("canvas");
    canvas.width = video.offsetWidth;
    canvas.height = video.offsetHeight;
    var ctx = canvas.getContext("2d");
    try {
      if (ctx) {
        ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
        if (!this.options.allowTaint) {
          ctx.getImageData(0, 0, canvas.width, canvas.height);
        }
      }
      return canvas;
    } catch (e2) {
      this.context.logger.info("Unable to clone video as it is tainted", video);
    }
    var blankCanvas = video.ownerDocument.createElement("canvas");
    blankCanvas.width = video.offsetWidth;
    blankCanvas.height = video.offsetHeight;
    return blankCanvas;
  };
  DocumentCloner2.prototype.appendChildNode = function(clone2, child, copyStyles) {
    if (!isElementNode(child) || !isScriptElement(child) && !child.hasAttribute(IGNORE_ATTRIBUTE) && (typeof this.options.ignoreElements !== "function" || !this.options.ignoreElements(child))) {
      if (!this.options.copyStyles || !isElementNode(child) || !isStyleElement(child)) {
        clone2.appendChild(this.cloneNode(child, copyStyles));
      }
    }
  };
  DocumentCloner2.prototype.cloneChildNodes = function(node2, clone2, copyStyles) {
    var _this = this;
    for (var child = node2.shadowRoot ? node2.shadowRoot.firstChild : node2.firstChild; child; child = child.nextSibling) {
      if (isElementNode(child) && isSlotElement(child) && typeof child.assignedNodes === "function") {
        var assignedNodes = child.assignedNodes();
        if (assignedNodes.length) {
          assignedNodes.forEach(function(assignedNode) {
            return _this.appendChildNode(clone2, assignedNode, copyStyles);
          });
        }
      } else {
        this.appendChildNode(clone2, child, copyStyles);
      }
    }
  };
  DocumentCloner2.prototype.cloneNode = function(node2, copyStyles) {
    if (isTextNode(node2)) {
      return document.createTextNode(node2.data);
    }
    if (!node2.ownerDocument) {
      return node2.cloneNode(false);
    }
    var window2 = node2.ownerDocument.defaultView;
    if (window2 && isElementNode(node2) && (isHTMLElementNode(node2) || isSVGElementNode(node2))) {
      var clone2 = this.createElementClone(node2);
      clone2.style.transitionProperty = "none";
      var style2 = window2.getComputedStyle(node2);
      var styleBefore = window2.getComputedStyle(node2, ":before");
      var styleAfter = window2.getComputedStyle(node2, ":after");
      if (this.referenceElement === node2 && isHTMLElementNode(clone2)) {
        this.clonedReferenceElement = clone2;
      }
      if (isBodyElement(clone2)) {
        createPseudoHideStyles(clone2);
      }
      var counters = this.counters.parse(new CSSParsedCounterDeclaration(this.context, style2));
      var before = this.resolvePseudoContent(node2, clone2, styleBefore, PseudoElementType.BEFORE);
      if (isCustomElement(node2)) {
        copyStyles = true;
      }
      if (!isVideoElement(node2)) {
        this.cloneChildNodes(node2, clone2, copyStyles);
      }
      if (before) {
        clone2.insertBefore(before, clone2.firstChild);
      }
      var after = this.resolvePseudoContent(node2, clone2, styleAfter, PseudoElementType.AFTER);
      if (after) {
        clone2.appendChild(after);
      }
      this.counters.pop(counters);
      if (style2 && (this.options.copyStyles || isSVGElementNode(node2)) && !isIFrameElement(node2) || copyStyles) {
        copyCSSStyles(style2, clone2);
      }
      if (node2.scrollTop !== 0 || node2.scrollLeft !== 0) {
        this.scrolledElements.push([clone2, node2.scrollLeft, node2.scrollTop]);
      }
      if ((isTextareaElement(node2) || isSelectElement(node2)) && (isTextareaElement(clone2) || isSelectElement(clone2))) {
        clone2.value = node2.value;
      }
      return clone2;
    }
    return node2.cloneNode(false);
  };
  DocumentCloner2.prototype.resolvePseudoContent = function(node2, clone2, style2, pseudoElt) {
    var _this = this;
    if (!style2) {
      return;
    }
    var value = style2.content;
    var document2 = clone2.ownerDocument;
    if (!document2 || !value || value === "none" || value === "-moz-alt-content" || style2.display === "none") {
      return;
    }
    this.counters.parse(new CSSParsedCounterDeclaration(this.context, style2));
    var declaration = new CSSParsedPseudoDeclaration(this.context, style2);
    var anonymousReplacedElement = document2.createElement("html2canvaspseudoelement");
    copyCSSStyles(style2, anonymousReplacedElement);
    declaration.content.forEach(function(token) {
      if (token.type === 0) {
        anonymousReplacedElement.appendChild(document2.createTextNode(token.value));
      } else if (token.type === 22) {
        var img = document2.createElement("img");
        img.src = token.value;
        img.style.opacity = "1";
        anonymousReplacedElement.appendChild(img);
      } else if (token.type === 18) {
        if (token.name === "attr") {
          var attr = token.values.filter(isIdentToken);
          if (attr.length) {
            anonymousReplacedElement.appendChild(document2.createTextNode(node2.getAttribute(attr[0].value) || ""));
          }
        } else if (token.name === "counter") {
          var _a2 = token.values.filter(nonFunctionArgSeparator), counter2 = _a2[0], counterStyle = _a2[1];
          if (counter2 && isIdentToken(counter2)) {
            var counterState = _this.counters.getCounterValue(counter2.value);
            var counterType = counterStyle && isIdentToken(counterStyle) ? listStyleType.parse(_this.context, counterStyle.value) : 3;
            anonymousReplacedElement.appendChild(document2.createTextNode(createCounterText(counterState, counterType, false)));
          }
        } else if (token.name === "counters") {
          var _b2 = token.values.filter(nonFunctionArgSeparator), counter2 = _b2[0], delim = _b2[1], counterStyle = _b2[2];
          if (counter2 && isIdentToken(counter2)) {
            var counterStates = _this.counters.getCounterValues(counter2.value);
            var counterType_1 = counterStyle && isIdentToken(counterStyle) ? listStyleType.parse(_this.context, counterStyle.value) : 3;
            var separator = delim && delim.type === 0 ? delim.value : "";
            var text2 = counterStates.map(function(value2) {
              return createCounterText(value2, counterType_1, false);
            }).join(separator);
            anonymousReplacedElement.appendChild(document2.createTextNode(text2));
          }
        } else
          ;
      } else if (token.type === 20) {
        switch (token.value) {
          case "open-quote":
            anonymousReplacedElement.appendChild(document2.createTextNode(getQuote(declaration.quotes, _this.quoteDepth++, true)));
            break;
          case "close-quote":
            anonymousReplacedElement.appendChild(document2.createTextNode(getQuote(declaration.quotes, --_this.quoteDepth, false)));
            break;
          default:
            anonymousReplacedElement.appendChild(document2.createTextNode(token.value));
        }
      }
    });
    anonymousReplacedElement.className = PSEUDO_HIDE_ELEMENT_CLASS_BEFORE + " " + PSEUDO_HIDE_ELEMENT_CLASS_AFTER;
    var newClassName = pseudoElt === PseudoElementType.BEFORE ? " " + PSEUDO_HIDE_ELEMENT_CLASS_BEFORE : " " + PSEUDO_HIDE_ELEMENT_CLASS_AFTER;
    if (isSVGElementNode(clone2)) {
      clone2.className.baseValue += newClassName;
    } else {
      clone2.className += newClassName;
    }
    return anonymousReplacedElement;
  };
  DocumentCloner2.destroy = function(container) {
    if (container.parentNode) {
      container.parentNode.removeChild(container);
      return true;
    }
    return false;
  };
  return DocumentCloner2;
}();
var PseudoElementType;
(function(PseudoElementType2) {
  PseudoElementType2[PseudoElementType2["BEFORE"] = 0] = "BEFORE";
  PseudoElementType2[PseudoElementType2["AFTER"] = 1] = "AFTER";
})(PseudoElementType || (PseudoElementType = {}));
var createIFrameContainer = function(ownerDocument, bounds) {
  var cloneIframeContainer = ownerDocument.createElement("iframe");
  cloneIframeContainer.className = "html2canvas-container";
  cloneIframeContainer.style.visibility = "hidden";
  cloneIframeContainer.style.position = "fixed";
  cloneIframeContainer.style.left = "-10000px";
  cloneIframeContainer.style.top = "0px";
  cloneIframeContainer.style.border = "0";
  cloneIframeContainer.width = bounds.width.toString();
  cloneIframeContainer.height = bounds.height.toString();
  cloneIframeContainer.scrolling = "no";
  cloneIframeContainer.setAttribute(IGNORE_ATTRIBUTE, "true");
  ownerDocument.body.appendChild(cloneIframeContainer);
  return cloneIframeContainer;
};
var imageReady = function(img) {
  return new Promise(function(resolve2) {
    if (img.complete) {
      resolve2();
      return;
    }
    if (!img.src) {
      resolve2();
      return;
    }
    img.onload = resolve2;
    img.onerror = resolve2;
  });
};
var imagesReady = function(document2) {
  return Promise.all([].slice.call(document2.images, 0).map(imageReady));
};
var iframeLoader = function(iframe) {
  return new Promise(function(resolve2, reject2) {
    var cloneWindow = iframe.contentWindow;
    if (!cloneWindow) {
      return reject2("No window assigned for iframe");
    }
    var documentClone = cloneWindow.document;
    cloneWindow.onload = iframe.onload = function() {
      cloneWindow.onload = iframe.onload = null;
      var interval = setInterval(function() {
        if (documentClone.body.childNodes.length > 0 && documentClone.readyState === "complete") {
          clearInterval(interval);
          resolve2(iframe);
        }
      }, 50);
    };
  });
};
var ignoredStyleProperties = [
  "all",
  "d",
  "content"
];
var copyCSSStyles = function(style2, target) {
  for (var i2 = style2.length - 1; i2 >= 0; i2--) {
    var property = style2.item(i2);
    if (ignoredStyleProperties.indexOf(property) === -1) {
      target.style.setProperty(property, style2.getPropertyValue(property));
    }
  }
  return target;
};
var serializeDoctype = function(doctype) {
  var str = "";
  if (doctype) {
    str += "<!DOCTYPE ";
    if (doctype.name) {
      str += doctype.name;
    }
    if (doctype.internalSubset) {
      str += doctype.internalSubset;
    }
    if (doctype.publicId) {
      str += '"' + doctype.publicId + '"';
    }
    if (doctype.systemId) {
      str += '"' + doctype.systemId + '"';
    }
    str += ">";
  }
  return str;
};
var restoreOwnerScroll = function(ownerDocument, x2, y2) {
  if (ownerDocument && ownerDocument.defaultView && (x2 !== ownerDocument.defaultView.pageXOffset || y2 !== ownerDocument.defaultView.pageYOffset)) {
    ownerDocument.defaultView.scrollTo(x2, y2);
  }
};
var restoreNodeScroll = function(_a2) {
  var element = _a2[0], x2 = _a2[1], y2 = _a2[2];
  element.scrollLeft = x2;
  element.scrollTop = y2;
};
var PSEUDO_BEFORE = ":before";
var PSEUDO_AFTER = ":after";
var PSEUDO_HIDE_ELEMENT_CLASS_BEFORE = "___html2canvas___pseudoelement_before";
var PSEUDO_HIDE_ELEMENT_CLASS_AFTER = "___html2canvas___pseudoelement_after";
var PSEUDO_HIDE_ELEMENT_STYLE = '{\n    content: "" !important;\n    display: none !important;\n}';
var createPseudoHideStyles = function(body) {
  createStyles(body, "." + PSEUDO_HIDE_ELEMENT_CLASS_BEFORE + PSEUDO_BEFORE + PSEUDO_HIDE_ELEMENT_STYLE + "\n         ." + PSEUDO_HIDE_ELEMENT_CLASS_AFTER + PSEUDO_AFTER + PSEUDO_HIDE_ELEMENT_STYLE);
};
var createStyles = function(body, styles) {
  var document2 = body.ownerDocument;
  if (document2) {
    var style2 = document2.createElement("style");
    style2.textContent = styles;
    body.appendChild(style2);
  }
};
var CacheStorage = function() {
  function CacheStorage2() {
  }
  CacheStorage2.getOrigin = function(url) {
    var link = CacheStorage2._link;
    if (!link) {
      return "about:blank";
    }
    link.href = url;
    link.href = link.href;
    return link.protocol + link.hostname + link.port;
  };
  CacheStorage2.isSameOrigin = function(src) {
    return CacheStorage2.getOrigin(src) === CacheStorage2._origin;
  };
  CacheStorage2.setContext = function(window2) {
    CacheStorage2._link = window2.document.createElement("a");
    CacheStorage2._origin = CacheStorage2.getOrigin(window2.location.href);
  };
  CacheStorage2._origin = "about:blank";
  return CacheStorage2;
}();
var Cache = function() {
  function Cache2(context, _options) {
    this.context = context;
    this._options = _options;
    this._cache = {};
  }
  Cache2.prototype.addImage = function(src) {
    var result = Promise.resolve();
    if (this.has(src)) {
      return result;
    }
    if (isBlobImage(src) || isRenderable(src)) {
      (this._cache[src] = this.loadImage(src)).catch(function() {
      });
      return result;
    }
    return result;
  };
  Cache2.prototype.match = function(src) {
    return this._cache[src];
  };
  Cache2.prototype.loadImage = function(key) {
    return __awaiter(this, void 0, void 0, function() {
      var isSameOrigin, useCORS, useProxy, src;
      var _this = this;
      return __generator(this, function(_a2) {
        switch (_a2.label) {
          case 0:
            isSameOrigin = CacheStorage.isSameOrigin(key);
            useCORS = !isInlineImage(key) && this._options.useCORS === true && FEATURES.SUPPORT_CORS_IMAGES && !isSameOrigin;
            useProxy = !isInlineImage(key) && !isSameOrigin && !isBlobImage(key) && typeof this._options.proxy === "string" && FEATURES.SUPPORT_CORS_XHR && !useCORS;
            if (!isSameOrigin && this._options.allowTaint === false && !isInlineImage(key) && !isBlobImage(key) && !useProxy && !useCORS) {
              return [2];
            }
            src = key;
            if (!useProxy)
              return [3, 2];
            return [4, this.proxy(src)];
          case 1:
            src = _a2.sent();
            _a2.label = 2;
          case 2:
            this.context.logger.debug("Added image " + key.substring(0, 256));
            return [4, new Promise(function(resolve2, reject2) {
              var img = new Image();
              img.onload = function() {
                return resolve2(img);
              };
              img.onerror = reject2;
              if (isInlineBase64Image(src) || useCORS) {
                img.crossOrigin = "anonymous";
              }
              img.src = src;
              if (img.complete === true) {
                setTimeout(function() {
                  return resolve2(img);
                }, 500);
              }
              if (_this._options.imageTimeout > 0) {
                setTimeout(function() {
                  return reject2("Timed out (" + _this._options.imageTimeout + "ms) loading image");
                }, _this._options.imageTimeout);
              }
            })];
          case 3:
            return [2, _a2.sent()];
        }
      });
    });
  };
  Cache2.prototype.has = function(key) {
    return typeof this._cache[key] !== "undefined";
  };
  Cache2.prototype.keys = function() {
    return Promise.resolve(Object.keys(this._cache));
  };
  Cache2.prototype.proxy = function(src) {
    var _this = this;
    var proxy = this._options.proxy;
    if (!proxy) {
      throw new Error("No proxy defined");
    }
    var key = src.substring(0, 256);
    return new Promise(function(resolve2, reject2) {
      var responseType = FEATURES.SUPPORT_RESPONSE_TYPE ? "blob" : "text";
      var xhr2 = new XMLHttpRequest();
      xhr2.onload = function() {
        if (xhr2.status === 200) {
          if (responseType === "text") {
            resolve2(xhr2.response);
          } else {
            var reader_1 = new FileReader();
            reader_1.addEventListener("load", function() {
              return resolve2(reader_1.result);
            }, false);
            reader_1.addEventListener("error", function(e2) {
              return reject2(e2);
            }, false);
            reader_1.readAsDataURL(xhr2.response);
          }
        } else {
          reject2("Failed to proxy resource " + key + " with status code " + xhr2.status);
        }
      };
      xhr2.onerror = reject2;
      var queryString = proxy.indexOf("?") > -1 ? "&" : "?";
      xhr2.open("GET", "" + proxy + queryString + "url=" + encodeURIComponent(src) + "&responseType=" + responseType);
      if (responseType !== "text" && xhr2 instanceof XMLHttpRequest) {
        xhr2.responseType = responseType;
      }
      if (_this._options.imageTimeout) {
        var timeout_1 = _this._options.imageTimeout;
        xhr2.timeout = timeout_1;
        xhr2.ontimeout = function() {
          return reject2("Timed out (" + timeout_1 + "ms) proxying " + key);
        };
      }
      xhr2.send();
    });
  };
  return Cache2;
}();
var INLINE_SVG = /^data:image\/svg\+xml/i;
var INLINE_BASE64 = /^data:image\/.*;base64,/i;
var INLINE_IMG = /^data:image\/.*/i;
var isRenderable = function(src) {
  return FEATURES.SUPPORT_SVG_DRAWING || !isSVG(src);
};
var isInlineImage = function(src) {
  return INLINE_IMG.test(src);
};
var isInlineBase64Image = function(src) {
  return INLINE_BASE64.test(src);
};
var isBlobImage = function(src) {
  return src.substr(0, 4) === "blob";
};
var isSVG = function(src) {
  return src.substr(-3).toLowerCase() === "svg" || INLINE_SVG.test(src);
};
var Vector = function() {
  function Vector2(x2, y2) {
    this.type = 0;
    this.x = x2;
    this.y = y2;
  }
  Vector2.prototype.add = function(deltaX, deltaY) {
    return new Vector2(this.x + deltaX, this.y + deltaY);
  };
  return Vector2;
}();
var lerp = function(a2, b2, t3) {
  return new Vector(a2.x + (b2.x - a2.x) * t3, a2.y + (b2.y - a2.y) * t3);
};
var BezierCurve = function() {
  function BezierCurve2(start2, startControl, endControl, end) {
    this.type = 1;
    this.start = start2;
    this.startControl = startControl;
    this.endControl = endControl;
    this.end = end;
  }
  BezierCurve2.prototype.subdivide = function(t3, firstHalf) {
    var ab = lerp(this.start, this.startControl, t3);
    var bc = lerp(this.startControl, this.endControl, t3);
    var cd = lerp(this.endControl, this.end, t3);
    var abbc = lerp(ab, bc, t3);
    var bccd = lerp(bc, cd, t3);
    var dest = lerp(abbc, bccd, t3);
    return firstHalf ? new BezierCurve2(this.start, ab, abbc, dest) : new BezierCurve2(dest, bccd, cd, this.end);
  };
  BezierCurve2.prototype.add = function(deltaX, deltaY) {
    return new BezierCurve2(this.start.add(deltaX, deltaY), this.startControl.add(deltaX, deltaY), this.endControl.add(deltaX, deltaY), this.end.add(deltaX, deltaY));
  };
  BezierCurve2.prototype.reverse = function() {
    return new BezierCurve2(this.end, this.endControl, this.startControl, this.start);
  };
  return BezierCurve2;
}();
var isBezierCurve = function(path) {
  return path.type === 1;
};
var BoundCurves = function() {
  function BoundCurves2(element) {
    var styles = element.styles;
    var bounds = element.bounds;
    var _a2 = getAbsoluteValueForTuple(styles.borderTopLeftRadius, bounds.width, bounds.height), tlh = _a2[0], tlv = _a2[1];
    var _b2 = getAbsoluteValueForTuple(styles.borderTopRightRadius, bounds.width, bounds.height), trh = _b2[0], trv = _b2[1];
    var _c = getAbsoluteValueForTuple(styles.borderBottomRightRadius, bounds.width, bounds.height), brh = _c[0], brv = _c[1];
    var _d = getAbsoluteValueForTuple(styles.borderBottomLeftRadius, bounds.width, bounds.height), blh = _d[0], blv = _d[1];
    var factors = [];
    factors.push((tlh + trh) / bounds.width);
    factors.push((blh + brh) / bounds.width);
    factors.push((tlv + blv) / bounds.height);
    factors.push((trv + brv) / bounds.height);
    var maxFactor = Math.max.apply(Math, factors);
    if (maxFactor > 1) {
      tlh /= maxFactor;
      tlv /= maxFactor;
      trh /= maxFactor;
      trv /= maxFactor;
      brh /= maxFactor;
      brv /= maxFactor;
      blh /= maxFactor;
      blv /= maxFactor;
    }
    var topWidth = bounds.width - trh;
    var rightHeight = bounds.height - brv;
    var bottomWidth = bounds.width - brh;
    var leftHeight = bounds.height - blv;
    var borderTopWidth2 = styles.borderTopWidth;
    var borderRightWidth2 = styles.borderRightWidth;
    var borderBottomWidth2 = styles.borderBottomWidth;
    var borderLeftWidth2 = styles.borderLeftWidth;
    var paddingTop2 = getAbsoluteValue(styles.paddingTop, element.bounds.width);
    var paddingRight2 = getAbsoluteValue(styles.paddingRight, element.bounds.width);
    var paddingBottom2 = getAbsoluteValue(styles.paddingBottom, element.bounds.width);
    var paddingLeft2 = getAbsoluteValue(styles.paddingLeft, element.bounds.width);
    this.topLeftBorderDoubleOuterBox = tlh > 0 || tlv > 0 ? getCurvePoints(bounds.left + borderLeftWidth2 / 3, bounds.top + borderTopWidth2 / 3, tlh - borderLeftWidth2 / 3, tlv - borderTopWidth2 / 3, CORNER.TOP_LEFT) : new Vector(bounds.left + borderLeftWidth2 / 3, bounds.top + borderTopWidth2 / 3);
    this.topRightBorderDoubleOuterBox = tlh > 0 || tlv > 0 ? getCurvePoints(bounds.left + topWidth, bounds.top + borderTopWidth2 / 3, trh - borderRightWidth2 / 3, trv - borderTopWidth2 / 3, CORNER.TOP_RIGHT) : new Vector(bounds.left + bounds.width - borderRightWidth2 / 3, bounds.top + borderTopWidth2 / 3);
    this.bottomRightBorderDoubleOuterBox = brh > 0 || brv > 0 ? getCurvePoints(bounds.left + bottomWidth, bounds.top + rightHeight, brh - borderRightWidth2 / 3, brv - borderBottomWidth2 / 3, CORNER.BOTTOM_RIGHT) : new Vector(bounds.left + bounds.width - borderRightWidth2 / 3, bounds.top + bounds.height - borderBottomWidth2 / 3);
    this.bottomLeftBorderDoubleOuterBox = blh > 0 || blv > 0 ? getCurvePoints(bounds.left + borderLeftWidth2 / 3, bounds.top + leftHeight, blh - borderLeftWidth2 / 3, blv - borderBottomWidth2 / 3, CORNER.BOTTOM_LEFT) : new Vector(bounds.left + borderLeftWidth2 / 3, bounds.top + bounds.height - borderBottomWidth2 / 3);
    this.topLeftBorderDoubleInnerBox = tlh > 0 || tlv > 0 ? getCurvePoints(bounds.left + borderLeftWidth2 * 2 / 3, bounds.top + borderTopWidth2 * 2 / 3, tlh - borderLeftWidth2 * 2 / 3, tlv - borderTopWidth2 * 2 / 3, CORNER.TOP_LEFT) : new Vector(bounds.left + borderLeftWidth2 * 2 / 3, bounds.top + borderTopWidth2 * 2 / 3);
    this.topRightBorderDoubleInnerBox = tlh > 0 || tlv > 0 ? getCurvePoints(bounds.left + topWidth, bounds.top + borderTopWidth2 * 2 / 3, trh - borderRightWidth2 * 2 / 3, trv - borderTopWidth2 * 2 / 3, CORNER.TOP_RIGHT) : new Vector(bounds.left + bounds.width - borderRightWidth2 * 2 / 3, bounds.top + borderTopWidth2 * 2 / 3);
    this.bottomRightBorderDoubleInnerBox = brh > 0 || brv > 0 ? getCurvePoints(bounds.left + bottomWidth, bounds.top + rightHeight, brh - borderRightWidth2 * 2 / 3, brv - borderBottomWidth2 * 2 / 3, CORNER.BOTTOM_RIGHT) : new Vector(bounds.left + bounds.width - borderRightWidth2 * 2 / 3, bounds.top + bounds.height - borderBottomWidth2 * 2 / 3);
    this.bottomLeftBorderDoubleInnerBox = blh > 0 || blv > 0 ? getCurvePoints(bounds.left + borderLeftWidth2 * 2 / 3, bounds.top + leftHeight, blh - borderLeftWidth2 * 2 / 3, blv - borderBottomWidth2 * 2 / 3, CORNER.BOTTOM_LEFT) : new Vector(bounds.left + borderLeftWidth2 * 2 / 3, bounds.top + bounds.height - borderBottomWidth2 * 2 / 3);
    this.topLeftBorderStroke = tlh > 0 || tlv > 0 ? getCurvePoints(bounds.left + borderLeftWidth2 / 2, bounds.top + borderTopWidth2 / 2, tlh - borderLeftWidth2 / 2, tlv - borderTopWidth2 / 2, CORNER.TOP_LEFT) : new Vector(bounds.left + borderLeftWidth2 / 2, bounds.top + borderTopWidth2 / 2);
    this.topRightBorderStroke = tlh > 0 || tlv > 0 ? getCurvePoints(bounds.left + topWidth, bounds.top + borderTopWidth2 / 2, trh - borderRightWidth2 / 2, trv - borderTopWidth2 / 2, CORNER.TOP_RIGHT) : new Vector(bounds.left + bounds.width - borderRightWidth2 / 2, bounds.top + borderTopWidth2 / 2);
    this.bottomRightBorderStroke = brh > 0 || brv > 0 ? getCurvePoints(bounds.left + bottomWidth, bounds.top + rightHeight, brh - borderRightWidth2 / 2, brv - borderBottomWidth2 / 2, CORNER.BOTTOM_RIGHT) : new Vector(bounds.left + bounds.width - borderRightWidth2 / 2, bounds.top + bounds.height - borderBottomWidth2 / 2);
    this.bottomLeftBorderStroke = blh > 0 || blv > 0 ? getCurvePoints(bounds.left + borderLeftWidth2 / 2, bounds.top + leftHeight, blh - borderLeftWidth2 / 2, blv - borderBottomWidth2 / 2, CORNER.BOTTOM_LEFT) : new Vector(bounds.left + borderLeftWidth2 / 2, bounds.top + bounds.height - borderBottomWidth2 / 2);
    this.topLeftBorderBox = tlh > 0 || tlv > 0 ? getCurvePoints(bounds.left, bounds.top, tlh, tlv, CORNER.TOP_LEFT) : new Vector(bounds.left, bounds.top);
    this.topRightBorderBox = trh > 0 || trv > 0 ? getCurvePoints(bounds.left + topWidth, bounds.top, trh, trv, CORNER.TOP_RIGHT) : new Vector(bounds.left + bounds.width, bounds.top);
    this.bottomRightBorderBox = brh > 0 || brv > 0 ? getCurvePoints(bounds.left + bottomWidth, bounds.top + rightHeight, brh, brv, CORNER.BOTTOM_RIGHT) : new Vector(bounds.left + bounds.width, bounds.top + bounds.height);
    this.bottomLeftBorderBox = blh > 0 || blv > 0 ? getCurvePoints(bounds.left, bounds.top + leftHeight, blh, blv, CORNER.BOTTOM_LEFT) : new Vector(bounds.left, bounds.top + bounds.height);
    this.topLeftPaddingBox = tlh > 0 || tlv > 0 ? getCurvePoints(bounds.left + borderLeftWidth2, bounds.top + borderTopWidth2, Math.max(0, tlh - borderLeftWidth2), Math.max(0, tlv - borderTopWidth2), CORNER.TOP_LEFT) : new Vector(bounds.left + borderLeftWidth2, bounds.top + borderTopWidth2);
    this.topRightPaddingBox = trh > 0 || trv > 0 ? getCurvePoints(bounds.left + Math.min(topWidth, bounds.width - borderRightWidth2), bounds.top + borderTopWidth2, topWidth > bounds.width + borderRightWidth2 ? 0 : Math.max(0, trh - borderRightWidth2), Math.max(0, trv - borderTopWidth2), CORNER.TOP_RIGHT) : new Vector(bounds.left + bounds.width - borderRightWidth2, bounds.top + borderTopWidth2);
    this.bottomRightPaddingBox = brh > 0 || brv > 0 ? getCurvePoints(bounds.left + Math.min(bottomWidth, bounds.width - borderLeftWidth2), bounds.top + Math.min(rightHeight, bounds.height - borderBottomWidth2), Math.max(0, brh - borderRightWidth2), Math.max(0, brv - borderBottomWidth2), CORNER.BOTTOM_RIGHT) : new Vector(bounds.left + bounds.width - borderRightWidth2, bounds.top + bounds.height - borderBottomWidth2);
    this.bottomLeftPaddingBox = blh > 0 || blv > 0 ? getCurvePoints(bounds.left + borderLeftWidth2, bounds.top + Math.min(leftHeight, bounds.height - borderBottomWidth2), Math.max(0, blh - borderLeftWidth2), Math.max(0, blv - borderBottomWidth2), CORNER.BOTTOM_LEFT) : new Vector(bounds.left + borderLeftWidth2, bounds.top + bounds.height - borderBottomWidth2);
    this.topLeftContentBox = tlh > 0 || tlv > 0 ? getCurvePoints(bounds.left + borderLeftWidth2 + paddingLeft2, bounds.top + borderTopWidth2 + paddingTop2, Math.max(0, tlh - (borderLeftWidth2 + paddingLeft2)), Math.max(0, tlv - (borderTopWidth2 + paddingTop2)), CORNER.TOP_LEFT) : new Vector(bounds.left + borderLeftWidth2 + paddingLeft2, bounds.top + borderTopWidth2 + paddingTop2);
    this.topRightContentBox = trh > 0 || trv > 0 ? getCurvePoints(bounds.left + Math.min(topWidth, bounds.width + borderLeftWidth2 + paddingLeft2), bounds.top + borderTopWidth2 + paddingTop2, topWidth > bounds.width + borderLeftWidth2 + paddingLeft2 ? 0 : trh - borderLeftWidth2 + paddingLeft2, trv - (borderTopWidth2 + paddingTop2), CORNER.TOP_RIGHT) : new Vector(bounds.left + bounds.width - (borderRightWidth2 + paddingRight2), bounds.top + borderTopWidth2 + paddingTop2);
    this.bottomRightContentBox = brh > 0 || brv > 0 ? getCurvePoints(bounds.left + Math.min(bottomWidth, bounds.width - (borderLeftWidth2 + paddingLeft2)), bounds.top + Math.min(rightHeight, bounds.height + borderTopWidth2 + paddingTop2), Math.max(0, brh - (borderRightWidth2 + paddingRight2)), brv - (borderBottomWidth2 + paddingBottom2), CORNER.BOTTOM_RIGHT) : new Vector(bounds.left + bounds.width - (borderRightWidth2 + paddingRight2), bounds.top + bounds.height - (borderBottomWidth2 + paddingBottom2));
    this.bottomLeftContentBox = blh > 0 || blv > 0 ? getCurvePoints(bounds.left + borderLeftWidth2 + paddingLeft2, bounds.top + leftHeight, Math.max(0, blh - (borderLeftWidth2 + paddingLeft2)), blv - (borderBottomWidth2 + paddingBottom2), CORNER.BOTTOM_LEFT) : new Vector(bounds.left + borderLeftWidth2 + paddingLeft2, bounds.top + bounds.height - (borderBottomWidth2 + paddingBottom2));
  }
  return BoundCurves2;
}();
var CORNER;
(function(CORNER2) {
  CORNER2[CORNER2["TOP_LEFT"] = 0] = "TOP_LEFT";
  CORNER2[CORNER2["TOP_RIGHT"] = 1] = "TOP_RIGHT";
  CORNER2[CORNER2["BOTTOM_RIGHT"] = 2] = "BOTTOM_RIGHT";
  CORNER2[CORNER2["BOTTOM_LEFT"] = 3] = "BOTTOM_LEFT";
})(CORNER || (CORNER = {}));
var getCurvePoints = function(x2, y2, r1, r2, position2) {
  var kappa = 4 * ((Math.sqrt(2) - 1) / 3);
  var ox = r1 * kappa;
  var oy = r2 * kappa;
  var xm = x2 + r1;
  var ym = y2 + r2;
  switch (position2) {
    case CORNER.TOP_LEFT:
      return new BezierCurve(new Vector(x2, ym), new Vector(x2, ym - oy), new Vector(xm - ox, y2), new Vector(xm, y2));
    case CORNER.TOP_RIGHT:
      return new BezierCurve(new Vector(x2, y2), new Vector(x2 + ox, y2), new Vector(xm, ym - oy), new Vector(xm, ym));
    case CORNER.BOTTOM_RIGHT:
      return new BezierCurve(new Vector(xm, y2), new Vector(xm, y2 + oy), new Vector(x2 + ox, ym), new Vector(x2, ym));
    case CORNER.BOTTOM_LEFT:
    default:
      return new BezierCurve(new Vector(xm, ym), new Vector(xm - ox, ym), new Vector(x2, y2 + oy), new Vector(x2, y2));
  }
};
var calculateBorderBoxPath = function(curves) {
  return [curves.topLeftBorderBox, curves.topRightBorderBox, curves.bottomRightBorderBox, curves.bottomLeftBorderBox];
};
var calculateContentBoxPath = function(curves) {
  return [
    curves.topLeftContentBox,
    curves.topRightContentBox,
    curves.bottomRightContentBox,
    curves.bottomLeftContentBox
  ];
};
var calculatePaddingBoxPath = function(curves) {
  return [
    curves.topLeftPaddingBox,
    curves.topRightPaddingBox,
    curves.bottomRightPaddingBox,
    curves.bottomLeftPaddingBox
  ];
};
var TransformEffect = function() {
  function TransformEffect2(offsetX, offsetY, matrix2) {
    this.offsetX = offsetX;
    this.offsetY = offsetY;
    this.matrix = matrix2;
    this.type = 0;
    this.target = 2 | 4;
  }
  return TransformEffect2;
}();
var ClipEffect = function() {
  function ClipEffect2(path, target) {
    this.path = path;
    this.target = target;
    this.type = 1;
  }
  return ClipEffect2;
}();
var OpacityEffect = function() {
  function OpacityEffect2(opacity2) {
    this.opacity = opacity2;
    this.type = 2;
    this.target = 2 | 4;
  }
  return OpacityEffect2;
}();
var isTransformEffect = function(effect) {
  return effect.type === 0;
};
var isClipEffect = function(effect) {
  return effect.type === 1;
};
var isOpacityEffect = function(effect) {
  return effect.type === 2;
};
var equalPath = function(a2, b2) {
  if (a2.length === b2.length) {
    return a2.some(function(v2, i2) {
      return v2 === b2[i2];
    });
  }
  return false;
};
var transformPath = function(path, deltaX, deltaY, deltaW, deltaH) {
  return path.map(function(point, index2) {
    switch (index2) {
      case 0:
        return point.add(deltaX, deltaY);
      case 1:
        return point.add(deltaX + deltaW, deltaY);
      case 2:
        return point.add(deltaX + deltaW, deltaY + deltaH);
      case 3:
        return point.add(deltaX, deltaY + deltaH);
    }
    return point;
  });
};
var StackingContext = function() {
  function StackingContext2(container) {
    this.element = container;
    this.inlineLevel = [];
    this.nonInlineLevel = [];
    this.negativeZIndex = [];
    this.zeroOrAutoZIndexOrTransformedOrOpacity = [];
    this.positiveZIndex = [];
    this.nonPositionedFloats = [];
    this.nonPositionedInlineLevel = [];
  }
  return StackingContext2;
}();
var ElementPaint = function() {
  function ElementPaint2(container, parent) {
    this.container = container;
    this.parent = parent;
    this.effects = [];
    this.curves = new BoundCurves(this.container);
    if (this.container.styles.opacity < 1) {
      this.effects.push(new OpacityEffect(this.container.styles.opacity));
    }
    if (this.container.styles.transform !== null) {
      var offsetX = this.container.bounds.left + this.container.styles.transformOrigin[0].number;
      var offsetY = this.container.bounds.top + this.container.styles.transformOrigin[1].number;
      var matrix2 = this.container.styles.transform;
      this.effects.push(new TransformEffect(offsetX, offsetY, matrix2));
    }
    if (this.container.styles.overflowX !== 0) {
      var borderBox = calculateBorderBoxPath(this.curves);
      var paddingBox2 = calculatePaddingBoxPath(this.curves);
      if (equalPath(borderBox, paddingBox2)) {
        this.effects.push(new ClipEffect(borderBox, 2 | 4));
      } else {
        this.effects.push(new ClipEffect(borderBox, 2));
        this.effects.push(new ClipEffect(paddingBox2, 4));
      }
    }
  }
  ElementPaint2.prototype.getEffects = function(target) {
    var inFlow = [2, 3].indexOf(this.container.styles.position) === -1;
    var parent = this.parent;
    var effects = this.effects.slice(0);
    while (parent) {
      var croplessEffects = parent.effects.filter(function(effect) {
        return !isClipEffect(effect);
      });
      if (inFlow || parent.container.styles.position !== 0 || !parent.parent) {
        effects.unshift.apply(effects, croplessEffects);
        inFlow = [2, 3].indexOf(parent.container.styles.position) === -1;
        if (parent.container.styles.overflowX !== 0) {
          var borderBox = calculateBorderBoxPath(parent.curves);
          var paddingBox2 = calculatePaddingBoxPath(parent.curves);
          if (!equalPath(borderBox, paddingBox2)) {
            effects.unshift(new ClipEffect(paddingBox2, 2 | 4));
          }
        }
      } else {
        effects.unshift.apply(effects, croplessEffects);
      }
      parent = parent.parent;
    }
    return effects.filter(function(effect) {
      return contains(effect.target, target);
    });
  };
  return ElementPaint2;
}();
var parseStackTree = function(parent, stackingContext, realStackingContext, listItems) {
  parent.container.elements.forEach(function(child) {
    var treatAsRealStackingContext = contains(child.flags, 4);
    var createsStackingContext2 = contains(child.flags, 2);
    var paintContainer = new ElementPaint(child, parent);
    if (contains(child.styles.display, 2048)) {
      listItems.push(paintContainer);
    }
    var listOwnerItems = contains(child.flags, 8) ? [] : listItems;
    if (treatAsRealStackingContext || createsStackingContext2) {
      var parentStack = treatAsRealStackingContext || child.styles.isPositioned() ? realStackingContext : stackingContext;
      var stack = new StackingContext(paintContainer);
      if (child.styles.isPositioned() || child.styles.opacity < 1 || child.styles.isTransformed()) {
        var order_1 = child.styles.zIndex.order;
        if (order_1 < 0) {
          var index_1 = 0;
          parentStack.negativeZIndex.some(function(current, i2) {
            if (order_1 > current.element.container.styles.zIndex.order) {
              index_1 = i2;
              return false;
            } else if (index_1 > 0) {
              return true;
            }
            return false;
          });
          parentStack.negativeZIndex.splice(index_1, 0, stack);
        } else if (order_1 > 0) {
          var index_2 = 0;
          parentStack.positiveZIndex.some(function(current, i2) {
            if (order_1 >= current.element.container.styles.zIndex.order) {
              index_2 = i2 + 1;
              return false;
            } else if (index_2 > 0) {
              return true;
            }
            return false;
          });
          parentStack.positiveZIndex.splice(index_2, 0, stack);
        } else {
          parentStack.zeroOrAutoZIndexOrTransformedOrOpacity.push(stack);
        }
      } else {
        if (child.styles.isFloating()) {
          parentStack.nonPositionedFloats.push(stack);
        } else {
          parentStack.nonPositionedInlineLevel.push(stack);
        }
      }
      parseStackTree(paintContainer, stack, treatAsRealStackingContext ? stack : realStackingContext, listOwnerItems);
    } else {
      if (child.styles.isInlineLevel()) {
        stackingContext.inlineLevel.push(paintContainer);
      } else {
        stackingContext.nonInlineLevel.push(paintContainer);
      }
      parseStackTree(paintContainer, stackingContext, realStackingContext, listOwnerItems);
    }
    if (contains(child.flags, 8)) {
      processListItems(child, listOwnerItems);
    }
  });
};
var processListItems = function(owner, elements2) {
  var numbering = owner instanceof OLElementContainer ? owner.start : 1;
  var reversed = owner instanceof OLElementContainer ? owner.reversed : false;
  for (var i2 = 0; i2 < elements2.length; i2++) {
    var item = elements2[i2];
    if (item.container instanceof LIElementContainer && typeof item.container.value === "number" && item.container.value !== 0) {
      numbering = item.container.value;
    }
    item.listValue = createCounterText(numbering, item.container.styles.listStyleType, true);
    numbering += reversed ? -1 : 1;
  }
};
var parseStackingContexts = function(container) {
  var paintContainer = new ElementPaint(container, null);
  var root2 = new StackingContext(paintContainer);
  var listItems = [];
  parseStackTree(paintContainer, root2, root2, listItems);
  processListItems(paintContainer.container, listItems);
  return root2;
};
var parsePathForBorder = function(curves, borderSide) {
  switch (borderSide) {
    case 0:
      return createPathFromCurves(curves.topLeftBorderBox, curves.topLeftPaddingBox, curves.topRightBorderBox, curves.topRightPaddingBox);
    case 1:
      return createPathFromCurves(curves.topRightBorderBox, curves.topRightPaddingBox, curves.bottomRightBorderBox, curves.bottomRightPaddingBox);
    case 2:
      return createPathFromCurves(curves.bottomRightBorderBox, curves.bottomRightPaddingBox, curves.bottomLeftBorderBox, curves.bottomLeftPaddingBox);
    case 3:
    default:
      return createPathFromCurves(curves.bottomLeftBorderBox, curves.bottomLeftPaddingBox, curves.topLeftBorderBox, curves.topLeftPaddingBox);
  }
};
var parsePathForBorderDoubleOuter = function(curves, borderSide) {
  switch (borderSide) {
    case 0:
      return createPathFromCurves(curves.topLeftBorderBox, curves.topLeftBorderDoubleOuterBox, curves.topRightBorderBox, curves.topRightBorderDoubleOuterBox);
    case 1:
      return createPathFromCurves(curves.topRightBorderBox, curves.topRightBorderDoubleOuterBox, curves.bottomRightBorderBox, curves.bottomRightBorderDoubleOuterBox);
    case 2:
      return createPathFromCurves(curves.bottomRightBorderBox, curves.bottomRightBorderDoubleOuterBox, curves.bottomLeftBorderBox, curves.bottomLeftBorderDoubleOuterBox);
    case 3:
    default:
      return createPathFromCurves(curves.bottomLeftBorderBox, curves.bottomLeftBorderDoubleOuterBox, curves.topLeftBorderBox, curves.topLeftBorderDoubleOuterBox);
  }
};
var parsePathForBorderDoubleInner = function(curves, borderSide) {
  switch (borderSide) {
    case 0:
      return createPathFromCurves(curves.topLeftBorderDoubleInnerBox, curves.topLeftPaddingBox, curves.topRightBorderDoubleInnerBox, curves.topRightPaddingBox);
    case 1:
      return createPathFromCurves(curves.topRightBorderDoubleInnerBox, curves.topRightPaddingBox, curves.bottomRightBorderDoubleInnerBox, curves.bottomRightPaddingBox);
    case 2:
      return createPathFromCurves(curves.bottomRightBorderDoubleInnerBox, curves.bottomRightPaddingBox, curves.bottomLeftBorderDoubleInnerBox, curves.bottomLeftPaddingBox);
    case 3:
    default:
      return createPathFromCurves(curves.bottomLeftBorderDoubleInnerBox, curves.bottomLeftPaddingBox, curves.topLeftBorderDoubleInnerBox, curves.topLeftPaddingBox);
  }
};
var parsePathForBorderStroke = function(curves, borderSide) {
  switch (borderSide) {
    case 0:
      return createStrokePathFromCurves(curves.topLeftBorderStroke, curves.topRightBorderStroke);
    case 1:
      return createStrokePathFromCurves(curves.topRightBorderStroke, curves.bottomRightBorderStroke);
    case 2:
      return createStrokePathFromCurves(curves.bottomRightBorderStroke, curves.bottomLeftBorderStroke);
    case 3:
    default:
      return createStrokePathFromCurves(curves.bottomLeftBorderStroke, curves.topLeftBorderStroke);
  }
};
var createStrokePathFromCurves = function(outer1, outer2) {
  var path = [];
  if (isBezierCurve(outer1)) {
    path.push(outer1.subdivide(0.5, false));
  } else {
    path.push(outer1);
  }
  if (isBezierCurve(outer2)) {
    path.push(outer2.subdivide(0.5, true));
  } else {
    path.push(outer2);
  }
  return path;
};
var createPathFromCurves = function(outer1, inner1, outer2, inner2) {
  var path = [];
  if (isBezierCurve(outer1)) {
    path.push(outer1.subdivide(0.5, false));
  } else {
    path.push(outer1);
  }
  if (isBezierCurve(outer2)) {
    path.push(outer2.subdivide(0.5, true));
  } else {
    path.push(outer2);
  }
  if (isBezierCurve(inner2)) {
    path.push(inner2.subdivide(0.5, true).reverse());
  } else {
    path.push(inner2);
  }
  if (isBezierCurve(inner1)) {
    path.push(inner1.subdivide(0.5, false).reverse());
  } else {
    path.push(inner1);
  }
  return path;
};
var paddingBox = function(element) {
  var bounds = element.bounds;
  var styles = element.styles;
  return bounds.add(styles.borderLeftWidth, styles.borderTopWidth, -(styles.borderRightWidth + styles.borderLeftWidth), -(styles.borderTopWidth + styles.borderBottomWidth));
};
var contentBox = function(element) {
  var styles = element.styles;
  var bounds = element.bounds;
  var paddingLeft2 = getAbsoluteValue(styles.paddingLeft, bounds.width);
  var paddingRight2 = getAbsoluteValue(styles.paddingRight, bounds.width);
  var paddingTop2 = getAbsoluteValue(styles.paddingTop, bounds.width);
  var paddingBottom2 = getAbsoluteValue(styles.paddingBottom, bounds.width);
  return bounds.add(paddingLeft2 + styles.borderLeftWidth, paddingTop2 + styles.borderTopWidth, -(styles.borderRightWidth + styles.borderLeftWidth + paddingLeft2 + paddingRight2), -(styles.borderTopWidth + styles.borderBottomWidth + paddingTop2 + paddingBottom2));
};
var calculateBackgroundPositioningArea = function(backgroundOrigin2, element) {
  if (backgroundOrigin2 === 0) {
    return element.bounds;
  }
  if (backgroundOrigin2 === 2) {
    return contentBox(element);
  }
  return paddingBox(element);
};
var calculateBackgroundPaintingArea = function(backgroundClip2, element) {
  if (backgroundClip2 === 0) {
    return element.bounds;
  }
  if (backgroundClip2 === 2) {
    return contentBox(element);
  }
  return paddingBox(element);
};
var calculateBackgroundRendering = function(container, index2, intrinsicSize) {
  var backgroundPositioningArea = calculateBackgroundPositioningArea(getBackgroundValueForIndex(container.styles.backgroundOrigin, index2), container);
  var backgroundPaintingArea = calculateBackgroundPaintingArea(getBackgroundValueForIndex(container.styles.backgroundClip, index2), container);
  var backgroundImageSize = calculateBackgroundSize(getBackgroundValueForIndex(container.styles.backgroundSize, index2), intrinsicSize, backgroundPositioningArea);
  var sizeWidth = backgroundImageSize[0], sizeHeight = backgroundImageSize[1];
  var position2 = getAbsoluteValueForTuple(getBackgroundValueForIndex(container.styles.backgroundPosition, index2), backgroundPositioningArea.width - sizeWidth, backgroundPositioningArea.height - sizeHeight);
  var path = calculateBackgroundRepeatPath(getBackgroundValueForIndex(container.styles.backgroundRepeat, index2), position2, backgroundImageSize, backgroundPositioningArea, backgroundPaintingArea);
  var offsetX = Math.round(backgroundPositioningArea.left + position2[0]);
  var offsetY = Math.round(backgroundPositioningArea.top + position2[1]);
  return [path, offsetX, offsetY, sizeWidth, sizeHeight];
};
var isAuto = function(token) {
  return isIdentToken(token) && token.value === BACKGROUND_SIZE.AUTO;
};
var hasIntrinsicValue = function(value) {
  return typeof value === "number";
};
var calculateBackgroundSize = function(size, _a2, bounds) {
  var intrinsicWidth = _a2[0], intrinsicHeight = _a2[1], intrinsicProportion = _a2[2];
  var first = size[0], second = size[1];
  if (!first) {
    return [0, 0];
  }
  if (isLengthPercentage(first) && second && isLengthPercentage(second)) {
    return [getAbsoluteValue(first, bounds.width), getAbsoluteValue(second, bounds.height)];
  }
  var hasIntrinsicProportion = hasIntrinsicValue(intrinsicProportion);
  if (isIdentToken(first) && (first.value === BACKGROUND_SIZE.CONTAIN || first.value === BACKGROUND_SIZE.COVER)) {
    if (hasIntrinsicValue(intrinsicProportion)) {
      var targetRatio = bounds.width / bounds.height;
      return targetRatio < intrinsicProportion !== (first.value === BACKGROUND_SIZE.COVER) ? [bounds.width, bounds.width / intrinsicProportion] : [bounds.height * intrinsicProportion, bounds.height];
    }
    return [bounds.width, bounds.height];
  }
  var hasIntrinsicWidth = hasIntrinsicValue(intrinsicWidth);
  var hasIntrinsicHeight = hasIntrinsicValue(intrinsicHeight);
  var hasIntrinsicDimensions = hasIntrinsicWidth || hasIntrinsicHeight;
  if (isAuto(first) && (!second || isAuto(second))) {
    if (hasIntrinsicWidth && hasIntrinsicHeight) {
      return [intrinsicWidth, intrinsicHeight];
    }
    if (!hasIntrinsicProportion && !hasIntrinsicDimensions) {
      return [bounds.width, bounds.height];
    }
    if (hasIntrinsicDimensions && hasIntrinsicProportion) {
      var width_1 = hasIntrinsicWidth ? intrinsicWidth : intrinsicHeight * intrinsicProportion;
      var height_1 = hasIntrinsicHeight ? intrinsicHeight : intrinsicWidth / intrinsicProportion;
      return [width_1, height_1];
    }
    var width_2 = hasIntrinsicWidth ? intrinsicWidth : bounds.width;
    var height_2 = hasIntrinsicHeight ? intrinsicHeight : bounds.height;
    return [width_2, height_2];
  }
  if (hasIntrinsicProportion) {
    var width_3 = 0;
    var height_3 = 0;
    if (isLengthPercentage(first)) {
      width_3 = getAbsoluteValue(first, bounds.width);
    } else if (isLengthPercentage(second)) {
      height_3 = getAbsoluteValue(second, bounds.height);
    }
    if (isAuto(first)) {
      width_3 = height_3 * intrinsicProportion;
    } else if (!second || isAuto(second)) {
      height_3 = width_3 / intrinsicProportion;
    }
    return [width_3, height_3];
  }
  var width = null;
  var height = null;
  if (isLengthPercentage(first)) {
    width = getAbsoluteValue(first, bounds.width);
  } else if (second && isLengthPercentage(second)) {
    height = getAbsoluteValue(second, bounds.height);
  }
  if (width !== null && (!second || isAuto(second))) {
    height = hasIntrinsicWidth && hasIntrinsicHeight ? width / intrinsicWidth * intrinsicHeight : bounds.height;
  }
  if (height !== null && isAuto(first)) {
    width = hasIntrinsicWidth && hasIntrinsicHeight ? height / intrinsicHeight * intrinsicWidth : bounds.width;
  }
  if (width !== null && height !== null) {
    return [width, height];
  }
  throw new Error("Unable to calculate background-size for element");
};
var getBackgroundValueForIndex = function(values2, index2) {
  var value = values2[index2];
  if (typeof value === "undefined") {
    return values2[0];
  }
  return value;
};
var calculateBackgroundRepeatPath = function(repeat, _a2, _b2, backgroundPositioningArea, backgroundPaintingArea) {
  var x2 = _a2[0], y2 = _a2[1];
  var width = _b2[0], height = _b2[1];
  switch (repeat) {
    case 2:
      return [
        new Vector(Math.round(backgroundPositioningArea.left), Math.round(backgroundPositioningArea.top + y2)),
        new Vector(Math.round(backgroundPositioningArea.left + backgroundPositioningArea.width), Math.round(backgroundPositioningArea.top + y2)),
        new Vector(Math.round(backgroundPositioningArea.left + backgroundPositioningArea.width), Math.round(height + backgroundPositioningArea.top + y2)),
        new Vector(Math.round(backgroundPositioningArea.left), Math.round(height + backgroundPositioningArea.top + y2))
      ];
    case 3:
      return [
        new Vector(Math.round(backgroundPositioningArea.left + x2), Math.round(backgroundPositioningArea.top)),
        new Vector(Math.round(backgroundPositioningArea.left + x2 + width), Math.round(backgroundPositioningArea.top)),
        new Vector(Math.round(backgroundPositioningArea.left + x2 + width), Math.round(backgroundPositioningArea.height + backgroundPositioningArea.top)),
        new Vector(Math.round(backgroundPositioningArea.left + x2), Math.round(backgroundPositioningArea.height + backgroundPositioningArea.top))
      ];
    case 1:
      return [
        new Vector(Math.round(backgroundPositioningArea.left + x2), Math.round(backgroundPositioningArea.top + y2)),
        new Vector(Math.round(backgroundPositioningArea.left + x2 + width), Math.round(backgroundPositioningArea.top + y2)),
        new Vector(Math.round(backgroundPositioningArea.left + x2 + width), Math.round(backgroundPositioningArea.top + y2 + height)),
        new Vector(Math.round(backgroundPositioningArea.left + x2), Math.round(backgroundPositioningArea.top + y2 + height))
      ];
    default:
      return [
        new Vector(Math.round(backgroundPaintingArea.left), Math.round(backgroundPaintingArea.top)),
        new Vector(Math.round(backgroundPaintingArea.left + backgroundPaintingArea.width), Math.round(backgroundPaintingArea.top)),
        new Vector(Math.round(backgroundPaintingArea.left + backgroundPaintingArea.width), Math.round(backgroundPaintingArea.height + backgroundPaintingArea.top)),
        new Vector(Math.round(backgroundPaintingArea.left), Math.round(backgroundPaintingArea.height + backgroundPaintingArea.top))
      ];
  }
};
var SMALL_IMAGE = "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7";
var SAMPLE_TEXT = "Hidden Text";
var FontMetrics = function() {
  function FontMetrics2(document2) {
    this._data = {};
    this._document = document2;
  }
  FontMetrics2.prototype.parseMetrics = function(fontFamily2, fontSize2) {
    var container = this._document.createElement("div");
    var img = this._document.createElement("img");
    var span = this._document.createElement("span");
    var body = this._document.body;
    container.style.visibility = "hidden";
    container.style.fontFamily = fontFamily2;
    container.style.fontSize = fontSize2;
    container.style.margin = "0";
    container.style.padding = "0";
    container.style.whiteSpace = "nowrap";
    body.appendChild(container);
    img.src = SMALL_IMAGE;
    img.width = 1;
    img.height = 1;
    img.style.margin = "0";
    img.style.padding = "0";
    img.style.verticalAlign = "baseline";
    span.style.fontFamily = fontFamily2;
    span.style.fontSize = fontSize2;
    span.style.margin = "0";
    span.style.padding = "0";
    span.appendChild(this._document.createTextNode(SAMPLE_TEXT));
    container.appendChild(span);
    container.appendChild(img);
    var baseline = img.offsetTop - span.offsetTop + 2;
    container.removeChild(span);
    container.appendChild(this._document.createTextNode(SAMPLE_TEXT));
    container.style.lineHeight = "normal";
    img.style.verticalAlign = "super";
    var middle = img.offsetTop - container.offsetTop + 2;
    body.removeChild(container);
    return { baseline, middle };
  };
  FontMetrics2.prototype.getMetrics = function(fontFamily2, fontSize2) {
    var key = fontFamily2 + " " + fontSize2;
    if (typeof this._data[key] === "undefined") {
      this._data[key] = this.parseMetrics(fontFamily2, fontSize2);
    }
    return this._data[key];
  };
  return FontMetrics2;
}();
var Renderer = function() {
  function Renderer2(context, options) {
    this.context = context;
    this.options = options;
  }
  return Renderer2;
}();
var MASK_OFFSET = 1e4;
var CanvasRenderer = function(_super) {
  __extends(CanvasRenderer2, _super);
  function CanvasRenderer2(context, options) {
    var _this = _super.call(this, context, options) || this;
    _this._activeEffects = [];
    _this.canvas = options.canvas ? options.canvas : document.createElement("canvas");
    _this.ctx = _this.canvas.getContext("2d");
    if (!options.canvas) {
      _this.canvas.width = Math.floor(options.width * options.scale);
      _this.canvas.height = Math.floor(options.height * options.scale);
      _this.canvas.style.width = options.width + "px";
      _this.canvas.style.height = options.height + "px";
    }
    _this.fontMetrics = new FontMetrics(document);
    _this.ctx.scale(_this.options.scale, _this.options.scale);
    _this.ctx.translate(-options.x, -options.y);
    _this.ctx.textBaseline = "bottom";
    _this._activeEffects = [];
    _this.context.logger.debug("Canvas renderer initialized (" + options.width + "x" + options.height + ") with scale " + options.scale);
    return _this;
  }
  CanvasRenderer2.prototype.applyEffects = function(effects) {
    var _this = this;
    while (this._activeEffects.length) {
      this.popEffect();
    }
    effects.forEach(function(effect) {
      return _this.applyEffect(effect);
    });
  };
  CanvasRenderer2.prototype.applyEffect = function(effect) {
    this.ctx.save();
    if (isOpacityEffect(effect)) {
      this.ctx.globalAlpha = effect.opacity;
    }
    if (isTransformEffect(effect)) {
      this.ctx.translate(effect.offsetX, effect.offsetY);
      this.ctx.transform(effect.matrix[0], effect.matrix[1], effect.matrix[2], effect.matrix[3], effect.matrix[4], effect.matrix[5]);
      this.ctx.translate(-effect.offsetX, -effect.offsetY);
    }
    if (isClipEffect(effect)) {
      this.path(effect.path);
      this.ctx.clip();
    }
    this._activeEffects.push(effect);
  };
  CanvasRenderer2.prototype.popEffect = function() {
    this._activeEffects.pop();
    this.ctx.restore();
  };
  CanvasRenderer2.prototype.renderStack = function(stack) {
    return __awaiter(this, void 0, void 0, function() {
      var styles;
      return __generator(this, function(_a2) {
        switch (_a2.label) {
          case 0:
            styles = stack.element.container.styles;
            if (!styles.isVisible())
              return [3, 2];
            return [4, this.renderStackContent(stack)];
          case 1:
            _a2.sent();
            _a2.label = 2;
          case 2:
            return [2];
        }
      });
    });
  };
  CanvasRenderer2.prototype.renderNode = function(paint) {
    return __awaiter(this, void 0, void 0, function() {
      return __generator(this, function(_a2) {
        switch (_a2.label) {
          case 0:
            if (contains(paint.container.flags, 16)) {
              debugger;
            }
            if (!paint.container.styles.isVisible())
              return [3, 3];
            return [4, this.renderNodeBackgroundAndBorders(paint)];
          case 1:
            _a2.sent();
            return [4, this.renderNodeContent(paint)];
          case 2:
            _a2.sent();
            _a2.label = 3;
          case 3:
            return [2];
        }
      });
    });
  };
  CanvasRenderer2.prototype.renderTextWithLetterSpacing = function(text2, letterSpacing2, baseline) {
    var _this = this;
    if (letterSpacing2 === 0) {
      this.ctx.fillText(text2.text, text2.bounds.left, text2.bounds.top + baseline);
    } else {
      var letters = segmentGraphemes(text2.text);
      letters.reduce(function(left, letter) {
        _this.ctx.fillText(letter, left, text2.bounds.top + baseline);
        return left + _this.ctx.measureText(letter).width;
      }, text2.bounds.left);
    }
  };
  CanvasRenderer2.prototype.createFontStyle = function(styles) {
    var fontVariant2 = styles.fontVariant.filter(function(variant) {
      return variant === "normal" || variant === "small-caps";
    }).join("");
    var fontFamily2 = fixIOSSystemFonts(styles.fontFamily).join(", ");
    var fontSize2 = isDimensionToken(styles.fontSize) ? "" + styles.fontSize.number + styles.fontSize.unit : styles.fontSize.number + "px";
    return [
      [styles.fontStyle, fontVariant2, styles.fontWeight, fontSize2, fontFamily2].join(" "),
      fontFamily2,
      fontSize2
    ];
  };
  CanvasRenderer2.prototype.renderTextNode = function(text2, styles) {
    return __awaiter(this, void 0, void 0, function() {
      var _a2, font, fontFamily2, fontSize2, _b2, baseline, middle, paintOrder2;
      var _this = this;
      return __generator(this, function(_c) {
        _a2 = this.createFontStyle(styles), font = _a2[0], fontFamily2 = _a2[1], fontSize2 = _a2[2];
        this.ctx.font = font;
        this.ctx.direction = styles.direction === 1 ? "rtl" : "ltr";
        this.ctx.textAlign = "left";
        this.ctx.textBaseline = "alphabetic";
        _b2 = this.fontMetrics.getMetrics(fontFamily2, fontSize2), baseline = _b2.baseline, middle = _b2.middle;
        paintOrder2 = styles.paintOrder;
        text2.textBounds.forEach(function(text3) {
          paintOrder2.forEach(function(paintOrderLayer) {
            switch (paintOrderLayer) {
              case 0:
                _this.ctx.fillStyle = asString(styles.color);
                _this.renderTextWithLetterSpacing(text3, styles.letterSpacing, baseline);
                var textShadows = styles.textShadow;
                if (textShadows.length && text3.text.trim().length) {
                  textShadows.slice(0).reverse().forEach(function(textShadow2) {
                    _this.ctx.shadowColor = asString(textShadow2.color);
                    _this.ctx.shadowOffsetX = textShadow2.offsetX.number * _this.options.scale;
                    _this.ctx.shadowOffsetY = textShadow2.offsetY.number * _this.options.scale;
                    _this.ctx.shadowBlur = textShadow2.blur.number;
                    _this.renderTextWithLetterSpacing(text3, styles.letterSpacing, baseline);
                  });
                  _this.ctx.shadowColor = "";
                  _this.ctx.shadowOffsetX = 0;
                  _this.ctx.shadowOffsetY = 0;
                  _this.ctx.shadowBlur = 0;
                }
                if (styles.textDecorationLine.length) {
                  _this.ctx.fillStyle = asString(styles.textDecorationColor || styles.color);
                  styles.textDecorationLine.forEach(function(textDecorationLine2) {
                    switch (textDecorationLine2) {
                      case 1:
                        _this.ctx.fillRect(text3.bounds.left, Math.round(text3.bounds.top + baseline), text3.bounds.width, 1);
                        break;
                      case 2:
                        _this.ctx.fillRect(text3.bounds.left, Math.round(text3.bounds.top), text3.bounds.width, 1);
                        break;
                      case 3:
                        _this.ctx.fillRect(text3.bounds.left, Math.ceil(text3.bounds.top + middle), text3.bounds.width, 1);
                        break;
                    }
                  });
                }
                break;
              case 1:
                if (styles.webkitTextStrokeWidth && text3.text.trim().length) {
                  _this.ctx.strokeStyle = asString(styles.webkitTextStrokeColor);
                  _this.ctx.lineWidth = styles.webkitTextStrokeWidth;
                  _this.ctx.lineJoin = !!window.chrome ? "miter" : "round";
                  _this.ctx.strokeText(text3.text, text3.bounds.left, text3.bounds.top + baseline);
                }
                _this.ctx.strokeStyle = "";
                _this.ctx.lineWidth = 0;
                _this.ctx.lineJoin = "miter";
                break;
            }
          });
        });
        return [2];
      });
    });
  };
  CanvasRenderer2.prototype.renderReplacedElement = function(container, curves, image2) {
    if (image2 && container.intrinsicWidth > 0 && container.intrinsicHeight > 0) {
      var box = contentBox(container);
      var path = calculatePaddingBoxPath(curves);
      this.path(path);
      this.ctx.save();
      this.ctx.clip();
      this.ctx.drawImage(image2, 0, 0, container.intrinsicWidth, container.intrinsicHeight, box.left, box.top, box.width, box.height);
      this.ctx.restore();
    }
  };
  CanvasRenderer2.prototype.renderNodeContent = function(paint) {
    return __awaiter(this, void 0, void 0, function() {
      var container, curves, styles, _i, _a2, child, image2, image2, iframeRenderer, canvas, size, _b2, fontFamily2, fontSize2, baseline, bounds, x2, textBounds, img, image2, url, fontFamily2, bounds;
      return __generator(this, function(_c) {
        switch (_c.label) {
          case 0:
            this.applyEffects(paint.getEffects(4));
            container = paint.container;
            curves = paint.curves;
            styles = container.styles;
            _i = 0, _a2 = container.textNodes;
            _c.label = 1;
          case 1:
            if (!(_i < _a2.length))
              return [3, 4];
            child = _a2[_i];
            return [4, this.renderTextNode(child, styles)];
          case 2:
            _c.sent();
            _c.label = 3;
          case 3:
            _i++;
            return [3, 1];
          case 4:
            if (!(container instanceof ImageElementContainer))
              return [3, 8];
            _c.label = 5;
          case 5:
            _c.trys.push([5, 7, , 8]);
            return [4, this.context.cache.match(container.src)];
          case 6:
            image2 = _c.sent();
            this.renderReplacedElement(container, curves, image2);
            return [3, 8];
          case 7:
            _c.sent();
            this.context.logger.error("Error loading image " + container.src);
            return [3, 8];
          case 8:
            if (container instanceof CanvasElementContainer) {
              this.renderReplacedElement(container, curves, container.canvas);
            }
            if (!(container instanceof SVGElementContainer))
              return [3, 12];
            _c.label = 9;
          case 9:
            _c.trys.push([9, 11, , 12]);
            return [4, this.context.cache.match(container.svg)];
          case 10:
            image2 = _c.sent();
            this.renderReplacedElement(container, curves, image2);
            return [3, 12];
          case 11:
            _c.sent();
            this.context.logger.error("Error loading svg " + container.svg.substring(0, 255));
            return [3, 12];
          case 12:
            if (!(container instanceof IFrameElementContainer && container.tree))
              return [3, 14];
            iframeRenderer = new CanvasRenderer2(this.context, {
              scale: this.options.scale,
              backgroundColor: container.backgroundColor,
              x: 0,
              y: 0,
              width: container.width,
              height: container.height
            });
            return [4, iframeRenderer.render(container.tree)];
          case 13:
            canvas = _c.sent();
            if (container.width && container.height) {
              this.ctx.drawImage(canvas, 0, 0, container.width, container.height, container.bounds.left, container.bounds.top, container.bounds.width, container.bounds.height);
            }
            _c.label = 14;
          case 14:
            if (container instanceof InputElementContainer) {
              size = Math.min(container.bounds.width, container.bounds.height);
              if (container.type === CHECKBOX) {
                if (container.checked) {
                  this.ctx.save();
                  this.path([
                    new Vector(container.bounds.left + size * 0.39363, container.bounds.top + size * 0.79),
                    new Vector(container.bounds.left + size * 0.16, container.bounds.top + size * 0.5549),
                    new Vector(container.bounds.left + size * 0.27347, container.bounds.top + size * 0.44071),
                    new Vector(container.bounds.left + size * 0.39694, container.bounds.top + size * 0.5649),
                    new Vector(container.bounds.left + size * 0.72983, container.bounds.top + size * 0.23),
                    new Vector(container.bounds.left + size * 0.84, container.bounds.top + size * 0.34085),
                    new Vector(container.bounds.left + size * 0.39363, container.bounds.top + size * 0.79)
                  ]);
                  this.ctx.fillStyle = asString(INPUT_COLOR);
                  this.ctx.fill();
                  this.ctx.restore();
                }
              } else if (container.type === RADIO) {
                if (container.checked) {
                  this.ctx.save();
                  this.ctx.beginPath();
                  this.ctx.arc(container.bounds.left + size / 2, container.bounds.top + size / 2, size / 4, 0, Math.PI * 2, true);
                  this.ctx.fillStyle = asString(INPUT_COLOR);
                  this.ctx.fill();
                  this.ctx.restore();
                }
              }
            }
            if (isTextInputElement(container) && container.value.length) {
              _b2 = this.createFontStyle(styles), fontFamily2 = _b2[0], fontSize2 = _b2[1];
              baseline = this.fontMetrics.getMetrics(fontFamily2, fontSize2).baseline;
              this.ctx.font = fontFamily2;
              this.ctx.fillStyle = asString(styles.color);
              this.ctx.textBaseline = "alphabetic";
              this.ctx.textAlign = canvasTextAlign(container.styles.textAlign);
              bounds = contentBox(container);
              x2 = 0;
              switch (container.styles.textAlign) {
                case 1:
                  x2 += bounds.width / 2;
                  break;
                case 2:
                  x2 += bounds.width;
                  break;
              }
              textBounds = bounds.add(x2, 0, 0, -bounds.height / 2 + 1);
              this.ctx.save();
              this.path([
                new Vector(bounds.left, bounds.top),
                new Vector(bounds.left + bounds.width, bounds.top),
                new Vector(bounds.left + bounds.width, bounds.top + bounds.height),
                new Vector(bounds.left, bounds.top + bounds.height)
              ]);
              this.ctx.clip();
              this.renderTextWithLetterSpacing(new TextBounds(container.value, textBounds), styles.letterSpacing, baseline);
              this.ctx.restore();
              this.ctx.textBaseline = "alphabetic";
              this.ctx.textAlign = "left";
            }
            if (!contains(container.styles.display, 2048))
              return [3, 20];
            if (!(container.styles.listStyleImage !== null))
              return [3, 19];
            img = container.styles.listStyleImage;
            if (!(img.type === 0))
              return [3, 18];
            image2 = void 0;
            url = img.url;
            _c.label = 15;
          case 15:
            _c.trys.push([15, 17, , 18]);
            return [4, this.context.cache.match(url)];
          case 16:
            image2 = _c.sent();
            this.ctx.drawImage(image2, container.bounds.left - (image2.width + 10), container.bounds.top);
            return [3, 18];
          case 17:
            _c.sent();
            this.context.logger.error("Error loading list-style-image " + url);
            return [3, 18];
          case 18:
            return [3, 20];
          case 19:
            if (paint.listValue && container.styles.listStyleType !== -1) {
              fontFamily2 = this.createFontStyle(styles)[0];
              this.ctx.font = fontFamily2;
              this.ctx.fillStyle = asString(styles.color);
              this.ctx.textBaseline = "middle";
              this.ctx.textAlign = "right";
              bounds = new Bounds(container.bounds.left, container.bounds.top + getAbsoluteValue(container.styles.paddingTop, container.bounds.width), container.bounds.width, computeLineHeight(styles.lineHeight, styles.fontSize.number) / 2 + 1);
              this.renderTextWithLetterSpacing(new TextBounds(paint.listValue, bounds), styles.letterSpacing, computeLineHeight(styles.lineHeight, styles.fontSize.number) / 2 + 2);
              this.ctx.textBaseline = "bottom";
              this.ctx.textAlign = "left";
            }
            _c.label = 20;
          case 20:
            return [2];
        }
      });
    });
  };
  CanvasRenderer2.prototype.renderStackContent = function(stack) {
    return __awaiter(this, void 0, void 0, function() {
      var _i, _a2, child, _b2, _c, child, _d, _e, child, _f, _g, child, _h, _j, child, _k, _l, child, _m, _o, child;
      return __generator(this, function(_p) {
        switch (_p.label) {
          case 0:
            if (contains(stack.element.container.flags, 16)) {
              debugger;
            }
            return [4, this.renderNodeBackgroundAndBorders(stack.element)];
          case 1:
            _p.sent();
            _i = 0, _a2 = stack.negativeZIndex;
            _p.label = 2;
          case 2:
            if (!(_i < _a2.length))
              return [3, 5];
            child = _a2[_i];
            return [4, this.renderStack(child)];
          case 3:
            _p.sent();
            _p.label = 4;
          case 4:
            _i++;
            return [3, 2];
          case 5:
            return [4, this.renderNodeContent(stack.element)];
          case 6:
            _p.sent();
            _b2 = 0, _c = stack.nonInlineLevel;
            _p.label = 7;
          case 7:
            if (!(_b2 < _c.length))
              return [3, 10];
            child = _c[_b2];
            return [4, this.renderNode(child)];
          case 8:
            _p.sent();
            _p.label = 9;
          case 9:
            _b2++;
            return [3, 7];
          case 10:
            _d = 0, _e = stack.nonPositionedFloats;
            _p.label = 11;
          case 11:
            if (!(_d < _e.length))
              return [3, 14];
            child = _e[_d];
            return [4, this.renderStack(child)];
          case 12:
            _p.sent();
            _p.label = 13;
          case 13:
            _d++;
            return [3, 11];
          case 14:
            _f = 0, _g = stack.nonPositionedInlineLevel;
            _p.label = 15;
          case 15:
            if (!(_f < _g.length))
              return [3, 18];
            child = _g[_f];
            return [4, this.renderStack(child)];
          case 16:
            _p.sent();
            _p.label = 17;
          case 17:
            _f++;
            return [3, 15];
          case 18:
            _h = 0, _j = stack.inlineLevel;
            _p.label = 19;
          case 19:
            if (!(_h < _j.length))
              return [3, 22];
            child = _j[_h];
            return [4, this.renderNode(child)];
          case 20:
            _p.sent();
            _p.label = 21;
          case 21:
            _h++;
            return [3, 19];
          case 22:
            _k = 0, _l = stack.zeroOrAutoZIndexOrTransformedOrOpacity;
            _p.label = 23;
          case 23:
            if (!(_k < _l.length))
              return [3, 26];
            child = _l[_k];
            return [4, this.renderStack(child)];
          case 24:
            _p.sent();
            _p.label = 25;
          case 25:
            _k++;
            return [3, 23];
          case 26:
            _m = 0, _o = stack.positiveZIndex;
            _p.label = 27;
          case 27:
            if (!(_m < _o.length))
              return [3, 30];
            child = _o[_m];
            return [4, this.renderStack(child)];
          case 28:
            _p.sent();
            _p.label = 29;
          case 29:
            _m++;
            return [3, 27];
          case 30:
            return [2];
        }
      });
    });
  };
  CanvasRenderer2.prototype.mask = function(paths) {
    this.ctx.beginPath();
    this.ctx.moveTo(0, 0);
    this.ctx.lineTo(this.canvas.width, 0);
    this.ctx.lineTo(this.canvas.width, this.canvas.height);
    this.ctx.lineTo(0, this.canvas.height);
    this.ctx.lineTo(0, 0);
    this.formatPath(paths.slice(0).reverse());
    this.ctx.closePath();
  };
  CanvasRenderer2.prototype.path = function(paths) {
    this.ctx.beginPath();
    this.formatPath(paths);
    this.ctx.closePath();
  };
  CanvasRenderer2.prototype.formatPath = function(paths) {
    var _this = this;
    paths.forEach(function(point, index2) {
      var start2 = isBezierCurve(point) ? point.start : point;
      if (index2 === 0) {
        _this.ctx.moveTo(start2.x, start2.y);
      } else {
        _this.ctx.lineTo(start2.x, start2.y);
      }
      if (isBezierCurve(point)) {
        _this.ctx.bezierCurveTo(point.startControl.x, point.startControl.y, point.endControl.x, point.endControl.y, point.end.x, point.end.y);
      }
    });
  };
  CanvasRenderer2.prototype.renderRepeat = function(path, pattern, offsetX, offsetY) {
    this.path(path);
    this.ctx.fillStyle = pattern;
    this.ctx.translate(offsetX, offsetY);
    this.ctx.fill();
    this.ctx.translate(-offsetX, -offsetY);
  };
  CanvasRenderer2.prototype.resizeImage = function(image2, width, height) {
    var _a2;
    if (image2.width === width && image2.height === height) {
      return image2;
    }
    var ownerDocument = (_a2 = this.canvas.ownerDocument) !== null && _a2 !== void 0 ? _a2 : document;
    var canvas = ownerDocument.createElement("canvas");
    canvas.width = Math.max(1, width);
    canvas.height = Math.max(1, height);
    var ctx = canvas.getContext("2d");
    ctx.drawImage(image2, 0, 0, image2.width, image2.height, 0, 0, width, height);
    return canvas;
  };
  CanvasRenderer2.prototype.renderBackgroundImage = function(container) {
    return __awaiter(this, void 0, void 0, function() {
      var index2, _loop_1, this_1, _i, _a2, backgroundImage2;
      return __generator(this, function(_b2) {
        switch (_b2.label) {
          case 0:
            index2 = container.styles.backgroundImage.length - 1;
            _loop_1 = function(backgroundImage3) {
              var image2, url, _c, path, x2, y2, width, height, pattern, _d, path, x2, y2, width, height, _e, lineLength, x0, x1, y0, y1, canvas, ctx, gradient_1, pattern, _f, path, left, top_1, width, height, position2, x2, y2, _g, rx, ry, radialGradient_1, midX, midY, f2, invF;
              return __generator(this, function(_h) {
                switch (_h.label) {
                  case 0:
                    if (!(backgroundImage3.type === 0))
                      return [3, 5];
                    image2 = void 0;
                    url = backgroundImage3.url;
                    _h.label = 1;
                  case 1:
                    _h.trys.push([1, 3, , 4]);
                    return [4, this_1.context.cache.match(url)];
                  case 2:
                    image2 = _h.sent();
                    return [3, 4];
                  case 3:
                    _h.sent();
                    this_1.context.logger.error("Error loading background-image " + url);
                    return [3, 4];
                  case 4:
                    if (image2) {
                      _c = calculateBackgroundRendering(container, index2, [
                        image2.width,
                        image2.height,
                        image2.width / image2.height
                      ]), path = _c[0], x2 = _c[1], y2 = _c[2], width = _c[3], height = _c[4];
                      pattern = this_1.ctx.createPattern(this_1.resizeImage(image2, width, height), "repeat");
                      this_1.renderRepeat(path, pattern, x2, y2);
                    }
                    return [3, 6];
                  case 5:
                    if (isLinearGradient(backgroundImage3)) {
                      _d = calculateBackgroundRendering(container, index2, [null, null, null]), path = _d[0], x2 = _d[1], y2 = _d[2], width = _d[3], height = _d[4];
                      _e = calculateGradientDirection(backgroundImage3.angle, width, height), lineLength = _e[0], x0 = _e[1], x1 = _e[2], y0 = _e[3], y1 = _e[4];
                      canvas = document.createElement("canvas");
                      canvas.width = width;
                      canvas.height = height;
                      ctx = canvas.getContext("2d");
                      gradient_1 = ctx.createLinearGradient(x0, y0, x1, y1);
                      processColorStops(backgroundImage3.stops, lineLength).forEach(function(colorStop) {
                        return gradient_1.addColorStop(colorStop.stop, asString(colorStop.color));
                      });
                      ctx.fillStyle = gradient_1;
                      ctx.fillRect(0, 0, width, height);
                      if (width > 0 && height > 0) {
                        pattern = this_1.ctx.createPattern(canvas, "repeat");
                        this_1.renderRepeat(path, pattern, x2, y2);
                      }
                    } else if (isRadialGradient(backgroundImage3)) {
                      _f = calculateBackgroundRendering(container, index2, [
                        null,
                        null,
                        null
                      ]), path = _f[0], left = _f[1], top_1 = _f[2], width = _f[3], height = _f[4];
                      position2 = backgroundImage3.position.length === 0 ? [FIFTY_PERCENT] : backgroundImage3.position;
                      x2 = getAbsoluteValue(position2[0], width);
                      y2 = getAbsoluteValue(position2[position2.length - 1], height);
                      _g = calculateRadius(backgroundImage3, x2, y2, width, height), rx = _g[0], ry = _g[1];
                      if (rx > 0 && ry > 0) {
                        radialGradient_1 = this_1.ctx.createRadialGradient(left + x2, top_1 + y2, 0, left + x2, top_1 + y2, rx);
                        processColorStops(backgroundImage3.stops, rx * 2).forEach(function(colorStop) {
                          return radialGradient_1.addColorStop(colorStop.stop, asString(colorStop.color));
                        });
                        this_1.path(path);
                        this_1.ctx.fillStyle = radialGradient_1;
                        if (rx !== ry) {
                          midX = container.bounds.left + 0.5 * container.bounds.width;
                          midY = container.bounds.top + 0.5 * container.bounds.height;
                          f2 = ry / rx;
                          invF = 1 / f2;
                          this_1.ctx.save();
                          this_1.ctx.translate(midX, midY);
                          this_1.ctx.transform(1, 0, 0, f2, 0, 0);
                          this_1.ctx.translate(-midX, -midY);
                          this_1.ctx.fillRect(left, invF * (top_1 - midY) + midY, width, height * invF);
                          this_1.ctx.restore();
                        } else {
                          this_1.ctx.fill();
                        }
                      }
                    }
                    _h.label = 6;
                  case 6:
                    index2--;
                    return [2];
                }
              });
            };
            this_1 = this;
            _i = 0, _a2 = container.styles.backgroundImage.slice(0).reverse();
            _b2.label = 1;
          case 1:
            if (!(_i < _a2.length))
              return [3, 4];
            backgroundImage2 = _a2[_i];
            return [5, _loop_1(backgroundImage2)];
          case 2:
            _b2.sent();
            _b2.label = 3;
          case 3:
            _i++;
            return [3, 1];
          case 4:
            return [2];
        }
      });
    });
  };
  CanvasRenderer2.prototype.renderSolidBorder = function(color2, side, curvePoints) {
    return __awaiter(this, void 0, void 0, function() {
      return __generator(this, function(_a2) {
        this.path(parsePathForBorder(curvePoints, side));
        this.ctx.fillStyle = asString(color2);
        this.ctx.fill();
        return [2];
      });
    });
  };
  CanvasRenderer2.prototype.renderDoubleBorder = function(color2, width, side, curvePoints) {
    return __awaiter(this, void 0, void 0, function() {
      var outerPaths, innerPaths;
      return __generator(this, function(_a2) {
        switch (_a2.label) {
          case 0:
            if (!(width < 3))
              return [3, 2];
            return [4, this.renderSolidBorder(color2, side, curvePoints)];
          case 1:
            _a2.sent();
            return [2];
          case 2:
            outerPaths = parsePathForBorderDoubleOuter(curvePoints, side);
            this.path(outerPaths);
            this.ctx.fillStyle = asString(color2);
            this.ctx.fill();
            innerPaths = parsePathForBorderDoubleInner(curvePoints, side);
            this.path(innerPaths);
            this.ctx.fill();
            return [2];
        }
      });
    });
  };
  CanvasRenderer2.prototype.renderNodeBackgroundAndBorders = function(paint) {
    return __awaiter(this, void 0, void 0, function() {
      var styles, hasBackground, borders, backgroundPaintingArea, side, _i, borders_1, border;
      var _this = this;
      return __generator(this, function(_a2) {
        switch (_a2.label) {
          case 0:
            this.applyEffects(paint.getEffects(2));
            styles = paint.container.styles;
            hasBackground = !isTransparent(styles.backgroundColor) || styles.backgroundImage.length;
            borders = [
              { style: styles.borderTopStyle, color: styles.borderTopColor, width: styles.borderTopWidth },
              { style: styles.borderRightStyle, color: styles.borderRightColor, width: styles.borderRightWidth },
              { style: styles.borderBottomStyle, color: styles.borderBottomColor, width: styles.borderBottomWidth },
              { style: styles.borderLeftStyle, color: styles.borderLeftColor, width: styles.borderLeftWidth }
            ];
            backgroundPaintingArea = calculateBackgroundCurvedPaintingArea(getBackgroundValueForIndex(styles.backgroundClip, 0), paint.curves);
            if (!(hasBackground || styles.boxShadow.length))
              return [3, 2];
            this.ctx.save();
            this.path(backgroundPaintingArea);
            this.ctx.clip();
            if (!isTransparent(styles.backgroundColor)) {
              this.ctx.fillStyle = asString(styles.backgroundColor);
              this.ctx.fill();
            }
            return [4, this.renderBackgroundImage(paint.container)];
          case 1:
            _a2.sent();
            this.ctx.restore();
            styles.boxShadow.slice(0).reverse().forEach(function(shadow) {
              _this.ctx.save();
              var borderBoxArea = calculateBorderBoxPath(paint.curves);
              var maskOffset = shadow.inset ? 0 : MASK_OFFSET;
              var shadowPaintingArea = transformPath(borderBoxArea, -maskOffset + (shadow.inset ? 1 : -1) * shadow.spread.number, (shadow.inset ? 1 : -1) * shadow.spread.number, shadow.spread.number * (shadow.inset ? -2 : 2), shadow.spread.number * (shadow.inset ? -2 : 2));
              if (shadow.inset) {
                _this.path(borderBoxArea);
                _this.ctx.clip();
                _this.mask(shadowPaintingArea);
              } else {
                _this.mask(borderBoxArea);
                _this.ctx.clip();
                _this.path(shadowPaintingArea);
              }
              _this.ctx.shadowOffsetX = shadow.offsetX.number + maskOffset;
              _this.ctx.shadowOffsetY = shadow.offsetY.number;
              _this.ctx.shadowColor = asString(shadow.color);
              _this.ctx.shadowBlur = shadow.blur.number;
              _this.ctx.fillStyle = shadow.inset ? asString(shadow.color) : "rgba(0,0,0,1)";
              _this.ctx.fill();
              _this.ctx.restore();
            });
            _a2.label = 2;
          case 2:
            side = 0;
            _i = 0, borders_1 = borders;
            _a2.label = 3;
          case 3:
            if (!(_i < borders_1.length))
              return [3, 13];
            border = borders_1[_i];
            if (!(border.style !== 0 && !isTransparent(border.color) && border.width > 0))
              return [3, 11];
            if (!(border.style === 2))
              return [3, 5];
            return [4, this.renderDashedDottedBorder(border.color, border.width, side, paint.curves, 2)];
          case 4:
            _a2.sent();
            return [3, 11];
          case 5:
            if (!(border.style === 3))
              return [3, 7];
            return [4, this.renderDashedDottedBorder(border.color, border.width, side, paint.curves, 3)];
          case 6:
            _a2.sent();
            return [3, 11];
          case 7:
            if (!(border.style === 4))
              return [3, 9];
            return [4, this.renderDoubleBorder(border.color, border.width, side, paint.curves)];
          case 8:
            _a2.sent();
            return [3, 11];
          case 9:
            return [4, this.renderSolidBorder(border.color, side, paint.curves)];
          case 10:
            _a2.sent();
            _a2.label = 11;
          case 11:
            side++;
            _a2.label = 12;
          case 12:
            _i++;
            return [3, 3];
          case 13:
            return [2];
        }
      });
    });
  };
  CanvasRenderer2.prototype.renderDashedDottedBorder = function(color2, width, side, curvePoints, style2) {
    return __awaiter(this, void 0, void 0, function() {
      var strokePaths, boxPaths, startX, startY, endX, endY, length, dashLength, spaceLength, useLineDash, multiplier, numberOfDashes, minSpace, maxSpace, path1, path2, path1, path2;
      return __generator(this, function(_a2) {
        this.ctx.save();
        strokePaths = parsePathForBorderStroke(curvePoints, side);
        boxPaths = parsePathForBorder(curvePoints, side);
        if (style2 === 2) {
          this.path(boxPaths);
          this.ctx.clip();
        }
        if (isBezierCurve(boxPaths[0])) {
          startX = boxPaths[0].start.x;
          startY = boxPaths[0].start.y;
        } else {
          startX = boxPaths[0].x;
          startY = boxPaths[0].y;
        }
        if (isBezierCurve(boxPaths[1])) {
          endX = boxPaths[1].end.x;
          endY = boxPaths[1].end.y;
        } else {
          endX = boxPaths[1].x;
          endY = boxPaths[1].y;
        }
        if (side === 0 || side === 2) {
          length = Math.abs(startX - endX);
        } else {
          length = Math.abs(startY - endY);
        }
        this.ctx.beginPath();
        if (style2 === 3) {
          this.formatPath(strokePaths);
        } else {
          this.formatPath(boxPaths.slice(0, 2));
        }
        dashLength = width < 3 ? width * 3 : width * 2;
        spaceLength = width < 3 ? width * 2 : width;
        if (style2 === 3) {
          dashLength = width;
          spaceLength = width;
        }
        useLineDash = true;
        if (length <= dashLength * 2) {
          useLineDash = false;
        } else if (length <= dashLength * 2 + spaceLength) {
          multiplier = length / (2 * dashLength + spaceLength);
          dashLength *= multiplier;
          spaceLength *= multiplier;
        } else {
          numberOfDashes = Math.floor((length + spaceLength) / (dashLength + spaceLength));
          minSpace = (length - numberOfDashes * dashLength) / (numberOfDashes - 1);
          maxSpace = (length - (numberOfDashes + 1) * dashLength) / numberOfDashes;
          spaceLength = maxSpace <= 0 || Math.abs(spaceLength - minSpace) < Math.abs(spaceLength - maxSpace) ? minSpace : maxSpace;
        }
        if (useLineDash) {
          if (style2 === 3) {
            this.ctx.setLineDash([0, dashLength + spaceLength]);
          } else {
            this.ctx.setLineDash([dashLength, spaceLength]);
          }
        }
        if (style2 === 3) {
          this.ctx.lineCap = "round";
          this.ctx.lineWidth = width;
        } else {
          this.ctx.lineWidth = width * 2 + 1.1;
        }
        this.ctx.strokeStyle = asString(color2);
        this.ctx.stroke();
        this.ctx.setLineDash([]);
        if (style2 === 2) {
          if (isBezierCurve(boxPaths[0])) {
            path1 = boxPaths[3];
            path2 = boxPaths[0];
            this.ctx.beginPath();
            this.formatPath([new Vector(path1.end.x, path1.end.y), new Vector(path2.start.x, path2.start.y)]);
            this.ctx.stroke();
          }
          if (isBezierCurve(boxPaths[1])) {
            path1 = boxPaths[1];
            path2 = boxPaths[2];
            this.ctx.beginPath();
            this.formatPath([new Vector(path1.end.x, path1.end.y), new Vector(path2.start.x, path2.start.y)]);
            this.ctx.stroke();
          }
        }
        this.ctx.restore();
        return [2];
      });
    });
  };
  CanvasRenderer2.prototype.render = function(element) {
    return __awaiter(this, void 0, void 0, function() {
      var stack;
      return __generator(this, function(_a2) {
        switch (_a2.label) {
          case 0:
            if (this.options.backgroundColor) {
              this.ctx.fillStyle = asString(this.options.backgroundColor);
              this.ctx.fillRect(this.options.x, this.options.y, this.options.width, this.options.height);
            }
            stack = parseStackingContexts(element);
            return [4, this.renderStack(stack)];
          case 1:
            _a2.sent();
            this.applyEffects([]);
            return [2, this.canvas];
        }
      });
    });
  };
  return CanvasRenderer2;
}(Renderer);
var isTextInputElement = function(container) {
  if (container instanceof TextareaElementContainer) {
    return true;
  } else if (container instanceof SelectElementContainer) {
    return true;
  } else if (container instanceof InputElementContainer && container.type !== RADIO && container.type !== CHECKBOX) {
    return true;
  }
  return false;
};
var calculateBackgroundCurvedPaintingArea = function(clip, curves) {
  switch (clip) {
    case 0:
      return calculateBorderBoxPath(curves);
    case 2:
      return calculateContentBoxPath(curves);
    case 1:
    default:
      return calculatePaddingBoxPath(curves);
  }
};
var canvasTextAlign = function(textAlign2) {
  switch (textAlign2) {
    case 1:
      return "center";
    case 2:
      return "right";
    case 0:
    default:
      return "left";
  }
};
var iOSBrokenFonts = ["-apple-system", "system-ui"];
var fixIOSSystemFonts = function(fontFamilies) {
  return /iPhone OS 15_(0|1)/.test(window.navigator.userAgent) ? fontFamilies.filter(function(fontFamily2) {
    return iOSBrokenFonts.indexOf(fontFamily2) === -1;
  }) : fontFamilies;
};
var ForeignObjectRenderer = function(_super) {
  __extends(ForeignObjectRenderer2, _super);
  function ForeignObjectRenderer2(context, options) {
    var _this = _super.call(this, context, options) || this;
    _this.canvas = options.canvas ? options.canvas : document.createElement("canvas");
    _this.ctx = _this.canvas.getContext("2d");
    _this.options = options;
    _this.canvas.width = Math.floor(options.width * options.scale);
    _this.canvas.height = Math.floor(options.height * options.scale);
    _this.canvas.style.width = options.width + "px";
    _this.canvas.style.height = options.height + "px";
    _this.ctx.scale(_this.options.scale, _this.options.scale);
    _this.ctx.translate(-options.x, -options.y);
    _this.context.logger.debug("EXPERIMENTAL ForeignObject renderer initialized (" + options.width + "x" + options.height + " at " + options.x + "," + options.y + ") with scale " + options.scale);
    return _this;
  }
  ForeignObjectRenderer2.prototype.render = function(element) {
    return __awaiter(this, void 0, void 0, function() {
      var svg2, img;
      return __generator(this, function(_a2) {
        switch (_a2.label) {
          case 0:
            svg2 = createForeignObjectSVG(this.options.width * this.options.scale, this.options.height * this.options.scale, this.options.scale, this.options.scale, element);
            return [4, loadSerializedSVG(svg2)];
          case 1:
            img = _a2.sent();
            if (this.options.backgroundColor) {
              this.ctx.fillStyle = asString(this.options.backgroundColor);
              this.ctx.fillRect(0, 0, this.options.width * this.options.scale, this.options.height * this.options.scale);
            }
            this.ctx.drawImage(img, -this.options.x * this.options.scale, -this.options.y * this.options.scale);
            return [2, this.canvas];
        }
      });
    });
  };
  return ForeignObjectRenderer2;
}(Renderer);
var loadSerializedSVG = function(svg2) {
  return new Promise(function(resolve2, reject2) {
    var img = new Image();
    img.onload = function() {
      resolve2(img);
    };
    img.onerror = reject2;
    img.src = "data:image/svg+xml;charset=utf-8," + encodeURIComponent(new XMLSerializer().serializeToString(svg2));
  });
};
var Logger = function() {
  function Logger2(_a2) {
    var id = _a2.id, enabled = _a2.enabled;
    this.id = id;
    this.enabled = enabled;
    this.start = Date.now();
  }
  Logger2.prototype.debug = function() {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      args[_i] = arguments[_i];
    }
    if (this.enabled) {
      if (typeof window !== "undefined" && window.console && typeof console.debug === "function") {
        console.debug.apply(console, __spreadArray([this.id, this.getTime() + "ms"], args));
      } else {
        this.info.apply(this, args);
      }
    }
  };
  Logger2.prototype.getTime = function() {
    return Date.now() - this.start;
  };
  Logger2.prototype.info = function() {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      args[_i] = arguments[_i];
    }
    if (this.enabled) {
      if (typeof window !== "undefined" && window.console && typeof console.info === "function") {
        console.info.apply(console, __spreadArray([this.id, this.getTime() + "ms"], args));
      }
    }
  };
  Logger2.prototype.warn = function() {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      args[_i] = arguments[_i];
    }
    if (this.enabled) {
      if (typeof window !== "undefined" && window.console && typeof console.warn === "function") {
        console.warn.apply(console, __spreadArray([this.id, this.getTime() + "ms"], args));
      } else {
        this.info.apply(this, args);
      }
    }
  };
  Logger2.prototype.error = function() {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      args[_i] = arguments[_i];
    }
    if (this.enabled) {
      if (typeof window !== "undefined" && window.console && typeof console.error === "function") {
        console.error.apply(console, __spreadArray([this.id, this.getTime() + "ms"], args));
      } else {
        this.info.apply(this, args);
      }
    }
  };
  Logger2.instances = {};
  return Logger2;
}();
var Context = function() {
  function Context2(options, windowBounds) {
    var _a2;
    this.windowBounds = windowBounds;
    this.instanceName = "#" + Context2.instanceCount++;
    this.logger = new Logger({ id: this.instanceName, enabled: options.logging });
    this.cache = (_a2 = options.cache) !== null && _a2 !== void 0 ? _a2 : new Cache(this, options);
  }
  Context2.instanceCount = 1;
  return Context2;
}();
var html2canvas = function(element, options) {
  if (options === void 0) {
    options = {};
  }
  return renderElement(element, options);
};
if (typeof window !== "undefined") {
  CacheStorage.setContext(window);
}
var renderElement = function(element, opts) {
  return __awaiter(void 0, void 0, void 0, function() {
    var ownerDocument, defaultView, resourceOptions, contextOptions, windowOptions, windowBounds, context, foreignObjectRendering, cloneOptions, documentCloner, clonedElement, container, _a2, width, height, left, top, backgroundColor2, renderOptions, canvas, renderer, root2, renderer;
    var _b2, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t2;
    return __generator(this, function(_u) {
      switch (_u.label) {
        case 0:
          if (!element || typeof element !== "object") {
            return [2, Promise.reject("Invalid element provided as first argument")];
          }
          ownerDocument = element.ownerDocument;
          if (!ownerDocument) {
            throw new Error("Element is not attached to a Document");
          }
          defaultView = ownerDocument.defaultView;
          if (!defaultView) {
            throw new Error("Document is not attached to a Window");
          }
          resourceOptions = {
            allowTaint: (_b2 = opts.allowTaint) !== null && _b2 !== void 0 ? _b2 : false,
            imageTimeout: (_c = opts.imageTimeout) !== null && _c !== void 0 ? _c : 15e3,
            proxy: opts.proxy,
            useCORS: (_d = opts.useCORS) !== null && _d !== void 0 ? _d : false
          };
          contextOptions = __assign({ logging: (_e = opts.logging) !== null && _e !== void 0 ? _e : true, cache: opts.cache }, resourceOptions);
          windowOptions = {
            windowWidth: (_f = opts.windowWidth) !== null && _f !== void 0 ? _f : defaultView.innerWidth,
            windowHeight: (_g = opts.windowHeight) !== null && _g !== void 0 ? _g : defaultView.innerHeight,
            scrollX: (_h = opts.scrollX) !== null && _h !== void 0 ? _h : defaultView.pageXOffset,
            scrollY: (_j = opts.scrollY) !== null && _j !== void 0 ? _j : defaultView.pageYOffset
          };
          windowBounds = new Bounds(windowOptions.scrollX, windowOptions.scrollY, windowOptions.windowWidth, windowOptions.windowHeight);
          context = new Context(contextOptions, windowBounds);
          foreignObjectRendering = (_k = opts.foreignObjectRendering) !== null && _k !== void 0 ? _k : false;
          cloneOptions = {
            allowTaint: (_l = opts.allowTaint) !== null && _l !== void 0 ? _l : false,
            onclone: opts.onclone,
            ignoreElements: opts.ignoreElements,
            inlineImages: foreignObjectRendering,
            copyStyles: foreignObjectRendering
          };
          context.logger.debug("Starting document clone with size " + windowBounds.width + "x" + windowBounds.height + " scrolled to " + -windowBounds.left + "," + -windowBounds.top);
          documentCloner = new DocumentCloner(context, element, cloneOptions);
          clonedElement = documentCloner.clonedReferenceElement;
          if (!clonedElement) {
            return [2, Promise.reject("Unable to find element in cloned iframe")];
          }
          return [4, documentCloner.toIFrame(ownerDocument, windowBounds)];
        case 1:
          container = _u.sent();
          _a2 = isBodyElement(clonedElement) || isHTMLElement(clonedElement) ? parseDocumentSize(clonedElement.ownerDocument) : parseBounds(context, clonedElement), width = _a2.width, height = _a2.height, left = _a2.left, top = _a2.top;
          backgroundColor2 = parseBackgroundColor(context, clonedElement, opts.backgroundColor);
          renderOptions = {
            canvas: opts.canvas,
            backgroundColor: backgroundColor2,
            scale: (_o = (_m = opts.scale) !== null && _m !== void 0 ? _m : defaultView.devicePixelRatio) !== null && _o !== void 0 ? _o : 1,
            x: ((_p = opts.x) !== null && _p !== void 0 ? _p : 0) + left,
            y: ((_q = opts.y) !== null && _q !== void 0 ? _q : 0) + top,
            width: (_r = opts.width) !== null && _r !== void 0 ? _r : Math.ceil(width),
            height: (_s = opts.height) !== null && _s !== void 0 ? _s : Math.ceil(height)
          };
          if (!foreignObjectRendering)
            return [3, 3];
          context.logger.debug("Document cloned, using foreign object rendering");
          renderer = new ForeignObjectRenderer(context, renderOptions);
          return [4, renderer.render(clonedElement)];
        case 2:
          canvas = _u.sent();
          return [3, 5];
        case 3:
          context.logger.debug("Document cloned, element located at " + left + "," + top + " with size " + width + "x" + height + " using computed rendering");
          context.logger.debug("Starting DOM parsing");
          root2 = parseTree(context, clonedElement);
          if (backgroundColor2 === root2.styles.backgroundColor) {
            root2.styles.backgroundColor = COLORS.TRANSPARENT;
          }
          context.logger.debug("Starting renderer for element at " + renderOptions.x + "," + renderOptions.y + " with size " + renderOptions.width + "x" + renderOptions.height);
          renderer = new CanvasRenderer(context, renderOptions);
          return [4, renderer.render(root2)];
        case 4:
          canvas = _u.sent();
          _u.label = 5;
        case 5:
          if ((_t2 = opts.removeContainer) !== null && _t2 !== void 0 ? _t2 : true) {
            if (!DocumentCloner.destroy(container)) {
              context.logger.error("Cannot detach cloned iframe as it is not in the DOM anymore");
            }
          }
          context.logger.debug("Finished rendering");
          return [2, canvas];
      }
    });
  });
};
var parseBackgroundColor = function(context, element, backgroundColorOverride) {
  var ownerDocument = element.ownerDocument;
  var documentBackgroundColor = ownerDocument.documentElement ? parseColor(context, getComputedStyle(ownerDocument.documentElement).backgroundColor) : COLORS.TRANSPARENT;
  var bodyBackgroundColor = ownerDocument.body ? parseColor(context, getComputedStyle(ownerDocument.body).backgroundColor) : COLORS.TRANSPARENT;
  var defaultBackgroundColor = typeof backgroundColorOverride === "string" ? parseColor(context, backgroundColorOverride) : backgroundColorOverride === null ? COLORS.TRANSPARENT : 4294967295;
  return element === ownerDocument.documentElement ? isTransparent(documentBackgroundColor) ? isTransparent(bodyBackgroundColor) ? defaultBackgroundColor : bodyBackgroundColor : documentBackgroundColor : defaultBackgroundColor;
};
var html2canvas_esm = Object.freeze(Object.defineProperty({
  __proto__: null,
  "default": html2canvas
}, Symbol.toStringTag, { value: "Module" }));
function _toConsumableArray(arr) {
  if (Array.isArray(arr)) {
    for (var i2 = 0, arr2 = Array(arr.length); i2 < arr.length; i2++) {
      arr2[i2] = arr[i2];
    }
    return arr2;
  } else {
    return Array.from(arr);
  }
}
var hasOwnProperty$1 = Object.hasOwnProperty;
var setPrototypeOf$2 = Object.setPrototypeOf;
var isFrozen = Object.isFrozen;
var getPrototypeOf$2 = Object.getPrototypeOf;
var getOwnPropertyDescriptor$5 = Object.getOwnPropertyDescriptor;
var freeze = Object.freeze;
var seal = Object.seal;
var create$3 = Object.create;
var _ref = typeof Reflect !== "undefined" && Reflect;
var apply$4 = _ref.apply;
var construct$1 = _ref.construct;
if (!apply$4) {
  apply$4 = function apply2(fun, thisValue, args) {
    return fun.apply(thisValue, args);
  };
}
if (!freeze) {
  freeze = function freeze2(x2) {
    return x2;
  };
}
if (!seal) {
  seal = function seal2(x2) {
    return x2;
  };
}
if (!construct$1) {
  construct$1 = function construct2(Func, args) {
    return new (Function.prototype.bind.apply(Func, [null].concat(_toConsumableArray(args))))();
  };
}
var arrayForEach = unapply(Array.prototype.forEach);
var arrayPop = unapply(Array.prototype.pop);
var arrayPush = unapply(Array.prototype.push);
var stringToLowerCase = unapply(String.prototype.toLowerCase);
var stringMatch = unapply(String.prototype.match);
var stringReplace = unapply(String.prototype.replace);
var stringIndexOf$2 = unapply(String.prototype.indexOf);
var stringTrim$1 = unapply(String.prototype.trim);
var regExpTest = unapply(RegExp.prototype.test);
var typeErrorCreate = unconstruct(TypeError);
function unapply(func) {
  return function(thisArg) {
    for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      args[_key - 1] = arguments[_key];
    }
    return apply$4(func, thisArg, args);
  };
}
function unconstruct(func) {
  return function() {
    for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      args[_key2] = arguments[_key2];
    }
    return construct$1(func, args);
  };
}
function addToSet(set2, array) {
  if (setPrototypeOf$2) {
    setPrototypeOf$2(set2, null);
  }
  var l2 = array.length;
  while (l2--) {
    var element = array[l2];
    if (typeof element === "string") {
      var lcElement = stringToLowerCase(element);
      if (lcElement !== element) {
        if (!isFrozen(array)) {
          array[l2] = lcElement;
        }
        element = lcElement;
      }
    }
    set2[element] = true;
  }
  return set2;
}
function clone(object) {
  var newObject = create$3(null);
  var property = void 0;
  for (property in object) {
    if (apply$4(hasOwnProperty$1, object, [property])) {
      newObject[property] = object[property];
    }
  }
  return newObject;
}
function lookupGetter(object, prop) {
  while (object !== null) {
    var desc = getOwnPropertyDescriptor$5(object, prop);
    if (desc) {
      if (desc.get) {
        return unapply(desc.get);
      }
      if (typeof desc.value === "function") {
        return unapply(desc.value);
      }
    }
    object = getPrototypeOf$2(object);
  }
  function fallbackValue(element) {
    console.warn("fallback value for", element);
    return null;
  }
  return fallbackValue;
}
var html$3 = freeze(["a", "abbr", "acronym", "address", "area", "article", "aside", "audio", "b", "bdi", "bdo", "big", "blink", "blockquote", "body", "br", "button", "canvas", "caption", "center", "cite", "code", "col", "colgroup", "content", "data", "datalist", "dd", "decorator", "del", "details", "dfn", "dialog", "dir", "div", "dl", "dt", "element", "em", "fieldset", "figcaption", "figure", "font", "footer", "form", "h1", "h2", "h3", "h4", "h5", "h6", "head", "header", "hgroup", "hr", "html", "i", "img", "input", "ins", "kbd", "label", "legend", "li", "main", "map", "mark", "marquee", "menu", "menuitem", "meter", "nav", "nobr", "ol", "optgroup", "option", "output", "p", "picture", "pre", "progress", "q", "rp", "rt", "ruby", "s", "samp", "section", "select", "shadow", "small", "source", "spacer", "span", "strike", "strong", "style", "sub", "summary", "sup", "table", "tbody", "td", "template", "textarea", "tfoot", "th", "thead", "time", "tr", "track", "tt", "u", "ul", "var", "video", "wbr"]);
var svg = freeze(["svg", "a", "altglyph", "altglyphdef", "altglyphitem", "animatecolor", "animatemotion", "animatetransform", "circle", "clippath", "defs", "desc", "ellipse", "filter", "font", "g", "glyph", "glyphref", "hkern", "image", "line", "lineargradient", "marker", "mask", "metadata", "mpath", "path", "pattern", "polygon", "polyline", "radialgradient", "rect", "stop", "style", "switch", "symbol", "text", "textpath", "title", "tref", "tspan", "view", "vkern"]);
var svgFilters = freeze(["feBlend", "feColorMatrix", "feComponentTransfer", "feComposite", "feConvolveMatrix", "feDiffuseLighting", "feDisplacementMap", "feDistantLight", "feFlood", "feFuncA", "feFuncB", "feFuncG", "feFuncR", "feGaussianBlur", "feImage", "feMerge", "feMergeNode", "feMorphology", "feOffset", "fePointLight", "feSpecularLighting", "feSpotLight", "feTile", "feTurbulence"]);
var svgDisallowed = freeze(["animate", "color-profile", "cursor", "discard", "fedropshadow", "font-face", "font-face-format", "font-face-name", "font-face-src", "font-face-uri", "foreignobject", "hatch", "hatchpath", "mesh", "meshgradient", "meshpatch", "meshrow", "missing-glyph", "script", "set", "solidcolor", "unknown", "use"]);
var mathMl = freeze(["math", "menclose", "merror", "mfenced", "mfrac", "mglyph", "mi", "mlabeledtr", "mmultiscripts", "mn", "mo", "mover", "mpadded", "mphantom", "mroot", "mrow", "ms", "mspace", "msqrt", "mstyle", "msub", "msup", "msubsup", "mtable", "mtd", "mtext", "mtr", "munder", "munderover"]);
var mathMlDisallowed = freeze(["maction", "maligngroup", "malignmark", "mlongdiv", "mscarries", "mscarry", "msgroup", "mstack", "msline", "msrow", "semantics", "annotation", "annotation-xml", "mprescripts", "none"]);
var text = freeze(["#text"]);
var html$1$1 = freeze(["accept", "action", "align", "alt", "autocapitalize", "autocomplete", "autopictureinpicture", "autoplay", "background", "bgcolor", "border", "capture", "cellpadding", "cellspacing", "checked", "cite", "class", "clear", "color", "cols", "colspan", "controls", "controlslist", "coords", "crossorigin", "datetime", "decoding", "default", "dir", "disabled", "disablepictureinpicture", "disableremoteplayback", "download", "draggable", "enctype", "enterkeyhint", "face", "for", "headers", "height", "hidden", "high", "href", "hreflang", "id", "inputmode", "integrity", "ismap", "kind", "label", "lang", "list", "loading", "loop", "low", "max", "maxlength", "media", "method", "min", "minlength", "multiple", "muted", "name", "nonce", "noshade", "novalidate", "nowrap", "open", "optimum", "pattern", "placeholder", "playsinline", "poster", "preload", "pubdate", "radiogroup", "readonly", "rel", "required", "rev", "reversed", "role", "rows", "rowspan", "spellcheck", "scope", "selected", "shape", "size", "sizes", "span", "srclang", "start", "src", "srcset", "step", "style", "summary", "tabindex", "title", "translate", "type", "usemap", "valign", "value", "width", "xmlns", "slot"]);
var svg$1 = freeze(["accent-height", "accumulate", "additive", "alignment-baseline", "ascent", "attributename", "attributetype", "azimuth", "basefrequency", "baseline-shift", "begin", "bias", "by", "class", "clip", "clippathunits", "clip-path", "clip-rule", "color", "color-interpolation", "color-interpolation-filters", "color-profile", "color-rendering", "cx", "cy", "d", "dx", "dy", "diffuseconstant", "direction", "display", "divisor", "dur", "edgemode", "elevation", "end", "fill", "fill-opacity", "fill-rule", "filter", "filterunits", "flood-color", "flood-opacity", "font-family", "font-size", "font-size-adjust", "font-stretch", "font-style", "font-variant", "font-weight", "fx", "fy", "g1", "g2", "glyph-name", "glyphref", "gradientunits", "gradienttransform", "height", "href", "id", "image-rendering", "in", "in2", "k", "k1", "k2", "k3", "k4", "kerning", "keypoints", "keysplines", "keytimes", "lang", "lengthadjust", "letter-spacing", "kernelmatrix", "kernelunitlength", "lighting-color", "local", "marker-end", "marker-mid", "marker-start", "markerheight", "markerunits", "markerwidth", "maskcontentunits", "maskunits", "max", "mask", "media", "method", "mode", "min", "name", "numoctaves", "offset", "operator", "opacity", "order", "orient", "orientation", "origin", "overflow", "paint-order", "path", "pathlength", "patterncontentunits", "patterntransform", "patternunits", "points", "preservealpha", "preserveaspectratio", "primitiveunits", "r", "rx", "ry", "radius", "refx", "refy", "repeatcount", "repeatdur", "restart", "result", "rotate", "scale", "seed", "shape-rendering", "specularconstant", "specularexponent", "spreadmethod", "startoffset", "stddeviation", "stitchtiles", "stop-color", "stop-opacity", "stroke-dasharray", "stroke-dashoffset", "stroke-linecap", "stroke-linejoin", "stroke-miterlimit", "stroke-opacity", "stroke", "stroke-width", "style", "surfacescale", "systemlanguage", "tabindex", "targetx", "targety", "transform", "transform-origin", "text-anchor", "text-decoration", "text-rendering", "textlength", "type", "u1", "u2", "unicode", "values", "viewbox", "visibility", "version", "vert-adv-y", "vert-origin-x", "vert-origin-y", "width", "word-spacing", "wrap", "writing-mode", "xchannelselector", "ychannelselector", "x", "x1", "x2", "xmlns", "y", "y1", "y2", "z", "zoomandpan"]);
var mathMl$1 = freeze(["accent", "accentunder", "align", "bevelled", "close", "columnsalign", "columnlines", "columnspan", "denomalign", "depth", "dir", "display", "displaystyle", "encoding", "fence", "frame", "height", "href", "id", "largeop", "length", "linethickness", "lspace", "lquote", "mathbackground", "mathcolor", "mathsize", "mathvariant", "maxsize", "minsize", "movablelimits", "notation", "numalign", "open", "rowalign", "rowlines", "rowspacing", "rowspan", "rspace", "rquote", "scriptlevel", "scriptminsize", "scriptsizemultiplier", "selection", "separator", "separators", "stretchy", "subscriptshift", "supscriptshift", "symmetric", "voffset", "width", "xmlns"]);
var xml = freeze(["xlink:href", "xml:id", "xlink:title", "xml:space", "xmlns:xlink"]);
var MUSTACHE_EXPR = seal(/\{\{[\s\S]*|[\s\S]*\}\}/gm);
var ERB_EXPR = seal(/<%[\s\S]*|[\s\S]*%>/gm);
var DATA_ATTR = seal(/^data-[\-\w.\u00B7-\uFFFF]/);
var ARIA_ATTR = seal(/^aria-[\-\w]+$/);
var IS_ALLOWED_URI = seal(/^(?:(?:(?:f|ht)tps?|mailto|tel|callto|cid|xmpp):|[^a-z]|[a-z+.\-]+(?:[^a-z+.\-:]|$))/i);
var IS_SCRIPT_OR_DATA = seal(/^(?:\w+script|data):/i);
var ATTR_WHITESPACE = seal(/[\u0000-\u0020\u00A0\u1680\u180E\u2000-\u2029\u205F\u3000]/g);
var _typeof$1 = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function(obj) {
  return typeof obj;
} : function(obj) {
  return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
};
function _toConsumableArray$1(arr) {
  if (Array.isArray(arr)) {
    for (var i2 = 0, arr2 = Array(arr.length); i2 < arr.length; i2++) {
      arr2[i2] = arr[i2];
    }
    return arr2;
  } else {
    return Array.from(arr);
  }
}
var getGlobal = function getGlobal2() {
  return typeof window === "undefined" ? null : window;
};
var _createTrustedTypesPolicy = function _createTrustedTypesPolicy2(trustedTypes, document2) {
  if ((typeof trustedTypes === "undefined" ? "undefined" : _typeof$1(trustedTypes)) !== "object" || typeof trustedTypes.createPolicy !== "function") {
    return null;
  }
  var suffix2 = null;
  var ATTR_NAME = "data-tt-policy-suffix";
  if (document2.currentScript && document2.currentScript.hasAttribute(ATTR_NAME)) {
    suffix2 = document2.currentScript.getAttribute(ATTR_NAME);
  }
  var policyName = "dompurify" + (suffix2 ? "#" + suffix2 : "");
  try {
    return trustedTypes.createPolicy(policyName, {
      createHTML: function createHTML(html$$1) {
        return html$$1;
      }
    });
  } catch (_2) {
    console.warn("TrustedTypes policy " + policyName + " could not be created.");
    return null;
  }
};
function createDOMPurify() {
  var window2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : getGlobal();
  var DOMPurify = function DOMPurify2(root2) {
    return createDOMPurify(root2);
  };
  DOMPurify.version = "2.3.5";
  DOMPurify.removed = [];
  if (!window2 || !window2.document || window2.document.nodeType !== 9) {
    DOMPurify.isSupported = false;
    return DOMPurify;
  }
  var originalDocument = window2.document;
  var document2 = window2.document;
  var DocumentFragment = window2.DocumentFragment, HTMLTemplateElement = window2.HTMLTemplateElement, Node2 = window2.Node, Element2 = window2.Element, NodeFilter = window2.NodeFilter, _window$NamedNodeMap = window2.NamedNodeMap, NamedNodeMap = _window$NamedNodeMap === void 0 ? window2.NamedNodeMap || window2.MozNamedAttrMap : _window$NamedNodeMap, HTMLFormElement = window2.HTMLFormElement, DOMParser2 = window2.DOMParser, trustedTypes = window2.trustedTypes;
  var ElementPrototype = Element2.prototype;
  var cloneNode = lookupGetter(ElementPrototype, "cloneNode");
  var getNextSibling = lookupGetter(ElementPrototype, "nextSibling");
  var getChildNodes = lookupGetter(ElementPrototype, "childNodes");
  var getParentNode = lookupGetter(ElementPrototype, "parentNode");
  if (typeof HTMLTemplateElement === "function") {
    var template = document2.createElement("template");
    if (template.content && template.content.ownerDocument) {
      document2 = template.content.ownerDocument;
    }
  }
  var trustedTypesPolicy = _createTrustedTypesPolicy(trustedTypes, originalDocument);
  var emptyHTML = trustedTypesPolicy ? trustedTypesPolicy.createHTML("") : "";
  var _document = document2, implementation = _document.implementation, createNodeIterator = _document.createNodeIterator, createDocumentFragment = _document.createDocumentFragment, getElementsByTagName = _document.getElementsByTagName;
  var importNode = originalDocument.importNode;
  var documentMode = {};
  try {
    documentMode = clone(document2).documentMode ? document2.documentMode : {};
  } catch (_2) {
  }
  var hooks = {};
  DOMPurify.isSupported = typeof getParentNode === "function" && implementation && typeof implementation.createHTMLDocument !== "undefined" && documentMode !== 9;
  var MUSTACHE_EXPR$$1 = MUSTACHE_EXPR, ERB_EXPR$$1 = ERB_EXPR, DATA_ATTR$$1 = DATA_ATTR, ARIA_ATTR$$1 = ARIA_ATTR, IS_SCRIPT_OR_DATA$$1 = IS_SCRIPT_OR_DATA, ATTR_WHITESPACE$$1 = ATTR_WHITESPACE;
  var IS_ALLOWED_URI$$1 = IS_ALLOWED_URI;
  var ALLOWED_TAGS = null;
  var DEFAULT_ALLOWED_TAGS = addToSet({}, [].concat(_toConsumableArray$1(html$3), _toConsumableArray$1(svg), _toConsumableArray$1(svgFilters), _toConsumableArray$1(mathMl), _toConsumableArray$1(text)));
  var ALLOWED_ATTR = null;
  var DEFAULT_ALLOWED_ATTR = addToSet({}, [].concat(_toConsumableArray$1(html$1$1), _toConsumableArray$1(svg$1), _toConsumableArray$1(mathMl$1), _toConsumableArray$1(xml)));
  var CUSTOM_ELEMENT_HANDLING = Object.seal(Object.create(null, {
    tagNameCheck: {
      writable: true,
      configurable: false,
      enumerable: true,
      value: null
    },
    attributeNameCheck: {
      writable: true,
      configurable: false,
      enumerable: true,
      value: null
    },
    allowCustomizedBuiltInElements: {
      writable: true,
      configurable: false,
      enumerable: true,
      value: false
    }
  }));
  var FORBID_TAGS = null;
  var FORBID_ATTR = null;
  var ALLOW_ARIA_ATTR = true;
  var ALLOW_DATA_ATTR = true;
  var ALLOW_UNKNOWN_PROTOCOLS = false;
  var SAFE_FOR_TEMPLATES = false;
  var WHOLE_DOCUMENT = false;
  var SET_CONFIG = false;
  var FORCE_BODY = false;
  var RETURN_DOM = false;
  var RETURN_DOM_FRAGMENT = false;
  var RETURN_TRUSTED_TYPE = false;
  var SANITIZE_DOM = true;
  var KEEP_CONTENT = true;
  var IN_PLACE = false;
  var USE_PROFILES = {};
  var FORBID_CONTENTS = null;
  var DEFAULT_FORBID_CONTENTS = addToSet({}, ["annotation-xml", "audio", "colgroup", "desc", "foreignobject", "head", "iframe", "math", "mi", "mn", "mo", "ms", "mtext", "noembed", "noframes", "noscript", "plaintext", "script", "style", "svg", "template", "thead", "title", "video", "xmp"]);
  var DATA_URI_TAGS = null;
  var DEFAULT_DATA_URI_TAGS = addToSet({}, ["audio", "video", "img", "source", "image", "track"]);
  var URI_SAFE_ATTRIBUTES = null;
  var DEFAULT_URI_SAFE_ATTRIBUTES = addToSet({}, ["alt", "class", "for", "id", "label", "name", "pattern", "placeholder", "role", "summary", "title", "value", "style", "xmlns"]);
  var MATHML_NAMESPACE = "http://www.w3.org/1998/Math/MathML";
  var SVG_NAMESPACE = "http://www.w3.org/2000/svg";
  var HTML_NAMESPACE = "http://www.w3.org/1999/xhtml";
  var NAMESPACE = HTML_NAMESPACE;
  var IS_EMPTY_INPUT = false;
  var PARSER_MEDIA_TYPE = void 0;
  var SUPPORTED_PARSER_MEDIA_TYPES = ["application/xhtml+xml", "text/html"];
  var DEFAULT_PARSER_MEDIA_TYPE = "text/html";
  var transformCaseFunc = void 0;
  var CONFIG = null;
  var formElement = document2.createElement("form");
  var isRegexOrFunction = function isRegexOrFunction2(testValue) {
    return testValue instanceof RegExp || testValue instanceof Function;
  };
  var _parseConfig = function _parseConfig2(cfg) {
    if (CONFIG && CONFIG === cfg) {
      return;
    }
    if (!cfg || (typeof cfg === "undefined" ? "undefined" : _typeof$1(cfg)) !== "object") {
      cfg = {};
    }
    cfg = clone(cfg);
    ALLOWED_TAGS = "ALLOWED_TAGS" in cfg ? addToSet({}, cfg.ALLOWED_TAGS) : DEFAULT_ALLOWED_TAGS;
    ALLOWED_ATTR = "ALLOWED_ATTR" in cfg ? addToSet({}, cfg.ALLOWED_ATTR) : DEFAULT_ALLOWED_ATTR;
    URI_SAFE_ATTRIBUTES = "ADD_URI_SAFE_ATTR" in cfg ? addToSet(clone(DEFAULT_URI_SAFE_ATTRIBUTES), cfg.ADD_URI_SAFE_ATTR) : DEFAULT_URI_SAFE_ATTRIBUTES;
    DATA_URI_TAGS = "ADD_DATA_URI_TAGS" in cfg ? addToSet(clone(DEFAULT_DATA_URI_TAGS), cfg.ADD_DATA_URI_TAGS) : DEFAULT_DATA_URI_TAGS;
    FORBID_CONTENTS = "FORBID_CONTENTS" in cfg ? addToSet({}, cfg.FORBID_CONTENTS) : DEFAULT_FORBID_CONTENTS;
    FORBID_TAGS = "FORBID_TAGS" in cfg ? addToSet({}, cfg.FORBID_TAGS) : {};
    FORBID_ATTR = "FORBID_ATTR" in cfg ? addToSet({}, cfg.FORBID_ATTR) : {};
    USE_PROFILES = "USE_PROFILES" in cfg ? cfg.USE_PROFILES : false;
    ALLOW_ARIA_ATTR = cfg.ALLOW_ARIA_ATTR !== false;
    ALLOW_DATA_ATTR = cfg.ALLOW_DATA_ATTR !== false;
    ALLOW_UNKNOWN_PROTOCOLS = cfg.ALLOW_UNKNOWN_PROTOCOLS || false;
    SAFE_FOR_TEMPLATES = cfg.SAFE_FOR_TEMPLATES || false;
    WHOLE_DOCUMENT = cfg.WHOLE_DOCUMENT || false;
    RETURN_DOM = cfg.RETURN_DOM || false;
    RETURN_DOM_FRAGMENT = cfg.RETURN_DOM_FRAGMENT || false;
    RETURN_TRUSTED_TYPE = cfg.RETURN_TRUSTED_TYPE || false;
    FORCE_BODY = cfg.FORCE_BODY || false;
    SANITIZE_DOM = cfg.SANITIZE_DOM !== false;
    KEEP_CONTENT = cfg.KEEP_CONTENT !== false;
    IN_PLACE = cfg.IN_PLACE || false;
    IS_ALLOWED_URI$$1 = cfg.ALLOWED_URI_REGEXP || IS_ALLOWED_URI$$1;
    NAMESPACE = cfg.NAMESPACE || HTML_NAMESPACE;
    if (cfg.CUSTOM_ELEMENT_HANDLING && isRegexOrFunction(cfg.CUSTOM_ELEMENT_HANDLING.tagNameCheck)) {
      CUSTOM_ELEMENT_HANDLING.tagNameCheck = cfg.CUSTOM_ELEMENT_HANDLING.tagNameCheck;
    }
    if (cfg.CUSTOM_ELEMENT_HANDLING && isRegexOrFunction(cfg.CUSTOM_ELEMENT_HANDLING.attributeNameCheck)) {
      CUSTOM_ELEMENT_HANDLING.attributeNameCheck = cfg.CUSTOM_ELEMENT_HANDLING.attributeNameCheck;
    }
    if (cfg.CUSTOM_ELEMENT_HANDLING && typeof cfg.CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements === "boolean") {
      CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements = cfg.CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements;
    }
    PARSER_MEDIA_TYPE = SUPPORTED_PARSER_MEDIA_TYPES.indexOf(cfg.PARSER_MEDIA_TYPE) === -1 ? PARSER_MEDIA_TYPE = DEFAULT_PARSER_MEDIA_TYPE : PARSER_MEDIA_TYPE = cfg.PARSER_MEDIA_TYPE;
    transformCaseFunc = PARSER_MEDIA_TYPE === "application/xhtml+xml" ? function(x2) {
      return x2;
    } : stringToLowerCase;
    if (SAFE_FOR_TEMPLATES) {
      ALLOW_DATA_ATTR = false;
    }
    if (RETURN_DOM_FRAGMENT) {
      RETURN_DOM = true;
    }
    if (USE_PROFILES) {
      ALLOWED_TAGS = addToSet({}, [].concat(_toConsumableArray$1(text)));
      ALLOWED_ATTR = [];
      if (USE_PROFILES.html === true) {
        addToSet(ALLOWED_TAGS, html$3);
        addToSet(ALLOWED_ATTR, html$1$1);
      }
      if (USE_PROFILES.svg === true) {
        addToSet(ALLOWED_TAGS, svg);
        addToSet(ALLOWED_ATTR, svg$1);
        addToSet(ALLOWED_ATTR, xml);
      }
      if (USE_PROFILES.svgFilters === true) {
        addToSet(ALLOWED_TAGS, svgFilters);
        addToSet(ALLOWED_ATTR, svg$1);
        addToSet(ALLOWED_ATTR, xml);
      }
      if (USE_PROFILES.mathMl === true) {
        addToSet(ALLOWED_TAGS, mathMl);
        addToSet(ALLOWED_ATTR, mathMl$1);
        addToSet(ALLOWED_ATTR, xml);
      }
    }
    if (cfg.ADD_TAGS) {
      if (ALLOWED_TAGS === DEFAULT_ALLOWED_TAGS) {
        ALLOWED_TAGS = clone(ALLOWED_TAGS);
      }
      addToSet(ALLOWED_TAGS, cfg.ADD_TAGS);
    }
    if (cfg.ADD_ATTR) {
      if (ALLOWED_ATTR === DEFAULT_ALLOWED_ATTR) {
        ALLOWED_ATTR = clone(ALLOWED_ATTR);
      }
      addToSet(ALLOWED_ATTR, cfg.ADD_ATTR);
    }
    if (cfg.ADD_URI_SAFE_ATTR) {
      addToSet(URI_SAFE_ATTRIBUTES, cfg.ADD_URI_SAFE_ATTR);
    }
    if (cfg.FORBID_CONTENTS) {
      if (FORBID_CONTENTS === DEFAULT_FORBID_CONTENTS) {
        FORBID_CONTENTS = clone(FORBID_CONTENTS);
      }
      addToSet(FORBID_CONTENTS, cfg.FORBID_CONTENTS);
    }
    if (KEEP_CONTENT) {
      ALLOWED_TAGS["#text"] = true;
    }
    if (WHOLE_DOCUMENT) {
      addToSet(ALLOWED_TAGS, ["html", "head", "body"]);
    }
    if (ALLOWED_TAGS.table) {
      addToSet(ALLOWED_TAGS, ["tbody"]);
      delete FORBID_TAGS.tbody;
    }
    if (freeze) {
      freeze(cfg);
    }
    CONFIG = cfg;
  };
  var MATHML_TEXT_INTEGRATION_POINTS = addToSet({}, ["mi", "mo", "mn", "ms", "mtext"]);
  var HTML_INTEGRATION_POINTS = addToSet({}, ["foreignobject", "desc", "title", "annotation-xml"]);
  var ALL_SVG_TAGS = addToSet({}, svg);
  addToSet(ALL_SVG_TAGS, svgFilters);
  addToSet(ALL_SVG_TAGS, svgDisallowed);
  var ALL_MATHML_TAGS = addToSet({}, mathMl);
  addToSet(ALL_MATHML_TAGS, mathMlDisallowed);
  var _checkValidNamespace = function _checkValidNamespace2(element) {
    var parent = getParentNode(element);
    if (!parent || !parent.tagName) {
      parent = {
        namespaceURI: HTML_NAMESPACE,
        tagName: "template"
      };
    }
    var tagName = stringToLowerCase(element.tagName);
    var parentTagName = stringToLowerCase(parent.tagName);
    if (element.namespaceURI === SVG_NAMESPACE) {
      if (parent.namespaceURI === HTML_NAMESPACE) {
        return tagName === "svg";
      }
      if (parent.namespaceURI === MATHML_NAMESPACE) {
        return tagName === "svg" && (parentTagName === "annotation-xml" || MATHML_TEXT_INTEGRATION_POINTS[parentTagName]);
      }
      return Boolean(ALL_SVG_TAGS[tagName]);
    }
    if (element.namespaceURI === MATHML_NAMESPACE) {
      if (parent.namespaceURI === HTML_NAMESPACE) {
        return tagName === "math";
      }
      if (parent.namespaceURI === SVG_NAMESPACE) {
        return tagName === "math" && HTML_INTEGRATION_POINTS[parentTagName];
      }
      return Boolean(ALL_MATHML_TAGS[tagName]);
    }
    if (element.namespaceURI === HTML_NAMESPACE) {
      if (parent.namespaceURI === SVG_NAMESPACE && !HTML_INTEGRATION_POINTS[parentTagName]) {
        return false;
      }
      if (parent.namespaceURI === MATHML_NAMESPACE && !MATHML_TEXT_INTEGRATION_POINTS[parentTagName]) {
        return false;
      }
      var commonSvgAndHTMLElements = addToSet({}, ["title", "style", "font", "a", "script"]);
      return !ALL_MATHML_TAGS[tagName] && (commonSvgAndHTMLElements[tagName] || !ALL_SVG_TAGS[tagName]);
    }
    return false;
  };
  var _forceRemove = function _forceRemove2(node2) {
    arrayPush(DOMPurify.removed, { element: node2 });
    try {
      node2.parentNode.removeChild(node2);
    } catch (_2) {
      try {
        node2.outerHTML = emptyHTML;
      } catch (_3) {
        node2.remove();
      }
    }
  };
  var _removeAttribute = function _removeAttribute2(name, node2) {
    try {
      arrayPush(DOMPurify.removed, {
        attribute: node2.getAttributeNode(name),
        from: node2
      });
    } catch (_2) {
      arrayPush(DOMPurify.removed, {
        attribute: null,
        from: node2
      });
    }
    node2.removeAttribute(name);
    if (name === "is" && !ALLOWED_ATTR[name]) {
      if (RETURN_DOM || RETURN_DOM_FRAGMENT) {
        try {
          _forceRemove(node2);
        } catch (_2) {
        }
      } else {
        try {
          node2.setAttribute(name, "");
        } catch (_2) {
        }
      }
    }
  };
  var _initDocument = function _initDocument2(dirty) {
    var doc = void 0;
    var leadingWhitespace = void 0;
    if (FORCE_BODY) {
      dirty = "<remove></remove>" + dirty;
    } else {
      var matches = stringMatch(dirty, /^[\r\n\t ]+/);
      leadingWhitespace = matches && matches[0];
    }
    if (PARSER_MEDIA_TYPE === "application/xhtml+xml") {
      dirty = '<html xmlns="http://www.w3.org/1999/xhtml"><head></head><body>' + dirty + "</body></html>";
    }
    var dirtyPayload = trustedTypesPolicy ? trustedTypesPolicy.createHTML(dirty) : dirty;
    if (NAMESPACE === HTML_NAMESPACE) {
      try {
        doc = new DOMParser2().parseFromString(dirtyPayload, PARSER_MEDIA_TYPE);
      } catch (_2) {
      }
    }
    if (!doc || !doc.documentElement) {
      doc = implementation.createDocument(NAMESPACE, "template", null);
      try {
        doc.documentElement.innerHTML = IS_EMPTY_INPUT ? "" : dirtyPayload;
      } catch (_2) {
      }
    }
    var body = doc.body || doc.documentElement;
    if (dirty && leadingWhitespace) {
      body.insertBefore(document2.createTextNode(leadingWhitespace), body.childNodes[0] || null);
    }
    if (NAMESPACE === HTML_NAMESPACE) {
      return getElementsByTagName.call(doc, WHOLE_DOCUMENT ? "html" : "body")[0];
    }
    return WHOLE_DOCUMENT ? doc.documentElement : body;
  };
  var _createIterator = function _createIterator2(root2) {
    return createNodeIterator.call(root2.ownerDocument || root2, root2, NodeFilter.SHOW_ELEMENT | NodeFilter.SHOW_COMMENT | NodeFilter.SHOW_TEXT, null, false);
  };
  var _isClobbered = function _isClobbered2(elm) {
    return elm instanceof HTMLFormElement && (typeof elm.nodeName !== "string" || typeof elm.textContent !== "string" || typeof elm.removeChild !== "function" || !(elm.attributes instanceof NamedNodeMap) || typeof elm.removeAttribute !== "function" || typeof elm.setAttribute !== "function" || typeof elm.namespaceURI !== "string" || typeof elm.insertBefore !== "function");
  };
  var _isNode = function _isNode2(object) {
    return (typeof Node2 === "undefined" ? "undefined" : _typeof$1(Node2)) === "object" ? object instanceof Node2 : object && (typeof object === "undefined" ? "undefined" : _typeof$1(object)) === "object" && typeof object.nodeType === "number" && typeof object.nodeName === "string";
  };
  var _executeHook = function _executeHook2(entryPoint, currentNode, data2) {
    if (!hooks[entryPoint]) {
      return;
    }
    arrayForEach(hooks[entryPoint], function(hook) {
      hook.call(DOMPurify, currentNode, data2, CONFIG);
    });
  };
  var _sanitizeElements = function _sanitizeElements2(currentNode) {
    var content2 = void 0;
    _executeHook("beforeSanitizeElements", currentNode, null);
    if (_isClobbered(currentNode)) {
      _forceRemove(currentNode);
      return true;
    }
    if (stringMatch(currentNode.nodeName, /[\u0080-\uFFFF]/)) {
      _forceRemove(currentNode);
      return true;
    }
    var tagName = transformCaseFunc(currentNode.nodeName);
    _executeHook("uponSanitizeElement", currentNode, {
      tagName,
      allowedTags: ALLOWED_TAGS
    });
    if (!_isNode(currentNode.firstElementChild) && (!_isNode(currentNode.content) || !_isNode(currentNode.content.firstElementChild)) && regExpTest(/<[/\w]/g, currentNode.innerHTML) && regExpTest(/<[/\w]/g, currentNode.textContent)) {
      _forceRemove(currentNode);
      return true;
    }
    if (tagName === "select" && regExpTest(/<template/i, currentNode.innerHTML)) {
      _forceRemove(currentNode);
      return true;
    }
    if (!ALLOWED_TAGS[tagName] || FORBID_TAGS[tagName]) {
      if (KEEP_CONTENT && !FORBID_CONTENTS[tagName]) {
        var parentNode = getParentNode(currentNode) || currentNode.parentNode;
        var childNodes = getChildNodes(currentNode) || currentNode.childNodes;
        if (childNodes && parentNode) {
          var childCount = childNodes.length;
          for (var i2 = childCount - 1; i2 >= 0; --i2) {
            parentNode.insertBefore(cloneNode(childNodes[i2], true), getNextSibling(currentNode));
          }
        }
      }
      if (!FORBID_TAGS[tagName] && _basicCustomElementTest(tagName)) {
        if (CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof RegExp && regExpTest(CUSTOM_ELEMENT_HANDLING.tagNameCheck, tagName))
          return false;
        if (CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof Function && CUSTOM_ELEMENT_HANDLING.tagNameCheck(tagName))
          return false;
      }
      _forceRemove(currentNode);
      return true;
    }
    if (currentNode instanceof Element2 && !_checkValidNamespace(currentNode)) {
      _forceRemove(currentNode);
      return true;
    }
    if ((tagName === "noscript" || tagName === "noembed") && regExpTest(/<\/no(script|embed)/i, currentNode.innerHTML)) {
      _forceRemove(currentNode);
      return true;
    }
    if (SAFE_FOR_TEMPLATES && currentNode.nodeType === 3) {
      content2 = currentNode.textContent;
      content2 = stringReplace(content2, MUSTACHE_EXPR$$1, " ");
      content2 = stringReplace(content2, ERB_EXPR$$1, " ");
      if (currentNode.textContent !== content2) {
        arrayPush(DOMPurify.removed, { element: currentNode.cloneNode() });
        currentNode.textContent = content2;
      }
    }
    _executeHook("afterSanitizeElements", currentNode, null);
    return false;
  };
  var _isValidAttribute = function _isValidAttribute2(lcTag, lcName, value) {
    if (SANITIZE_DOM && (lcName === "id" || lcName === "name") && (value in document2 || value in formElement)) {
      return false;
    }
    if (ALLOW_DATA_ATTR && !FORBID_ATTR[lcName] && regExpTest(DATA_ATTR$$1, lcName))
      ;
    else if (ALLOW_ARIA_ATTR && regExpTest(ARIA_ATTR$$1, lcName))
      ;
    else if (!ALLOWED_ATTR[lcName] || FORBID_ATTR[lcName]) {
      if (_basicCustomElementTest(lcTag) && (CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof RegExp && regExpTest(CUSTOM_ELEMENT_HANDLING.tagNameCheck, lcTag) || CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof Function && CUSTOM_ELEMENT_HANDLING.tagNameCheck(lcTag)) && (CUSTOM_ELEMENT_HANDLING.attributeNameCheck instanceof RegExp && regExpTest(CUSTOM_ELEMENT_HANDLING.attributeNameCheck, lcName) || CUSTOM_ELEMENT_HANDLING.attributeNameCheck instanceof Function && CUSTOM_ELEMENT_HANDLING.attributeNameCheck(lcName)) || lcName === "is" && CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements && (CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof RegExp && regExpTest(CUSTOM_ELEMENT_HANDLING.tagNameCheck, value) || CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof Function && CUSTOM_ELEMENT_HANDLING.tagNameCheck(value)))
        ;
      else {
        return false;
      }
    } else if (URI_SAFE_ATTRIBUTES[lcName])
      ;
    else if (regExpTest(IS_ALLOWED_URI$$1, stringReplace(value, ATTR_WHITESPACE$$1, "")))
      ;
    else if ((lcName === "src" || lcName === "xlink:href" || lcName === "href") && lcTag !== "script" && stringIndexOf$2(value, "data:") === 0 && DATA_URI_TAGS[lcTag])
      ;
    else if (ALLOW_UNKNOWN_PROTOCOLS && !regExpTest(IS_SCRIPT_OR_DATA$$1, stringReplace(value, ATTR_WHITESPACE$$1, "")))
      ;
    else if (!value)
      ;
    else {
      return false;
    }
    return true;
  };
  var _basicCustomElementTest = function _basicCustomElementTest2(tagName) {
    return tagName.indexOf("-") > 0;
  };
  var _sanitizeAttributes = function _sanitizeAttributes2(currentNode) {
    var attr = void 0;
    var value = void 0;
    var lcName = void 0;
    var l2 = void 0;
    _executeHook("beforeSanitizeAttributes", currentNode, null);
    var attributes = currentNode.attributes;
    if (!attributes) {
      return;
    }
    var hookEvent = {
      attrName: "",
      attrValue: "",
      keepAttr: true,
      allowedAttributes: ALLOWED_ATTR
    };
    l2 = attributes.length;
    while (l2--) {
      attr = attributes[l2];
      var _attr = attr, name = _attr.name, namespaceURI = _attr.namespaceURI;
      value = stringTrim$1(attr.value);
      lcName = transformCaseFunc(name);
      hookEvent.attrName = lcName;
      hookEvent.attrValue = value;
      hookEvent.keepAttr = true;
      hookEvent.forceKeepAttr = void 0;
      _executeHook("uponSanitizeAttribute", currentNode, hookEvent);
      value = hookEvent.attrValue;
      if (hookEvent.forceKeepAttr) {
        continue;
      }
      _removeAttribute(name, currentNode);
      if (!hookEvent.keepAttr) {
        continue;
      }
      if (regExpTest(/\/>/i, value)) {
        _removeAttribute(name, currentNode);
        continue;
      }
      if (SAFE_FOR_TEMPLATES) {
        value = stringReplace(value, MUSTACHE_EXPR$$1, " ");
        value = stringReplace(value, ERB_EXPR$$1, " ");
      }
      var lcTag = transformCaseFunc(currentNode.nodeName);
      if (!_isValidAttribute(lcTag, lcName, value)) {
        continue;
      }
      try {
        if (namespaceURI) {
          currentNode.setAttributeNS(namespaceURI, name, value);
        } else {
          currentNode.setAttribute(name, value);
        }
        arrayPop(DOMPurify.removed);
      } catch (_2) {
      }
    }
    _executeHook("afterSanitizeAttributes", currentNode, null);
  };
  var _sanitizeShadowDOM = function _sanitizeShadowDOM2(fragment) {
    var shadowNode = void 0;
    var shadowIterator = _createIterator(fragment);
    _executeHook("beforeSanitizeShadowDOM", fragment, null);
    while (shadowNode = shadowIterator.nextNode()) {
      _executeHook("uponSanitizeShadowNode", shadowNode, null);
      if (_sanitizeElements(shadowNode)) {
        continue;
      }
      if (shadowNode.content instanceof DocumentFragment) {
        _sanitizeShadowDOM2(shadowNode.content);
      }
      _sanitizeAttributes(shadowNode);
    }
    _executeHook("afterSanitizeShadowDOM", fragment, null);
  };
  DOMPurify.sanitize = function(dirty, cfg) {
    var body = void 0;
    var importedNode = void 0;
    var currentNode = void 0;
    var oldNode = void 0;
    var returnNode = void 0;
    IS_EMPTY_INPUT = !dirty;
    if (IS_EMPTY_INPUT) {
      dirty = "<!-->";
    }
    if (typeof dirty !== "string" && !_isNode(dirty)) {
      if (typeof dirty.toString !== "function") {
        throw typeErrorCreate("toString is not a function");
      } else {
        dirty = dirty.toString();
        if (typeof dirty !== "string") {
          throw typeErrorCreate("dirty is not a string, aborting");
        }
      }
    }
    if (!DOMPurify.isSupported) {
      if (_typeof$1(window2.toStaticHTML) === "object" || typeof window2.toStaticHTML === "function") {
        if (typeof dirty === "string") {
          return window2.toStaticHTML(dirty);
        }
        if (_isNode(dirty)) {
          return window2.toStaticHTML(dirty.outerHTML);
        }
      }
      return dirty;
    }
    if (!SET_CONFIG) {
      _parseConfig(cfg);
    }
    DOMPurify.removed = [];
    if (typeof dirty === "string") {
      IN_PLACE = false;
    }
    if (IN_PLACE) {
      if (dirty.nodeName) {
        var tagName = transformCaseFunc(dirty.nodeName);
        if (!ALLOWED_TAGS[tagName] || FORBID_TAGS[tagName]) {
          throw typeErrorCreate("root node is forbidden and cannot be sanitized in-place");
        }
      }
    } else if (dirty instanceof Node2) {
      body = _initDocument("<!---->");
      importedNode = body.ownerDocument.importNode(dirty, true);
      if (importedNode.nodeType === 1 && importedNode.nodeName === "BODY") {
        body = importedNode;
      } else if (importedNode.nodeName === "HTML") {
        body = importedNode;
      } else {
        body.appendChild(importedNode);
      }
    } else {
      if (!RETURN_DOM && !SAFE_FOR_TEMPLATES && !WHOLE_DOCUMENT && dirty.indexOf("<") === -1) {
        return trustedTypesPolicy && RETURN_TRUSTED_TYPE ? trustedTypesPolicy.createHTML(dirty) : dirty;
      }
      body = _initDocument(dirty);
      if (!body) {
        return RETURN_DOM ? null : RETURN_TRUSTED_TYPE ? emptyHTML : "";
      }
    }
    if (body && FORCE_BODY) {
      _forceRemove(body.firstChild);
    }
    var nodeIterator = _createIterator(IN_PLACE ? dirty : body);
    while (currentNode = nodeIterator.nextNode()) {
      if (currentNode.nodeType === 3 && currentNode === oldNode) {
        continue;
      }
      if (_sanitizeElements(currentNode)) {
        continue;
      }
      if (currentNode.content instanceof DocumentFragment) {
        _sanitizeShadowDOM(currentNode.content);
      }
      _sanitizeAttributes(currentNode);
      oldNode = currentNode;
    }
    oldNode = null;
    if (IN_PLACE) {
      return dirty;
    }
    if (RETURN_DOM) {
      if (RETURN_DOM_FRAGMENT) {
        returnNode = createDocumentFragment.call(body.ownerDocument);
        while (body.firstChild) {
          returnNode.appendChild(body.firstChild);
        }
      } else {
        returnNode = body;
      }
      if (ALLOWED_ATTR.shadowroot) {
        returnNode = importNode.call(originalDocument, returnNode, true);
      }
      return returnNode;
    }
    var serializedHTML = WHOLE_DOCUMENT ? body.outerHTML : body.innerHTML;
    if (SAFE_FOR_TEMPLATES) {
      serializedHTML = stringReplace(serializedHTML, MUSTACHE_EXPR$$1, " ");
      serializedHTML = stringReplace(serializedHTML, ERB_EXPR$$1, " ");
    }
    return trustedTypesPolicy && RETURN_TRUSTED_TYPE ? trustedTypesPolicy.createHTML(serializedHTML) : serializedHTML;
  };
  DOMPurify.setConfig = function(cfg) {
    _parseConfig(cfg);
    SET_CONFIG = true;
  };
  DOMPurify.clearConfig = function() {
    CONFIG = null;
    SET_CONFIG = false;
  };
  DOMPurify.isValidAttribute = function(tag, attr, value) {
    if (!CONFIG) {
      _parseConfig({});
    }
    var lcTag = transformCaseFunc(tag);
    var lcName = transformCaseFunc(attr);
    return _isValidAttribute(lcTag, lcName, value);
  };
  DOMPurify.addHook = function(entryPoint, hookFunction) {
    if (typeof hookFunction !== "function") {
      return;
    }
    hooks[entryPoint] = hooks[entryPoint] || [];
    arrayPush(hooks[entryPoint], hookFunction);
  };
  DOMPurify.removeHook = function(entryPoint) {
    if (hooks[entryPoint]) {
      arrayPop(hooks[entryPoint]);
    }
  };
  DOMPurify.removeHooks = function(entryPoint) {
    if (hooks[entryPoint]) {
      hooks[entryPoint] = [];
    }
  };
  DOMPurify.removeAllHooks = function() {
    hooks = {};
  };
  return DOMPurify;
}
var purify = createDOMPurify();
var purify_es = Object.freeze(Object.defineProperty({
  __proto__: null,
  "default": purify
}, Symbol.toStringTag, { value: "Module" }));
var check = function(it2) {
  return it2 && it2.Math == Math && it2;
};
var global$I = check(typeof globalThis == "object" && globalThis) || check(typeof window == "object" && window) || check(typeof self == "object" && self) || check(typeof commonjsGlobal == "object" && commonjsGlobal) || function() {
  return this;
}() || Function("return this")();
var objectGetOwnPropertyDescriptor = {};
var fails$k = function(exec2) {
  try {
    return !!exec2();
  } catch (error) {
    return true;
  }
};
var fails$j = fails$k;
var descriptors = !fails$j(function() {
  return Object.defineProperty({}, 1, { get: function() {
    return 7;
  } })[1] != 7;
});
var fails$i = fails$k;
var functionBindNative = !fails$i(function() {
  var test2 = function() {
  }.bind();
  return typeof test2 != "function" || test2.hasOwnProperty("prototype");
});
var NATIVE_BIND$3 = functionBindNative;
var call$f = Function.prototype.call;
var functionCall = NATIVE_BIND$3 ? call$f.bind(call$f) : function() {
  return call$f.apply(call$f, arguments);
};
var objectPropertyIsEnumerable = {};
var $propertyIsEnumerable = {}.propertyIsEnumerable;
var getOwnPropertyDescriptor$4 = Object.getOwnPropertyDescriptor;
var NASHORN_BUG = getOwnPropertyDescriptor$4 && !$propertyIsEnumerable.call({ 1: 2 }, 1);
objectPropertyIsEnumerable.f = NASHORN_BUG ? function propertyIsEnumerable(V2) {
  var descriptor = getOwnPropertyDescriptor$4(this, V2);
  return !!descriptor && descriptor.enumerable;
} : $propertyIsEnumerable;
var createPropertyDescriptor$4 = function(bitmap, value) {
  return {
    enumerable: !(bitmap & 1),
    configurable: !(bitmap & 2),
    writable: !(bitmap & 4),
    value
  };
};
var NATIVE_BIND$2 = functionBindNative;
var FunctionPrototype$2 = Function.prototype;
var bind$5 = FunctionPrototype$2.bind;
var call$e = FunctionPrototype$2.call;
var uncurryThis$q = NATIVE_BIND$2 && bind$5.bind(call$e, call$e);
var functionUncurryThis = NATIVE_BIND$2 ? function(fn) {
  return fn && uncurryThis$q(fn);
} : function(fn) {
  return fn && function() {
    return call$e.apply(fn, arguments);
  };
};
var uncurryThis$p = functionUncurryThis;
var toString$b = uncurryThis$p({}.toString);
var stringSlice$6 = uncurryThis$p("".slice);
var classofRaw$1 = function(it2) {
  return stringSlice$6(toString$b(it2), 8, -1);
};
var global$H = global$I;
var uncurryThis$o = functionUncurryThis;
var fails$h = fails$k;
var classof$8 = classofRaw$1;
var Object$5 = global$H.Object;
var split = uncurryThis$o("".split);
var indexedObject = fails$h(function() {
  return !Object$5("z").propertyIsEnumerable(0);
}) ? function(it2) {
  return classof$8(it2) == "String" ? split(it2, "") : Object$5(it2);
} : Object$5;
var global$G = global$I;
var TypeError$g = global$G.TypeError;
var requireObjectCoercible$a = function(it2) {
  if (it2 == void 0)
    throw TypeError$g("Can't call method on " + it2);
  return it2;
};
var IndexedObject$1 = indexedObject;
var requireObjectCoercible$9 = requireObjectCoercible$a;
var toIndexedObject$5 = function(it2) {
  return IndexedObject$1(requireObjectCoercible$9(it2));
};
var isCallable$j = function(argument) {
  return typeof argument == "function";
};
var isCallable$i = isCallable$j;
var isObject$8 = function(it2) {
  return typeof it2 == "object" ? it2 !== null : isCallable$i(it2);
};
var global$F = global$I;
var isCallable$h = isCallable$j;
var aFunction = function(argument) {
  return isCallable$h(argument) ? argument : void 0;
};
var getBuiltIn$7 = function(namespace, method) {
  return arguments.length < 2 ? aFunction(global$F[namespace]) : global$F[namespace] && global$F[namespace][method];
};
var uncurryThis$n = functionUncurryThis;
var objectIsPrototypeOf = uncurryThis$n({}.isPrototypeOf);
var getBuiltIn$6 = getBuiltIn$7;
var engineUserAgent = getBuiltIn$6("navigator", "userAgent") || "";
var global$E = global$I;
var userAgent$3 = engineUserAgent;
var process$4 = global$E.process;
var Deno = global$E.Deno;
var versions = process$4 && process$4.versions || Deno && Deno.version;
var v8 = versions && versions.v8;
var match;
var version;
if (v8) {
  match = v8.split(".");
  version = match[0] > 0 && match[0] < 4 ? 1 : +(match[0] + match[1]);
}
if (!version && userAgent$3) {
  match = userAgent$3.match(/Edge\/(\d+)/);
  if (!match || match[1] >= 74) {
    match = userAgent$3.match(/Chrome\/(\d+)/);
    if (match)
      version = +match[1];
  }
}
var engineV8Version = version;
var V8_VERSION$1 = engineV8Version;
var fails$g = fails$k;
var nativeSymbol = !!Object.getOwnPropertySymbols && !fails$g(function() {
  var symbol = Symbol();
  return !String(symbol) || !(Object(symbol) instanceof Symbol) || !Symbol.sham && V8_VERSION$1 && V8_VERSION$1 < 41;
});
var NATIVE_SYMBOL$1 = nativeSymbol;
var useSymbolAsUid = NATIVE_SYMBOL$1 && !Symbol.sham && typeof Symbol.iterator == "symbol";
var global$D = global$I;
var getBuiltIn$5 = getBuiltIn$7;
var isCallable$g = isCallable$j;
var isPrototypeOf$3 = objectIsPrototypeOf;
var USE_SYMBOL_AS_UID$1 = useSymbolAsUid;
var Object$4 = global$D.Object;
var isSymbol$2 = USE_SYMBOL_AS_UID$1 ? function(it2) {
  return typeof it2 == "symbol";
} : function(it2) {
  var $Symbol = getBuiltIn$5("Symbol");
  return isCallable$g($Symbol) && isPrototypeOf$3($Symbol.prototype, Object$4(it2));
};
var global$C = global$I;
var String$5 = global$C.String;
var tryToString$4 = function(argument) {
  try {
    return String$5(argument);
  } catch (error) {
    return "Object";
  }
};
var global$B = global$I;
var isCallable$f = isCallable$j;
var tryToString$3 = tryToString$4;
var TypeError$f = global$B.TypeError;
var aCallable$6 = function(argument) {
  if (isCallable$f(argument))
    return argument;
  throw TypeError$f(tryToString$3(argument) + " is not a function");
};
var aCallable$5 = aCallable$6;
var getMethod$6 = function(V2, P2) {
  var func = V2[P2];
  return func == null ? void 0 : aCallable$5(func);
};
var global$A = global$I;
var call$d = functionCall;
var isCallable$e = isCallable$j;
var isObject$7 = isObject$8;
var TypeError$e = global$A.TypeError;
var ordinaryToPrimitive$1 = function(input, pref) {
  var fn, val;
  if (pref === "string" && isCallable$e(fn = input.toString) && !isObject$7(val = call$d(fn, input)))
    return val;
  if (isCallable$e(fn = input.valueOf) && !isObject$7(val = call$d(fn, input)))
    return val;
  if (pref !== "string" && isCallable$e(fn = input.toString) && !isObject$7(val = call$d(fn, input)))
    return val;
  throw TypeError$e("Can't convert object to primitive value");
};
var shared$4 = { exports: {} };
var global$z = global$I;
var defineProperty$2 = Object.defineProperty;
var setGlobal$3 = function(key, value) {
  try {
    defineProperty$2(global$z, key, { value, configurable: true, writable: true });
  } catch (error) {
    global$z[key] = value;
  }
  return value;
};
var global$y = global$I;
var setGlobal$2 = setGlobal$3;
var SHARED = "__core-js_shared__";
var store$3 = global$y[SHARED] || setGlobal$2(SHARED, {});
var sharedStore = store$3;
var store$2 = sharedStore;
(shared$4.exports = function(key, value) {
  return store$2[key] || (store$2[key] = value !== void 0 ? value : {});
})("versions", []).push({
  version: "3.20.3",
  mode: "global",
  copyright: "\xA9 2014-2022 Denis Pushkarev (zloirock.ru)",
  license: "https://github.com/zloirock/core-js/blob/v3.20.3/LICENSE",
  source: "https://github.com/zloirock/core-js"
});
var global$x = global$I;
var requireObjectCoercible$8 = requireObjectCoercible$a;
var Object$3 = global$x.Object;
var toObject$4 = function(argument) {
  return Object$3(requireObjectCoercible$8(argument));
};
var uncurryThis$m = functionUncurryThis;
var toObject$3 = toObject$4;
var hasOwnProperty = uncurryThis$m({}.hasOwnProperty);
var hasOwnProperty_1 = Object.hasOwn || function hasOwn(it2, key) {
  return hasOwnProperty(toObject$3(it2), key);
};
var uncurryThis$l = functionUncurryThis;
var id$1 = 0;
var postfix = Math.random();
var toString$a = uncurryThis$l(1 .toString);
var uid$2 = function(key) {
  return "Symbol(" + (key === void 0 ? "" : key) + ")_" + toString$a(++id$1 + postfix, 36);
};
var global$w = global$I;
var shared$3 = shared$4.exports;
var hasOwn$9 = hasOwnProperty_1;
var uid$1 = uid$2;
var NATIVE_SYMBOL = nativeSymbol;
var USE_SYMBOL_AS_UID = useSymbolAsUid;
var WellKnownSymbolsStore = shared$3("wks");
var Symbol$1 = global$w.Symbol;
var symbolFor = Symbol$1 && Symbol$1["for"];
var createWellKnownSymbol = USE_SYMBOL_AS_UID ? Symbol$1 : Symbol$1 && Symbol$1.withoutSetter || uid$1;
var wellKnownSymbol$i = function(name) {
  if (!hasOwn$9(WellKnownSymbolsStore, name) || !(NATIVE_SYMBOL || typeof WellKnownSymbolsStore[name] == "string")) {
    var description = "Symbol." + name;
    if (NATIVE_SYMBOL && hasOwn$9(Symbol$1, name)) {
      WellKnownSymbolsStore[name] = Symbol$1[name];
    } else if (USE_SYMBOL_AS_UID && symbolFor) {
      WellKnownSymbolsStore[name] = symbolFor(description);
    } else {
      WellKnownSymbolsStore[name] = createWellKnownSymbol(description);
    }
  }
  return WellKnownSymbolsStore[name];
};
var global$v = global$I;
var call$c = functionCall;
var isObject$6 = isObject$8;
var isSymbol$1 = isSymbol$2;
var getMethod$5 = getMethod$6;
var ordinaryToPrimitive = ordinaryToPrimitive$1;
var wellKnownSymbol$h = wellKnownSymbol$i;
var TypeError$d = global$v.TypeError;
var TO_PRIMITIVE = wellKnownSymbol$h("toPrimitive");
var toPrimitive$1 = function(input, pref) {
  if (!isObject$6(input) || isSymbol$1(input))
    return input;
  var exoticToPrim = getMethod$5(input, TO_PRIMITIVE);
  var result;
  if (exoticToPrim) {
    if (pref === void 0)
      pref = "default";
    result = call$c(exoticToPrim, input, pref);
    if (!isObject$6(result) || isSymbol$1(result))
      return result;
    throw TypeError$d("Can't convert object to primitive value");
  }
  if (pref === void 0)
    pref = "number";
  return ordinaryToPrimitive(input, pref);
};
var toPrimitive = toPrimitive$1;
var isSymbol = isSymbol$2;
var toPropertyKey$3 = function(argument) {
  var key = toPrimitive(argument, "string");
  return isSymbol(key) ? key : key + "";
};
var global$u = global$I;
var isObject$5 = isObject$8;
var document$3 = global$u.document;
var EXISTS$1 = isObject$5(document$3) && isObject$5(document$3.createElement);
var documentCreateElement$2 = function(it2) {
  return EXISTS$1 ? document$3.createElement(it2) : {};
};
var DESCRIPTORS$8 = descriptors;
var fails$f = fails$k;
var createElement$1 = documentCreateElement$2;
var ie8DomDefine = !DESCRIPTORS$8 && !fails$f(function() {
  return Object.defineProperty(createElement$1("div"), "a", {
    get: function() {
      return 7;
    }
  }).a != 7;
});
var DESCRIPTORS$7 = descriptors;
var call$b = functionCall;
var propertyIsEnumerableModule = objectPropertyIsEnumerable;
var createPropertyDescriptor$3 = createPropertyDescriptor$4;
var toIndexedObject$4 = toIndexedObject$5;
var toPropertyKey$2 = toPropertyKey$3;
var hasOwn$8 = hasOwnProperty_1;
var IE8_DOM_DEFINE$1 = ie8DomDefine;
var $getOwnPropertyDescriptor$1 = Object.getOwnPropertyDescriptor;
objectGetOwnPropertyDescriptor.f = DESCRIPTORS$7 ? $getOwnPropertyDescriptor$1 : function getOwnPropertyDescriptor(O2, P2) {
  O2 = toIndexedObject$4(O2);
  P2 = toPropertyKey$2(P2);
  if (IE8_DOM_DEFINE$1)
    try {
      return $getOwnPropertyDescriptor$1(O2, P2);
    } catch (error) {
    }
  if (hasOwn$8(O2, P2))
    return createPropertyDescriptor$3(!call$b(propertyIsEnumerableModule.f, O2, P2), O2[P2]);
};
var objectDefineProperty = {};
var DESCRIPTORS$6 = descriptors;
var fails$e = fails$k;
var v8PrototypeDefineBug = DESCRIPTORS$6 && fails$e(function() {
  return Object.defineProperty(function() {
  }, "prototype", {
    value: 42,
    writable: false
  }).prototype != 42;
});
var global$t = global$I;
var isObject$4 = isObject$8;
var String$4 = global$t.String;
var TypeError$c = global$t.TypeError;
var anObject$g = function(argument) {
  if (isObject$4(argument))
    return argument;
  throw TypeError$c(String$4(argument) + " is not an object");
};
var global$s = global$I;
var DESCRIPTORS$5 = descriptors;
var IE8_DOM_DEFINE = ie8DomDefine;
var V8_PROTOTYPE_DEFINE_BUG$1 = v8PrototypeDefineBug;
var anObject$f = anObject$g;
var toPropertyKey$1 = toPropertyKey$3;
var TypeError$b = global$s.TypeError;
var $defineProperty = Object.defineProperty;
var $getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
var ENUMERABLE = "enumerable";
var CONFIGURABLE$1 = "configurable";
var WRITABLE = "writable";
objectDefineProperty.f = DESCRIPTORS$5 ? V8_PROTOTYPE_DEFINE_BUG$1 ? function defineProperty(O2, P2, Attributes2) {
  anObject$f(O2);
  P2 = toPropertyKey$1(P2);
  anObject$f(Attributes2);
  if (typeof O2 === "function" && P2 === "prototype" && "value" in Attributes2 && WRITABLE in Attributes2 && !Attributes2[WRITABLE]) {
    var current = $getOwnPropertyDescriptor(O2, P2);
    if (current && current[WRITABLE]) {
      O2[P2] = Attributes2.value;
      Attributes2 = {
        configurable: CONFIGURABLE$1 in Attributes2 ? Attributes2[CONFIGURABLE$1] : current[CONFIGURABLE$1],
        enumerable: ENUMERABLE in Attributes2 ? Attributes2[ENUMERABLE] : current[ENUMERABLE],
        writable: false
      };
    }
  }
  return $defineProperty(O2, P2, Attributes2);
} : $defineProperty : function defineProperty2(O2, P2, Attributes2) {
  anObject$f(O2);
  P2 = toPropertyKey$1(P2);
  anObject$f(Attributes2);
  if (IE8_DOM_DEFINE)
    try {
      return $defineProperty(O2, P2, Attributes2);
    } catch (error) {
    }
  if ("get" in Attributes2 || "set" in Attributes2)
    throw TypeError$b("Accessors not supported");
  if ("value" in Attributes2)
    O2[P2] = Attributes2.value;
  return O2;
};
var DESCRIPTORS$4 = descriptors;
var definePropertyModule$5 = objectDefineProperty;
var createPropertyDescriptor$2 = createPropertyDescriptor$4;
var createNonEnumerableProperty$6 = DESCRIPTORS$4 ? function(object, key, value) {
  return definePropertyModule$5.f(object, key, createPropertyDescriptor$2(1, value));
} : function(object, key, value) {
  object[key] = value;
  return object;
};
var redefine$7 = { exports: {} };
var uncurryThis$k = functionUncurryThis;
var isCallable$d = isCallable$j;
var store$1 = sharedStore;
var functionToString = uncurryThis$k(Function.toString);
if (!isCallable$d(store$1.inspectSource)) {
  store$1.inspectSource = function(it2) {
    return functionToString(it2);
  };
}
var inspectSource$4 = store$1.inspectSource;
var global$r = global$I;
var isCallable$c = isCallable$j;
var inspectSource$3 = inspectSource$4;
var WeakMap$1 = global$r.WeakMap;
var nativeWeakMap = isCallable$c(WeakMap$1) && /native code/.test(inspectSource$3(WeakMap$1));
var shared$2 = shared$4.exports;
var uid = uid$2;
var keys = shared$2("keys");
var sharedKey$3 = function(key) {
  return keys[key] || (keys[key] = uid(key));
};
var hiddenKeys$4 = {};
var NATIVE_WEAK_MAP = nativeWeakMap;
var global$q = global$I;
var uncurryThis$j = functionUncurryThis;
var isObject$3 = isObject$8;
var createNonEnumerableProperty$5 = createNonEnumerableProperty$6;
var hasOwn$7 = hasOwnProperty_1;
var shared$1 = sharedStore;
var sharedKey$2 = sharedKey$3;
var hiddenKeys$3 = hiddenKeys$4;
var OBJECT_ALREADY_INITIALIZED = "Object already initialized";
var TypeError$a = global$q.TypeError;
var WeakMap = global$q.WeakMap;
var set$1;
var get;
var has;
var enforce = function(it2) {
  return has(it2) ? get(it2) : set$1(it2, {});
};
var getterFor = function(TYPE) {
  return function(it2) {
    var state;
    if (!isObject$3(it2) || (state = get(it2)).type !== TYPE) {
      throw TypeError$a("Incompatible receiver, " + TYPE + " required");
    }
    return state;
  };
};
if (NATIVE_WEAK_MAP || shared$1.state) {
  store = shared$1.state || (shared$1.state = new WeakMap());
  wmget = uncurryThis$j(store.get);
  wmhas = uncurryThis$j(store.has);
  wmset = uncurryThis$j(store.set);
  set$1 = function(it2, metadata) {
    if (wmhas(store, it2))
      throw new TypeError$a(OBJECT_ALREADY_INITIALIZED);
    metadata.facade = it2;
    wmset(store, it2, metadata);
    return metadata;
  };
  get = function(it2) {
    return wmget(store, it2) || {};
  };
  has = function(it2) {
    return wmhas(store, it2);
  };
} else {
  STATE = sharedKey$2("state");
  hiddenKeys$3[STATE] = true;
  set$1 = function(it2, metadata) {
    if (hasOwn$7(it2, STATE))
      throw new TypeError$a(OBJECT_ALREADY_INITIALIZED);
    metadata.facade = it2;
    createNonEnumerableProperty$5(it2, STATE, metadata);
    return metadata;
  };
  get = function(it2) {
    return hasOwn$7(it2, STATE) ? it2[STATE] : {};
  };
  has = function(it2) {
    return hasOwn$7(it2, STATE);
  };
}
var store;
var wmget;
var wmhas;
var wmset;
var STATE;
var internalState = {
  set: set$1,
  get,
  has,
  enforce,
  getterFor
};
var DESCRIPTORS$3 = descriptors;
var hasOwn$6 = hasOwnProperty_1;
var FunctionPrototype$1 = Function.prototype;
var getDescriptor = DESCRIPTORS$3 && Object.getOwnPropertyDescriptor;
var EXISTS = hasOwn$6(FunctionPrototype$1, "name");
var PROPER = EXISTS && function something() {
}.name === "something";
var CONFIGURABLE = EXISTS && (!DESCRIPTORS$3 || DESCRIPTORS$3 && getDescriptor(FunctionPrototype$1, "name").configurable);
var functionName = {
  EXISTS,
  PROPER,
  CONFIGURABLE
};
var global$p = global$I;
var isCallable$b = isCallable$j;
var hasOwn$5 = hasOwnProperty_1;
var createNonEnumerableProperty$4 = createNonEnumerableProperty$6;
var setGlobal$1 = setGlobal$3;
var inspectSource$2 = inspectSource$4;
var InternalStateModule$2 = internalState;
var CONFIGURABLE_FUNCTION_NAME$1 = functionName.CONFIGURABLE;
var getInternalState$3 = InternalStateModule$2.get;
var enforceInternalState = InternalStateModule$2.enforce;
var TEMPLATE = String(String).split("String");
(redefine$7.exports = function(O2, key, value, options) {
  var unsafe = options ? !!options.unsafe : false;
  var simple = options ? !!options.enumerable : false;
  var noTargetGet = options ? !!options.noTargetGet : false;
  var name = options && options.name !== void 0 ? options.name : key;
  var state;
  if (isCallable$b(value)) {
    if (String(name).slice(0, 7) === "Symbol(") {
      name = "[" + String(name).replace(/^Symbol\(([^)]*)\)/, "$1") + "]";
    }
    if (!hasOwn$5(value, "name") || CONFIGURABLE_FUNCTION_NAME$1 && value.name !== name) {
      createNonEnumerableProperty$4(value, "name", name);
    }
    state = enforceInternalState(value);
    if (!state.source) {
      state.source = TEMPLATE.join(typeof name == "string" ? name : "");
    }
  }
  if (O2 === global$p) {
    if (simple)
      O2[key] = value;
    else
      setGlobal$1(key, value);
    return;
  } else if (!unsafe) {
    delete O2[key];
  } else if (!noTargetGet && O2[key]) {
    simple = true;
  }
  if (simple)
    O2[key] = value;
  else
    createNonEnumerableProperty$4(O2, key, value);
})(Function.prototype, "toString", function toString() {
  return isCallable$b(this) && getInternalState$3(this).source || inspectSource$2(this);
});
var objectGetOwnPropertyNames = {};
var ceil = Math.ceil;
var floor$1 = Math.floor;
var toIntegerOrInfinity$4 = function(argument) {
  var number = +argument;
  return number !== number || number === 0 ? 0 : (number > 0 ? floor$1 : ceil)(number);
};
var toIntegerOrInfinity$3 = toIntegerOrInfinity$4;
var max$2 = Math.max;
var min$5 = Math.min;
var toAbsoluteIndex$2 = function(index2, length) {
  var integer = toIntegerOrInfinity$3(index2);
  return integer < 0 ? max$2(integer + length, 0) : min$5(integer, length);
};
var toIntegerOrInfinity$2 = toIntegerOrInfinity$4;
var min$4 = Math.min;
var toLength$6 = function(argument) {
  return argument > 0 ? min$4(toIntegerOrInfinity$2(argument), 9007199254740991) : 0;
};
var toLength$5 = toLength$6;
var lengthOfArrayLike$4 = function(obj) {
  return toLength$5(obj.length);
};
var toIndexedObject$3 = toIndexedObject$5;
var toAbsoluteIndex$1 = toAbsoluteIndex$2;
var lengthOfArrayLike$3 = lengthOfArrayLike$4;
var createMethod$3 = function(IS_INCLUDES) {
  return function($this, el, fromIndex) {
    var O2 = toIndexedObject$3($this);
    var length = lengthOfArrayLike$3(O2);
    var index2 = toAbsoluteIndex$1(fromIndex, length);
    var value;
    if (IS_INCLUDES && el != el)
      while (length > index2) {
        value = O2[index2++];
        if (value != value)
          return true;
      }
    else
      for (; length > index2; index2++) {
        if ((IS_INCLUDES || index2 in O2) && O2[index2] === el)
          return IS_INCLUDES || index2 || 0;
      }
    return !IS_INCLUDES && -1;
  };
};
var arrayIncludes = {
  includes: createMethod$3(true),
  indexOf: createMethod$3(false)
};
var uncurryThis$i = functionUncurryThis;
var hasOwn$4 = hasOwnProperty_1;
var toIndexedObject$2 = toIndexedObject$5;
var indexOf$1 = arrayIncludes.indexOf;
var hiddenKeys$2 = hiddenKeys$4;
var push$2 = uncurryThis$i([].push);
var objectKeysInternal = function(object, names2) {
  var O2 = toIndexedObject$2(object);
  var i2 = 0;
  var result = [];
  var key;
  for (key in O2)
    !hasOwn$4(hiddenKeys$2, key) && hasOwn$4(O2, key) && push$2(result, key);
  while (names2.length > i2)
    if (hasOwn$4(O2, key = names2[i2++])) {
      ~indexOf$1(result, key) || push$2(result, key);
    }
  return result;
};
var enumBugKeys$3 = [
  "constructor",
  "hasOwnProperty",
  "isPrototypeOf",
  "propertyIsEnumerable",
  "toLocaleString",
  "toString",
  "valueOf"
];
var internalObjectKeys$1 = objectKeysInternal;
var enumBugKeys$2 = enumBugKeys$3;
var hiddenKeys$1 = enumBugKeys$2.concat("length", "prototype");
objectGetOwnPropertyNames.f = Object.getOwnPropertyNames || function getOwnPropertyNames(O2) {
  return internalObjectKeys$1(O2, hiddenKeys$1);
};
var objectGetOwnPropertySymbols = {};
objectGetOwnPropertySymbols.f = Object.getOwnPropertySymbols;
var getBuiltIn$4 = getBuiltIn$7;
var uncurryThis$h = functionUncurryThis;
var getOwnPropertyNamesModule = objectGetOwnPropertyNames;
var getOwnPropertySymbolsModule = objectGetOwnPropertySymbols;
var anObject$e = anObject$g;
var concat$1 = uncurryThis$h([].concat);
var ownKeys$4 = getBuiltIn$4("Reflect", "ownKeys") || function ownKeys(it2) {
  var keys3 = getOwnPropertyNamesModule.f(anObject$e(it2));
  var getOwnPropertySymbols = getOwnPropertySymbolsModule.f;
  return getOwnPropertySymbols ? concat$1(keys3, getOwnPropertySymbols(it2)) : keys3;
};
var hasOwn$3 = hasOwnProperty_1;
var ownKeys$3 = ownKeys$4;
var getOwnPropertyDescriptorModule = objectGetOwnPropertyDescriptor;
var definePropertyModule$4 = objectDefineProperty;
var copyConstructorProperties$1 = function(target, source, exceptions) {
  var keys3 = ownKeys$3(source);
  var defineProperty4 = definePropertyModule$4.f;
  var getOwnPropertyDescriptor3 = getOwnPropertyDescriptorModule.f;
  for (var i2 = 0; i2 < keys3.length; i2++) {
    var key = keys3[i2];
    if (!hasOwn$3(target, key) && !(exceptions && hasOwn$3(exceptions, key))) {
      defineProperty4(target, key, getOwnPropertyDescriptor3(source, key));
    }
  }
};
var fails$d = fails$k;
var isCallable$a = isCallable$j;
var replacement = /#|\.prototype\./;
var isForced$2 = function(feature2, detection) {
  var value = data[normalize(feature2)];
  return value == POLYFILL ? true : value == NATIVE ? false : isCallable$a(detection) ? fails$d(detection) : !!detection;
};
var normalize = isForced$2.normalize = function(string) {
  return String(string).replace(replacement, ".").toLowerCase();
};
var data = isForced$2.data = {};
var NATIVE = isForced$2.NATIVE = "N";
var POLYFILL = isForced$2.POLYFILL = "P";
var isForced_1 = isForced$2;
var global$o = global$I;
var getOwnPropertyDescriptor$3 = objectGetOwnPropertyDescriptor.f;
var createNonEnumerableProperty$3 = createNonEnumerableProperty$6;
var redefine$6 = redefine$7.exports;
var setGlobal = setGlobal$3;
var copyConstructorProperties = copyConstructorProperties$1;
var isForced$1 = isForced_1;
var _export = function(options, source) {
  var TARGET = options.target;
  var GLOBAL = options.global;
  var STATIC = options.stat;
  var FORCED2, target, key, targetProperty, sourceProperty, descriptor;
  if (GLOBAL) {
    target = global$o;
  } else if (STATIC) {
    target = global$o[TARGET] || setGlobal(TARGET, {});
  } else {
    target = (global$o[TARGET] || {}).prototype;
  }
  if (target)
    for (key in source) {
      sourceProperty = source[key];
      if (options.noTargetGet) {
        descriptor = getOwnPropertyDescriptor$3(target, key);
        targetProperty = descriptor && descriptor.value;
      } else
        targetProperty = target[key];
      FORCED2 = isForced$1(GLOBAL ? key : TARGET + (STATIC ? "." : "#") + key, options.forced);
      if (!FORCED2 && targetProperty !== void 0) {
        if (typeof sourceProperty == typeof targetProperty)
          continue;
        copyConstructorProperties(sourceProperty, targetProperty);
      }
      if (options.sham || targetProperty && targetProperty.sham) {
        createNonEnumerableProperty$3(sourceProperty, "sham", true);
      }
      redefine$6(target, key, sourceProperty, options);
    }
};
var global$n = global$I;
var nativePromiseConstructor = global$n.Promise;
var redefine$5 = redefine$7.exports;
var redefineAll$1 = function(target, src, options) {
  for (var key in src)
    redefine$5(target, key, src[key], options);
  return target;
};
var global$m = global$I;
var isCallable$9 = isCallable$j;
var String$3 = global$m.String;
var TypeError$9 = global$m.TypeError;
var aPossiblePrototype$1 = function(argument) {
  if (typeof argument == "object" || isCallable$9(argument))
    return argument;
  throw TypeError$9("Can't set " + String$3(argument) + " as a prototype");
};
var uncurryThis$g = functionUncurryThis;
var anObject$d = anObject$g;
var aPossiblePrototype = aPossiblePrototype$1;
var objectSetPrototypeOf = Object.setPrototypeOf || ("__proto__" in {} ? function() {
  var CORRECT_SETTER = false;
  var test2 = {};
  var setter;
  try {
    setter = uncurryThis$g(Object.getOwnPropertyDescriptor(Object.prototype, "__proto__").set);
    setter(test2, []);
    CORRECT_SETTER = test2 instanceof Array;
  } catch (error) {
  }
  return function setPrototypeOf2(O2, proto) {
    anObject$d(O2);
    aPossiblePrototype(proto);
    if (CORRECT_SETTER)
      setter(O2, proto);
    else
      O2.__proto__ = proto;
    return O2;
  };
}() : void 0);
var defineProperty$1 = objectDefineProperty.f;
var hasOwn$2 = hasOwnProperty_1;
var wellKnownSymbol$g = wellKnownSymbol$i;
var TO_STRING_TAG$3 = wellKnownSymbol$g("toStringTag");
var setToStringTag$3 = function(target, TAG, STATIC) {
  if (target && !STATIC)
    target = target.prototype;
  if (target && !hasOwn$2(target, TO_STRING_TAG$3)) {
    defineProperty$1(target, TO_STRING_TAG$3, { configurable: true, value: TAG });
  }
};
var getBuiltIn$3 = getBuiltIn$7;
var definePropertyModule$3 = objectDefineProperty;
var wellKnownSymbol$f = wellKnownSymbol$i;
var DESCRIPTORS$2 = descriptors;
var SPECIES$3 = wellKnownSymbol$f("species");
var setSpecies$1 = function(CONSTRUCTOR_NAME) {
  var Constructor = getBuiltIn$3(CONSTRUCTOR_NAME);
  var defineProperty4 = definePropertyModule$3.f;
  if (DESCRIPTORS$2 && Constructor && !Constructor[SPECIES$3]) {
    defineProperty4(Constructor, SPECIES$3, {
      configurable: true,
      get: function() {
        return this;
      }
    });
  }
};
var global$l = global$I;
var isPrototypeOf$2 = objectIsPrototypeOf;
var TypeError$8 = global$l.TypeError;
var anInstance$1 = function(it2, Prototype) {
  if (isPrototypeOf$2(Prototype, it2))
    return it2;
  throw TypeError$8("Incorrect invocation");
};
var uncurryThis$f = functionUncurryThis;
var aCallable$4 = aCallable$6;
var NATIVE_BIND$1 = functionBindNative;
var bind$4 = uncurryThis$f(uncurryThis$f.bind);
var functionBindContext = function(fn, that) {
  aCallable$4(fn);
  return that === void 0 ? fn : NATIVE_BIND$1 ? bind$4(fn, that) : function() {
    return fn.apply(that, arguments);
  };
};
var iterators = {};
var wellKnownSymbol$e = wellKnownSymbol$i;
var Iterators$4 = iterators;
var ITERATOR$5 = wellKnownSymbol$e("iterator");
var ArrayPrototype$1 = Array.prototype;
var isArrayIteratorMethod$1 = function(it2) {
  return it2 !== void 0 && (Iterators$4.Array === it2 || ArrayPrototype$1[ITERATOR$5] === it2);
};
var wellKnownSymbol$d = wellKnownSymbol$i;
var TO_STRING_TAG$2 = wellKnownSymbol$d("toStringTag");
var test$1 = {};
test$1[TO_STRING_TAG$2] = "z";
var toStringTagSupport = String(test$1) === "[object z]";
var global$k = global$I;
var TO_STRING_TAG_SUPPORT = toStringTagSupport;
var isCallable$8 = isCallable$j;
var classofRaw = classofRaw$1;
var wellKnownSymbol$c = wellKnownSymbol$i;
var TO_STRING_TAG$1 = wellKnownSymbol$c("toStringTag");
var Object$2 = global$k.Object;
var CORRECT_ARGUMENTS = classofRaw(function() {
  return arguments;
}()) == "Arguments";
var tryGet = function(it2, key) {
  try {
    return it2[key];
  } catch (error) {
  }
};
var classof$7 = TO_STRING_TAG_SUPPORT ? classofRaw : function(it2) {
  var O2, tag, result;
  return it2 === void 0 ? "Undefined" : it2 === null ? "Null" : typeof (tag = tryGet(O2 = Object$2(it2), TO_STRING_TAG$1)) == "string" ? tag : CORRECT_ARGUMENTS ? classofRaw(O2) : (result = classofRaw(O2)) == "Object" && isCallable$8(O2.callee) ? "Arguments" : result;
};
var classof$6 = classof$7;
var getMethod$4 = getMethod$6;
var Iterators$3 = iterators;
var wellKnownSymbol$b = wellKnownSymbol$i;
var ITERATOR$4 = wellKnownSymbol$b("iterator");
var getIteratorMethod$2 = function(it2) {
  if (it2 != void 0)
    return getMethod$4(it2, ITERATOR$4) || getMethod$4(it2, "@@iterator") || Iterators$3[classof$6(it2)];
};
var global$j = global$I;
var call$a = functionCall;
var aCallable$3 = aCallable$6;
var anObject$c = anObject$g;
var tryToString$2 = tryToString$4;
var getIteratorMethod$1 = getIteratorMethod$2;
var TypeError$7 = global$j.TypeError;
var getIterator$1 = function(argument, usingIterator) {
  var iteratorMethod = arguments.length < 2 ? getIteratorMethod$1(argument) : usingIterator;
  if (aCallable$3(iteratorMethod))
    return anObject$c(call$a(iteratorMethod, argument));
  throw TypeError$7(tryToString$2(argument) + " is not iterable");
};
var call$9 = functionCall;
var anObject$b = anObject$g;
var getMethod$3 = getMethod$6;
var iteratorClose$1 = function(iterator, kind, value) {
  var innerResult, innerError;
  anObject$b(iterator);
  try {
    innerResult = getMethod$3(iterator, "return");
    if (!innerResult) {
      if (kind === "throw")
        throw value;
      return value;
    }
    innerResult = call$9(innerResult, iterator);
  } catch (error) {
    innerError = true;
    innerResult = error;
  }
  if (kind === "throw")
    throw value;
  if (innerError)
    throw innerResult;
  anObject$b(innerResult);
  return value;
};
var global$i = global$I;
var bind$3 = functionBindContext;
var call$8 = functionCall;
var anObject$a = anObject$g;
var tryToString$1 = tryToString$4;
var isArrayIteratorMethod = isArrayIteratorMethod$1;
var lengthOfArrayLike$2 = lengthOfArrayLike$4;
var isPrototypeOf$1 = objectIsPrototypeOf;
var getIterator = getIterator$1;
var getIteratorMethod = getIteratorMethod$2;
var iteratorClose = iteratorClose$1;
var TypeError$6 = global$i.TypeError;
var Result = function(stopped, result) {
  this.stopped = stopped;
  this.result = result;
};
var ResultPrototype = Result.prototype;
var iterate$1 = function(iterable, unboundFunction, options) {
  var that = options && options.that;
  var AS_ENTRIES = !!(options && options.AS_ENTRIES);
  var IS_ITERATOR = !!(options && options.IS_ITERATOR);
  var INTERRUPTED = !!(options && options.INTERRUPTED);
  var fn = bind$3(unboundFunction, that);
  var iterator, iterFn, index2, length, result, next, step;
  var stop = function(condition) {
    if (iterator)
      iteratorClose(iterator, "normal", condition);
    return new Result(true, condition);
  };
  var callFn = function(value) {
    if (AS_ENTRIES) {
      anObject$a(value);
      return INTERRUPTED ? fn(value[0], value[1], stop) : fn(value[0], value[1]);
    }
    return INTERRUPTED ? fn(value, stop) : fn(value);
  };
  if (IS_ITERATOR) {
    iterator = iterable;
  } else {
    iterFn = getIteratorMethod(iterable);
    if (!iterFn)
      throw TypeError$6(tryToString$1(iterable) + " is not iterable");
    if (isArrayIteratorMethod(iterFn)) {
      for (index2 = 0, length = lengthOfArrayLike$2(iterable); length > index2; index2++) {
        result = callFn(iterable[index2]);
        if (result && isPrototypeOf$1(ResultPrototype, result))
          return result;
      }
      return new Result(false);
    }
    iterator = getIterator(iterable, iterFn);
  }
  next = iterator.next;
  while (!(step = call$8(next, iterator)).done) {
    try {
      result = callFn(step.value);
    } catch (error) {
      iteratorClose(iterator, "throw", error);
    }
    if (typeof result == "object" && result && isPrototypeOf$1(ResultPrototype, result))
      return result;
  }
  return new Result(false);
};
var wellKnownSymbol$a = wellKnownSymbol$i;
var ITERATOR$3 = wellKnownSymbol$a("iterator");
var SAFE_CLOSING = false;
try {
  called = 0;
  iteratorWithReturn = {
    next: function() {
      return { done: !!called++ };
    },
    "return": function() {
      SAFE_CLOSING = true;
    }
  };
  iteratorWithReturn[ITERATOR$3] = function() {
    return this;
  };
  Array.from(iteratorWithReturn, function() {
    throw 2;
  });
} catch (error) {
}
var called;
var iteratorWithReturn;
var checkCorrectnessOfIteration$1 = function(exec2, SKIP_CLOSING) {
  if (!SKIP_CLOSING && !SAFE_CLOSING)
    return false;
  var ITERATION_SUPPORT = false;
  try {
    var object = {};
    object[ITERATOR$3] = function() {
      return {
        next: function() {
          return { done: ITERATION_SUPPORT = true };
        }
      };
    };
    exec2(object);
  } catch (error) {
  }
  return ITERATION_SUPPORT;
};
var uncurryThis$e = functionUncurryThis;
var fails$c = fails$k;
var isCallable$7 = isCallable$j;
var classof$5 = classof$7;
var getBuiltIn$2 = getBuiltIn$7;
var inspectSource$1 = inspectSource$4;
var noop$1 = function() {
};
var empty = [];
var construct = getBuiltIn$2("Reflect", "construct");
var constructorRegExp = /^\s*(?:class|function)\b/;
var exec$2 = uncurryThis$e(constructorRegExp.exec);
var INCORRECT_TO_STRING = !constructorRegExp.exec(noop$1);
var isConstructorModern = function isConstructor(argument) {
  if (!isCallable$7(argument))
    return false;
  try {
    construct(noop$1, empty, argument);
    return true;
  } catch (error) {
    return false;
  }
};
var isConstructorLegacy = function isConstructor2(argument) {
  if (!isCallable$7(argument))
    return false;
  switch (classof$5(argument)) {
    case "AsyncFunction":
    case "GeneratorFunction":
    case "AsyncGeneratorFunction":
      return false;
  }
  try {
    return INCORRECT_TO_STRING || !!exec$2(constructorRegExp, inspectSource$1(argument));
  } catch (error) {
    return true;
  }
};
isConstructorLegacy.sham = true;
var isConstructor$1 = !construct || fails$c(function() {
  var called;
  return isConstructorModern(isConstructorModern.call) || !isConstructorModern(Object) || !isConstructorModern(function() {
    called = true;
  }) || called;
}) ? isConstructorLegacy : isConstructorModern;
var global$h = global$I;
var isConstructor3 = isConstructor$1;
var tryToString = tryToString$4;
var TypeError$5 = global$h.TypeError;
var aConstructor$1 = function(argument) {
  if (isConstructor3(argument))
    return argument;
  throw TypeError$5(tryToString(argument) + " is not a constructor");
};
var anObject$9 = anObject$g;
var aConstructor = aConstructor$1;
var wellKnownSymbol$9 = wellKnownSymbol$i;
var SPECIES$2 = wellKnownSymbol$9("species");
var speciesConstructor$2 = function(O2, defaultConstructor) {
  var C2 = anObject$9(O2).constructor;
  var S2;
  return C2 === void 0 || (S2 = anObject$9(C2)[SPECIES$2]) == void 0 ? defaultConstructor : aConstructor(S2);
};
var NATIVE_BIND = functionBindNative;
var FunctionPrototype = Function.prototype;
var apply$3 = FunctionPrototype.apply;
var call$7 = FunctionPrototype.call;
var functionApply = typeof Reflect == "object" && Reflect.apply || (NATIVE_BIND ? call$7.bind(apply$3) : function() {
  return call$7.apply(apply$3, arguments);
});
var getBuiltIn$1 = getBuiltIn$7;
var html$2 = getBuiltIn$1("document", "documentElement");
var uncurryThis$d = functionUncurryThis;
var arraySlice$2 = uncurryThis$d([].slice);
var userAgent$2 = engineUserAgent;
var engineIsIos = /(?:ipad|iphone|ipod).*applewebkit/i.test(userAgent$2);
var classof$4 = classofRaw$1;
var global$g = global$I;
var engineIsNode = classof$4(global$g.process) == "process";
var global$f = global$I;
var apply$2 = functionApply;
var bind$2 = functionBindContext;
var isCallable$6 = isCallable$j;
var hasOwn$1 = hasOwnProperty_1;
var fails$b = fails$k;
var html$1 = html$2;
var arraySlice$1 = arraySlice$2;
var createElement = documentCreateElement$2;
var IS_IOS$1 = engineIsIos;
var IS_NODE$3 = engineIsNode;
var set = global$f.setImmediate;
var clear = global$f.clearImmediate;
var process$3 = global$f.process;
var Dispatch = global$f.Dispatch;
var Function$1 = global$f.Function;
var MessageChannel = global$f.MessageChannel;
var String$2 = global$f.String;
var counter = 0;
var queue$2 = {};
var ONREADYSTATECHANGE = "onreadystatechange";
var location$1;
var defer;
var channel;
var port;
try {
  location$1 = global$f.location;
} catch (error) {
}
var run = function(id) {
  if (hasOwn$1(queue$2, id)) {
    var fn = queue$2[id];
    delete queue$2[id];
    fn();
  }
};
var runner = function(id) {
  return function() {
    run(id);
  };
};
var listener = function(event) {
  run(event.data);
};
var post = function(id) {
  global$f.postMessage(String$2(id), location$1.protocol + "//" + location$1.host);
};
if (!set || !clear) {
  set = function setImmediate(fn) {
    var args = arraySlice$1(arguments, 1);
    queue$2[++counter] = function() {
      apply$2(isCallable$6(fn) ? fn : Function$1(fn), void 0, args);
    };
    defer(counter);
    return counter;
  };
  clear = function clearImmediate(id) {
    delete queue$2[id];
  };
  if (IS_NODE$3) {
    defer = function(id) {
      process$3.nextTick(runner(id));
    };
  } else if (Dispatch && Dispatch.now) {
    defer = function(id) {
      Dispatch.now(runner(id));
    };
  } else if (MessageChannel && !IS_IOS$1) {
    channel = new MessageChannel();
    port = channel.port2;
    channel.port1.onmessage = listener;
    defer = bind$2(port.postMessage, port);
  } else if (global$f.addEventListener && isCallable$6(global$f.postMessage) && !global$f.importScripts && location$1 && location$1.protocol !== "file:" && !fails$b(post)) {
    defer = post;
    global$f.addEventListener("message", listener, false);
  } else if (ONREADYSTATECHANGE in createElement("script")) {
    defer = function(id) {
      html$1.appendChild(createElement("script"))[ONREADYSTATECHANGE] = function() {
        html$1.removeChild(this);
        run(id);
      };
    };
  } else {
    defer = function(id) {
      setTimeout(runner(id), 0);
    };
  }
}
var task$1 = {
  set,
  clear
};
var userAgent$1 = engineUserAgent;
var global$e = global$I;
var engineIsIosPebble = /ipad|iphone|ipod/i.test(userAgent$1) && global$e.Pebble !== void 0;
var userAgent = engineUserAgent;
var engineIsWebosWebkit = /web0s(?!.*chrome)/i.test(userAgent);
var global$d = global$I;
var bind$1 = functionBindContext;
var getOwnPropertyDescriptor$2 = objectGetOwnPropertyDescriptor.f;
var macrotask = task$1.set;
var IS_IOS = engineIsIos;
var IS_IOS_PEBBLE = engineIsIosPebble;
var IS_WEBOS_WEBKIT = engineIsWebosWebkit;
var IS_NODE$2 = engineIsNode;
var MutationObserver = global$d.MutationObserver || global$d.WebKitMutationObserver;
var document$2 = global$d.document;
var process$2 = global$d.process;
var Promise$1 = global$d.Promise;
var queueMicrotaskDescriptor = getOwnPropertyDescriptor$2(global$d, "queueMicrotask");
var queueMicrotask = queueMicrotaskDescriptor && queueMicrotaskDescriptor.value;
var flush;
var head;
var last$1;
var notify$1;
var toggle;
var node$1;
var promise;
var then;
if (!queueMicrotask) {
  flush = function() {
    var parent, fn;
    if (IS_NODE$2 && (parent = process$2.domain))
      parent.exit();
    while (head) {
      fn = head.fn;
      head = head.next;
      try {
        fn();
      } catch (error) {
        if (head)
          notify$1();
        else
          last$1 = void 0;
        throw error;
      }
    }
    last$1 = void 0;
    if (parent)
      parent.enter();
  };
  if (!IS_IOS && !IS_NODE$2 && !IS_WEBOS_WEBKIT && MutationObserver && document$2) {
    toggle = true;
    node$1 = document$2.createTextNode("");
    new MutationObserver(flush).observe(node$1, { characterData: true });
    notify$1 = function() {
      node$1.data = toggle = !toggle;
    };
  } else if (!IS_IOS_PEBBLE && Promise$1 && Promise$1.resolve) {
    promise = Promise$1.resolve(void 0);
    promise.constructor = Promise$1;
    then = bind$1(promise.then, promise);
    notify$1 = function() {
      then(flush);
    };
  } else if (IS_NODE$2) {
    notify$1 = function() {
      process$2.nextTick(flush);
    };
  } else {
    macrotask = bind$1(macrotask, global$d);
    notify$1 = function() {
      macrotask(flush);
    };
  }
}
var microtask$1 = queueMicrotask || function(fn) {
  var task2 = { fn, next: void 0 };
  if (last$1)
    last$1.next = task2;
  if (!head) {
    head = task2;
    notify$1();
  }
  last$1 = task2;
};
var newPromiseCapability$2 = {};
var aCallable$2 = aCallable$6;
var PromiseCapability = function(C2) {
  var resolve2, reject2;
  this.promise = new C2(function($$resolve, $$reject) {
    if (resolve2 !== void 0 || reject2 !== void 0)
      throw TypeError("Bad Promise constructor");
    resolve2 = $$resolve;
    reject2 = $$reject;
  });
  this.resolve = aCallable$2(resolve2);
  this.reject = aCallable$2(reject2);
};
newPromiseCapability$2.f = function(C2) {
  return new PromiseCapability(C2);
};
var anObject$8 = anObject$g;
var isObject$2 = isObject$8;
var newPromiseCapability$1 = newPromiseCapability$2;
var promiseResolve$1 = function(C2, x2) {
  anObject$8(C2);
  if (isObject$2(x2) && x2.constructor === C2)
    return x2;
  var promiseCapability = newPromiseCapability$1.f(C2);
  var resolve2 = promiseCapability.resolve;
  resolve2(x2);
  return promiseCapability.promise;
};
var global$c = global$I;
var hostReportErrors$1 = function(a2, b2) {
  var console2 = global$c.console;
  if (console2 && console2.error) {
    arguments.length == 1 ? console2.error(a2) : console2.error(a2, b2);
  }
};
var perform$1 = function(exec2) {
  try {
    return { error: false, value: exec2() };
  } catch (error) {
    return { error: true, value: error };
  }
};
var Queue$1 = function() {
  this.head = null;
  this.tail = null;
};
Queue$1.prototype = {
  add: function(item) {
    var entry = { item, next: null };
    if (this.head)
      this.tail.next = entry;
    else
      this.head = entry;
    this.tail = entry;
  },
  get: function() {
    var entry = this.head;
    if (entry) {
      this.head = entry.next;
      if (this.tail === entry)
        this.tail = null;
      return entry.item;
    }
  }
};
var queue$1 = Queue$1;
var engineIsBrowser = typeof window == "object";
var $$9 = _export;
var global$b = global$I;
var getBuiltIn = getBuiltIn$7;
var call$6 = functionCall;
var NativePromise = nativePromiseConstructor;
var redefine$4 = redefine$7.exports;
var redefineAll = redefineAll$1;
var setPrototypeOf$1 = objectSetPrototypeOf;
var setToStringTag$2 = setToStringTag$3;
var setSpecies = setSpecies$1;
var aCallable$1 = aCallable$6;
var isCallable$5 = isCallable$j;
var isObject$1 = isObject$8;
var anInstance = anInstance$1;
var inspectSource = inspectSource$4;
var iterate = iterate$1;
var checkCorrectnessOfIteration = checkCorrectnessOfIteration$1;
var speciesConstructor$1 = speciesConstructor$2;
var task = task$1.set;
var microtask = microtask$1;
var promiseResolve = promiseResolve$1;
var hostReportErrors = hostReportErrors$1;
var newPromiseCapabilityModule = newPromiseCapability$2;
var perform = perform$1;
var Queue = queue$1;
var InternalStateModule$1 = internalState;
var isForced = isForced_1;
var wellKnownSymbol$8 = wellKnownSymbol$i;
var IS_BROWSER = engineIsBrowser;
var IS_NODE$1 = engineIsNode;
var V8_VERSION = engineV8Version;
var SPECIES$1 = wellKnownSymbol$8("species");
var PROMISE = "Promise";
var getInternalState$2 = InternalStateModule$1.getterFor(PROMISE);
var setInternalState$1 = InternalStateModule$1.set;
var getInternalPromiseState = InternalStateModule$1.getterFor(PROMISE);
var NativePromisePrototype = NativePromise && NativePromise.prototype;
var PromiseConstructor = NativePromise;
var PromisePrototype = NativePromisePrototype;
var TypeError$4 = global$b.TypeError;
var document$1 = global$b.document;
var process$1 = global$b.process;
var newPromiseCapability = newPromiseCapabilityModule.f;
var newGenericPromiseCapability = newPromiseCapability;
var DISPATCH_EVENT = !!(document$1 && document$1.createEvent && global$b.dispatchEvent);
var NATIVE_REJECTION_EVENT = isCallable$5(global$b.PromiseRejectionEvent);
var UNHANDLED_REJECTION = "unhandledrejection";
var REJECTION_HANDLED = "rejectionhandled";
var PENDING = 0;
var FULFILLED = 1;
var REJECTED = 2;
var HANDLED = 1;
var UNHANDLED = 2;
var SUBCLASSING = false;
var Internal;
var OwnPromiseCapability;
var PromiseWrapper;
var nativeThen;
var FORCED = isForced(PROMISE, function() {
  var PROMISE_CONSTRUCTOR_SOURCE = inspectSource(PromiseConstructor);
  var GLOBAL_CORE_JS_PROMISE = PROMISE_CONSTRUCTOR_SOURCE !== String(PromiseConstructor);
  if (!GLOBAL_CORE_JS_PROMISE && V8_VERSION === 66)
    return true;
  if (V8_VERSION >= 51 && /native code/.test(PROMISE_CONSTRUCTOR_SOURCE))
    return false;
  var promise2 = new PromiseConstructor(function(resolve2) {
    resolve2(1);
  });
  var FakePromise = function(exec2) {
    exec2(function() {
    }, function() {
    });
  };
  var constructor = promise2.constructor = {};
  constructor[SPECIES$1] = FakePromise;
  SUBCLASSING = promise2.then(function() {
  }) instanceof FakePromise;
  if (!SUBCLASSING)
    return true;
  return !GLOBAL_CORE_JS_PROMISE && IS_BROWSER && !NATIVE_REJECTION_EVENT;
});
var INCORRECT_ITERATION = FORCED || !checkCorrectnessOfIteration(function(iterable) {
  PromiseConstructor.all(iterable)["catch"](function() {
  });
});
var isThenable = function(it2) {
  var then2;
  return isObject$1(it2) && isCallable$5(then2 = it2.then) ? then2 : false;
};
var callReaction = function(reaction, state) {
  var value = state.value;
  var ok = state.state == FULFILLED;
  var handler = ok ? reaction.ok : reaction.fail;
  var resolve2 = reaction.resolve;
  var reject2 = reaction.reject;
  var domain = reaction.domain;
  var result, then2, exited;
  try {
    if (handler) {
      if (!ok) {
        if (state.rejection === UNHANDLED)
          onHandleUnhandled(state);
        state.rejection = HANDLED;
      }
      if (handler === true)
        result = value;
      else {
        if (domain)
          domain.enter();
        result = handler(value);
        if (domain) {
          domain.exit();
          exited = true;
        }
      }
      if (result === reaction.promise) {
        reject2(TypeError$4("Promise-chain cycle"));
      } else if (then2 = isThenable(result)) {
        call$6(then2, result, resolve2, reject2);
      } else
        resolve2(result);
    } else
      reject2(value);
  } catch (error) {
    if (domain && !exited)
      domain.exit();
    reject2(error);
  }
};
var notify = function(state, isReject) {
  if (state.notified)
    return;
  state.notified = true;
  microtask(function() {
    var reactions = state.reactions;
    var reaction;
    while (reaction = reactions.get()) {
      callReaction(reaction, state);
    }
    state.notified = false;
    if (isReject && !state.rejection)
      onUnhandled(state);
  });
};
var dispatchEvent = function(name, promise2, reason) {
  var event, handler;
  if (DISPATCH_EVENT) {
    event = document$1.createEvent("Event");
    event.promise = promise2;
    event.reason = reason;
    event.initEvent(name, false, true);
    global$b.dispatchEvent(event);
  } else
    event = { promise: promise2, reason };
  if (!NATIVE_REJECTION_EVENT && (handler = global$b["on" + name]))
    handler(event);
  else if (name === UNHANDLED_REJECTION)
    hostReportErrors("Unhandled promise rejection", reason);
};
var onUnhandled = function(state) {
  call$6(task, global$b, function() {
    var promise2 = state.facade;
    var value = state.value;
    var IS_UNHANDLED = isUnhandled(state);
    var result;
    if (IS_UNHANDLED) {
      result = perform(function() {
        if (IS_NODE$1) {
          process$1.emit("unhandledRejection", value, promise2);
        } else
          dispatchEvent(UNHANDLED_REJECTION, promise2, value);
      });
      state.rejection = IS_NODE$1 || isUnhandled(state) ? UNHANDLED : HANDLED;
      if (result.error)
        throw result.value;
    }
  });
};
var isUnhandled = function(state) {
  return state.rejection !== HANDLED && !state.parent;
};
var onHandleUnhandled = function(state) {
  call$6(task, global$b, function() {
    var promise2 = state.facade;
    if (IS_NODE$1) {
      process$1.emit("rejectionHandled", promise2);
    } else
      dispatchEvent(REJECTION_HANDLED, promise2, state.value);
  });
};
var bind = function(fn, state, unwrap) {
  return function(value) {
    fn(state, value, unwrap);
  };
};
var internalReject = function(state, value, unwrap) {
  if (state.done)
    return;
  state.done = true;
  if (unwrap)
    state = unwrap;
  state.value = value;
  state.state = REJECTED;
  notify(state, true);
};
var internalResolve = function(state, value, unwrap) {
  if (state.done)
    return;
  state.done = true;
  if (unwrap)
    state = unwrap;
  try {
    if (state.facade === value)
      throw TypeError$4("Promise can't be resolved itself");
    var then2 = isThenable(value);
    if (then2) {
      microtask(function() {
        var wrapper = { done: false };
        try {
          call$6(then2, value, bind(internalResolve, wrapper, state), bind(internalReject, wrapper, state));
        } catch (error) {
          internalReject(wrapper, error, state);
        }
      });
    } else {
      state.value = value;
      state.state = FULFILLED;
      notify(state, false);
    }
  } catch (error) {
    internalReject({ done: false }, error, state);
  }
};
if (FORCED) {
  PromiseConstructor = function Promise2(executor) {
    anInstance(this, PromisePrototype);
    aCallable$1(executor);
    call$6(Internal, this);
    var state = getInternalState$2(this);
    try {
      executor(bind(internalResolve, state), bind(internalReject, state));
    } catch (error) {
      internalReject(state, error);
    }
  };
  PromisePrototype = PromiseConstructor.prototype;
  Internal = function Promise2(executor) {
    setInternalState$1(this, {
      type: PROMISE,
      done: false,
      notified: false,
      parent: false,
      reactions: new Queue(),
      rejection: false,
      state: PENDING,
      value: void 0
    });
  };
  Internal.prototype = redefineAll(PromisePrototype, {
    then: function then2(onFulfilled, onRejected) {
      var state = getInternalPromiseState(this);
      var reaction = newPromiseCapability(speciesConstructor$1(this, PromiseConstructor));
      state.parent = true;
      reaction.ok = isCallable$5(onFulfilled) ? onFulfilled : true;
      reaction.fail = isCallable$5(onRejected) && onRejected;
      reaction.domain = IS_NODE$1 ? process$1.domain : void 0;
      if (state.state == PENDING)
        state.reactions.add(reaction);
      else
        microtask(function() {
          callReaction(reaction, state);
        });
      return reaction.promise;
    },
    "catch": function(onRejected) {
      return this.then(void 0, onRejected);
    }
  });
  OwnPromiseCapability = function() {
    var promise2 = new Internal();
    var state = getInternalState$2(promise2);
    this.promise = promise2;
    this.resolve = bind(internalResolve, state);
    this.reject = bind(internalReject, state);
  };
  newPromiseCapabilityModule.f = newPromiseCapability = function(C2) {
    return C2 === PromiseConstructor || C2 === PromiseWrapper ? new OwnPromiseCapability(C2) : newGenericPromiseCapability(C2);
  };
  if (isCallable$5(NativePromise) && NativePromisePrototype !== Object.prototype) {
    nativeThen = NativePromisePrototype.then;
    if (!SUBCLASSING) {
      redefine$4(NativePromisePrototype, "then", function then2(onFulfilled, onRejected) {
        var that = this;
        return new PromiseConstructor(function(resolve2, reject2) {
          call$6(nativeThen, that, resolve2, reject2);
        }).then(onFulfilled, onRejected);
      }, { unsafe: true });
      redefine$4(NativePromisePrototype, "catch", PromisePrototype["catch"], { unsafe: true });
    }
    try {
      delete NativePromisePrototype.constructor;
    } catch (error) {
    }
    if (setPrototypeOf$1) {
      setPrototypeOf$1(NativePromisePrototype, PromisePrototype);
    }
  }
}
$$9({ global: true, wrap: true, forced: FORCED }, {
  Promise: PromiseConstructor
});
setToStringTag$2(PromiseConstructor, PROMISE, false);
setSpecies(PROMISE);
PromiseWrapper = getBuiltIn(PROMISE);
$$9({ target: PROMISE, stat: true, forced: FORCED }, {
  reject: function reject(r2) {
    var capability = newPromiseCapability(this);
    call$6(capability.reject, void 0, r2);
    return capability.promise;
  }
});
$$9({ target: PROMISE, stat: true, forced: FORCED }, {
  resolve: function resolve(x2) {
    return promiseResolve(this, x2);
  }
});
$$9({ target: PROMISE, stat: true, forced: INCORRECT_ITERATION }, {
  all: function all2(iterable) {
    var C2 = this;
    var capability = newPromiseCapability(C2);
    var resolve2 = capability.resolve;
    var reject2 = capability.reject;
    var result = perform(function() {
      var $promiseResolve = aCallable$1(C2.resolve);
      var values2 = [];
      var counter2 = 0;
      var remaining = 1;
      iterate(iterable, function(promise2) {
        var index2 = counter2++;
        var alreadyCalled = false;
        remaining++;
        call$6($promiseResolve, C2, promise2).then(function(value) {
          if (alreadyCalled)
            return;
          alreadyCalled = true;
          values2[index2] = value;
          --remaining || resolve2(values2);
        }, reject2);
      });
      --remaining || resolve2(values2);
    });
    if (result.error)
      reject2(result.value);
    return capability.promise;
  },
  race: function race(iterable) {
    var C2 = this;
    var capability = newPromiseCapability(C2);
    var reject2 = capability.reject;
    var result = perform(function() {
      var $promiseResolve = aCallable$1(C2.resolve);
      iterate(iterable, function(promise2) {
        call$6($promiseResolve, C2, promise2).then(capability.resolve, reject2);
      });
    });
    if (result.error)
      reject2(result.value);
    return capability.promise;
  }
});
function asyncGeneratorStep(gen, resolve2, reject2, _next, _throw, key, arg) {
  try {
    var info = gen[key](arg);
    var value = info.value;
  } catch (error) {
    reject2(error);
    return;
  }
  if (info.done) {
    resolve2(value);
  } else {
    Promise.resolve(value).then(_next, _throw);
  }
}
function _asyncToGenerator(fn) {
  return function() {
    var self2 = this, args = arguments;
    return new Promise(function(resolve2, reject2) {
      var gen = fn.apply(self2, args);
      function _next(value) {
        asyncGeneratorStep(gen, resolve2, reject2, _next, _throw, "next", value);
      }
      function _throw(err) {
        asyncGeneratorStep(gen, resolve2, reject2, _next, _throw, "throw", err);
      }
      _next(void 0);
    });
  };
}
var global$a = global$I;
var classof$3 = classof$7;
var String$1 = global$a.String;
var toString$9 = function(argument) {
  if (classof$3(argument) === "Symbol")
    throw TypeError("Cannot convert a Symbol value to a string");
  return String$1(argument);
};
var anObject$7 = anObject$g;
var regexpFlags$1 = function() {
  var that = anObject$7(this);
  var result = "";
  if (that.global)
    result += "g";
  if (that.ignoreCase)
    result += "i";
  if (that.multiline)
    result += "m";
  if (that.dotAll)
    result += "s";
  if (that.unicode)
    result += "u";
  if (that.sticky)
    result += "y";
  return result;
};
var fails$a = fails$k;
var global$9 = global$I;
var $RegExp$2 = global$9.RegExp;
var UNSUPPORTED_Y$2 = fails$a(function() {
  var re2 = $RegExp$2("a", "y");
  re2.lastIndex = 2;
  return re2.exec("abcd") != null;
});
var MISSED_STICKY = UNSUPPORTED_Y$2 || fails$a(function() {
  return !$RegExp$2("a", "y").sticky;
});
var BROKEN_CARET = UNSUPPORTED_Y$2 || fails$a(function() {
  var re2 = $RegExp$2("^r", "gy");
  re2.lastIndex = 2;
  return re2.exec("str") != null;
});
var regexpStickyHelpers = {
  BROKEN_CARET,
  MISSED_STICKY,
  UNSUPPORTED_Y: UNSUPPORTED_Y$2
};
var objectDefineProperties = {};
var internalObjectKeys = objectKeysInternal;
var enumBugKeys$1 = enumBugKeys$3;
var objectKeys$1 = Object.keys || function keys2(O2) {
  return internalObjectKeys(O2, enumBugKeys$1);
};
var DESCRIPTORS$1 = descriptors;
var V8_PROTOTYPE_DEFINE_BUG = v8PrototypeDefineBug;
var definePropertyModule$2 = objectDefineProperty;
var anObject$6 = anObject$g;
var toIndexedObject$1 = toIndexedObject$5;
var objectKeys = objectKeys$1;
objectDefineProperties.f = DESCRIPTORS$1 && !V8_PROTOTYPE_DEFINE_BUG ? Object.defineProperties : function defineProperties(O2, Properties) {
  anObject$6(O2);
  var props = toIndexedObject$1(Properties);
  var keys3 = objectKeys(Properties);
  var length = keys3.length;
  var index2 = 0;
  var key;
  while (length > index2)
    definePropertyModule$2.f(O2, key = keys3[index2++], props[key]);
  return O2;
};
var anObject$5 = anObject$g;
var definePropertiesModule = objectDefineProperties;
var enumBugKeys = enumBugKeys$3;
var hiddenKeys = hiddenKeys$4;
var html = html$2;
var documentCreateElement$1 = documentCreateElement$2;
var sharedKey$1 = sharedKey$3;
var GT = ">";
var LT = "<";
var PROTOTYPE = "prototype";
var SCRIPT = "script";
var IE_PROTO$1 = sharedKey$1("IE_PROTO");
var EmptyConstructor = function() {
};
var scriptTag = function(content2) {
  return LT + SCRIPT + GT + content2 + LT + "/" + SCRIPT + GT;
};
var NullProtoObjectViaActiveX = function(activeXDocument2) {
  activeXDocument2.write(scriptTag(""));
  activeXDocument2.close();
  var temp = activeXDocument2.parentWindow.Object;
  activeXDocument2 = null;
  return temp;
};
var NullProtoObjectViaIFrame = function() {
  var iframe = documentCreateElement$1("iframe");
  var JS = "java" + SCRIPT + ":";
  var iframeDocument;
  iframe.style.display = "none";
  html.appendChild(iframe);
  iframe.src = String(JS);
  iframeDocument = iframe.contentWindow.document;
  iframeDocument.open();
  iframeDocument.write(scriptTag("document.F=Object"));
  iframeDocument.close();
  return iframeDocument.F;
};
var activeXDocument;
var NullProtoObject = function() {
  try {
    activeXDocument = new ActiveXObject("htmlfile");
  } catch (error) {
  }
  NullProtoObject = typeof document != "undefined" ? document.domain && activeXDocument ? NullProtoObjectViaActiveX(activeXDocument) : NullProtoObjectViaIFrame() : NullProtoObjectViaActiveX(activeXDocument);
  var length = enumBugKeys.length;
  while (length--)
    delete NullProtoObject[PROTOTYPE][enumBugKeys[length]];
  return NullProtoObject();
};
hiddenKeys[IE_PROTO$1] = true;
var objectCreate = Object.create || function create(O2, Properties) {
  var result;
  if (O2 !== null) {
    EmptyConstructor[PROTOTYPE] = anObject$5(O2);
    result = new EmptyConstructor();
    EmptyConstructor[PROTOTYPE] = null;
    result[IE_PROTO$1] = O2;
  } else
    result = NullProtoObject();
  return Properties === void 0 ? result : definePropertiesModule.f(result, Properties);
};
var fails$9 = fails$k;
var global$8 = global$I;
var $RegExp$1 = global$8.RegExp;
var regexpUnsupportedDotAll = fails$9(function() {
  var re2 = $RegExp$1(".", "s");
  return !(re2.dotAll && re2.exec("\n") && re2.flags === "s");
});
var fails$8 = fails$k;
var global$7 = global$I;
var $RegExp = global$7.RegExp;
var regexpUnsupportedNcg = fails$8(function() {
  var re2 = $RegExp("(?<a>b)", "g");
  return re2.exec("b").groups.a !== "b" || "b".replace(re2, "$<a>c") !== "bc";
});
var call$5 = functionCall;
var uncurryThis$c = functionUncurryThis;
var toString$8 = toString$9;
var regexpFlags = regexpFlags$1;
var stickyHelpers$1 = regexpStickyHelpers;
var shared = shared$4.exports;
var create$2 = objectCreate;
var getInternalState$1 = internalState.get;
var UNSUPPORTED_DOT_ALL = regexpUnsupportedDotAll;
var UNSUPPORTED_NCG = regexpUnsupportedNcg;
var nativeReplace = shared("native-string-replace", String.prototype.replace);
var nativeExec = RegExp.prototype.exec;
var patchedExec = nativeExec;
var charAt$3 = uncurryThis$c("".charAt);
var indexOf = uncurryThis$c("".indexOf);
var replace$2 = uncurryThis$c("".replace);
var stringSlice$5 = uncurryThis$c("".slice);
var UPDATES_LAST_INDEX_WRONG = function() {
  var re1 = /a/;
  var re2 = /b*/g;
  call$5(nativeExec, re1, "a");
  call$5(nativeExec, re2, "a");
  return re1.lastIndex !== 0 || re2.lastIndex !== 0;
}();
var UNSUPPORTED_Y$1 = stickyHelpers$1.BROKEN_CARET;
var NPCG_INCLUDED = /()??/.exec("")[1] !== void 0;
var PATCH = UPDATES_LAST_INDEX_WRONG || NPCG_INCLUDED || UNSUPPORTED_Y$1 || UNSUPPORTED_DOT_ALL || UNSUPPORTED_NCG;
if (PATCH) {
  patchedExec = function exec2(string) {
    var re2 = this;
    var state = getInternalState$1(re2);
    var str = toString$8(string);
    var raw = state.raw;
    var result, reCopy, lastIndex, match2, i2, object, group;
    if (raw) {
      raw.lastIndex = re2.lastIndex;
      result = call$5(patchedExec, raw, str);
      re2.lastIndex = raw.lastIndex;
      return result;
    }
    var groups = state.groups;
    var sticky = UNSUPPORTED_Y$1 && re2.sticky;
    var flags = call$5(regexpFlags, re2);
    var source = re2.source;
    var charsAdded = 0;
    var strCopy = str;
    if (sticky) {
      flags = replace$2(flags, "y", "");
      if (indexOf(flags, "g") === -1) {
        flags += "g";
      }
      strCopy = stringSlice$5(str, re2.lastIndex);
      if (re2.lastIndex > 0 && (!re2.multiline || re2.multiline && charAt$3(str, re2.lastIndex - 1) !== "\n")) {
        source = "(?: " + source + ")";
        strCopy = " " + strCopy;
        charsAdded++;
      }
      reCopy = new RegExp("^(?:" + source + ")", flags);
    }
    if (NPCG_INCLUDED) {
      reCopy = new RegExp("^" + source + "$(?!\\s)", flags);
    }
    if (UPDATES_LAST_INDEX_WRONG)
      lastIndex = re2.lastIndex;
    match2 = call$5(nativeExec, sticky ? reCopy : re2, strCopy);
    if (sticky) {
      if (match2) {
        match2.input = stringSlice$5(match2.input, charsAdded);
        match2[0] = stringSlice$5(match2[0], charsAdded);
        match2.index = re2.lastIndex;
        re2.lastIndex += match2[0].length;
      } else
        re2.lastIndex = 0;
    } else if (UPDATES_LAST_INDEX_WRONG && match2) {
      re2.lastIndex = re2.global ? match2.index + match2[0].length : lastIndex;
    }
    if (NPCG_INCLUDED && match2 && match2.length > 1) {
      call$5(nativeReplace, match2[0], reCopy, function() {
        for (i2 = 1; i2 < arguments.length - 2; i2++) {
          if (arguments[i2] === void 0)
            match2[i2] = void 0;
        }
      });
    }
    if (match2 && groups) {
      match2.groups = object = create$2(null);
      for (i2 = 0; i2 < groups.length; i2++) {
        group = groups[i2];
        object[group[0]] = match2[group[1]];
      }
    }
    return match2;
  };
}
var regexpExec$3 = patchedExec;
var $$8 = _export;
var exec$1 = regexpExec$3;
$$8({ target: "RegExp", proto: true, forced: /./.exec !== exec$1 }, {
  exec: exec$1
});
var uncurryThis$b = functionUncurryThis;
var redefine$3 = redefine$7.exports;
var regexpExec$2 = regexpExec$3;
var fails$7 = fails$k;
var wellKnownSymbol$7 = wellKnownSymbol$i;
var createNonEnumerableProperty$2 = createNonEnumerableProperty$6;
var SPECIES = wellKnownSymbol$7("species");
var RegExpPrototype$1 = RegExp.prototype;
var fixRegexpWellKnownSymbolLogic = function(KEY, exec2, FORCED2, SHAM) {
  var SYMBOL = wellKnownSymbol$7(KEY);
  var DELEGATES_TO_SYMBOL = !fails$7(function() {
    var O2 = {};
    O2[SYMBOL] = function() {
      return 7;
    };
    return ""[KEY](O2) != 7;
  });
  var DELEGATES_TO_EXEC = DELEGATES_TO_SYMBOL && !fails$7(function() {
    var execCalled = false;
    var re2 = /a/;
    if (KEY === "split") {
      re2 = {};
      re2.constructor = {};
      re2.constructor[SPECIES] = function() {
        return re2;
      };
      re2.flags = "";
      re2[SYMBOL] = /./[SYMBOL];
    }
    re2.exec = function() {
      execCalled = true;
      return null;
    };
    re2[SYMBOL]("");
    return !execCalled;
  });
  if (!DELEGATES_TO_SYMBOL || !DELEGATES_TO_EXEC || FORCED2) {
    var uncurriedNativeRegExpMethod = uncurryThis$b(/./[SYMBOL]);
    var methods = exec2(SYMBOL, ""[KEY], function(nativeMethod, regexp, str, arg2, forceStringMethod) {
      var uncurriedNativeMethod = uncurryThis$b(nativeMethod);
      var $exec = regexp.exec;
      if ($exec === regexpExec$2 || $exec === RegExpPrototype$1.exec) {
        if (DELEGATES_TO_SYMBOL && !forceStringMethod) {
          return { done: true, value: uncurriedNativeRegExpMethod(regexp, str, arg2) };
        }
        return { done: true, value: uncurriedNativeMethod(str, regexp, arg2) };
      }
      return { done: false };
    });
    redefine$3(String.prototype, KEY, methods[0]);
    redefine$3(RegExpPrototype$1, SYMBOL, methods[1]);
  }
  if (SHAM)
    createNonEnumerableProperty$2(RegExpPrototype$1[SYMBOL], "sham", true);
};
var uncurryThis$a = functionUncurryThis;
var toIntegerOrInfinity$1 = toIntegerOrInfinity$4;
var toString$7 = toString$9;
var requireObjectCoercible$7 = requireObjectCoercible$a;
var charAt$2 = uncurryThis$a("".charAt);
var charCodeAt = uncurryThis$a("".charCodeAt);
var stringSlice$4 = uncurryThis$a("".slice);
var createMethod$2 = function(CONVERT_TO_STRING) {
  return function($this, pos) {
    var S2 = toString$7(requireObjectCoercible$7($this));
    var position2 = toIntegerOrInfinity$1(pos);
    var size = S2.length;
    var first, second;
    if (position2 < 0 || position2 >= size)
      return CONVERT_TO_STRING ? "" : void 0;
    first = charCodeAt(S2, position2);
    return first < 55296 || first > 56319 || position2 + 1 === size || (second = charCodeAt(S2, position2 + 1)) < 56320 || second > 57343 ? CONVERT_TO_STRING ? charAt$2(S2, position2) : first : CONVERT_TO_STRING ? stringSlice$4(S2, position2, position2 + 2) : (first - 55296 << 10) + (second - 56320) + 65536;
  };
};
var stringMultibyte = {
  codeAt: createMethod$2(false),
  charAt: createMethod$2(true)
};
var charAt$1 = stringMultibyte.charAt;
var advanceStringIndex$3 = function(S2, index2, unicode) {
  return index2 + (unicode ? charAt$1(S2, index2).length : 1);
};
var global$6 = global$I;
var call$4 = functionCall;
var anObject$4 = anObject$g;
var isCallable$4 = isCallable$j;
var classof$2 = classofRaw$1;
var regexpExec$1 = regexpExec$3;
var TypeError$3 = global$6.TypeError;
var regexpExecAbstract = function(R2, S2) {
  var exec2 = R2.exec;
  if (isCallable$4(exec2)) {
    var result = call$4(exec2, R2, S2);
    if (result !== null)
      anObject$4(result);
    return result;
  }
  if (classof$2(R2) === "RegExp")
    return call$4(regexpExec$1, R2, S2);
  throw TypeError$3("RegExp#exec called on incompatible receiver");
};
var call$3 = functionCall;
var fixRegExpWellKnownSymbolLogic$2 = fixRegexpWellKnownSymbolLogic;
var anObject$3 = anObject$g;
var toLength$4 = toLength$6;
var toString$6 = toString$9;
var requireObjectCoercible$6 = requireObjectCoercible$a;
var getMethod$2 = getMethod$6;
var advanceStringIndex$2 = advanceStringIndex$3;
var regExpExec$1 = regexpExecAbstract;
fixRegExpWellKnownSymbolLogic$2("match", function(MATCH2, nativeMatch, maybeCallNative) {
  return [
    function match2(regexp) {
      var O2 = requireObjectCoercible$6(this);
      var matcher = regexp == void 0 ? void 0 : getMethod$2(regexp, MATCH2);
      return matcher ? call$3(matcher, regexp, O2) : new RegExp(regexp)[MATCH2](toString$6(O2));
    },
    function(string) {
      var rx = anObject$3(this);
      var S2 = toString$6(string);
      var res = maybeCallNative(nativeMatch, rx, S2);
      if (res.done)
        return res.value;
      if (!rx.global)
        return regExpExec$1(rx, S2);
      var fullUnicode = rx.unicode;
      rx.lastIndex = 0;
      var A2 = [];
      var n2 = 0;
      var result;
      while ((result = regExpExec$1(rx, S2)) !== null) {
        var matchStr = toString$6(result[0]);
        A2[n2] = matchStr;
        if (matchStr === "")
          rx.lastIndex = advanceStringIndex$2(S2, toLength$4(rx.lastIndex), fullUnicode);
        n2++;
      }
      return n2 === 0 ? null : A2;
    }
  ];
});
var uncurryThis$9 = functionUncurryThis;
var toObject$2 = toObject$4;
var floor = Math.floor;
var charAt = uncurryThis$9("".charAt);
var replace$1 = uncurryThis$9("".replace);
var stringSlice$3 = uncurryThis$9("".slice);
var SUBSTITUTION_SYMBOLS = /\$([$&'`]|\d{1,2}|<[^>]*>)/g;
var SUBSTITUTION_SYMBOLS_NO_NAMED = /\$([$&'`]|\d{1,2})/g;
var getSubstitution$1 = function(matched, str, position2, captures, namedCaptures, replacement2) {
  var tailPos = position2 + matched.length;
  var m2 = captures.length;
  var symbols = SUBSTITUTION_SYMBOLS_NO_NAMED;
  if (namedCaptures !== void 0) {
    namedCaptures = toObject$2(namedCaptures);
    symbols = SUBSTITUTION_SYMBOLS;
  }
  return replace$1(replacement2, symbols, function(match2, ch) {
    var capture;
    switch (charAt(ch, 0)) {
      case "$":
        return "$";
      case "&":
        return matched;
      case "`":
        return stringSlice$3(str, 0, position2);
      case "'":
        return stringSlice$3(str, tailPos);
      case "<":
        capture = namedCaptures[stringSlice$3(ch, 1, -1)];
        break;
      default:
        var n2 = +ch;
        if (n2 === 0)
          return match2;
        if (n2 > m2) {
          var f2 = floor(n2 / 10);
          if (f2 === 0)
            return match2;
          if (f2 <= m2)
            return captures[f2 - 1] === void 0 ? charAt(ch, 1) : captures[f2 - 1] + charAt(ch, 1);
          return match2;
        }
        capture = captures[n2 - 1];
    }
    return capture === void 0 ? "" : capture;
  });
};
var apply$1 = functionApply;
var call$2 = functionCall;
var uncurryThis$8 = functionUncurryThis;
var fixRegExpWellKnownSymbolLogic$1 = fixRegexpWellKnownSymbolLogic;
var fails$6 = fails$k;
var anObject$2 = anObject$g;
var isCallable$3 = isCallable$j;
var toIntegerOrInfinity = toIntegerOrInfinity$4;
var toLength$3 = toLength$6;
var toString$5 = toString$9;
var requireObjectCoercible$5 = requireObjectCoercible$a;
var advanceStringIndex$1 = advanceStringIndex$3;
var getMethod$1 = getMethod$6;
var getSubstitution = getSubstitution$1;
var regExpExec = regexpExecAbstract;
var wellKnownSymbol$6 = wellKnownSymbol$i;
var REPLACE = wellKnownSymbol$6("replace");
var max$1 = Math.max;
var min$3 = Math.min;
var concat = uncurryThis$8([].concat);
var push$1 = uncurryThis$8([].push);
var stringIndexOf$1 = uncurryThis$8("".indexOf);
var stringSlice$2 = uncurryThis$8("".slice);
var maybeToString = function(it2) {
  return it2 === void 0 ? it2 : String(it2);
};
var REPLACE_KEEPS_$0 = function() {
  return "a".replace(/./, "$0") === "$0";
}();
var REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE = function() {
  if (/./[REPLACE]) {
    return /./[REPLACE]("a", "$0") === "";
  }
  return false;
}();
var REPLACE_SUPPORTS_NAMED_GROUPS = !fails$6(function() {
  var re2 = /./;
  re2.exec = function() {
    var result = [];
    result.groups = { a: "7" };
    return result;
  };
  return "".replace(re2, "$<a>") !== "7";
});
fixRegExpWellKnownSymbolLogic$1("replace", function(_2, nativeReplace2, maybeCallNative) {
  var UNSAFE_SUBSTITUTE = REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE ? "$" : "$0";
  return [
    function replace2(searchValue, replaceValue) {
      var O2 = requireObjectCoercible$5(this);
      var replacer = searchValue == void 0 ? void 0 : getMethod$1(searchValue, REPLACE);
      return replacer ? call$2(replacer, searchValue, O2, replaceValue) : call$2(nativeReplace2, toString$5(O2), searchValue, replaceValue);
    },
    function(string, replaceValue) {
      var rx = anObject$2(this);
      var S2 = toString$5(string);
      if (typeof replaceValue == "string" && stringIndexOf$1(replaceValue, UNSAFE_SUBSTITUTE) === -1 && stringIndexOf$1(replaceValue, "$<") === -1) {
        var res = maybeCallNative(nativeReplace2, rx, S2, replaceValue);
        if (res.done)
          return res.value;
      }
      var functionalReplace = isCallable$3(replaceValue);
      if (!functionalReplace)
        replaceValue = toString$5(replaceValue);
      var global2 = rx.global;
      if (global2) {
        var fullUnicode = rx.unicode;
        rx.lastIndex = 0;
      }
      var results = [];
      while (true) {
        var result = regExpExec(rx, S2);
        if (result === null)
          break;
        push$1(results, result);
        if (!global2)
          break;
        var matchStr = toString$5(result[0]);
        if (matchStr === "")
          rx.lastIndex = advanceStringIndex$1(S2, toLength$3(rx.lastIndex), fullUnicode);
      }
      var accumulatedResult = "";
      var nextSourcePosition = 0;
      for (var i2 = 0; i2 < results.length; i2++) {
        result = results[i2];
        var matched = toString$5(result[0]);
        var position2 = max$1(min$3(toIntegerOrInfinity(result.index), S2.length), 0);
        var captures = [];
        for (var j2 = 1; j2 < result.length; j2++)
          push$1(captures, maybeToString(result[j2]));
        var namedCaptures = result.groups;
        if (functionalReplace) {
          var replacerArgs = concat([matched], captures, position2, S2);
          if (namedCaptures !== void 0)
            push$1(replacerArgs, namedCaptures);
          var replacement2 = toString$5(apply$1(replaceValue, void 0, replacerArgs));
        } else {
          replacement2 = getSubstitution(matched, S2, position2, captures, namedCaptures, replaceValue);
        }
        if (position2 >= nextSourcePosition) {
          accumulatedResult += stringSlice$2(S2, nextSourcePosition, position2) + replacement2;
          nextSourcePosition = position2 + matched.length;
        }
      }
      return accumulatedResult + stringSlice$2(S2, nextSourcePosition);
    }
  ];
}, !REPLACE_SUPPORTS_NAMED_GROUPS || !REPLACE_KEEPS_$0 || REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE);
var isObject = isObject$8;
var classof$1 = classofRaw$1;
var wellKnownSymbol$5 = wellKnownSymbol$i;
var MATCH$1 = wellKnownSymbol$5("match");
var isRegexp = function(it2) {
  var isRegExp2;
  return isObject(it2) && ((isRegExp2 = it2[MATCH$1]) !== void 0 ? !!isRegExp2 : classof$1(it2) == "RegExp");
};
var global$5 = global$I;
var isRegExp$1 = isRegexp;
var TypeError$2 = global$5.TypeError;
var notARegexp = function(it2) {
  if (isRegExp$1(it2)) {
    throw TypeError$2("The method doesn't accept regular expressions");
  }
  return it2;
};
var wellKnownSymbol$4 = wellKnownSymbol$i;
var MATCH = wellKnownSymbol$4("match");
var correctIsRegexpLogic = function(METHOD_NAME) {
  var regexp = /./;
  try {
    "/./"[METHOD_NAME](regexp);
  } catch (error1) {
    try {
      regexp[MATCH] = false;
      return "/./"[METHOD_NAME](regexp);
    } catch (error2) {
    }
  }
  return false;
};
var $$7 = _export;
var uncurryThis$7 = functionUncurryThis;
var getOwnPropertyDescriptor$1 = objectGetOwnPropertyDescriptor.f;
var toLength$2 = toLength$6;
var toString$4 = toString$9;
var notARegExp$2 = notARegexp;
var requireObjectCoercible$4 = requireObjectCoercible$a;
var correctIsRegExpLogic$2 = correctIsRegexpLogic;
var un$StartsWith = uncurryThis$7("".startsWith);
var stringSlice$1 = uncurryThis$7("".slice);
var min$2 = Math.min;
var CORRECT_IS_REGEXP_LOGIC$1 = correctIsRegExpLogic$2("startsWith");
var MDN_POLYFILL_BUG$1 = !CORRECT_IS_REGEXP_LOGIC$1 && !!function() {
  var descriptor = getOwnPropertyDescriptor$1(String.prototype, "startsWith");
  return descriptor && !descriptor.writable;
}();
$$7({ target: "String", proto: true, forced: !MDN_POLYFILL_BUG$1 && !CORRECT_IS_REGEXP_LOGIC$1 }, {
  startsWith: function startsWith(searchString) {
    var that = toString$4(requireObjectCoercible$4(this));
    notARegExp$2(searchString);
    var index2 = toLength$2(min$2(arguments.length > 1 ? arguments[1] : void 0, that.length));
    var search = toString$4(searchString);
    return un$StartsWith ? un$StartsWith(that, search, index2) : stringSlice$1(that, index2, index2 + search.length) === search;
  }
});
var wellKnownSymbol$3 = wellKnownSymbol$i;
var create$1 = objectCreate;
var definePropertyModule$1 = objectDefineProperty;
var UNSCOPABLES = wellKnownSymbol$3("unscopables");
var ArrayPrototype = Array.prototype;
if (ArrayPrototype[UNSCOPABLES] == void 0) {
  definePropertyModule$1.f(ArrayPrototype, UNSCOPABLES, {
    configurable: true,
    value: create$1(null)
  });
}
var addToUnscopables$1 = function(key) {
  ArrayPrototype[UNSCOPABLES][key] = true;
};
var fails$5 = fails$k;
var correctPrototypeGetter = !fails$5(function() {
  function F2() {
  }
  F2.prototype.constructor = null;
  return Object.getPrototypeOf(new F2()) !== F2.prototype;
});
var global$4 = global$I;
var hasOwn2 = hasOwnProperty_1;
var isCallable$2 = isCallable$j;
var toObject$1 = toObject$4;
var sharedKey = sharedKey$3;
var CORRECT_PROTOTYPE_GETTER = correctPrototypeGetter;
var IE_PROTO = sharedKey("IE_PROTO");
var Object$1 = global$4.Object;
var ObjectPrototype = Object$1.prototype;
var objectGetPrototypeOf = CORRECT_PROTOTYPE_GETTER ? Object$1.getPrototypeOf : function(O2) {
  var object = toObject$1(O2);
  if (hasOwn2(object, IE_PROTO))
    return object[IE_PROTO];
  var constructor = object.constructor;
  if (isCallable$2(constructor) && object instanceof constructor) {
    return constructor.prototype;
  }
  return object instanceof Object$1 ? ObjectPrototype : null;
};
var fails$4 = fails$k;
var isCallable$1 = isCallable$j;
var getPrototypeOf$1 = objectGetPrototypeOf;
var redefine$2 = redefine$7.exports;
var wellKnownSymbol$2 = wellKnownSymbol$i;
var ITERATOR$2 = wellKnownSymbol$2("iterator");
var BUGGY_SAFARI_ITERATORS$1 = false;
var IteratorPrototype$2;
var PrototypeOfArrayIteratorPrototype;
var arrayIterator;
if ([].keys) {
  arrayIterator = [].keys();
  if (!("next" in arrayIterator))
    BUGGY_SAFARI_ITERATORS$1 = true;
  else {
    PrototypeOfArrayIteratorPrototype = getPrototypeOf$1(getPrototypeOf$1(arrayIterator));
    if (PrototypeOfArrayIteratorPrototype !== Object.prototype)
      IteratorPrototype$2 = PrototypeOfArrayIteratorPrototype;
  }
}
var NEW_ITERATOR_PROTOTYPE = IteratorPrototype$2 == void 0 || fails$4(function() {
  var test2 = {};
  return IteratorPrototype$2[ITERATOR$2].call(test2) !== test2;
});
if (NEW_ITERATOR_PROTOTYPE)
  IteratorPrototype$2 = {};
if (!isCallable$1(IteratorPrototype$2[ITERATOR$2])) {
  redefine$2(IteratorPrototype$2, ITERATOR$2, function() {
    return this;
  });
}
var iteratorsCore = {
  IteratorPrototype: IteratorPrototype$2,
  BUGGY_SAFARI_ITERATORS: BUGGY_SAFARI_ITERATORS$1
};
var IteratorPrototype$1 = iteratorsCore.IteratorPrototype;
var create2 = objectCreate;
var createPropertyDescriptor$1 = createPropertyDescriptor$4;
var setToStringTag$1 = setToStringTag$3;
var Iterators$2 = iterators;
var returnThis$1 = function() {
  return this;
};
var createIteratorConstructor$1 = function(IteratorConstructor, NAME, next, ENUMERABLE_NEXT) {
  var TO_STRING_TAG2 = NAME + " Iterator";
  IteratorConstructor.prototype = create2(IteratorPrototype$1, { next: createPropertyDescriptor$1(+!ENUMERABLE_NEXT, next) });
  setToStringTag$1(IteratorConstructor, TO_STRING_TAG2, false);
  Iterators$2[TO_STRING_TAG2] = returnThis$1;
  return IteratorConstructor;
};
var $$6 = _export;
var call$1 = functionCall;
var FunctionName = functionName;
var isCallable = isCallable$j;
var createIteratorConstructor = createIteratorConstructor$1;
var getPrototypeOf = objectGetPrototypeOf;
var setPrototypeOf = objectSetPrototypeOf;
var setToStringTag = setToStringTag$3;
var createNonEnumerableProperty$1 = createNonEnumerableProperty$6;
var redefine$1 = redefine$7.exports;
var wellKnownSymbol$1 = wellKnownSymbol$i;
var Iterators$1 = iterators;
var IteratorsCore = iteratorsCore;
var PROPER_FUNCTION_NAME$2 = FunctionName.PROPER;
var CONFIGURABLE_FUNCTION_NAME = FunctionName.CONFIGURABLE;
var IteratorPrototype = IteratorsCore.IteratorPrototype;
var BUGGY_SAFARI_ITERATORS = IteratorsCore.BUGGY_SAFARI_ITERATORS;
var ITERATOR$1 = wellKnownSymbol$1("iterator");
var KEYS = "keys";
var VALUES = "values";
var ENTRIES = "entries";
var returnThis = function() {
  return this;
};
var defineIterator$1 = function(Iterable, NAME, IteratorConstructor, next, DEFAULT2, IS_SET, FORCED2) {
  createIteratorConstructor(IteratorConstructor, NAME, next);
  var getIterationMethod = function(KIND) {
    if (KIND === DEFAULT2 && defaultIterator)
      return defaultIterator;
    if (!BUGGY_SAFARI_ITERATORS && KIND in IterablePrototype)
      return IterablePrototype[KIND];
    switch (KIND) {
      case KEYS:
        return function keys3() {
          return new IteratorConstructor(this, KIND);
        };
      case VALUES:
        return function values2() {
          return new IteratorConstructor(this, KIND);
        };
      case ENTRIES:
        return function entries() {
          return new IteratorConstructor(this, KIND);
        };
    }
    return function() {
      return new IteratorConstructor(this);
    };
  };
  var TO_STRING_TAG2 = NAME + " Iterator";
  var INCORRECT_VALUES_NAME = false;
  var IterablePrototype = Iterable.prototype;
  var nativeIterator = IterablePrototype[ITERATOR$1] || IterablePrototype["@@iterator"] || DEFAULT2 && IterablePrototype[DEFAULT2];
  var defaultIterator = !BUGGY_SAFARI_ITERATORS && nativeIterator || getIterationMethod(DEFAULT2);
  var anyNativeIterator = NAME == "Array" ? IterablePrototype.entries || nativeIterator : nativeIterator;
  var CurrentIteratorPrototype, methods, KEY;
  if (anyNativeIterator) {
    CurrentIteratorPrototype = getPrototypeOf(anyNativeIterator.call(new Iterable()));
    if (CurrentIteratorPrototype !== Object.prototype && CurrentIteratorPrototype.next) {
      if (getPrototypeOf(CurrentIteratorPrototype) !== IteratorPrototype) {
        if (setPrototypeOf) {
          setPrototypeOf(CurrentIteratorPrototype, IteratorPrototype);
        } else if (!isCallable(CurrentIteratorPrototype[ITERATOR$1])) {
          redefine$1(CurrentIteratorPrototype, ITERATOR$1, returnThis);
        }
      }
      setToStringTag(CurrentIteratorPrototype, TO_STRING_TAG2, true);
    }
  }
  if (PROPER_FUNCTION_NAME$2 && DEFAULT2 == VALUES && nativeIterator && nativeIterator.name !== VALUES) {
    if (CONFIGURABLE_FUNCTION_NAME) {
      createNonEnumerableProperty$1(IterablePrototype, "name", VALUES);
    } else {
      INCORRECT_VALUES_NAME = true;
      defaultIterator = function values2() {
        return call$1(nativeIterator, this);
      };
    }
  }
  if (DEFAULT2) {
    methods = {
      values: getIterationMethod(VALUES),
      keys: IS_SET ? defaultIterator : getIterationMethod(KEYS),
      entries: getIterationMethod(ENTRIES)
    };
    if (FORCED2)
      for (KEY in methods) {
        if (BUGGY_SAFARI_ITERATORS || INCORRECT_VALUES_NAME || !(KEY in IterablePrototype)) {
          redefine$1(IterablePrototype, KEY, methods[KEY]);
        }
      }
    else
      $$6({ target: NAME, proto: true, forced: BUGGY_SAFARI_ITERATORS || INCORRECT_VALUES_NAME }, methods);
  }
  if (IterablePrototype[ITERATOR$1] !== defaultIterator) {
    redefine$1(IterablePrototype, ITERATOR$1, defaultIterator, { name: DEFAULT2 });
  }
  Iterators$1[NAME] = defaultIterator;
  return methods;
};
var toIndexedObject = toIndexedObject$5;
var addToUnscopables = addToUnscopables$1;
var Iterators = iterators;
var InternalStateModule = internalState;
var defineProperty3 = objectDefineProperty.f;
var defineIterator = defineIterator$1;
var DESCRIPTORS = descriptors;
var ARRAY_ITERATOR = "Array Iterator";
var setInternalState = InternalStateModule.set;
var getInternalState = InternalStateModule.getterFor(ARRAY_ITERATOR);
var es_array_iterator = defineIterator(Array, "Array", function(iterated, kind) {
  setInternalState(this, {
    type: ARRAY_ITERATOR,
    target: toIndexedObject(iterated),
    index: 0,
    kind
  });
}, function() {
  var state = getInternalState(this);
  var target = state.target;
  var kind = state.kind;
  var index2 = state.index++;
  if (!target || index2 >= target.length) {
    state.target = void 0;
    return { value: void 0, done: true };
  }
  if (kind == "keys")
    return { value: index2, done: false };
  if (kind == "values")
    return { value: target[index2], done: false };
  return { value: [index2, target[index2]], done: false };
}, "values");
var values = Iterators.Arguments = Iterators.Array;
addToUnscopables("keys");
addToUnscopables("values");
addToUnscopables("entries");
if (DESCRIPTORS && values.name !== "values")
  try {
    defineProperty3(values, "name", { value: "values" });
  } catch (error) {
  }
var domIterables = {
  CSSRuleList: 0,
  CSSStyleDeclaration: 0,
  CSSValueList: 0,
  ClientRectList: 0,
  DOMRectList: 0,
  DOMStringList: 0,
  DOMTokenList: 1,
  DataTransferItemList: 0,
  FileList: 0,
  HTMLAllCollection: 0,
  HTMLCollection: 0,
  HTMLFormElement: 0,
  HTMLSelectElement: 0,
  MediaList: 0,
  MimeTypeArray: 0,
  NamedNodeMap: 0,
  NodeList: 1,
  PaintRequestList: 0,
  Plugin: 0,
  PluginArray: 0,
  SVGLengthList: 0,
  SVGNumberList: 0,
  SVGPathSegList: 0,
  SVGPointList: 0,
  SVGStringList: 0,
  SVGTransformList: 0,
  SourceBufferList: 0,
  StyleSheetList: 0,
  TextTrackCueList: 0,
  TextTrackList: 0,
  TouchList: 0
};
var documentCreateElement = documentCreateElement$2;
var classList = documentCreateElement("span").classList;
var DOMTokenListPrototype$1 = classList && classList.constructor && classList.constructor.prototype;
var domTokenListPrototype = DOMTokenListPrototype$1 === Object.prototype ? void 0 : DOMTokenListPrototype$1;
var global$3 = global$I;
var DOMIterables = domIterables;
var DOMTokenListPrototype = domTokenListPrototype;
var ArrayIteratorMethods = es_array_iterator;
var createNonEnumerableProperty = createNonEnumerableProperty$6;
var wellKnownSymbol = wellKnownSymbol$i;
var ITERATOR = wellKnownSymbol("iterator");
var TO_STRING_TAG = wellKnownSymbol("toStringTag");
var ArrayValues = ArrayIteratorMethods.values;
var handlePrototype = function(CollectionPrototype, COLLECTION_NAME) {
  if (CollectionPrototype) {
    if (CollectionPrototype[ITERATOR] !== ArrayValues)
      try {
        createNonEnumerableProperty(CollectionPrototype, ITERATOR, ArrayValues);
      } catch (error) {
        CollectionPrototype[ITERATOR] = ArrayValues;
      }
    if (!CollectionPrototype[TO_STRING_TAG]) {
      createNonEnumerableProperty(CollectionPrototype, TO_STRING_TAG, COLLECTION_NAME);
    }
    if (DOMIterables[COLLECTION_NAME])
      for (var METHOD_NAME in ArrayIteratorMethods) {
        if (CollectionPrototype[METHOD_NAME] !== ArrayIteratorMethods[METHOD_NAME])
          try {
            createNonEnumerableProperty(CollectionPrototype, METHOD_NAME, ArrayIteratorMethods[METHOD_NAME]);
          } catch (error) {
            CollectionPrototype[METHOD_NAME] = ArrayIteratorMethods[METHOD_NAME];
          }
      }
  }
};
for (COLLECTION_NAME in DOMIterables) {
  handlePrototype(global$3[COLLECTION_NAME] && global$3[COLLECTION_NAME].prototype, COLLECTION_NAME);
}
var COLLECTION_NAME;
handlePrototype(DOMTokenListPrototype, "DOMTokenList");
function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}
var global$2 = global$I;
var aCallable = aCallable$6;
var toObject = toObject$4;
var IndexedObject = indexedObject;
var lengthOfArrayLike$1 = lengthOfArrayLike$4;
var TypeError$1 = global$2.TypeError;
var createMethod$1 = function(IS_RIGHT) {
  return function(that, callbackfn, argumentsLength, memo) {
    aCallable(callbackfn);
    var O2 = toObject(that);
    var self2 = IndexedObject(O2);
    var length = lengthOfArrayLike$1(O2);
    var index2 = IS_RIGHT ? length - 1 : 0;
    var i2 = IS_RIGHT ? -1 : 1;
    if (argumentsLength < 2)
      while (true) {
        if (index2 in self2) {
          memo = self2[index2];
          index2 += i2;
          break;
        }
        index2 += i2;
        if (IS_RIGHT ? index2 < 0 : length <= index2) {
          throw TypeError$1("Reduce of empty array with no initial value");
        }
      }
    for (; IS_RIGHT ? index2 >= 0 : length > index2; index2 += i2)
      if (index2 in self2) {
        memo = callbackfn(memo, self2[index2], index2, O2);
      }
    return memo;
  };
};
var arrayReduce = {
  left: createMethod$1(false),
  right: createMethod$1(true)
};
var fails$3 = fails$k;
var arrayMethodIsStrict$2 = function(METHOD_NAME, argument) {
  var method = [][METHOD_NAME];
  return !!method && fails$3(function() {
    method.call(null, argument || function() {
      throw 1;
    }, 1);
  });
};
var $$5 = _export;
var $reduce = arrayReduce.left;
var arrayMethodIsStrict$1 = arrayMethodIsStrict$2;
var CHROME_VERSION = engineV8Version;
var IS_NODE = engineIsNode;
var STRICT_METHOD$1 = arrayMethodIsStrict$1("reduce");
var CHROME_BUG = !IS_NODE && CHROME_VERSION > 79 && CHROME_VERSION < 83;
$$5({ target: "Array", proto: true, forced: !STRICT_METHOD$1 || CHROME_BUG }, {
  reduce: function reduce(callbackfn) {
    var length = arguments.length;
    return $reduce(this, callbackfn, length, length > 1 ? arguments[1] : void 0);
  }
});
var $$4 = _export;
var uncurryThis$6 = functionUncurryThis;
var getOwnPropertyDescriptor2 = objectGetOwnPropertyDescriptor.f;
var toLength$1 = toLength$6;
var toString$3 = toString$9;
var notARegExp$1 = notARegexp;
var requireObjectCoercible$3 = requireObjectCoercible$a;
var correctIsRegExpLogic$1 = correctIsRegexpLogic;
var un$EndsWith = uncurryThis$6("".endsWith);
var slice = uncurryThis$6("".slice);
var min$1 = Math.min;
var CORRECT_IS_REGEXP_LOGIC = correctIsRegExpLogic$1("endsWith");
var MDN_POLYFILL_BUG = !CORRECT_IS_REGEXP_LOGIC && !!function() {
  var descriptor = getOwnPropertyDescriptor2(String.prototype, "endsWith");
  return descriptor && !descriptor.writable;
}();
$$4({ target: "String", proto: true, forced: !MDN_POLYFILL_BUG && !CORRECT_IS_REGEXP_LOGIC }, {
  endsWith: function endsWith(searchString) {
    var that = toString$3(requireObjectCoercible$3(this));
    notARegExp$1(searchString);
    var endPosition = arguments.length > 1 ? arguments[1] : void 0;
    var len = that.length;
    var end = endPosition === void 0 ? len : min$1(toLength$1(endPosition), len);
    var search = toString$3(searchString);
    return un$EndsWith ? un$EndsWith(that, search, end) : slice(that, end - search.length, end) === search;
  }
});
var toPropertyKey = toPropertyKey$3;
var definePropertyModule = objectDefineProperty;
var createPropertyDescriptor = createPropertyDescriptor$4;
var createProperty$1 = function(object, key, value) {
  var propertyKey = toPropertyKey(key);
  if (propertyKey in object)
    definePropertyModule.f(object, propertyKey, createPropertyDescriptor(0, value));
  else
    object[propertyKey] = value;
};
var global$1 = global$I;
var toAbsoluteIndex = toAbsoluteIndex$2;
var lengthOfArrayLike = lengthOfArrayLike$4;
var createProperty = createProperty$1;
var Array$1 = global$1.Array;
var max = Math.max;
var arraySliceSimple = function(O2, start2, end) {
  var length = lengthOfArrayLike(O2);
  var k2 = toAbsoluteIndex(start2, length);
  var fin = toAbsoluteIndex(end === void 0 ? length : end, length);
  var result = Array$1(max(fin - k2, 0));
  for (var n2 = 0; k2 < fin; k2++, n2++)
    createProperty(result, n2, O2[k2]);
  result.length = n2;
  return result;
};
var apply = functionApply;
var call = functionCall;
var uncurryThis$5 = functionUncurryThis;
var fixRegExpWellKnownSymbolLogic = fixRegexpWellKnownSymbolLogic;
var isRegExp = isRegexp;
var anObject$1 = anObject$g;
var requireObjectCoercible$2 = requireObjectCoercible$a;
var speciesConstructor = speciesConstructor$2;
var advanceStringIndex = advanceStringIndex$3;
var toLength = toLength$6;
var toString$2 = toString$9;
var getMethod = getMethod$6;
var arraySlice = arraySliceSimple;
var callRegExpExec = regexpExecAbstract;
var regexpExec = regexpExec$3;
var stickyHelpers = regexpStickyHelpers;
var fails$2 = fails$k;
var UNSUPPORTED_Y = stickyHelpers.UNSUPPORTED_Y;
var MAX_UINT32 = 4294967295;
var min = Math.min;
var $push = [].push;
var exec = uncurryThis$5(/./.exec);
var push = uncurryThis$5($push);
var stringSlice = uncurryThis$5("".slice);
var SPLIT_WORKS_WITH_OVERWRITTEN_EXEC = !fails$2(function() {
  var re2 = /(?:)/;
  var originalExec = re2.exec;
  re2.exec = function() {
    return originalExec.apply(this, arguments);
  };
  var result = "ab".split(re2);
  return result.length !== 2 || result[0] !== "a" || result[1] !== "b";
});
fixRegExpWellKnownSymbolLogic("split", function(SPLIT, nativeSplit, maybeCallNative) {
  var internalSplit;
  if ("abbc".split(/(b)*/)[1] == "c" || "test".split(/(?:)/, -1).length != 4 || "ab".split(/(?:ab)*/).length != 2 || ".".split(/(.?)(.?)/).length != 4 || ".".split(/()()/).length > 1 || "".split(/.?/).length) {
    internalSplit = function(separator, limit) {
      var string = toString$2(requireObjectCoercible$2(this));
      var lim = limit === void 0 ? MAX_UINT32 : limit >>> 0;
      if (lim === 0)
        return [];
      if (separator === void 0)
        return [string];
      if (!isRegExp(separator)) {
        return call(nativeSplit, string, separator, lim);
      }
      var output = [];
      var flags = (separator.ignoreCase ? "i" : "") + (separator.multiline ? "m" : "") + (separator.unicode ? "u" : "") + (separator.sticky ? "y" : "");
      var lastLastIndex = 0;
      var separatorCopy = new RegExp(separator.source, flags + "g");
      var match2, lastIndex, lastLength;
      while (match2 = call(regexpExec, separatorCopy, string)) {
        lastIndex = separatorCopy.lastIndex;
        if (lastIndex > lastLastIndex) {
          push(output, stringSlice(string, lastLastIndex, match2.index));
          if (match2.length > 1 && match2.index < string.length)
            apply($push, output, arraySlice(match2, 1));
          lastLength = match2[0].length;
          lastLastIndex = lastIndex;
          if (output.length >= lim)
            break;
        }
        if (separatorCopy.lastIndex === match2.index)
          separatorCopy.lastIndex++;
      }
      if (lastLastIndex === string.length) {
        if (lastLength || !exec(separatorCopy, ""))
          push(output, "");
      } else
        push(output, stringSlice(string, lastLastIndex));
      return output.length > lim ? arraySlice(output, 0, lim) : output;
    };
  } else if ("0".split(void 0, 0).length) {
    internalSplit = function(separator, limit) {
      return separator === void 0 && limit === 0 ? [] : call(nativeSplit, this, separator, limit);
    };
  } else
    internalSplit = nativeSplit;
  return [
    function split2(separator, limit) {
      var O2 = requireObjectCoercible$2(this);
      var splitter = separator == void 0 ? void 0 : getMethod(separator, SPLIT);
      return splitter ? call(splitter, separator, O2, limit) : call(internalSplit, toString$2(O2), separator, limit);
    },
    function(string, limit) {
      var rx = anObject$1(this);
      var S2 = toString$2(string);
      var res = maybeCallNative(internalSplit, rx, S2, limit, internalSplit !== nativeSplit);
      if (res.done)
        return res.value;
      var C2 = speciesConstructor(rx, RegExp);
      var unicodeMatching = rx.unicode;
      var flags = (rx.ignoreCase ? "i" : "") + (rx.multiline ? "m" : "") + (rx.unicode ? "u" : "") + (UNSUPPORTED_Y ? "g" : "y");
      var splitter = new C2(UNSUPPORTED_Y ? "^(?:" + rx.source + ")" : rx, flags);
      var lim = limit === void 0 ? MAX_UINT32 : limit >>> 0;
      if (lim === 0)
        return [];
      if (S2.length === 0)
        return callRegExpExec(splitter, S2) === null ? [S2] : [];
      var p5 = 0;
      var q2 = 0;
      var A2 = [];
      while (q2 < S2.length) {
        splitter.lastIndex = UNSUPPORTED_Y ? 0 : q2;
        var z2 = callRegExpExec(splitter, UNSUPPORTED_Y ? stringSlice(S2, q2) : S2);
        var e2;
        if (z2 === null || (e2 = min(toLength(splitter.lastIndex + (UNSUPPORTED_Y ? q2 : 0)), S2.length)) === p5) {
          q2 = advanceStringIndex(S2, q2, unicodeMatching);
        } else {
          push(A2, stringSlice(S2, p5, q2));
          if (A2.length === lim)
            return A2;
          for (var i2 = 1; i2 <= z2.length - 1; i2++) {
            push(A2, z2[i2]);
            if (A2.length === lim)
              return A2;
          }
          q2 = p5 = e2;
        }
      }
      push(A2, stringSlice(S2, p5));
      return A2;
    }
  ];
}, !SPLIT_WORKS_WITH_OVERWRITTEN_EXEC, UNSUPPORTED_Y);
var raf$1 = { exports: {} };
var performanceNow = { exports: {} };
(function() {
  var getNanoSeconds, hrtime, loadTime, moduleLoadTime, nodeLoadTime, upTime;
  if (typeof performance !== "undefined" && performance !== null && performance.now) {
    performanceNow.exports = function() {
      return performance.now();
    };
  } else if (typeof process !== "undefined" && process !== null && process.hrtime) {
    performanceNow.exports = function() {
      return (getNanoSeconds() - nodeLoadTime) / 1e6;
    };
    hrtime = process.hrtime;
    getNanoSeconds = function() {
      var hr;
      hr = hrtime();
      return hr[0] * 1e9 + hr[1];
    };
    moduleLoadTime = getNanoSeconds();
    upTime = process.uptime() * 1e9;
    nodeLoadTime = moduleLoadTime - upTime;
  } else if (Date.now) {
    performanceNow.exports = function() {
      return Date.now() - loadTime;
    };
    loadTime = Date.now();
  } else {
    performanceNow.exports = function() {
      return new Date().getTime() - loadTime;
    };
    loadTime = new Date().getTime();
  }
}).call(commonjsGlobal);
var now = performanceNow.exports;
var root = typeof window === "undefined" ? commonjsGlobal : window;
var vendors = ["moz", "webkit"];
var suffix = "AnimationFrame";
var raf = root["request" + suffix];
var caf = root["cancel" + suffix] || root["cancelRequest" + suffix];
for (i$1 = 0; !raf && i$1 < vendors.length; i$1++) {
  raf = root[vendors[i$1] + "Request" + suffix];
  caf = root[vendors[i$1] + "Cancel" + suffix] || root[vendors[i$1] + "CancelRequest" + suffix];
}
var i$1;
if (!raf || !caf) {
  last = 0, id = 0, queue = [], frameDuration = 1e3 / 60;
  raf = function(callback) {
    if (queue.length === 0) {
      var _now = now(), next = Math.max(0, frameDuration - (_now - last));
      last = next + _now;
      setTimeout(function() {
        var cp = queue.slice(0);
        queue.length = 0;
        for (var i2 = 0; i2 < cp.length; i2++) {
          if (!cp[i2].cancelled) {
            try {
              cp[i2].callback(last);
            } catch (e2) {
              setTimeout(function() {
                throw e2;
              }, 0);
            }
          }
        }
      }, Math.round(next));
    }
    queue.push({
      handle: ++id,
      callback,
      cancelled: false
    });
    return id;
  };
  caf = function(handle) {
    for (var i2 = 0; i2 < queue.length; i2++) {
      if (queue[i2].handle === handle) {
        queue[i2].cancelled = true;
      }
    }
  };
}
var last;
var id;
var queue;
var frameDuration;
raf$1.exports = function(fn) {
  return raf.call(root, fn);
};
raf$1.exports.cancel = function() {
  caf.apply(root, arguments);
};
raf$1.exports.polyfill = function(object) {
  if (!object) {
    object = root;
  }
  object.requestAnimationFrame = raf;
  object.cancelAnimationFrame = caf;
};
var requestAnimationFrame$1 = raf$1.exports;
var whitespaces$2 = "	\n\v\f\r \xA0\u1680\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\u2028\u2029\uFEFF";
var uncurryThis$4 = functionUncurryThis;
var requireObjectCoercible$1 = requireObjectCoercible$a;
var toString$1 = toString$9;
var whitespaces$1 = whitespaces$2;
var replace = uncurryThis$4("".replace);
var whitespace = "[" + whitespaces$1 + "]";
var ltrim = RegExp("^" + whitespace + whitespace + "*");
var rtrim = RegExp(whitespace + whitespace + "*$");
var createMethod = function(TYPE) {
  return function($this) {
    var string = toString$1(requireObjectCoercible$1($this));
    if (TYPE & 1)
      string = replace(string, ltrim, "");
    if (TYPE & 2)
      string = replace(string, rtrim, "");
    return string;
  };
};
var stringTrim = {
  start: createMethod(1),
  end: createMethod(2),
  trim: createMethod(3)
};
var PROPER_FUNCTION_NAME$1 = functionName.PROPER;
var fails$1 = fails$k;
var whitespaces = whitespaces$2;
var non = "\u200B\x85\u180E";
var stringTrimForced = function(METHOD_NAME) {
  return fails$1(function() {
    return !!whitespaces[METHOD_NAME]() || non[METHOD_NAME]() !== non || PROPER_FUNCTION_NAME$1 && whitespaces[METHOD_NAME].name !== METHOD_NAME;
  });
};
var $$3 = _export;
var $trim = stringTrim.trim;
var forcedStringTrimMethod = stringTrimForced;
$$3({ target: "String", proto: true, forced: forcedStringTrimMethod("trim") }, {
  trim: function trim() {
    return $trim(this);
  }
});
var rgbcolor = function(color_string) {
  this.ok = false;
  this.alpha = 1;
  if (color_string.charAt(0) == "#") {
    color_string = color_string.substr(1, 6);
  }
  color_string = color_string.replace(/ /g, "");
  color_string = color_string.toLowerCase();
  var simple_colors = {
    aliceblue: "f0f8ff",
    antiquewhite: "faebd7",
    aqua: "00ffff",
    aquamarine: "7fffd4",
    azure: "f0ffff",
    beige: "f5f5dc",
    bisque: "ffe4c4",
    black: "000000",
    blanchedalmond: "ffebcd",
    blue: "0000ff",
    blueviolet: "8a2be2",
    brown: "a52a2a",
    burlywood: "deb887",
    cadetblue: "5f9ea0",
    chartreuse: "7fff00",
    chocolate: "d2691e",
    coral: "ff7f50",
    cornflowerblue: "6495ed",
    cornsilk: "fff8dc",
    crimson: "dc143c",
    cyan: "00ffff",
    darkblue: "00008b",
    darkcyan: "008b8b",
    darkgoldenrod: "b8860b",
    darkgray: "a9a9a9",
    darkgreen: "006400",
    darkkhaki: "bdb76b",
    darkmagenta: "8b008b",
    darkolivegreen: "556b2f",
    darkorange: "ff8c00",
    darkorchid: "9932cc",
    darkred: "8b0000",
    darksalmon: "e9967a",
    darkseagreen: "8fbc8f",
    darkslateblue: "483d8b",
    darkslategray: "2f4f4f",
    darkturquoise: "00ced1",
    darkviolet: "9400d3",
    deeppink: "ff1493",
    deepskyblue: "00bfff",
    dimgray: "696969",
    dodgerblue: "1e90ff",
    feldspar: "d19275",
    firebrick: "b22222",
    floralwhite: "fffaf0",
    forestgreen: "228b22",
    fuchsia: "ff00ff",
    gainsboro: "dcdcdc",
    ghostwhite: "f8f8ff",
    gold: "ffd700",
    goldenrod: "daa520",
    gray: "808080",
    green: "008000",
    greenyellow: "adff2f",
    honeydew: "f0fff0",
    hotpink: "ff69b4",
    indianred: "cd5c5c",
    indigo: "4b0082",
    ivory: "fffff0",
    khaki: "f0e68c",
    lavender: "e6e6fa",
    lavenderblush: "fff0f5",
    lawngreen: "7cfc00",
    lemonchiffon: "fffacd",
    lightblue: "add8e6",
    lightcoral: "f08080",
    lightcyan: "e0ffff",
    lightgoldenrodyellow: "fafad2",
    lightgrey: "d3d3d3",
    lightgreen: "90ee90",
    lightpink: "ffb6c1",
    lightsalmon: "ffa07a",
    lightseagreen: "20b2aa",
    lightskyblue: "87cefa",
    lightslateblue: "8470ff",
    lightslategray: "778899",
    lightsteelblue: "b0c4de",
    lightyellow: "ffffe0",
    lime: "00ff00",
    limegreen: "32cd32",
    linen: "faf0e6",
    magenta: "ff00ff",
    maroon: "800000",
    mediumaquamarine: "66cdaa",
    mediumblue: "0000cd",
    mediumorchid: "ba55d3",
    mediumpurple: "9370d8",
    mediumseagreen: "3cb371",
    mediumslateblue: "7b68ee",
    mediumspringgreen: "00fa9a",
    mediumturquoise: "48d1cc",
    mediumvioletred: "c71585",
    midnightblue: "191970",
    mintcream: "f5fffa",
    mistyrose: "ffe4e1",
    moccasin: "ffe4b5",
    navajowhite: "ffdead",
    navy: "000080",
    oldlace: "fdf5e6",
    olive: "808000",
    olivedrab: "6b8e23",
    orange: "ffa500",
    orangered: "ff4500",
    orchid: "da70d6",
    palegoldenrod: "eee8aa",
    palegreen: "98fb98",
    paleturquoise: "afeeee",
    palevioletred: "d87093",
    papayawhip: "ffefd5",
    peachpuff: "ffdab9",
    peru: "cd853f",
    pink: "ffc0cb",
    plum: "dda0dd",
    powderblue: "b0e0e6",
    purple: "800080",
    rebeccapurple: "663399",
    red: "ff0000",
    rosybrown: "bc8f8f",
    royalblue: "4169e1",
    saddlebrown: "8b4513",
    salmon: "fa8072",
    sandybrown: "f4a460",
    seagreen: "2e8b57",
    seashell: "fff5ee",
    sienna: "a0522d",
    silver: "c0c0c0",
    skyblue: "87ceeb",
    slateblue: "6a5acd",
    slategray: "708090",
    snow: "fffafa",
    springgreen: "00ff7f",
    steelblue: "4682b4",
    tan: "d2b48c",
    teal: "008080",
    thistle: "d8bfd8",
    tomato: "ff6347",
    turquoise: "40e0d0",
    violet: "ee82ee",
    violetred: "d02090",
    wheat: "f5deb3",
    white: "ffffff",
    whitesmoke: "f5f5f5",
    yellow: "ffff00",
    yellowgreen: "9acd32"
  };
  color_string = simple_colors[color_string] || color_string;
  var color_defs = [
    {
      re: /^rgba\((\d{1,3}),\s*(\d{1,3}),\s*(\d{1,3}),\s*((?:\d?\.)?\d)\)$/,
      example: ["rgba(123, 234, 45, 0.8)", "rgba(255,234,245,1.0)"],
      process: function(bits3) {
        return [
          parseInt(bits3[1]),
          parseInt(bits3[2]),
          parseInt(bits3[3]),
          parseFloat(bits3[4])
        ];
      }
    },
    {
      re: /^rgb\((\d{1,3}),\s*(\d{1,3}),\s*(\d{1,3})\)$/,
      example: ["rgb(123, 234, 45)", "rgb(255,234,245)"],
      process: function(bits3) {
        return [
          parseInt(bits3[1]),
          parseInt(bits3[2]),
          parseInt(bits3[3])
        ];
      }
    },
    {
      re: /^([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/,
      example: ["#00ff00", "336699"],
      process: function(bits3) {
        return [
          parseInt(bits3[1], 16),
          parseInt(bits3[2], 16),
          parseInt(bits3[3], 16)
        ];
      }
    },
    {
      re: /^([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
      example: ["#fb0", "f0f"],
      process: function(bits3) {
        return [
          parseInt(bits3[1] + bits3[1], 16),
          parseInt(bits3[2] + bits3[2], 16),
          parseInt(bits3[3] + bits3[3], 16)
        ];
      }
    }
  ];
  for (var i2 = 0; i2 < color_defs.length; i2++) {
    var re2 = color_defs[i2].re;
    var processor = color_defs[i2].process;
    var bits2 = re2.exec(color_string);
    if (bits2) {
      var channels = processor(bits2);
      this.r = channels[0];
      this.g = channels[1];
      this.b = channels[2];
      if (channels.length > 3) {
        this.alpha = channels[3];
      }
      this.ok = true;
    }
  }
  this.r = this.r < 0 || isNaN(this.r) ? 0 : this.r > 255 ? 255 : this.r;
  this.g = this.g < 0 || isNaN(this.g) ? 0 : this.g > 255 ? 255 : this.g;
  this.b = this.b < 0 || isNaN(this.b) ? 0 : this.b > 255 ? 255 : this.b;
  this.alpha = this.alpha < 0 ? 0 : this.alpha > 1 || isNaN(this.alpha) ? 1 : this.alpha;
  this.toRGB = function() {
    return "rgb(" + this.r + ", " + this.g + ", " + this.b + ")";
  };
  this.toRGBA = function() {
    return "rgba(" + this.r + ", " + this.g + ", " + this.b + ", " + this.alpha + ")";
  };
  this.toHex = function() {
    var r2 = this.r.toString(16);
    var g2 = this.g.toString(16);
    var b2 = this.b.toString(16);
    if (r2.length == 1)
      r2 = "0" + r2;
    if (g2.length == 1)
      g2 = "0" + g2;
    if (b2.length == 1)
      b2 = "0" + b2;
    return "#" + r2 + g2 + b2;
  };
  this.getHelpXML = function() {
    var examples = new Array();
    for (var i3 = 0; i3 < color_defs.length; i3++) {
      var example = color_defs[i3].example;
      for (var j2 = 0; j2 < example.length; j2++) {
        examples[examples.length] = example[j2];
      }
    }
    for (var sc in simple_colors) {
      examples[examples.length] = sc;
    }
    var xml2 = document.createElement("ul");
    xml2.setAttribute("id", "rgbcolor-examples");
    for (var i3 = 0; i3 < examples.length; i3++) {
      try {
        var list_item = document.createElement("li");
        var list_color = new RGBColor(examples[i3]);
        var example_div = document.createElement("div");
        example_div.style.cssText = "margin: 3px; border: 1px solid black; background:" + list_color.toHex() + "; color:" + list_color.toHex();
        example_div.appendChild(document.createTextNode("test"));
        var list_item_value = document.createTextNode(" " + examples[i3] + " -> " + list_color.toRGB() + " -> " + list_color.toHex());
        list_item.appendChild(example_div);
        list_item.appendChild(list_item_value);
        xml2.appendChild(list_item);
      } catch (e2) {
      }
    }
    return xml2;
  };
};
var $$2 = _export;
var uncurryThis$3 = functionUncurryThis;
var notARegExp = notARegexp;
var requireObjectCoercible = requireObjectCoercible$a;
var toString2 = toString$9;
var correctIsRegExpLogic = correctIsRegexpLogic;
var stringIndexOf = uncurryThis$3("".indexOf);
$$2({ target: "String", proto: true, forced: !correctIsRegExpLogic("includes") }, {
  includes: function includes2(searchString) {
    return !!~stringIndexOf(toString2(requireObjectCoercible(this)), toString2(notARegExp(searchString)), arguments.length > 1 ? arguments[1] : void 0);
  }
});
var $$1 = _export;
var uncurryThis$2 = functionUncurryThis;
var $IndexOf = arrayIncludes.indexOf;
var arrayMethodIsStrict = arrayMethodIsStrict$2;
var un$IndexOf = uncurryThis$2([].indexOf);
var NEGATIVE_ZERO = !!un$IndexOf && 1 / un$IndexOf([1], 1, -0) < 0;
var STRICT_METHOD = arrayMethodIsStrict("indexOf");
$$1({ target: "Array", proto: true, forced: NEGATIVE_ZERO || !STRICT_METHOD }, {
  indexOf: function indexOf2(searchElement) {
    var fromIndex = arguments.length > 1 ? arguments[1] : void 0;
    return NEGATIVE_ZERO ? un$IndexOf(this, searchElement, fromIndex) || 0 : $IndexOf(this, searchElement, fromIndex);
  }
});
var classof = classofRaw$1;
var isArray$1 = Array.isArray || function isArray(argument) {
  return classof(argument) == "Array";
};
var $ = _export;
var uncurryThis$1 = functionUncurryThis;
var isArray2 = isArray$1;
var un$Reverse = uncurryThis$1([].reverse);
var test = [1, 2];
$({ target: "Array", proto: true, forced: String(test) === String(test.reverse()) }, {
  reverse: function reverse() {
    if (isArray2(this))
      this.length = this.length;
    return un$Reverse(this);
  }
});
var t2 = function(r2, e2) {
  return (t2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t3, r3) {
    t3.__proto__ = r3;
  } || function(t3, r3) {
    for (var e3 in r3)
      Object.prototype.hasOwnProperty.call(r3, e3) && (t3[e3] = r3[e3]);
  })(r2, e2);
};
function r(r2, e2) {
  if (typeof e2 != "function" && e2 !== null)
    throw new TypeError("Class extends value " + String(e2) + " is not a constructor or null");
  function i2() {
    this.constructor = r2;
  }
  t2(r2, e2), r2.prototype = e2 === null ? Object.create(e2) : (i2.prototype = e2.prototype, new i2());
}
function e(t3) {
  var r2 = "";
  Array.isArray(t3) || (t3 = [t3]);
  for (var e2 = 0; e2 < t3.length; e2++) {
    var i2 = t3[e2];
    if (i2.type === _.CLOSE_PATH)
      r2 += "z";
    else if (i2.type === _.HORIZ_LINE_TO)
      r2 += (i2.relative ? "h" : "H") + i2.x;
    else if (i2.type === _.VERT_LINE_TO)
      r2 += (i2.relative ? "v" : "V") + i2.y;
    else if (i2.type === _.MOVE_TO)
      r2 += (i2.relative ? "m" : "M") + i2.x + " " + i2.y;
    else if (i2.type === _.LINE_TO)
      r2 += (i2.relative ? "l" : "L") + i2.x + " " + i2.y;
    else if (i2.type === _.CURVE_TO)
      r2 += (i2.relative ? "c" : "C") + i2.x1 + " " + i2.y1 + " " + i2.x2 + " " + i2.y2 + " " + i2.x + " " + i2.y;
    else if (i2.type === _.SMOOTH_CURVE_TO)
      r2 += (i2.relative ? "s" : "S") + i2.x2 + " " + i2.y2 + " " + i2.x + " " + i2.y;
    else if (i2.type === _.QUAD_TO)
      r2 += (i2.relative ? "q" : "Q") + i2.x1 + " " + i2.y1 + " " + i2.x + " " + i2.y;
    else if (i2.type === _.SMOOTH_QUAD_TO)
      r2 += (i2.relative ? "t" : "T") + i2.x + " " + i2.y;
    else {
      if (i2.type !== _.ARC)
        throw new Error('Unexpected command type "' + i2.type + '" at index ' + e2 + ".");
      r2 += (i2.relative ? "a" : "A") + i2.rX + " " + i2.rY + " " + i2.xRot + " " + +i2.lArcFlag + " " + +i2.sweepFlag + " " + i2.x + " " + i2.y;
    }
  }
  return r2;
}
function i(t3, r2) {
  var e2 = t3[0], i2 = t3[1];
  return [e2 * Math.cos(r2) - i2 * Math.sin(r2), e2 * Math.sin(r2) + i2 * Math.cos(r2)];
}
function a() {
  for (var t3 = [], r2 = 0; r2 < arguments.length; r2++)
    t3[r2] = arguments[r2];
  for (var e2 = 0; e2 < t3.length; e2++)
    if (typeof t3[e2] != "number")
      throw new Error("assertNumbers arguments[" + e2 + "] is not a number. " + typeof t3[e2] + " == typeof " + t3[e2]);
  return true;
}
var n = Math.PI;
function o(t3, r2, e2) {
  t3.lArcFlag = t3.lArcFlag === 0 ? 0 : 1, t3.sweepFlag = t3.sweepFlag === 0 ? 0 : 1;
  var a2 = t3.rX, o2 = t3.rY, s2 = t3.x, u2 = t3.y;
  a2 = Math.abs(t3.rX), o2 = Math.abs(t3.rY);
  var h2 = i([(r2 - s2) / 2, (e2 - u2) / 2], -t3.xRot / 180 * n), c2 = h2[0], y2 = h2[1], p5 = Math.pow(c2, 2) / Math.pow(a2, 2) + Math.pow(y2, 2) / Math.pow(o2, 2);
  1 < p5 && (a2 *= Math.sqrt(p5), o2 *= Math.sqrt(p5)), t3.rX = a2, t3.rY = o2;
  var m2 = Math.pow(a2, 2) * Math.pow(y2, 2) + Math.pow(o2, 2) * Math.pow(c2, 2), O2 = (t3.lArcFlag !== t3.sweepFlag ? 1 : -1) * Math.sqrt(Math.max(0, (Math.pow(a2, 2) * Math.pow(o2, 2) - m2) / m2)), l2 = a2 * y2 / o2 * O2, T2 = -o2 * c2 / a2 * O2, v2 = i([l2, T2], t3.xRot / 180 * n);
  t3.cX = v2[0] + (r2 + s2) / 2, t3.cY = v2[1] + (e2 + u2) / 2, t3.phi1 = Math.atan2((y2 - T2) / o2, (c2 - l2) / a2), t3.phi2 = Math.atan2((-y2 - T2) / o2, (-c2 - l2) / a2), t3.sweepFlag === 0 && t3.phi2 > t3.phi1 && (t3.phi2 -= 2 * n), t3.sweepFlag === 1 && t3.phi2 < t3.phi1 && (t3.phi2 += 2 * n), t3.phi1 *= 180 / n, t3.phi2 *= 180 / n;
}
function s(t3, r2, e2) {
  a(t3, r2, e2);
  var i2 = t3 * t3 + r2 * r2 - e2 * e2;
  if (0 > i2)
    return [];
  if (i2 === 0)
    return [[t3 * e2 / (t3 * t3 + r2 * r2), r2 * e2 / (t3 * t3 + r2 * r2)]];
  var n2 = Math.sqrt(i2);
  return [[(t3 * e2 + r2 * n2) / (t3 * t3 + r2 * r2), (r2 * e2 - t3 * n2) / (t3 * t3 + r2 * r2)], [(t3 * e2 - r2 * n2) / (t3 * t3 + r2 * r2), (r2 * e2 + t3 * n2) / (t3 * t3 + r2 * r2)]];
}
var u;
var h = Math.PI / 180;
function c$1(t3, r2, e2) {
  return (1 - e2) * t3 + e2 * r2;
}
function y(t3, r2, e2, i2) {
  return t3 + Math.cos(i2 / 180 * n) * r2 + Math.sin(i2 / 180 * n) * e2;
}
function p(t3, r2, e2, i2) {
  var a2 = 1e-6, n2 = r2 - t3, o2 = e2 - r2, s2 = 3 * n2 + 3 * (i2 - e2) - 6 * o2, u2 = 6 * (o2 - n2), h2 = 3 * n2;
  return Math.abs(s2) < a2 ? [-h2 / u2] : function(t4, r3, e3) {
    e3 === void 0 && (e3 = 1e-6);
    var i3 = t4 * t4 / 4 - r3;
    if (i3 < -e3)
      return [];
    if (i3 <= e3)
      return [-t4 / 2];
    var a3 = Math.sqrt(i3);
    return [-t4 / 2 - a3, -t4 / 2 + a3];
  }(u2 / s2, h2 / s2, a2);
}
function m$1(t3, r2, e2, i2, a2) {
  var n2 = 1 - a2;
  return t3 * (n2 * n2 * n2) + r2 * (3 * n2 * n2 * a2) + e2 * (3 * n2 * a2 * a2) + i2 * (a2 * a2 * a2);
}
!function(t3) {
  function r2() {
    return u2(function(t4, r3, e3) {
      return t4.relative && (t4.x1 !== void 0 && (t4.x1 += r3), t4.y1 !== void 0 && (t4.y1 += e3), t4.x2 !== void 0 && (t4.x2 += r3), t4.y2 !== void 0 && (t4.y2 += e3), t4.x !== void 0 && (t4.x += r3), t4.y !== void 0 && (t4.y += e3), t4.relative = false), t4;
    });
  }
  function e2() {
    var t4 = NaN, r3 = NaN, e3 = NaN, i2 = NaN;
    return u2(function(a2, n3, o2) {
      return a2.type & _.SMOOTH_CURVE_TO && (a2.type = _.CURVE_TO, t4 = isNaN(t4) ? n3 : t4, r3 = isNaN(r3) ? o2 : r3, a2.x1 = a2.relative ? n3 - t4 : 2 * n3 - t4, a2.y1 = a2.relative ? o2 - r3 : 2 * o2 - r3), a2.type & _.CURVE_TO ? (t4 = a2.relative ? n3 + a2.x2 : a2.x2, r3 = a2.relative ? o2 + a2.y2 : a2.y2) : (t4 = NaN, r3 = NaN), a2.type & _.SMOOTH_QUAD_TO && (a2.type = _.QUAD_TO, e3 = isNaN(e3) ? n3 : e3, i2 = isNaN(i2) ? o2 : i2, a2.x1 = a2.relative ? n3 - e3 : 2 * n3 - e3, a2.y1 = a2.relative ? o2 - i2 : 2 * o2 - i2), a2.type & _.QUAD_TO ? (e3 = a2.relative ? n3 + a2.x1 : a2.x1, i2 = a2.relative ? o2 + a2.y1 : a2.y1) : (e3 = NaN, i2 = NaN), a2;
    });
  }
  function n2() {
    var t4 = NaN, r3 = NaN;
    return u2(function(e3, i2, a2) {
      if (e3.type & _.SMOOTH_QUAD_TO && (e3.type = _.QUAD_TO, t4 = isNaN(t4) ? i2 : t4, r3 = isNaN(r3) ? a2 : r3, e3.x1 = e3.relative ? i2 - t4 : 2 * i2 - t4, e3.y1 = e3.relative ? a2 - r3 : 2 * a2 - r3), e3.type & _.QUAD_TO) {
        t4 = e3.relative ? i2 + e3.x1 : e3.x1, r3 = e3.relative ? a2 + e3.y1 : e3.y1;
        var n3 = e3.x1, o2 = e3.y1;
        e3.type = _.CURVE_TO, e3.x1 = ((e3.relative ? 0 : i2) + 2 * n3) / 3, e3.y1 = ((e3.relative ? 0 : a2) + 2 * o2) / 3, e3.x2 = (e3.x + 2 * n3) / 3, e3.y2 = (e3.y + 2 * o2) / 3;
      } else
        t4 = NaN, r3 = NaN;
      return e3;
    });
  }
  function u2(t4) {
    var r3 = 0, e3 = 0, i2 = NaN, a2 = NaN;
    return function(n3) {
      if (isNaN(i2) && !(n3.type & _.MOVE_TO))
        throw new Error("path must start with moveto");
      var o2 = t4(n3, r3, e3, i2, a2);
      return n3.type & _.CLOSE_PATH && (r3 = i2, e3 = a2), n3.x !== void 0 && (r3 = n3.relative ? r3 + n3.x : n3.x), n3.y !== void 0 && (e3 = n3.relative ? e3 + n3.y : n3.y), n3.type & _.MOVE_TO && (i2 = r3, a2 = e3), o2;
    };
  }
  function O2(t4, r3, e3, i2, n3, o2) {
    return a(t4, r3, e3, i2, n3, o2), u2(function(a2, s2, u3, h2) {
      var c2 = a2.x1, y2 = a2.x2, p5 = a2.relative && !isNaN(h2), m2 = a2.x !== void 0 ? a2.x : p5 ? 0 : s2, O3 = a2.y !== void 0 ? a2.y : p5 ? 0 : u3;
      function l3(t5) {
        return t5 * t5;
      }
      a2.type & _.HORIZ_LINE_TO && r3 !== 0 && (a2.type = _.LINE_TO, a2.y = a2.relative ? 0 : u3), a2.type & _.VERT_LINE_TO && e3 !== 0 && (a2.type = _.LINE_TO, a2.x = a2.relative ? 0 : s2), a2.x !== void 0 && (a2.x = a2.x * t4 + O3 * e3 + (p5 ? 0 : n3)), a2.y !== void 0 && (a2.y = m2 * r3 + a2.y * i2 + (p5 ? 0 : o2)), a2.x1 !== void 0 && (a2.x1 = a2.x1 * t4 + a2.y1 * e3 + (p5 ? 0 : n3)), a2.y1 !== void 0 && (a2.y1 = c2 * r3 + a2.y1 * i2 + (p5 ? 0 : o2)), a2.x2 !== void 0 && (a2.x2 = a2.x2 * t4 + a2.y2 * e3 + (p5 ? 0 : n3)), a2.y2 !== void 0 && (a2.y2 = y2 * r3 + a2.y2 * i2 + (p5 ? 0 : o2));
      var T2 = t4 * i2 - r3 * e3;
      if (a2.xRot !== void 0 && (t4 !== 1 || r3 !== 0 || e3 !== 0 || i2 !== 1))
        if (T2 === 0)
          delete a2.rX, delete a2.rY, delete a2.xRot, delete a2.lArcFlag, delete a2.sweepFlag, a2.type = _.LINE_TO;
        else {
          var v2 = a2.xRot * Math.PI / 180, f2 = Math.sin(v2), N2 = Math.cos(v2), x2 = 1 / l3(a2.rX), d2 = 1 / l3(a2.rY), E2 = l3(N2) * x2 + l3(f2) * d2, A2 = 2 * f2 * N2 * (x2 - d2), C2 = l3(f2) * x2 + l3(N2) * d2, M2 = E2 * i2 * i2 - A2 * r3 * i2 + C2 * r3 * r3, R2 = A2 * (t4 * i2 + r3 * e3) - 2 * (E2 * e3 * i2 + C2 * t4 * r3), g2 = E2 * e3 * e3 - A2 * t4 * e3 + C2 * t4 * t4, I2 = (Math.atan2(R2, M2 - g2) + Math.PI) % Math.PI / 2, S2 = Math.sin(I2), L2 = Math.cos(I2);
          a2.rX = Math.abs(T2) / Math.sqrt(M2 * l3(L2) + R2 * S2 * L2 + g2 * l3(S2)), a2.rY = Math.abs(T2) / Math.sqrt(M2 * l3(S2) - R2 * S2 * L2 + g2 * l3(L2)), a2.xRot = 180 * I2 / Math.PI;
        }
      return a2.sweepFlag !== void 0 && 0 > T2 && (a2.sweepFlag = +!a2.sweepFlag), a2;
    });
  }
  function l2() {
    return function(t4) {
      var r3 = {};
      for (var e3 in t4)
        r3[e3] = t4[e3];
      return r3;
    };
  }
  t3.ROUND = function(t4) {
    function r3(r4) {
      return Math.round(r4 * t4) / t4;
    }
    return t4 === void 0 && (t4 = 1e13), a(t4), function(t5) {
      return t5.x1 !== void 0 && (t5.x1 = r3(t5.x1)), t5.y1 !== void 0 && (t5.y1 = r3(t5.y1)), t5.x2 !== void 0 && (t5.x2 = r3(t5.x2)), t5.y2 !== void 0 && (t5.y2 = r3(t5.y2)), t5.x !== void 0 && (t5.x = r3(t5.x)), t5.y !== void 0 && (t5.y = r3(t5.y)), t5.rX !== void 0 && (t5.rX = r3(t5.rX)), t5.rY !== void 0 && (t5.rY = r3(t5.rY)), t5;
    };
  }, t3.TO_ABS = r2, t3.TO_REL = function() {
    return u2(function(t4, r3, e3) {
      return t4.relative || (t4.x1 !== void 0 && (t4.x1 -= r3), t4.y1 !== void 0 && (t4.y1 -= e3), t4.x2 !== void 0 && (t4.x2 -= r3), t4.y2 !== void 0 && (t4.y2 -= e3), t4.x !== void 0 && (t4.x -= r3), t4.y !== void 0 && (t4.y -= e3), t4.relative = true), t4;
    });
  }, t3.NORMALIZE_HVZ = function(t4, r3, e3) {
    return t4 === void 0 && (t4 = true), r3 === void 0 && (r3 = true), e3 === void 0 && (e3 = true), u2(function(i2, a2, n3, o2, s2) {
      if (isNaN(o2) && !(i2.type & _.MOVE_TO))
        throw new Error("path must start with moveto");
      return r3 && i2.type & _.HORIZ_LINE_TO && (i2.type = _.LINE_TO, i2.y = i2.relative ? 0 : n3), e3 && i2.type & _.VERT_LINE_TO && (i2.type = _.LINE_TO, i2.x = i2.relative ? 0 : a2), t4 && i2.type & _.CLOSE_PATH && (i2.type = _.LINE_TO, i2.x = i2.relative ? o2 - a2 : o2, i2.y = i2.relative ? s2 - n3 : s2), i2.type & _.ARC && (i2.rX === 0 || i2.rY === 0) && (i2.type = _.LINE_TO, delete i2.rX, delete i2.rY, delete i2.xRot, delete i2.lArcFlag, delete i2.sweepFlag), i2;
    });
  }, t3.NORMALIZE_ST = e2, t3.QT_TO_C = n2, t3.INFO = u2, t3.SANITIZE = function(t4) {
    t4 === void 0 && (t4 = 0), a(t4);
    var r3 = NaN, e3 = NaN, i2 = NaN, n3 = NaN;
    return u2(function(a2, o2, s2, u3, h2) {
      var c2 = Math.abs, y2 = false, p5 = 0, m2 = 0;
      if (a2.type & _.SMOOTH_CURVE_TO && (p5 = isNaN(r3) ? 0 : o2 - r3, m2 = isNaN(e3) ? 0 : s2 - e3), a2.type & (_.CURVE_TO | _.SMOOTH_CURVE_TO) ? (r3 = a2.relative ? o2 + a2.x2 : a2.x2, e3 = a2.relative ? s2 + a2.y2 : a2.y2) : (r3 = NaN, e3 = NaN), a2.type & _.SMOOTH_QUAD_TO ? (i2 = isNaN(i2) ? o2 : 2 * o2 - i2, n3 = isNaN(n3) ? s2 : 2 * s2 - n3) : a2.type & _.QUAD_TO ? (i2 = a2.relative ? o2 + a2.x1 : a2.x1, n3 = a2.relative ? s2 + a2.y1 : a2.y2) : (i2 = NaN, n3 = NaN), a2.type & _.LINE_COMMANDS || a2.type & _.ARC && (a2.rX === 0 || a2.rY === 0 || !a2.lArcFlag) || a2.type & _.CURVE_TO || a2.type & _.SMOOTH_CURVE_TO || a2.type & _.QUAD_TO || a2.type & _.SMOOTH_QUAD_TO) {
        var O3 = a2.x === void 0 ? 0 : a2.relative ? a2.x : a2.x - o2, l3 = a2.y === void 0 ? 0 : a2.relative ? a2.y : a2.y - s2;
        p5 = isNaN(i2) ? a2.x1 === void 0 ? p5 : a2.relative ? a2.x : a2.x1 - o2 : i2 - o2, m2 = isNaN(n3) ? a2.y1 === void 0 ? m2 : a2.relative ? a2.y : a2.y1 - s2 : n3 - s2;
        var T2 = a2.x2 === void 0 ? 0 : a2.relative ? a2.x : a2.x2 - o2, v2 = a2.y2 === void 0 ? 0 : a2.relative ? a2.y : a2.y2 - s2;
        c2(O3) <= t4 && c2(l3) <= t4 && c2(p5) <= t4 && c2(m2) <= t4 && c2(T2) <= t4 && c2(v2) <= t4 && (y2 = true);
      }
      return a2.type & _.CLOSE_PATH && c2(o2 - u3) <= t4 && c2(s2 - h2) <= t4 && (y2 = true), y2 ? [] : a2;
    });
  }, t3.MATRIX = O2, t3.ROTATE = function(t4, r3, e3) {
    r3 === void 0 && (r3 = 0), e3 === void 0 && (e3 = 0), a(t4, r3, e3);
    var i2 = Math.sin(t4), n3 = Math.cos(t4);
    return O2(n3, i2, -i2, n3, r3 - r3 * n3 + e3 * i2, e3 - r3 * i2 - e3 * n3);
  }, t3.TRANSLATE = function(t4, r3) {
    return r3 === void 0 && (r3 = 0), a(t4, r3), O2(1, 0, 0, 1, t4, r3);
  }, t3.SCALE = function(t4, r3) {
    return r3 === void 0 && (r3 = t4), a(t4, r3), O2(t4, 0, 0, r3, 0, 0);
  }, t3.SKEW_X = function(t4) {
    return a(t4), O2(1, 0, Math.atan(t4), 1, 0, 0);
  }, t3.SKEW_Y = function(t4) {
    return a(t4), O2(1, Math.atan(t4), 0, 1, 0, 0);
  }, t3.X_AXIS_SYMMETRY = function(t4) {
    return t4 === void 0 && (t4 = 0), a(t4), O2(-1, 0, 0, 1, t4, 0);
  }, t3.Y_AXIS_SYMMETRY = function(t4) {
    return t4 === void 0 && (t4 = 0), a(t4), O2(1, 0, 0, -1, 0, t4);
  }, t3.A_TO_C = function() {
    return u2(function(t4, r3, e3) {
      return _.ARC === t4.type ? function(t5, r4, e4) {
        var a2, n3, s2, u3;
        t5.cX || o(t5, r4, e4);
        for (var y2 = Math.min(t5.phi1, t5.phi2), p5 = Math.max(t5.phi1, t5.phi2) - y2, m2 = Math.ceil(p5 / 90), O3 = new Array(m2), l3 = r4, T2 = e4, v2 = 0; v2 < m2; v2++) {
          var f2 = c$1(t5.phi1, t5.phi2, v2 / m2), N2 = c$1(t5.phi1, t5.phi2, (v2 + 1) / m2), x2 = N2 - f2, d2 = 4 / 3 * Math.tan(x2 * h / 4), E2 = [Math.cos(f2 * h) - d2 * Math.sin(f2 * h), Math.sin(f2 * h) + d2 * Math.cos(f2 * h)], A2 = E2[0], C2 = E2[1], M2 = [Math.cos(N2 * h), Math.sin(N2 * h)], R2 = M2[0], g2 = M2[1], I2 = [R2 + d2 * Math.sin(N2 * h), g2 - d2 * Math.cos(N2 * h)], S2 = I2[0], L2 = I2[1];
          O3[v2] = { relative: t5.relative, type: _.CURVE_TO };
          var H4 = function(r5, e5) {
            var a3 = i([r5 * t5.rX, e5 * t5.rY], t5.xRot), n4 = a3[0], o2 = a3[1];
            return [t5.cX + n4, t5.cY + o2];
          };
          a2 = H4(A2, C2), O3[v2].x1 = a2[0], O3[v2].y1 = a2[1], n3 = H4(S2, L2), O3[v2].x2 = n3[0], O3[v2].y2 = n3[1], s2 = H4(R2, g2), O3[v2].x = s2[0], O3[v2].y = s2[1], t5.relative && (O3[v2].x1 -= l3, O3[v2].y1 -= T2, O3[v2].x2 -= l3, O3[v2].y2 -= T2, O3[v2].x -= l3, O3[v2].y -= T2), l3 = (u3 = [O3[v2].x, O3[v2].y])[0], T2 = u3[1];
        }
        return O3;
      }(t4, t4.relative ? 0 : r3, t4.relative ? 0 : e3) : t4;
    });
  }, t3.ANNOTATE_ARCS = function() {
    return u2(function(t4, r3, e3) {
      return t4.relative && (r3 = 0, e3 = 0), _.ARC === t4.type && o(t4, r3, e3), t4;
    });
  }, t3.CLONE = l2, t3.CALCULATE_BOUNDS = function() {
    var t4 = function(t5) {
      var r3 = {};
      for (var e3 in t5)
        r3[e3] = t5[e3];
      return r3;
    }, i2 = r2(), a2 = n2(), h2 = e2(), c2 = u2(function(r3, e3, n3) {
      var u3 = h2(a2(i2(t4(r3))));
      function O3(t5) {
        t5 > c2.maxX && (c2.maxX = t5), t5 < c2.minX && (c2.minX = t5);
      }
      function l3(t5) {
        t5 > c2.maxY && (c2.maxY = t5), t5 < c2.minY && (c2.minY = t5);
      }
      if (u3.type & _.DRAWING_COMMANDS && (O3(e3), l3(n3)), u3.type & _.HORIZ_LINE_TO && O3(u3.x), u3.type & _.VERT_LINE_TO && l3(u3.y), u3.type & _.LINE_TO && (O3(u3.x), l3(u3.y)), u3.type & _.CURVE_TO) {
        O3(u3.x), l3(u3.y);
        for (var T2 = 0, v2 = p(e3, u3.x1, u3.x2, u3.x); T2 < v2.length; T2++) {
          0 < (w2 = v2[T2]) && 1 > w2 && O3(m$1(e3, u3.x1, u3.x2, u3.x, w2));
        }
        for (var f2 = 0, N2 = p(n3, u3.y1, u3.y2, u3.y); f2 < N2.length; f2++) {
          0 < (w2 = N2[f2]) && 1 > w2 && l3(m$1(n3, u3.y1, u3.y2, u3.y, w2));
        }
      }
      if (u3.type & _.ARC) {
        O3(u3.x), l3(u3.y), o(u3, e3, n3);
        for (var x2 = u3.xRot / 180 * Math.PI, d2 = Math.cos(x2) * u3.rX, E2 = Math.sin(x2) * u3.rX, A2 = -Math.sin(x2) * u3.rY, C2 = Math.cos(x2) * u3.rY, M2 = u3.phi1 < u3.phi2 ? [u3.phi1, u3.phi2] : -180 > u3.phi2 ? [u3.phi2 + 360, u3.phi1 + 360] : [u3.phi2, u3.phi1], R2 = M2[0], g2 = M2[1], I2 = function(t5) {
          var r4 = t5[0], e4 = t5[1], i3 = 180 * Math.atan2(e4, r4) / Math.PI;
          return i3 < R2 ? i3 + 360 : i3;
        }, S2 = 0, L2 = s(A2, -d2, 0).map(I2); S2 < L2.length; S2++) {
          (w2 = L2[S2]) > R2 && w2 < g2 && O3(y(u3.cX, d2, A2, w2));
        }
        for (var H4 = 0, U2 = s(C2, -E2, 0).map(I2); H4 < U2.length; H4++) {
          var w2;
          (w2 = U2[H4]) > R2 && w2 < g2 && l3(y(u3.cY, E2, C2, w2));
        }
      }
      return r3;
    });
    return c2.minX = 1 / 0, c2.maxX = -1 / 0, c2.minY = 1 / 0, c2.maxY = -1 / 0, c2;
  };
}(u || (u = {}));
var O;
var l = function() {
  function t3() {
  }
  return t3.prototype.round = function(t4) {
    return this.transform(u.ROUND(t4));
  }, t3.prototype.toAbs = function() {
    return this.transform(u.TO_ABS());
  }, t3.prototype.toRel = function() {
    return this.transform(u.TO_REL());
  }, t3.prototype.normalizeHVZ = function(t4, r2, e2) {
    return this.transform(u.NORMALIZE_HVZ(t4, r2, e2));
  }, t3.prototype.normalizeST = function() {
    return this.transform(u.NORMALIZE_ST());
  }, t3.prototype.qtToC = function() {
    return this.transform(u.QT_TO_C());
  }, t3.prototype.aToC = function() {
    return this.transform(u.A_TO_C());
  }, t3.prototype.sanitize = function(t4) {
    return this.transform(u.SANITIZE(t4));
  }, t3.prototype.translate = function(t4, r2) {
    return this.transform(u.TRANSLATE(t4, r2));
  }, t3.prototype.scale = function(t4, r2) {
    return this.transform(u.SCALE(t4, r2));
  }, t3.prototype.rotate = function(t4, r2, e2) {
    return this.transform(u.ROTATE(t4, r2, e2));
  }, t3.prototype.matrix = function(t4, r2, e2, i2, a2, n2) {
    return this.transform(u.MATRIX(t4, r2, e2, i2, a2, n2));
  }, t3.prototype.skewX = function(t4) {
    return this.transform(u.SKEW_X(t4));
  }, t3.prototype.skewY = function(t4) {
    return this.transform(u.SKEW_Y(t4));
  }, t3.prototype.xSymmetry = function(t4) {
    return this.transform(u.X_AXIS_SYMMETRY(t4));
  }, t3.prototype.ySymmetry = function(t4) {
    return this.transform(u.Y_AXIS_SYMMETRY(t4));
  }, t3.prototype.annotateArcs = function() {
    return this.transform(u.ANNOTATE_ARCS());
  }, t3;
}();
var T = function(t3) {
  return t3 === " " || t3 === "	" || t3 === "\r" || t3 === "\n";
};
var v = function(t3) {
  return "0".charCodeAt(0) <= t3.charCodeAt(0) && t3.charCodeAt(0) <= "9".charCodeAt(0);
};
var f = function(t3) {
  function e2() {
    var r2 = t3.call(this) || this;
    return r2.curNumber = "", r2.curCommandType = -1, r2.curCommandRelative = false, r2.canParseCommandOrComma = true, r2.curNumberHasExp = false, r2.curNumberHasExpDigits = false, r2.curNumberHasDecimal = false, r2.curArgs = [], r2;
  }
  return r(e2, t3), e2.prototype.finish = function(t4) {
    if (t4 === void 0 && (t4 = []), this.parse(" ", t4), this.curArgs.length !== 0 || !this.canParseCommandOrComma)
      throw new SyntaxError("Unterminated command at the path end.");
    return t4;
  }, e2.prototype.parse = function(t4, r2) {
    var e3 = this;
    r2 === void 0 && (r2 = []);
    for (var i2 = function(t5) {
      r2.push(t5), e3.curArgs.length = 0, e3.canParseCommandOrComma = true;
    }, a2 = 0; a2 < t4.length; a2++) {
      var n2 = t4[a2], o2 = !(this.curCommandType !== _.ARC || this.curArgs.length !== 3 && this.curArgs.length !== 4 || this.curNumber.length !== 1 || this.curNumber !== "0" && this.curNumber !== "1"), s2 = v(n2) && (this.curNumber === "0" && n2 === "0" || o2);
      if (!v(n2) || s2)
        if (n2 !== "e" && n2 !== "E")
          if (n2 !== "-" && n2 !== "+" || !this.curNumberHasExp || this.curNumberHasExpDigits)
            if (n2 !== "." || this.curNumberHasExp || this.curNumberHasDecimal || o2) {
              if (this.curNumber && this.curCommandType !== -1) {
                var u2 = Number(this.curNumber);
                if (isNaN(u2))
                  throw new SyntaxError("Invalid number ending at " + a2);
                if (this.curCommandType === _.ARC) {
                  if (this.curArgs.length === 0 || this.curArgs.length === 1) {
                    if (0 > u2)
                      throw new SyntaxError('Expected positive number, got "' + u2 + '" at index "' + a2 + '"');
                  } else if ((this.curArgs.length === 3 || this.curArgs.length === 4) && this.curNumber !== "0" && this.curNumber !== "1")
                    throw new SyntaxError('Expected a flag, got "' + this.curNumber + '" at index "' + a2 + '"');
                }
                this.curArgs.push(u2), this.curArgs.length === N[this.curCommandType] && (_.HORIZ_LINE_TO === this.curCommandType ? i2({ type: _.HORIZ_LINE_TO, relative: this.curCommandRelative, x: u2 }) : _.VERT_LINE_TO === this.curCommandType ? i2({ type: _.VERT_LINE_TO, relative: this.curCommandRelative, y: u2 }) : this.curCommandType === _.MOVE_TO || this.curCommandType === _.LINE_TO || this.curCommandType === _.SMOOTH_QUAD_TO ? (i2({ type: this.curCommandType, relative: this.curCommandRelative, x: this.curArgs[0], y: this.curArgs[1] }), _.MOVE_TO === this.curCommandType && (this.curCommandType = _.LINE_TO)) : this.curCommandType === _.CURVE_TO ? i2({ type: _.CURVE_TO, relative: this.curCommandRelative, x1: this.curArgs[0], y1: this.curArgs[1], x2: this.curArgs[2], y2: this.curArgs[3], x: this.curArgs[4], y: this.curArgs[5] }) : this.curCommandType === _.SMOOTH_CURVE_TO ? i2({ type: _.SMOOTH_CURVE_TO, relative: this.curCommandRelative, x2: this.curArgs[0], y2: this.curArgs[1], x: this.curArgs[2], y: this.curArgs[3] }) : this.curCommandType === _.QUAD_TO ? i2({ type: _.QUAD_TO, relative: this.curCommandRelative, x1: this.curArgs[0], y1: this.curArgs[1], x: this.curArgs[2], y: this.curArgs[3] }) : this.curCommandType === _.ARC && i2({ type: _.ARC, relative: this.curCommandRelative, rX: this.curArgs[0], rY: this.curArgs[1], xRot: this.curArgs[2], lArcFlag: this.curArgs[3], sweepFlag: this.curArgs[4], x: this.curArgs[5], y: this.curArgs[6] })), this.curNumber = "", this.curNumberHasExpDigits = false, this.curNumberHasExp = false, this.curNumberHasDecimal = false, this.canParseCommandOrComma = true;
              }
              if (!T(n2))
                if (n2 === "," && this.canParseCommandOrComma)
                  this.canParseCommandOrComma = false;
                else if (n2 !== "+" && n2 !== "-" && n2 !== ".")
                  if (s2)
                    this.curNumber = n2, this.curNumberHasDecimal = false;
                  else {
                    if (this.curArgs.length !== 0)
                      throw new SyntaxError("Unterminated command at index " + a2 + ".");
                    if (!this.canParseCommandOrComma)
                      throw new SyntaxError('Unexpected character "' + n2 + '" at index ' + a2 + ". Command cannot follow comma");
                    if (this.canParseCommandOrComma = false, n2 !== "z" && n2 !== "Z")
                      if (n2 === "h" || n2 === "H")
                        this.curCommandType = _.HORIZ_LINE_TO, this.curCommandRelative = n2 === "h";
                      else if (n2 === "v" || n2 === "V")
                        this.curCommandType = _.VERT_LINE_TO, this.curCommandRelative = n2 === "v";
                      else if (n2 === "m" || n2 === "M")
                        this.curCommandType = _.MOVE_TO, this.curCommandRelative = n2 === "m";
                      else if (n2 === "l" || n2 === "L")
                        this.curCommandType = _.LINE_TO, this.curCommandRelative = n2 === "l";
                      else if (n2 === "c" || n2 === "C")
                        this.curCommandType = _.CURVE_TO, this.curCommandRelative = n2 === "c";
                      else if (n2 === "s" || n2 === "S")
                        this.curCommandType = _.SMOOTH_CURVE_TO, this.curCommandRelative = n2 === "s";
                      else if (n2 === "q" || n2 === "Q")
                        this.curCommandType = _.QUAD_TO, this.curCommandRelative = n2 === "q";
                      else if (n2 === "t" || n2 === "T")
                        this.curCommandType = _.SMOOTH_QUAD_TO, this.curCommandRelative = n2 === "t";
                      else {
                        if (n2 !== "a" && n2 !== "A")
                          throw new SyntaxError('Unexpected character "' + n2 + '" at index ' + a2 + ".");
                        this.curCommandType = _.ARC, this.curCommandRelative = n2 === "a";
                      }
                    else
                      r2.push({ type: _.CLOSE_PATH }), this.canParseCommandOrComma = true, this.curCommandType = -1;
                  }
                else
                  this.curNumber = n2, this.curNumberHasDecimal = n2 === ".";
            } else
              this.curNumber += n2, this.curNumberHasDecimal = true;
          else
            this.curNumber += n2;
        else
          this.curNumber += n2, this.curNumberHasExp = true;
      else
        this.curNumber += n2, this.curNumberHasExpDigits = this.curNumberHasExp;
    }
    return r2;
  }, e2.prototype.transform = function(t4) {
    return Object.create(this, { parse: { value: function(r2, e3) {
      e3 === void 0 && (e3 = []);
      for (var i2 = 0, a2 = Object.getPrototypeOf(this).parse.call(this, r2); i2 < a2.length; i2++) {
        var n2 = a2[i2], o2 = t4(n2);
        Array.isArray(o2) ? e3.push.apply(e3, o2) : e3.push(o2);
      }
      return e3;
    } } });
  }, e2;
}(l);
var _ = function(t3) {
  function i2(r2) {
    var e2 = t3.call(this) || this;
    return e2.commands = typeof r2 == "string" ? i2.parse(r2) : r2, e2;
  }
  return r(i2, t3), i2.prototype.encode = function() {
    return i2.encode(this.commands);
  }, i2.prototype.getBounds = function() {
    var t4 = u.CALCULATE_BOUNDS();
    return this.transform(t4), t4;
  }, i2.prototype.transform = function(t4) {
    for (var r2 = [], e2 = 0, i3 = this.commands; e2 < i3.length; e2++) {
      var a2 = t4(i3[e2]);
      Array.isArray(a2) ? r2.push.apply(r2, a2) : r2.push(a2);
    }
    return this.commands = r2, this;
  }, i2.encode = function(t4) {
    return e(t4);
  }, i2.parse = function(t4) {
    var r2 = new f(), e2 = [];
    return r2.parse(t4, e2), r2.finish(e2), e2;
  }, i2.CLOSE_PATH = 1, i2.MOVE_TO = 2, i2.HORIZ_LINE_TO = 4, i2.VERT_LINE_TO = 8, i2.LINE_TO = 16, i2.CURVE_TO = 32, i2.SMOOTH_CURVE_TO = 64, i2.QUAD_TO = 128, i2.SMOOTH_QUAD_TO = 256, i2.ARC = 512, i2.LINE_COMMANDS = i2.LINE_TO | i2.HORIZ_LINE_TO | i2.VERT_LINE_TO, i2.DRAWING_COMMANDS = i2.HORIZ_LINE_TO | i2.VERT_LINE_TO | i2.LINE_TO | i2.CURVE_TO | i2.SMOOTH_CURVE_TO | i2.QUAD_TO | i2.SMOOTH_QUAD_TO | i2.ARC, i2;
}(l);
var N = ((O = {})[_.MOVE_TO] = 2, O[_.LINE_TO] = 2, O[_.HORIZ_LINE_TO] = 1, O[_.VERT_LINE_TO] = 1, O[_.CLOSE_PATH] = 0, O[_.QUAD_TO] = 4, O[_.SMOOTH_QUAD_TO] = 2, O[_.CURVE_TO] = 6, O[_.SMOOTH_CURVE_TO] = 4, O[_.ARC] = 7, O);
var uncurryThis = functionUncurryThis;
var PROPER_FUNCTION_NAME = functionName.PROPER;
var redefine = redefine$7.exports;
var anObject = anObject$g;
var isPrototypeOf = objectIsPrototypeOf;
var $toString = toString$9;
var fails = fails$k;
var regExpFlags = regexpFlags$1;
var TO_STRING = "toString";
var RegExpPrototype = RegExp.prototype;
var n$ToString = RegExpPrototype[TO_STRING];
var getFlags = uncurryThis(regExpFlags);
var NOT_GENERIC = fails(function() {
  return n$ToString.call({ source: "a", flags: "b" }) != "/a/b";
});
var INCORRECT_NAME = PROPER_FUNCTION_NAME && n$ToString.name != TO_STRING;
if (NOT_GENERIC || INCORRECT_NAME) {
  redefine(RegExp.prototype, TO_STRING, function toString3() {
    var R2 = anObject(this);
    var p5 = $toString(R2.source);
    var rf = R2.flags;
    var f2 = $toString(rf === void 0 && isPrototypeOf(RegExpPrototype, R2) && !("flags" in RegExpPrototype) ? getFlags(R2) : rf);
    return "/" + p5 + "/" + f2;
  }, { unsafe: true });
}
function _typeof(obj) {
  "@babel/helpers - typeof";
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof = function(obj2) {
      return typeof obj2;
    };
  } else {
    _typeof = function(obj2) {
      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    };
  }
  return _typeof(obj);
}
function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
var mulTable = [512, 512, 456, 512, 328, 456, 335, 512, 405, 328, 271, 456, 388, 335, 292, 512, 454, 405, 364, 328, 298, 271, 496, 456, 420, 388, 360, 335, 312, 292, 273, 512, 482, 454, 428, 405, 383, 364, 345, 328, 312, 298, 284, 271, 259, 496, 475, 456, 437, 420, 404, 388, 374, 360, 347, 335, 323, 312, 302, 292, 282, 273, 265, 512, 497, 482, 468, 454, 441, 428, 417, 405, 394, 383, 373, 364, 354, 345, 337, 328, 320, 312, 305, 298, 291, 284, 278, 271, 265, 259, 507, 496, 485, 475, 465, 456, 446, 437, 428, 420, 412, 404, 396, 388, 381, 374, 367, 360, 354, 347, 341, 335, 329, 323, 318, 312, 307, 302, 297, 292, 287, 282, 278, 273, 269, 265, 261, 512, 505, 497, 489, 482, 475, 468, 461, 454, 447, 441, 435, 428, 422, 417, 411, 405, 399, 394, 389, 383, 378, 373, 368, 364, 359, 354, 350, 345, 341, 337, 332, 328, 324, 320, 316, 312, 309, 305, 301, 298, 294, 291, 287, 284, 281, 278, 274, 271, 268, 265, 262, 259, 257, 507, 501, 496, 491, 485, 480, 475, 470, 465, 460, 456, 451, 446, 442, 437, 433, 428, 424, 420, 416, 412, 408, 404, 400, 396, 392, 388, 385, 381, 377, 374, 370, 367, 363, 360, 357, 354, 350, 347, 344, 341, 338, 335, 332, 329, 326, 323, 320, 318, 315, 312, 310, 307, 304, 302, 299, 297, 294, 292, 289, 287, 285, 282, 280, 278, 275, 273, 271, 269, 267, 265, 263, 261, 259];
var shgTable = [9, 11, 12, 13, 13, 14, 14, 15, 15, 15, 15, 16, 16, 16, 16, 17, 17, 17, 17, 17, 17, 17, 18, 18, 18, 18, 18, 18, 18, 18, 18, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24];
function getImageDataFromCanvas(canvas, topX, topY, width, height) {
  if (typeof canvas === "string") {
    canvas = document.getElementById(canvas);
  }
  if (!canvas || _typeof(canvas) !== "object" || !("getContext" in canvas)) {
    throw new TypeError("Expecting canvas with `getContext` method in processCanvasRGB(A) calls!");
  }
  var context = canvas.getContext("2d");
  try {
    return context.getImageData(topX, topY, width, height);
  } catch (e2) {
    throw new Error("unable to access image data: " + e2);
  }
}
function processCanvasRGBA(canvas, topX, topY, width, height, radius) {
  if (isNaN(radius) || radius < 1) {
    return;
  }
  radius |= 0;
  var imageData = getImageDataFromCanvas(canvas, topX, topY, width, height);
  imageData = processImageDataRGBA(imageData, topX, topY, width, height, radius);
  canvas.getContext("2d").putImageData(imageData, topX, topY);
}
function processImageDataRGBA(imageData, topX, topY, width, height, radius) {
  var pixels = imageData.data;
  var div = 2 * radius + 1;
  var widthMinus1 = width - 1;
  var heightMinus1 = height - 1;
  var radiusPlus1 = radius + 1;
  var sumFactor = radiusPlus1 * (radiusPlus1 + 1) / 2;
  var stackStart = new BlurStack();
  var stack = stackStart;
  var stackEnd;
  for (var i2 = 1; i2 < div; i2++) {
    stack = stack.next = new BlurStack();
    if (i2 === radiusPlus1) {
      stackEnd = stack;
    }
  }
  stack.next = stackStart;
  var stackIn = null, stackOut = null, yw = 0, yi = 0;
  var mulSum = mulTable[radius];
  var shgSum = shgTable[radius];
  for (var y2 = 0; y2 < height; y2++) {
    stack = stackStart;
    var pr = pixels[yi], pg = pixels[yi + 1], pb = pixels[yi + 2], pa = pixels[yi + 3];
    for (var _i = 0; _i < radiusPlus1; _i++) {
      stack.r = pr;
      stack.g = pg;
      stack.b = pb;
      stack.a = pa;
      stack = stack.next;
    }
    var rInSum = 0, gInSum = 0, bInSum = 0, aInSum = 0, rOutSum = radiusPlus1 * pr, gOutSum = radiusPlus1 * pg, bOutSum = radiusPlus1 * pb, aOutSum = radiusPlus1 * pa, rSum = sumFactor * pr, gSum = sumFactor * pg, bSum = sumFactor * pb, aSum = sumFactor * pa;
    for (var _i2 = 1; _i2 < radiusPlus1; _i2++) {
      var p5 = yi + ((widthMinus1 < _i2 ? widthMinus1 : _i2) << 2);
      var r2 = pixels[p5], g2 = pixels[p5 + 1], b2 = pixels[p5 + 2], a2 = pixels[p5 + 3];
      var rbs = radiusPlus1 - _i2;
      rSum += (stack.r = r2) * rbs;
      gSum += (stack.g = g2) * rbs;
      bSum += (stack.b = b2) * rbs;
      aSum += (stack.a = a2) * rbs;
      rInSum += r2;
      gInSum += g2;
      bInSum += b2;
      aInSum += a2;
      stack = stack.next;
    }
    stackIn = stackStart;
    stackOut = stackEnd;
    for (var x2 = 0; x2 < width; x2++) {
      var paInitial = aSum * mulSum >> shgSum;
      pixels[yi + 3] = paInitial;
      if (paInitial !== 0) {
        var _a2 = 255 / paInitial;
        pixels[yi] = (rSum * mulSum >> shgSum) * _a2;
        pixels[yi + 1] = (gSum * mulSum >> shgSum) * _a2;
        pixels[yi + 2] = (bSum * mulSum >> shgSum) * _a2;
      } else {
        pixels[yi] = pixels[yi + 1] = pixels[yi + 2] = 0;
      }
      rSum -= rOutSum;
      gSum -= gOutSum;
      bSum -= bOutSum;
      aSum -= aOutSum;
      rOutSum -= stackIn.r;
      gOutSum -= stackIn.g;
      bOutSum -= stackIn.b;
      aOutSum -= stackIn.a;
      var _p = x2 + radius + 1;
      _p = yw + (_p < widthMinus1 ? _p : widthMinus1) << 2;
      rInSum += stackIn.r = pixels[_p];
      gInSum += stackIn.g = pixels[_p + 1];
      bInSum += stackIn.b = pixels[_p + 2];
      aInSum += stackIn.a = pixels[_p + 3];
      rSum += rInSum;
      gSum += gInSum;
      bSum += bInSum;
      aSum += aInSum;
      stackIn = stackIn.next;
      var _stackOut = stackOut, _r = _stackOut.r, _g = _stackOut.g, _b2 = _stackOut.b, _a3 = _stackOut.a;
      rOutSum += _r;
      gOutSum += _g;
      bOutSum += _b2;
      aOutSum += _a3;
      rInSum -= _r;
      gInSum -= _g;
      bInSum -= _b2;
      aInSum -= _a3;
      stackOut = stackOut.next;
      yi += 4;
    }
    yw += width;
  }
  for (var _x = 0; _x < width; _x++) {
    yi = _x << 2;
    var _pr = pixels[yi], _pg = pixels[yi + 1], _pb = pixels[yi + 2], _pa = pixels[yi + 3], _rOutSum = radiusPlus1 * _pr, _gOutSum = radiusPlus1 * _pg, _bOutSum = radiusPlus1 * _pb, _aOutSum = radiusPlus1 * _pa, _rSum = sumFactor * _pr, _gSum = sumFactor * _pg, _bSum = sumFactor * _pb, _aSum = sumFactor * _pa;
    stack = stackStart;
    for (var _i3 = 0; _i3 < radiusPlus1; _i3++) {
      stack.r = _pr;
      stack.g = _pg;
      stack.b = _pb;
      stack.a = _pa;
      stack = stack.next;
    }
    var yp = width;
    var _gInSum = 0, _bInSum = 0, _aInSum = 0, _rInSum = 0;
    for (var _i4 = 1; _i4 <= radius; _i4++) {
      yi = yp + _x << 2;
      var _rbs = radiusPlus1 - _i4;
      _rSum += (stack.r = _pr = pixels[yi]) * _rbs;
      _gSum += (stack.g = _pg = pixels[yi + 1]) * _rbs;
      _bSum += (stack.b = _pb = pixels[yi + 2]) * _rbs;
      _aSum += (stack.a = _pa = pixels[yi + 3]) * _rbs;
      _rInSum += _pr;
      _gInSum += _pg;
      _bInSum += _pb;
      _aInSum += _pa;
      stack = stack.next;
      if (_i4 < heightMinus1) {
        yp += width;
      }
    }
    yi = _x;
    stackIn = stackStart;
    stackOut = stackEnd;
    for (var _y = 0; _y < height; _y++) {
      var _p2 = yi << 2;
      pixels[_p2 + 3] = _pa = _aSum * mulSum >> shgSum;
      if (_pa > 0) {
        _pa = 255 / _pa;
        pixels[_p2] = (_rSum * mulSum >> shgSum) * _pa;
        pixels[_p2 + 1] = (_gSum * mulSum >> shgSum) * _pa;
        pixels[_p2 + 2] = (_bSum * mulSum >> shgSum) * _pa;
      } else {
        pixels[_p2] = pixels[_p2 + 1] = pixels[_p2 + 2] = 0;
      }
      _rSum -= _rOutSum;
      _gSum -= _gOutSum;
      _bSum -= _bOutSum;
      _aSum -= _aOutSum;
      _rOutSum -= stackIn.r;
      _gOutSum -= stackIn.g;
      _bOutSum -= stackIn.b;
      _aOutSum -= stackIn.a;
      _p2 = _x + ((_p2 = _y + radiusPlus1) < heightMinus1 ? _p2 : heightMinus1) * width << 2;
      _rSum += _rInSum += stackIn.r = pixels[_p2];
      _gSum += _gInSum += stackIn.g = pixels[_p2 + 1];
      _bSum += _bInSum += stackIn.b = pixels[_p2 + 2];
      _aSum += _aInSum += stackIn.a = pixels[_p2 + 3];
      stackIn = stackIn.next;
      _rOutSum += _pr = stackOut.r;
      _gOutSum += _pg = stackOut.g;
      _bOutSum += _pb = stackOut.b;
      _aOutSum += _pa = stackOut.a;
      _rInSum -= _pr;
      _gInSum -= _pg;
      _bInSum -= _pb;
      _aInSum -= _pa;
      stackOut = stackOut.next;
      yi += width;
    }
  }
  return imageData;
}
var BlurStack = function BlurStack2() {
  _classCallCheck(this, BlurStack2);
  this.r = 0;
  this.g = 0;
  this.b = 0;
  this.a = 0;
  this.next = null;
};
function offscreen() {
  var {
    DOMParser: DOMParserFallback
  } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
  var preset = {
    window: null,
    ignoreAnimation: true,
    ignoreMouse: true,
    DOMParser: DOMParserFallback,
    createCanvas(width, height) {
      return new OffscreenCanvas(width, height);
    },
    createImage(url) {
      return _asyncToGenerator(function* () {
        var response = yield fetch(url);
        var blob = yield response.blob();
        var img = yield createImageBitmap(blob);
        return img;
      })();
    }
  };
  if (typeof DOMParser !== "undefined" || typeof DOMParserFallback === "undefined") {
    Reflect.deleteProperty(preset, "DOMParser");
  }
  return preset;
}
function node(_ref2) {
  var {
    DOMParser: DOMParser2,
    canvas,
    fetch: fetch2
  } = _ref2;
  return {
    window: null,
    ignoreAnimation: true,
    ignoreMouse: true,
    DOMParser: DOMParser2,
    fetch: fetch2,
    createCanvas: canvas.createCanvas,
    createImage: canvas.loadImage
  };
}
var index = Object.freeze({
  __proto__: null,
  offscreen,
  node
});
function compressSpaces(str) {
  return str.replace(/(?!\u3000)\s+/gm, " ");
}
function trimLeft(str) {
  return str.replace(/^[\n \t]+/, "");
}
function trimRight(str) {
  return str.replace(/[\n \t]+$/, "");
}
function toNumbers(str) {
  var matches = (str || "").match(/-?(\d+(?:\.\d*(?:[eE][+-]?\d+)?)?|\.\d+)(?=\D|$)/gm) || [];
  return matches.map(parseFloat);
}
var allUppercase = /^[A-Z-]+$/;
function normalizeAttributeName(name) {
  if (allUppercase.test(name)) {
    return name.toLowerCase();
  }
  return name;
}
function parseExternalUrl(url) {
  var urlMatch = /url\(('([^']+)'|"([^"]+)"|([^'")]+))\)/.exec(url) || [];
  return urlMatch[2] || urlMatch[3] || urlMatch[4];
}
function normalizeColor(color2) {
  if (!color2.startsWith("rgb")) {
    return color2;
  }
  var rgbParts = 3;
  var normalizedColor = color2.replace(/\d+(\.\d+)?/g, (num, isFloat) => rgbParts-- && isFloat ? String(Math.round(parseFloat(num))) : num);
  return normalizedColor;
}
var attributeRegex = /(\[[^\]]+\])/g;
var idRegex = /(#[^\s+>~.[:]+)/g;
var classRegex = /(\.[^\s+>~.[:]+)/g;
var pseudoElementRegex = /(::[^\s+>~.[:]+|:first-line|:first-letter|:before|:after)/gi;
var pseudoClassWithBracketsRegex = /(:[\w-]+\([^)]*\))/gi;
var pseudoClassRegex = /(:[^\s+>~.[:]+)/g;
var elementRegex = /([^\s+>~.[:]+)/g;
function findSelectorMatch(selector, regex) {
  var matches = regex.exec(selector);
  if (!matches) {
    return [selector, 0];
  }
  return [selector.replace(regex, " "), matches.length];
}
function getSelectorSpecificity(selector) {
  var specificity = [0, 0, 0];
  var currentSelector = selector.replace(/:not\(([^)]*)\)/g, "     $1 ").replace(/{[\s\S]*/gm, " ");
  var delta = 0;
  [currentSelector, delta] = findSelectorMatch(currentSelector, attributeRegex);
  specificity[1] += delta;
  [currentSelector, delta] = findSelectorMatch(currentSelector, idRegex);
  specificity[0] += delta;
  [currentSelector, delta] = findSelectorMatch(currentSelector, classRegex);
  specificity[1] += delta;
  [currentSelector, delta] = findSelectorMatch(currentSelector, pseudoElementRegex);
  specificity[2] += delta;
  [currentSelector, delta] = findSelectorMatch(currentSelector, pseudoClassWithBracketsRegex);
  specificity[1] += delta;
  [currentSelector, delta] = findSelectorMatch(currentSelector, pseudoClassRegex);
  specificity[1] += delta;
  currentSelector = currentSelector.replace(/[*\s+>~]/g, " ").replace(/[#.]/g, " ");
  [currentSelector, delta] = findSelectorMatch(currentSelector, elementRegex);
  specificity[2] += delta;
  return specificity.join("");
}
var PSEUDO_ZERO = 1e-8;
function vectorMagnitude(v2) {
  return Math.sqrt(Math.pow(v2[0], 2) + Math.pow(v2[1], 2));
}
function vectorsRatio(u2, v2) {
  return (u2[0] * v2[0] + u2[1] * v2[1]) / (vectorMagnitude(u2) * vectorMagnitude(v2));
}
function vectorsAngle(u2, v2) {
  return (u2[0] * v2[1] < u2[1] * v2[0] ? -1 : 1) * Math.acos(vectorsRatio(u2, v2));
}
function CB1(t3) {
  return t3 * t3 * t3;
}
function CB2(t3) {
  return 3 * t3 * t3 * (1 - t3);
}
function CB3(t3) {
  return 3 * t3 * (1 - t3) * (1 - t3);
}
function CB4(t3) {
  return (1 - t3) * (1 - t3) * (1 - t3);
}
function QB1(t3) {
  return t3 * t3;
}
function QB2(t3) {
  return 2 * t3 * (1 - t3);
}
function QB3(t3) {
  return (1 - t3) * (1 - t3);
}
var Property = class {
  constructor(document2, name, value) {
    this.document = document2;
    this.name = name;
    this.value = value;
    this.isNormalizedColor = false;
  }
  static empty(document2) {
    return new Property(document2, "EMPTY", "");
  }
  split() {
    var separator = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : " ";
    var {
      document: document2,
      name
    } = this;
    return compressSpaces(this.getString()).trim().split(separator).map((value) => new Property(document2, name, value));
  }
  hasValue(zeroIsValue) {
    var {
      value
    } = this;
    return value !== null && value !== "" && (zeroIsValue || value !== 0) && typeof value !== "undefined";
  }
  isString(regexp) {
    var {
      value
    } = this;
    var result = typeof value === "string";
    if (!result || !regexp) {
      return result;
    }
    return regexp.test(value);
  }
  isUrlDefinition() {
    return this.isString(/^url\(/);
  }
  isPixels() {
    if (!this.hasValue()) {
      return false;
    }
    var asString2 = this.getString();
    switch (true) {
      case asString2.endsWith("px"):
      case /^[0-9]+$/.test(asString2):
        return true;
      default:
        return false;
    }
  }
  setValue(value) {
    this.value = value;
    return this;
  }
  getValue(def) {
    if (typeof def === "undefined" || this.hasValue()) {
      return this.value;
    }
    return def;
  }
  getNumber(def) {
    if (!this.hasValue()) {
      if (typeof def === "undefined") {
        return 0;
      }
      return parseFloat(def);
    }
    var {
      value
    } = this;
    var n2 = parseFloat(value);
    if (this.isString(/%$/)) {
      n2 /= 100;
    }
    return n2;
  }
  getString(def) {
    if (typeof def === "undefined" || this.hasValue()) {
      return typeof this.value === "undefined" ? "" : String(this.value);
    }
    return String(def);
  }
  getColor(def) {
    var color2 = this.getString(def);
    if (this.isNormalizedColor) {
      return color2;
    }
    this.isNormalizedColor = true;
    color2 = normalizeColor(color2);
    this.value = color2;
    return color2;
  }
  getDpi() {
    return 96;
  }
  getRem() {
    return this.document.rootEmSize;
  }
  getEm() {
    return this.document.emSize;
  }
  getUnits() {
    return this.getString().replace(/[0-9.-]/g, "");
  }
  getPixels(axisOrIsFontSize) {
    var processPercent = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
    if (!this.hasValue()) {
      return 0;
    }
    var [axis, isFontSize] = typeof axisOrIsFontSize === "boolean" ? [void 0, axisOrIsFontSize] : [axisOrIsFontSize];
    var {
      viewPort
    } = this.document.screen;
    switch (true) {
      case this.isString(/vmin$/):
        return this.getNumber() / 100 * Math.min(viewPort.computeSize("x"), viewPort.computeSize("y"));
      case this.isString(/vmax$/):
        return this.getNumber() / 100 * Math.max(viewPort.computeSize("x"), viewPort.computeSize("y"));
      case this.isString(/vw$/):
        return this.getNumber() / 100 * viewPort.computeSize("x");
      case this.isString(/vh$/):
        return this.getNumber() / 100 * viewPort.computeSize("y");
      case this.isString(/rem$/):
        return this.getNumber() * this.getRem();
      case this.isString(/em$/):
        return this.getNumber() * this.getEm();
      case this.isString(/ex$/):
        return this.getNumber() * this.getEm() / 2;
      case this.isString(/px$/):
        return this.getNumber();
      case this.isString(/pt$/):
        return this.getNumber() * this.getDpi() * (1 / 72);
      case this.isString(/pc$/):
        return this.getNumber() * 15;
      case this.isString(/cm$/):
        return this.getNumber() * this.getDpi() / 2.54;
      case this.isString(/mm$/):
        return this.getNumber() * this.getDpi() / 25.4;
      case this.isString(/in$/):
        return this.getNumber() * this.getDpi();
      case (this.isString(/%$/) && isFontSize):
        return this.getNumber() * this.getEm();
      case this.isString(/%$/):
        return this.getNumber() * viewPort.computeSize(axis);
      default: {
        var n2 = this.getNumber();
        if (processPercent && n2 < 1) {
          return n2 * viewPort.computeSize(axis);
        }
        return n2;
      }
    }
  }
  getMilliseconds() {
    if (!this.hasValue()) {
      return 0;
    }
    if (this.isString(/ms$/)) {
      return this.getNumber();
    }
    return this.getNumber() * 1e3;
  }
  getRadians() {
    if (!this.hasValue()) {
      return 0;
    }
    switch (true) {
      case this.isString(/deg$/):
        return this.getNumber() * (Math.PI / 180);
      case this.isString(/grad$/):
        return this.getNumber() * (Math.PI / 200);
      case this.isString(/rad$/):
        return this.getNumber();
      default:
        return this.getNumber() * (Math.PI / 180);
    }
  }
  getDefinition() {
    var asString2 = this.getString();
    var name = /#([^)'"]+)/.exec(asString2);
    if (name) {
      name = name[1];
    }
    if (!name) {
      name = asString2;
    }
    return this.document.definitions[name];
  }
  getFillStyleDefinition(element, opacity2) {
    var def = this.getDefinition();
    if (!def) {
      return null;
    }
    if (typeof def.createGradient === "function") {
      return def.createGradient(this.document.ctx, element, opacity2);
    }
    if (typeof def.createPattern === "function") {
      if (def.getHrefAttribute().hasValue()) {
        var patternTransform = def.getAttribute("patternTransform");
        def = def.getHrefAttribute().getDefinition();
        if (patternTransform.hasValue()) {
          def.getAttribute("patternTransform", true).setValue(patternTransform.value);
        }
      }
      return def.createPattern(this.document.ctx, element, opacity2);
    }
    return null;
  }
  getTextBaseline() {
    if (!this.hasValue()) {
      return null;
    }
    return Property.textBaselineMapping[this.getString()];
  }
  addOpacity(opacity2) {
    var value = this.getColor();
    var len = value.length;
    var commas = 0;
    for (var i2 = 0; i2 < len; i2++) {
      if (value[i2] === ",") {
        commas++;
      }
      if (commas === 3) {
        break;
      }
    }
    if (opacity2.hasValue() && this.isString() && commas !== 3) {
      var color2 = new rgbcolor(value);
      if (color2.ok) {
        color2.alpha = opacity2.getNumber();
        value = color2.toRGBA();
      }
    }
    return new Property(this.document, this.name, value);
  }
};
Property.textBaselineMapping = {
  "baseline": "alphabetic",
  "before-edge": "top",
  "text-before-edge": "top",
  "middle": "middle",
  "central": "middle",
  "after-edge": "bottom",
  "text-after-edge": "bottom",
  "ideographic": "ideographic",
  "alphabetic": "alphabetic",
  "hanging": "hanging",
  "mathematical": "alphabetic"
};
var ViewPort = class {
  constructor() {
    this.viewPorts = [];
  }
  clear() {
    this.viewPorts = [];
  }
  setCurrent(width, height) {
    this.viewPorts.push({
      width,
      height
    });
  }
  removeCurrent() {
    this.viewPorts.pop();
  }
  getCurrent() {
    var {
      viewPorts
    } = this;
    return viewPorts[viewPorts.length - 1];
  }
  get width() {
    return this.getCurrent().width;
  }
  get height() {
    return this.getCurrent().height;
  }
  computeSize(d2) {
    if (typeof d2 === "number") {
      return d2;
    }
    if (d2 === "x") {
      return this.width;
    }
    if (d2 === "y") {
      return this.height;
    }
    return Math.sqrt(Math.pow(this.width, 2) + Math.pow(this.height, 2)) / Math.sqrt(2);
  }
};
var Point = class {
  constructor(x2, y2) {
    this.x = x2;
    this.y = y2;
  }
  static parse(point) {
    var defaultValue = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
    var [x2 = defaultValue, y2 = defaultValue] = toNumbers(point);
    return new Point(x2, y2);
  }
  static parseScale(scale2) {
    var defaultValue = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1;
    var [x2 = defaultValue, y2 = x2] = toNumbers(scale2);
    return new Point(x2, y2);
  }
  static parsePath(path) {
    var points = toNumbers(path);
    var len = points.length;
    var pathPoints = [];
    for (var i2 = 0; i2 < len; i2 += 2) {
      pathPoints.push(new Point(points[i2], points[i2 + 1]));
    }
    return pathPoints;
  }
  angleTo(point) {
    return Math.atan2(point.y - this.y, point.x - this.x);
  }
  applyTransform(transform2) {
    var {
      x: x2,
      y: y2
    } = this;
    var xp = x2 * transform2[0] + y2 * transform2[2] + transform2[4];
    var yp = x2 * transform2[1] + y2 * transform2[3] + transform2[5];
    this.x = xp;
    this.y = yp;
  }
};
var Mouse = class {
  constructor(screen) {
    this.screen = screen;
    this.working = false;
    this.events = [];
    this.eventElements = [];
    this.onClick = this.onClick.bind(this);
    this.onMouseMove = this.onMouseMove.bind(this);
  }
  isWorking() {
    return this.working;
  }
  start() {
    if (this.working) {
      return;
    }
    var {
      screen,
      onClick,
      onMouseMove
    } = this;
    var canvas = screen.ctx.canvas;
    canvas.onclick = onClick;
    canvas.onmousemove = onMouseMove;
    this.working = true;
  }
  stop() {
    if (!this.working) {
      return;
    }
    var canvas = this.screen.ctx.canvas;
    this.working = false;
    canvas.onclick = null;
    canvas.onmousemove = null;
  }
  hasEvents() {
    return this.working && this.events.length > 0;
  }
  runEvents() {
    if (!this.working) {
      return;
    }
    var {
      screen: document2,
      events: events2,
      eventElements
    } = this;
    var {
      style: style2
    } = document2.ctx.canvas;
    if (style2) {
      style2.cursor = "";
    }
    events2.forEach((_ref2, i2) => {
      var {
        run: run2
      } = _ref2;
      var element = eventElements[i2];
      while (element) {
        run2(element);
        element = element.parent;
      }
    });
    this.events = [];
    this.eventElements = [];
  }
  checkPath(element, ctx) {
    if (!this.working || !ctx) {
      return;
    }
    var {
      events: events2,
      eventElements
    } = this;
    events2.forEach((_ref2, i2) => {
      var {
        x: x2,
        y: y2
      } = _ref2;
      if (!eventElements[i2] && ctx.isPointInPath && ctx.isPointInPath(x2, y2)) {
        eventElements[i2] = element;
      }
    });
  }
  checkBoundingBox(element, boundingBox) {
    if (!this.working || !boundingBox) {
      return;
    }
    var {
      events: events2,
      eventElements
    } = this;
    events2.forEach((_ref3, i2) => {
      var {
        x: x2,
        y: y2
      } = _ref3;
      if (!eventElements[i2] && boundingBox.isPointInBox(x2, y2)) {
        eventElements[i2] = element;
      }
    });
  }
  mapXY(x2, y2) {
    var {
      window: window2,
      ctx
    } = this.screen;
    var point = new Point(x2, y2);
    var element = ctx.canvas;
    while (element) {
      point.x -= element.offsetLeft;
      point.y -= element.offsetTop;
      element = element.offsetParent;
    }
    if (window2.scrollX) {
      point.x += window2.scrollX;
    }
    if (window2.scrollY) {
      point.y += window2.scrollY;
    }
    return point;
  }
  onClick(event) {
    var {
      x: x2,
      y: y2
    } = this.mapXY(event.clientX, event.clientY);
    this.events.push({
      type: "onclick",
      x: x2,
      y: y2,
      run(eventTarget) {
        if (eventTarget.onClick) {
          eventTarget.onClick();
        }
      }
    });
  }
  onMouseMove(event) {
    var {
      x: x2,
      y: y2
    } = this.mapXY(event.clientX, event.clientY);
    this.events.push({
      type: "onmousemove",
      x: x2,
      y: y2,
      run(eventTarget) {
        if (eventTarget.onMouseMove) {
          eventTarget.onMouseMove();
        }
      }
    });
  }
};
var defaultWindow = typeof window !== "undefined" ? window : null;
var defaultFetch$1 = typeof fetch !== "undefined" ? fetch.bind(void 0) : null;
var Screen = class {
  constructor(ctx) {
    var {
      fetch: fetch2 = defaultFetch$1,
      window: window2 = defaultWindow
    } = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    this.ctx = ctx;
    this.FRAMERATE = 30;
    this.MAX_VIRTUAL_PIXELS = 3e4;
    this.CLIENT_WIDTH = 800;
    this.CLIENT_HEIGHT = 600;
    this.viewPort = new ViewPort();
    this.mouse = new Mouse(this);
    this.animations = [];
    this.waits = [];
    this.frameDuration = 0;
    this.isReadyLock = false;
    this.isFirstRender = true;
    this.intervalId = null;
    this.window = window2;
    this.fetch = fetch2;
  }
  wait(checker) {
    this.waits.push(checker);
  }
  ready() {
    if (!this.readyPromise) {
      return Promise.resolve();
    }
    return this.readyPromise;
  }
  isReady() {
    if (this.isReadyLock) {
      return true;
    }
    var isReadyLock = this.waits.every((_2) => _2());
    if (isReadyLock) {
      this.waits = [];
      if (this.resolveReady) {
        this.resolveReady();
      }
    }
    this.isReadyLock = isReadyLock;
    return isReadyLock;
  }
  setDefaults(ctx) {
    ctx.strokeStyle = "rgba(0,0,0,0)";
    ctx.lineCap = "butt";
    ctx.lineJoin = "miter";
    ctx.miterLimit = 4;
  }
  setViewBox(_ref2) {
    var {
      document: document2,
      ctx,
      aspectRatio,
      width,
      desiredWidth,
      height,
      desiredHeight,
      minX = 0,
      minY = 0,
      refX,
      refY,
      clip = false,
      clipX = 0,
      clipY = 0
    } = _ref2;
    var cleanAspectRatio = compressSpaces(aspectRatio).replace(/^defer\s/, "");
    var [aspectRatioAlign, aspectRatioMeetOrSlice] = cleanAspectRatio.split(" ");
    var align = aspectRatioAlign || "xMidYMid";
    var meetOrSlice = aspectRatioMeetOrSlice || "meet";
    var scaleX = width / desiredWidth;
    var scaleY = height / desiredHeight;
    var scaleMin = Math.min(scaleX, scaleY);
    var scaleMax = Math.max(scaleX, scaleY);
    var finalDesiredWidth = desiredWidth;
    var finalDesiredHeight = desiredHeight;
    if (meetOrSlice === "meet") {
      finalDesiredWidth *= scaleMin;
      finalDesiredHeight *= scaleMin;
    }
    if (meetOrSlice === "slice") {
      finalDesiredWidth *= scaleMax;
      finalDesiredHeight *= scaleMax;
    }
    var refXProp = new Property(document2, "refX", refX);
    var refYProp = new Property(document2, "refY", refY);
    var hasRefs = refXProp.hasValue() && refYProp.hasValue();
    if (hasRefs) {
      ctx.translate(-scaleMin * refXProp.getPixels("x"), -scaleMin * refYProp.getPixels("y"));
    }
    if (clip) {
      var scaledClipX = scaleMin * clipX;
      var scaledClipY = scaleMin * clipY;
      ctx.beginPath();
      ctx.moveTo(scaledClipX, scaledClipY);
      ctx.lineTo(width, scaledClipY);
      ctx.lineTo(width, height);
      ctx.lineTo(scaledClipX, height);
      ctx.closePath();
      ctx.clip();
    }
    if (!hasRefs) {
      var isMeetMinY = meetOrSlice === "meet" && scaleMin === scaleY;
      var isSliceMaxY = meetOrSlice === "slice" && scaleMax === scaleY;
      var isMeetMinX = meetOrSlice === "meet" && scaleMin === scaleX;
      var isSliceMaxX = meetOrSlice === "slice" && scaleMax === scaleX;
      if (align.startsWith("xMid") && (isMeetMinY || isSliceMaxY)) {
        ctx.translate(width / 2 - finalDesiredWidth / 2, 0);
      }
      if (align.endsWith("YMid") && (isMeetMinX || isSliceMaxX)) {
        ctx.translate(0, height / 2 - finalDesiredHeight / 2);
      }
      if (align.startsWith("xMax") && (isMeetMinY || isSliceMaxY)) {
        ctx.translate(width - finalDesiredWidth, 0);
      }
      if (align.endsWith("YMax") && (isMeetMinX || isSliceMaxX)) {
        ctx.translate(0, height - finalDesiredHeight);
      }
    }
    switch (true) {
      case align === "none":
        ctx.scale(scaleX, scaleY);
        break;
      case meetOrSlice === "meet":
        ctx.scale(scaleMin, scaleMin);
        break;
      case meetOrSlice === "slice":
        ctx.scale(scaleMax, scaleMax);
        break;
    }
    ctx.translate(-minX, -minY);
  }
  start(element) {
    var {
      enableRedraw = false,
      ignoreMouse = false,
      ignoreAnimation = false,
      ignoreDimensions = false,
      ignoreClear = false,
      forceRedraw,
      scaleWidth,
      scaleHeight,
      offsetX,
      offsetY
    } = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    var {
      FRAMERATE,
      mouse
    } = this;
    var frameDuration = 1e3 / FRAMERATE;
    this.frameDuration = frameDuration;
    this.readyPromise = new Promise((resolve2) => {
      this.resolveReady = resolve2;
    });
    if (this.isReady()) {
      this.render(element, ignoreDimensions, ignoreClear, scaleWidth, scaleHeight, offsetX, offsetY);
    }
    if (!enableRedraw) {
      return;
    }
    var now2 = Date.now();
    var then2 = now2;
    var delta = 0;
    var tick = () => {
      now2 = Date.now();
      delta = now2 - then2;
      if (delta >= frameDuration) {
        then2 = now2 - delta % frameDuration;
        if (this.shouldUpdate(ignoreAnimation, forceRedraw)) {
          this.render(element, ignoreDimensions, ignoreClear, scaleWidth, scaleHeight, offsetX, offsetY);
          mouse.runEvents();
        }
      }
      this.intervalId = requestAnimationFrame$1(tick);
    };
    if (!ignoreMouse) {
      mouse.start();
    }
    this.intervalId = requestAnimationFrame$1(tick);
  }
  stop() {
    if (this.intervalId) {
      requestAnimationFrame$1.cancel(this.intervalId);
      this.intervalId = null;
    }
    this.mouse.stop();
  }
  shouldUpdate(ignoreAnimation, forceRedraw) {
    if (!ignoreAnimation) {
      var {
        frameDuration
      } = this;
      var shouldUpdate = this.animations.reduce((shouldUpdate2, animation) => animation.update(frameDuration) || shouldUpdate2, false);
      if (shouldUpdate) {
        return true;
      }
    }
    if (typeof forceRedraw === "function" && forceRedraw()) {
      return true;
    }
    if (!this.isReadyLock && this.isReady()) {
      return true;
    }
    if (this.mouse.hasEvents()) {
      return true;
    }
    return false;
  }
  render(element, ignoreDimensions, ignoreClear, scaleWidth, scaleHeight, offsetX, offsetY) {
    var {
      CLIENT_WIDTH,
      CLIENT_HEIGHT,
      viewPort,
      ctx,
      isFirstRender
    } = this;
    var canvas = ctx.canvas;
    viewPort.clear();
    if (canvas.width && canvas.height) {
      viewPort.setCurrent(canvas.width, canvas.height);
    } else {
      viewPort.setCurrent(CLIENT_WIDTH, CLIENT_HEIGHT);
    }
    var widthStyle = element.getStyle("width");
    var heightStyle = element.getStyle("height");
    if (!ignoreDimensions && (isFirstRender || typeof scaleWidth !== "number" && typeof scaleHeight !== "number")) {
      if (widthStyle.hasValue()) {
        canvas.width = widthStyle.getPixels("x");
        if (canvas.style) {
          canvas.style.width = "".concat(canvas.width, "px");
        }
      }
      if (heightStyle.hasValue()) {
        canvas.height = heightStyle.getPixels("y");
        if (canvas.style) {
          canvas.style.height = "".concat(canvas.height, "px");
        }
      }
    }
    var cWidth = canvas.clientWidth || canvas.width;
    var cHeight = canvas.clientHeight || canvas.height;
    if (ignoreDimensions && widthStyle.hasValue() && heightStyle.hasValue()) {
      cWidth = widthStyle.getPixels("x");
      cHeight = heightStyle.getPixels("y");
    }
    viewPort.setCurrent(cWidth, cHeight);
    if (typeof offsetX === "number") {
      element.getAttribute("x", true).setValue(offsetX);
    }
    if (typeof offsetY === "number") {
      element.getAttribute("y", true).setValue(offsetY);
    }
    if (typeof scaleWidth === "number" || typeof scaleHeight === "number") {
      var viewBox = toNumbers(element.getAttribute("viewBox").getString());
      var xRatio = 0;
      var yRatio = 0;
      if (typeof scaleWidth === "number") {
        var _widthStyle = element.getStyle("width");
        if (_widthStyle.hasValue()) {
          xRatio = _widthStyle.getPixels("x") / scaleWidth;
        } else if (!isNaN(viewBox[2])) {
          xRatio = viewBox[2] / scaleWidth;
        }
      }
      if (typeof scaleHeight === "number") {
        var _heightStyle = element.getStyle("height");
        if (_heightStyle.hasValue()) {
          yRatio = _heightStyle.getPixels("y") / scaleHeight;
        } else if (!isNaN(viewBox[3])) {
          yRatio = viewBox[3] / scaleHeight;
        }
      }
      if (!xRatio) {
        xRatio = yRatio;
      }
      if (!yRatio) {
        yRatio = xRatio;
      }
      element.getAttribute("width", true).setValue(scaleWidth);
      element.getAttribute("height", true).setValue(scaleHeight);
      var transformStyle = element.getStyle("transform", true, true);
      transformStyle.setValue("".concat(transformStyle.getString(), " scale(").concat(1 / xRatio, ", ").concat(1 / yRatio, ")"));
    }
    if (!ignoreClear) {
      ctx.clearRect(0, 0, cWidth, cHeight);
    }
    element.render(ctx);
    if (isFirstRender) {
      this.isFirstRender = false;
    }
  }
};
Screen.defaultWindow = defaultWindow;
Screen.defaultFetch = defaultFetch$1;
var {
  defaultFetch
} = Screen;
var DefaultDOMParser = typeof DOMParser !== "undefined" ? DOMParser : null;
var Parser = class {
  constructor() {
    var {
      fetch: fetch2 = defaultFetch,
      DOMParser: DOMParser2 = DefaultDOMParser
    } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    this.fetch = fetch2;
    this.DOMParser = DOMParser2;
  }
  parse(resource) {
    var _this = this;
    return _asyncToGenerator(function* () {
      if (resource.startsWith("<")) {
        return _this.parseFromString(resource);
      }
      return _this.load(resource);
    })();
  }
  parseFromString(xml2) {
    var parser = new this.DOMParser();
    try {
      return this.checkDocument(parser.parseFromString(xml2, "image/svg+xml"));
    } catch (err) {
      return this.checkDocument(parser.parseFromString(xml2, "text/xml"));
    }
  }
  checkDocument(document2) {
    var parserError = document2.getElementsByTagName("parsererror")[0];
    if (parserError) {
      throw new Error(parserError.textContent);
    }
    return document2;
  }
  load(url) {
    var _this2 = this;
    return _asyncToGenerator(function* () {
      var response = yield _this2.fetch(url);
      var xml2 = yield response.text();
      return _this2.parseFromString(xml2);
    })();
  }
};
var Translate = class {
  constructor(_2, point) {
    this.type = "translate";
    this.point = null;
    this.point = Point.parse(point);
  }
  apply(ctx) {
    var {
      x: x2,
      y: y2
    } = this.point;
    ctx.translate(x2 || 0, y2 || 0);
  }
  unapply(ctx) {
    var {
      x: x2,
      y: y2
    } = this.point;
    ctx.translate(-1 * x2 || 0, -1 * y2 || 0);
  }
  applyToPoint(point) {
    var {
      x: x2,
      y: y2
    } = this.point;
    point.applyTransform([1, 0, 0, 1, x2 || 0, y2 || 0]);
  }
};
var Rotate = class {
  constructor(document2, rotate2, transformOrigin2) {
    this.type = "rotate";
    this.angle = null;
    this.originX = null;
    this.originY = null;
    this.cx = 0;
    this.cy = 0;
    var numbers = toNumbers(rotate2);
    this.angle = new Property(document2, "angle", numbers[0]);
    this.originX = transformOrigin2[0];
    this.originY = transformOrigin2[1];
    this.cx = numbers[1] || 0;
    this.cy = numbers[2] || 0;
  }
  apply(ctx) {
    var {
      cx,
      cy,
      originX,
      originY,
      angle: angle2
    } = this;
    var tx = cx + originX.getPixels("x");
    var ty = cy + originY.getPixels("y");
    ctx.translate(tx, ty);
    ctx.rotate(angle2.getRadians());
    ctx.translate(-tx, -ty);
  }
  unapply(ctx) {
    var {
      cx,
      cy,
      originX,
      originY,
      angle: angle2
    } = this;
    var tx = cx + originX.getPixels("x");
    var ty = cy + originY.getPixels("y");
    ctx.translate(tx, ty);
    ctx.rotate(-1 * angle2.getRadians());
    ctx.translate(-tx, -ty);
  }
  applyToPoint(point) {
    var {
      cx,
      cy,
      angle: angle2
    } = this;
    var rad = angle2.getRadians();
    point.applyTransform([
      1,
      0,
      0,
      1,
      cx || 0,
      cy || 0
    ]);
    point.applyTransform([Math.cos(rad), Math.sin(rad), -Math.sin(rad), Math.cos(rad), 0, 0]);
    point.applyTransform([
      1,
      0,
      0,
      1,
      -cx || 0,
      -cy || 0
    ]);
  }
};
var Scale = class {
  constructor(_2, scale2, transformOrigin2) {
    this.type = "scale";
    this.scale = null;
    this.originX = null;
    this.originY = null;
    var scaleSize = Point.parseScale(scale2);
    if (scaleSize.x === 0 || scaleSize.y === 0) {
      scaleSize.x = PSEUDO_ZERO;
      scaleSize.y = PSEUDO_ZERO;
    }
    this.scale = scaleSize;
    this.originX = transformOrigin2[0];
    this.originY = transformOrigin2[1];
  }
  apply(ctx) {
    var {
      scale: {
        x: x2,
        y: y2
      },
      originX,
      originY
    } = this;
    var tx = originX.getPixels("x");
    var ty = originY.getPixels("y");
    ctx.translate(tx, ty);
    ctx.scale(x2, y2 || x2);
    ctx.translate(-tx, -ty);
  }
  unapply(ctx) {
    var {
      scale: {
        x: x2,
        y: y2
      },
      originX,
      originY
    } = this;
    var tx = originX.getPixels("x");
    var ty = originY.getPixels("y");
    ctx.translate(tx, ty);
    ctx.scale(1 / x2, 1 / y2 || x2);
    ctx.translate(-tx, -ty);
  }
  applyToPoint(point) {
    var {
      x: x2,
      y: y2
    } = this.scale;
    point.applyTransform([x2 || 0, 0, 0, y2 || 0, 0, 0]);
  }
};
var Matrix = class {
  constructor(_2, matrix2, transformOrigin2) {
    this.type = "matrix";
    this.matrix = [];
    this.originX = null;
    this.originY = null;
    this.matrix = toNumbers(matrix2);
    this.originX = transformOrigin2[0];
    this.originY = transformOrigin2[1];
  }
  apply(ctx) {
    var {
      originX,
      originY,
      matrix: matrix2
    } = this;
    var tx = originX.getPixels("x");
    var ty = originY.getPixels("y");
    ctx.translate(tx, ty);
    ctx.transform(matrix2[0], matrix2[1], matrix2[2], matrix2[3], matrix2[4], matrix2[5]);
    ctx.translate(-tx, -ty);
  }
  unapply(ctx) {
    var {
      originX,
      originY,
      matrix: matrix2
    } = this;
    var a2 = matrix2[0];
    var b2 = matrix2[2];
    var c2 = matrix2[4];
    var d2 = matrix2[1];
    var e2 = matrix2[3];
    var f2 = matrix2[5];
    var g2 = 0;
    var h2 = 0;
    var i2 = 1;
    var det = 1 / (a2 * (e2 * i2 - f2 * h2) - b2 * (d2 * i2 - f2 * g2) + c2 * (d2 * h2 - e2 * g2));
    var tx = originX.getPixels("x");
    var ty = originY.getPixels("y");
    ctx.translate(tx, ty);
    ctx.transform(det * (e2 * i2 - f2 * h2), det * (f2 * g2 - d2 * i2), det * (c2 * h2 - b2 * i2), det * (a2 * i2 - c2 * g2), det * (b2 * f2 - c2 * e2), det * (c2 * d2 - a2 * f2));
    ctx.translate(-tx, -ty);
  }
  applyToPoint(point) {
    point.applyTransform(this.matrix);
  }
};
var Skew = class extends Matrix {
  constructor(document2, skew, transformOrigin2) {
    super(document2, skew, transformOrigin2);
    this.type = "skew";
    this.angle = null;
    this.angle = new Property(document2, "angle", skew);
  }
};
var SkewX = class extends Skew {
  constructor(document2, skew, transformOrigin2) {
    super(document2, skew, transformOrigin2);
    this.type = "skewX";
    this.matrix = [1, 0, Math.tan(this.angle.getRadians()), 1, 0, 0];
  }
};
var SkewY = class extends Skew {
  constructor(document2, skew, transformOrigin2) {
    super(document2, skew, transformOrigin2);
    this.type = "skewY";
    this.matrix = [1, Math.tan(this.angle.getRadians()), 0, 1, 0, 0];
  }
};
function parseTransforms(transform2) {
  return compressSpaces(transform2).trim().replace(/\)([a-zA-Z])/g, ") $1").replace(/\)(\s?,\s?)/g, ") ").split(/\s(?=[a-z])/);
}
function parseTransform(transform2) {
  var [type, value] = transform2.split("(");
  return [type.trim(), value.trim().replace(")", "")];
}
var Transform = class {
  constructor(document2, transform2, transformOrigin2) {
    this.document = document2;
    this.transforms = [];
    var data2 = parseTransforms(transform2);
    data2.forEach((transform3) => {
      if (transform3 === "none") {
        return;
      }
      var [type, value] = parseTransform(transform3);
      var TransformType = Transform.transformTypes[type];
      if (typeof TransformType !== "undefined") {
        this.transforms.push(new TransformType(this.document, value, transformOrigin2));
      }
    });
  }
  static fromElement(document2, element) {
    var transformStyle = element.getStyle("transform", false, true);
    var [transformOriginXProperty, transformOriginYProperty = transformOriginXProperty] = element.getStyle("transform-origin", false, true).split();
    var transformOrigin2 = [transformOriginXProperty, transformOriginYProperty];
    if (transformStyle.hasValue()) {
      return new Transform(document2, transformStyle.getString(), transformOrigin2);
    }
    return null;
  }
  apply(ctx) {
    var {
      transforms: transforms2
    } = this;
    var len = transforms2.length;
    for (var i2 = 0; i2 < len; i2++) {
      transforms2[i2].apply(ctx);
    }
  }
  unapply(ctx) {
    var {
      transforms: transforms2
    } = this;
    var len = transforms2.length;
    for (var i2 = len - 1; i2 >= 0; i2--) {
      transforms2[i2].unapply(ctx);
    }
  }
  applyToPoint(point) {
    var {
      transforms: transforms2
    } = this;
    var len = transforms2.length;
    for (var i2 = 0; i2 < len; i2++) {
      transforms2[i2].applyToPoint(point);
    }
  }
};
Transform.transformTypes = {
  translate: Translate,
  rotate: Rotate,
  scale: Scale,
  matrix: Matrix,
  skewX: SkewX,
  skewY: SkewY
};
var Element$1 = class {
  constructor(document2, node2) {
    var captureTextNodes = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
    this.document = document2;
    this.node = node2;
    this.captureTextNodes = captureTextNodes;
    this.attributes = {};
    this.styles = {};
    this.stylesSpecificity = {};
    this.animationFrozen = false;
    this.animationFrozenValue = "";
    this.parent = null;
    this.children = [];
    if (!node2 || node2.nodeType !== 1) {
      return;
    }
    Array.from(node2.attributes).forEach((attribute) => {
      var nodeName = normalizeAttributeName(attribute.nodeName);
      this.attributes[nodeName] = new Property(document2, nodeName, attribute.value);
    });
    this.addStylesFromStyleDefinition();
    if (this.getAttribute("style").hasValue()) {
      var styles = this.getAttribute("style").getString().split(";").map((_2) => _2.trim());
      styles.forEach((style2) => {
        if (!style2) {
          return;
        }
        var [name, value] = style2.split(":").map((_2) => _2.trim());
        this.styles[name] = new Property(document2, name, value);
      });
    }
    var {
      definitions
    } = document2;
    var id = this.getAttribute("id");
    if (id.hasValue()) {
      if (!definitions[id.getString()]) {
        definitions[id.getString()] = this;
      }
    }
    Array.from(node2.childNodes).forEach((childNode) => {
      if (childNode.nodeType === 1) {
        this.addChild(childNode);
      } else if (captureTextNodes && (childNode.nodeType === 3 || childNode.nodeType === 4)) {
        var textNode = document2.createTextNode(childNode);
        if (textNode.getText().length > 0) {
          this.addChild(textNode);
        }
      }
    });
  }
  getAttribute(name) {
    var createIfNotExists = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
    var attr = this.attributes[name];
    if (!attr && createIfNotExists) {
      var _attr = new Property(this.document, name, "");
      this.attributes[name] = _attr;
      return _attr;
    }
    return attr || Property.empty(this.document);
  }
  getHrefAttribute() {
    for (var key in this.attributes) {
      if (key === "href" || key.endsWith(":href")) {
        return this.attributes[key];
      }
    }
    return Property.empty(this.document);
  }
  getStyle(name) {
    var createIfNotExists = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
    var skipAncestors = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
    var style2 = this.styles[name];
    if (style2) {
      return style2;
    }
    var attr = this.getAttribute(name);
    if (attr !== null && attr !== void 0 && attr.hasValue()) {
      this.styles[name] = attr;
      return attr;
    }
    if (!skipAncestors) {
      var {
        parent
      } = this;
      if (parent) {
        var parentStyle = parent.getStyle(name);
        if (parentStyle !== null && parentStyle !== void 0 && parentStyle.hasValue()) {
          return parentStyle;
        }
      }
    }
    if (createIfNotExists) {
      var _style = new Property(this.document, name, "");
      this.styles[name] = _style;
      return _style;
    }
    return style2 || Property.empty(this.document);
  }
  render(ctx) {
    if (this.getStyle("display").getString() === "none" || this.getStyle("visibility").getString() === "hidden") {
      return;
    }
    ctx.save();
    if (this.getStyle("mask").hasValue()) {
      var mask = this.getStyle("mask").getDefinition();
      if (mask) {
        this.applyEffects(ctx);
        mask.apply(ctx, this);
      }
    } else if (this.getStyle("filter").getValue("none") !== "none") {
      var filter = this.getStyle("filter").getDefinition();
      if (filter) {
        this.applyEffects(ctx);
        filter.apply(ctx, this);
      }
    } else {
      this.setContext(ctx);
      this.renderChildren(ctx);
      this.clearContext(ctx);
    }
    ctx.restore();
  }
  setContext(_2) {
  }
  applyEffects(ctx) {
    var transform2 = Transform.fromElement(this.document, this);
    if (transform2) {
      transform2.apply(ctx);
    }
    var clipPathStyleProp = this.getStyle("clip-path", false, true);
    if (clipPathStyleProp.hasValue()) {
      var clip = clipPathStyleProp.getDefinition();
      if (clip) {
        clip.apply(ctx);
      }
    }
  }
  clearContext(_2) {
  }
  renderChildren(ctx) {
    this.children.forEach((child) => {
      child.render(ctx);
    });
  }
  addChild(childNode) {
    var child = childNode instanceof Element$1 ? childNode : this.document.createElement(childNode);
    child.parent = this;
    if (!Element$1.ignoreChildTypes.includes(child.type)) {
      this.children.push(child);
    }
  }
  matchesSelector(selector) {
    var {
      node: node2
    } = this;
    if (typeof node2.matches === "function") {
      return node2.matches(selector);
    }
    var styleClasses = node2.getAttribute("class");
    if (!styleClasses || styleClasses === "") {
      return false;
    }
    return styleClasses.split(" ").some((styleClass) => ".".concat(styleClass) === selector);
  }
  addStylesFromStyleDefinition() {
    var {
      styles,
      stylesSpecificity
    } = this.document;
    for (var selector in styles) {
      if (!selector.startsWith("@") && this.matchesSelector(selector)) {
        var style2 = styles[selector];
        var specificity = stylesSpecificity[selector];
        if (style2) {
          for (var name in style2) {
            var existingSpecificity = this.stylesSpecificity[name];
            if (typeof existingSpecificity === "undefined") {
              existingSpecificity = "000";
            }
            if (specificity >= existingSpecificity) {
              this.styles[name] = style2[name];
              this.stylesSpecificity[name] = specificity;
            }
          }
        }
      }
    }
  }
  removeStyles(element, ignoreStyles) {
    var toRestore = ignoreStyles.reduce((toRestore2, name) => {
      var styleProp = element.getStyle(name);
      if (!styleProp.hasValue()) {
        return toRestore2;
      }
      var value = styleProp.getString();
      styleProp.setValue("");
      return [...toRestore2, [name, value]];
    }, []);
    return toRestore;
  }
  restoreStyles(element, styles) {
    styles.forEach((_ref2) => {
      var [name, value] = _ref2;
      element.getStyle(name, true).setValue(value);
    });
  }
};
Element$1.ignoreChildTypes = ["title"];
var UnknownElement = class extends Element$1 {
  constructor(document2, node2, captureTextNodes) {
    super(document2, node2, captureTextNodes);
  }
};
function wrapFontFamily(fontFamily2) {
  var trimmed = fontFamily2.trim();
  return /^('|")/.test(trimmed) ? trimmed : '"'.concat(trimmed, '"');
}
function prepareFontFamily(fontFamily2) {
  return typeof process === "undefined" ? fontFamily2 : fontFamily2.trim().split(",").map(wrapFontFamily).join(",");
}
function prepareFontStyle(fontStyle2) {
  if (!fontStyle2) {
    return "";
  }
  var targetFontStyle = fontStyle2.trim().toLowerCase();
  switch (targetFontStyle) {
    case "normal":
    case "italic":
    case "oblique":
    case "inherit":
    case "initial":
    case "unset":
      return targetFontStyle;
    default:
      if (/^oblique\s+(-|)\d+deg$/.test(targetFontStyle)) {
        return targetFontStyle;
      }
      return "";
  }
}
function prepareFontWeight(fontWeight2) {
  if (!fontWeight2) {
    return "";
  }
  var targetFontWeight = fontWeight2.trim().toLowerCase();
  switch (targetFontWeight) {
    case "normal":
    case "bold":
    case "lighter":
    case "bolder":
    case "inherit":
    case "initial":
    case "unset":
      return targetFontWeight;
    default:
      if (/^[\d.]+$/.test(targetFontWeight)) {
        return targetFontWeight;
      }
      return "";
  }
}
var Font = class {
  constructor(fontStyle2, fontVariant2, fontWeight2, fontSize2, fontFamily2, inherit) {
    var inheritFont = inherit ? typeof inherit === "string" ? Font.parse(inherit) : inherit : {};
    this.fontFamily = fontFamily2 || inheritFont.fontFamily;
    this.fontSize = fontSize2 || inheritFont.fontSize;
    this.fontStyle = fontStyle2 || inheritFont.fontStyle;
    this.fontWeight = fontWeight2 || inheritFont.fontWeight;
    this.fontVariant = fontVariant2 || inheritFont.fontVariant;
  }
  static parse() {
    var font = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "";
    var inherit = arguments.length > 1 ? arguments[1] : void 0;
    var fontStyle2 = "";
    var fontVariant2 = "";
    var fontWeight2 = "";
    var fontSize2 = "";
    var fontFamily2 = "";
    var parts = compressSpaces(font).trim().split(" ");
    var set2 = {
      fontSize: false,
      fontStyle: false,
      fontWeight: false,
      fontVariant: false
    };
    parts.forEach((part) => {
      switch (true) {
        case (!set2.fontStyle && Font.styles.includes(part)):
          if (part !== "inherit") {
            fontStyle2 = part;
          }
          set2.fontStyle = true;
          break;
        case (!set2.fontVariant && Font.variants.includes(part)):
          if (part !== "inherit") {
            fontVariant2 = part;
          }
          set2.fontStyle = true;
          set2.fontVariant = true;
          break;
        case (!set2.fontWeight && Font.weights.includes(part)):
          if (part !== "inherit") {
            fontWeight2 = part;
          }
          set2.fontStyle = true;
          set2.fontVariant = true;
          set2.fontWeight = true;
          break;
        case !set2.fontSize:
          if (part !== "inherit") {
            [fontSize2] = part.split("/");
          }
          set2.fontStyle = true;
          set2.fontVariant = true;
          set2.fontWeight = true;
          set2.fontSize = true;
          break;
        default:
          if (part !== "inherit") {
            fontFamily2 += part;
          }
      }
    });
    return new Font(fontStyle2, fontVariant2, fontWeight2, fontSize2, fontFamily2, inherit);
  }
  toString() {
    return [
      prepareFontStyle(this.fontStyle),
      this.fontVariant,
      prepareFontWeight(this.fontWeight),
      this.fontSize,
      prepareFontFamily(this.fontFamily)
    ].join(" ").trim();
  }
};
Font.styles = "normal|italic|oblique|inherit";
Font.variants = "normal|small-caps|inherit";
Font.weights = "normal|bold|bolder|lighter|100|200|300|400|500|600|700|800|900|inherit";
var BoundingBox = class {
  constructor() {
    var x1 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : Number.NaN;
    var y1 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : Number.NaN;
    var x2 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : Number.NaN;
    var y2 = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : Number.NaN;
    this.x1 = x1;
    this.y1 = y1;
    this.x2 = x2;
    this.y2 = y2;
    this.addPoint(x1, y1);
    this.addPoint(x2, y2);
  }
  get x() {
    return this.x1;
  }
  get y() {
    return this.y1;
  }
  get width() {
    return this.x2 - this.x1;
  }
  get height() {
    return this.y2 - this.y1;
  }
  addPoint(x2, y2) {
    if (typeof x2 !== "undefined") {
      if (isNaN(this.x1) || isNaN(this.x2)) {
        this.x1 = x2;
        this.x2 = x2;
      }
      if (x2 < this.x1) {
        this.x1 = x2;
      }
      if (x2 > this.x2) {
        this.x2 = x2;
      }
    }
    if (typeof y2 !== "undefined") {
      if (isNaN(this.y1) || isNaN(this.y2)) {
        this.y1 = y2;
        this.y2 = y2;
      }
      if (y2 < this.y1) {
        this.y1 = y2;
      }
      if (y2 > this.y2) {
        this.y2 = y2;
      }
    }
  }
  addX(x2) {
    this.addPoint(x2, null);
  }
  addY(y2) {
    this.addPoint(null, y2);
  }
  addBoundingBox(boundingBox) {
    if (!boundingBox) {
      return;
    }
    var {
      x1,
      y1,
      x2,
      y2
    } = boundingBox;
    this.addPoint(x1, y1);
    this.addPoint(x2, y2);
  }
  sumCubic(t3, p0, p12, p22, p32) {
    return Math.pow(1 - t3, 3) * p0 + 3 * Math.pow(1 - t3, 2) * t3 * p12 + 3 * (1 - t3) * Math.pow(t3, 2) * p22 + Math.pow(t3, 3) * p32;
  }
  bezierCurveAdd(forX, p0, p12, p22, p32) {
    var b2 = 6 * p0 - 12 * p12 + 6 * p22;
    var a2 = -3 * p0 + 9 * p12 - 9 * p22 + 3 * p32;
    var c2 = 3 * p12 - 3 * p0;
    if (a2 === 0) {
      if (b2 === 0) {
        return;
      }
      var t3 = -c2 / b2;
      if (0 < t3 && t3 < 1) {
        if (forX) {
          this.addX(this.sumCubic(t3, p0, p12, p22, p32));
        } else {
          this.addY(this.sumCubic(t3, p0, p12, p22, p32));
        }
      }
      return;
    }
    var b2ac = Math.pow(b2, 2) - 4 * c2 * a2;
    if (b2ac < 0) {
      return;
    }
    var t1 = (-b2 + Math.sqrt(b2ac)) / (2 * a2);
    if (0 < t1 && t1 < 1) {
      if (forX) {
        this.addX(this.sumCubic(t1, p0, p12, p22, p32));
      } else {
        this.addY(this.sumCubic(t1, p0, p12, p22, p32));
      }
    }
    var t22 = (-b2 - Math.sqrt(b2ac)) / (2 * a2);
    if (0 < t22 && t22 < 1) {
      if (forX) {
        this.addX(this.sumCubic(t22, p0, p12, p22, p32));
      } else {
        this.addY(this.sumCubic(t22, p0, p12, p22, p32));
      }
    }
  }
  addBezierCurve(p0x, p0y, p1x, p1y, p2x, p2y, p3x, p3y) {
    this.addPoint(p0x, p0y);
    this.addPoint(p3x, p3y);
    this.bezierCurveAdd(true, p0x, p1x, p2x, p3x);
    this.bezierCurveAdd(false, p0y, p1y, p2y, p3y);
  }
  addQuadraticCurve(p0x, p0y, p1x, p1y, p2x, p2y) {
    var cp1x = p0x + 2 / 3 * (p1x - p0x);
    var cp1y = p0y + 2 / 3 * (p1y - p0y);
    var cp2x = cp1x + 1 / 3 * (p2x - p0x);
    var cp2y = cp1y + 1 / 3 * (p2y - p0y);
    this.addBezierCurve(p0x, p0y, cp1x, cp2x, cp1y, cp2y, p2x, p2y);
  }
  isPointInBox(x2, y2) {
    var {
      x1,
      y1,
      x2: x22,
      y2: y22
    } = this;
    return x1 <= x2 && x2 <= x22 && y1 <= y2 && y2 <= y22;
  }
};
var PathParser = class extends _ {
  constructor(path) {
    super(path.replace(/([+\-.])\s+/gm, "$1").replace(/[^MmZzLlHhVvCcSsQqTtAae\d\s.,+-].*/g, ""));
    this.control = null;
    this.start = null;
    this.current = null;
    this.command = null;
    this.commands = this.commands;
    this.i = -1;
    this.previousCommand = null;
    this.points = [];
    this.angles = [];
  }
  reset() {
    this.i = -1;
    this.command = null;
    this.previousCommand = null;
    this.start = new Point(0, 0);
    this.control = new Point(0, 0);
    this.current = new Point(0, 0);
    this.points = [];
    this.angles = [];
  }
  isEnd() {
    var {
      i: i2,
      commands
    } = this;
    return i2 >= commands.length - 1;
  }
  next() {
    var command = this.commands[++this.i];
    this.previousCommand = this.command;
    this.command = command;
    return command;
  }
  getPoint() {
    var xProp = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "x";
    var yProp = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "y";
    var point = new Point(this.command[xProp], this.command[yProp]);
    return this.makeAbsolute(point);
  }
  getAsControlPoint(xProp, yProp) {
    var point = this.getPoint(xProp, yProp);
    this.control = point;
    return point;
  }
  getAsCurrentPoint(xProp, yProp) {
    var point = this.getPoint(xProp, yProp);
    this.current = point;
    return point;
  }
  getReflectedControlPoint() {
    var previousCommand = this.previousCommand.type;
    if (previousCommand !== _.CURVE_TO && previousCommand !== _.SMOOTH_CURVE_TO && previousCommand !== _.QUAD_TO && previousCommand !== _.SMOOTH_QUAD_TO) {
      return this.current;
    }
    var {
      current: {
        x: cx,
        y: cy
      },
      control: {
        x: ox,
        y: oy
      }
    } = this;
    var point = new Point(2 * cx - ox, 2 * cy - oy);
    return point;
  }
  makeAbsolute(point) {
    if (this.command.relative) {
      var {
        x: x2,
        y: y2
      } = this.current;
      point.x += x2;
      point.y += y2;
    }
    return point;
  }
  addMarker(point, from, priorTo) {
    var {
      points,
      angles
    } = this;
    if (priorTo && angles.length > 0 && !angles[angles.length - 1]) {
      angles[angles.length - 1] = points[points.length - 1].angleTo(priorTo);
    }
    this.addMarkerAngle(point, from ? from.angleTo(point) : null);
  }
  addMarkerAngle(point, angle2) {
    this.points.push(point);
    this.angles.push(angle2);
  }
  getMarkerPoints() {
    return this.points;
  }
  getMarkerAngles() {
    var {
      angles
    } = this;
    var len = angles.length;
    for (var i2 = 0; i2 < len; i2++) {
      if (!angles[i2]) {
        for (var j2 = i2 + 1; j2 < len; j2++) {
          if (angles[j2]) {
            angles[i2] = angles[j2];
            break;
          }
        }
      }
    }
    return angles;
  }
};
var RenderedElement = class extends Element$1 {
  constructor() {
    super(...arguments);
    this.modifiedEmSizeStack = false;
  }
  calculateOpacity() {
    var opacity2 = 1;
    var element = this;
    while (element) {
      var opacityStyle = element.getStyle("opacity", false, true);
      if (opacityStyle.hasValue(true)) {
        opacity2 *= opacityStyle.getNumber();
      }
      element = element.parent;
    }
    return opacity2;
  }
  setContext(ctx) {
    var fromMeasure = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
    if (!fromMeasure) {
      var fillStyleProp = this.getStyle("fill");
      var fillOpacityStyleProp = this.getStyle("fill-opacity");
      var strokeStyleProp = this.getStyle("stroke");
      var strokeOpacityProp = this.getStyle("stroke-opacity");
      if (fillStyleProp.isUrlDefinition()) {
        var fillStyle = fillStyleProp.getFillStyleDefinition(this, fillOpacityStyleProp);
        if (fillStyle) {
          ctx.fillStyle = fillStyle;
        }
      } else if (fillStyleProp.hasValue()) {
        if (fillStyleProp.getString() === "currentColor") {
          fillStyleProp.setValue(this.getStyle("color").getColor());
        }
        var _fillStyle = fillStyleProp.getColor();
        if (_fillStyle !== "inherit") {
          ctx.fillStyle = _fillStyle === "none" ? "rgba(0,0,0,0)" : _fillStyle;
        }
      }
      if (fillOpacityStyleProp.hasValue()) {
        var _fillStyle2 = new Property(this.document, "fill", ctx.fillStyle).addOpacity(fillOpacityStyleProp).getColor();
        ctx.fillStyle = _fillStyle2;
      }
      if (strokeStyleProp.isUrlDefinition()) {
        var strokeStyle = strokeStyleProp.getFillStyleDefinition(this, strokeOpacityProp);
        if (strokeStyle) {
          ctx.strokeStyle = strokeStyle;
        }
      } else if (strokeStyleProp.hasValue()) {
        if (strokeStyleProp.getString() === "currentColor") {
          strokeStyleProp.setValue(this.getStyle("color").getColor());
        }
        var _strokeStyle = strokeStyleProp.getString();
        if (_strokeStyle !== "inherit") {
          ctx.strokeStyle = _strokeStyle === "none" ? "rgba(0,0,0,0)" : _strokeStyle;
        }
      }
      if (strokeOpacityProp.hasValue()) {
        var _strokeStyle2 = new Property(this.document, "stroke", ctx.strokeStyle).addOpacity(strokeOpacityProp).getString();
        ctx.strokeStyle = _strokeStyle2;
      }
      var strokeWidthStyleProp = this.getStyle("stroke-width");
      if (strokeWidthStyleProp.hasValue()) {
        var newLineWidth = strokeWidthStyleProp.getPixels();
        ctx.lineWidth = !newLineWidth ? PSEUDO_ZERO : newLineWidth;
      }
      var strokeLinecapStyleProp = this.getStyle("stroke-linecap");
      var strokeLinejoinStyleProp = this.getStyle("stroke-linejoin");
      var strokeMiterlimitProp = this.getStyle("stroke-miterlimit");
      var strokeDasharrayStyleProp = this.getStyle("stroke-dasharray");
      var strokeDashoffsetProp = this.getStyle("stroke-dashoffset");
      if (strokeLinecapStyleProp.hasValue()) {
        ctx.lineCap = strokeLinecapStyleProp.getString();
      }
      if (strokeLinejoinStyleProp.hasValue()) {
        ctx.lineJoin = strokeLinejoinStyleProp.getString();
      }
      if (strokeMiterlimitProp.hasValue()) {
        ctx.miterLimit = strokeMiterlimitProp.getNumber();
      }
      if (strokeDasharrayStyleProp.hasValue() && strokeDasharrayStyleProp.getString() !== "none") {
        var gaps = toNumbers(strokeDasharrayStyleProp.getString());
        if (typeof ctx.setLineDash !== "undefined") {
          ctx.setLineDash(gaps);
        } else if (typeof ctx.webkitLineDash !== "undefined") {
          ctx.webkitLineDash = gaps;
        } else if (typeof ctx.mozDash !== "undefined" && !(gaps.length === 1 && gaps[0] === 0)) {
          ctx.mozDash = gaps;
        }
        var offset2 = strokeDashoffsetProp.getPixels();
        if (typeof ctx.lineDashOffset !== "undefined") {
          ctx.lineDashOffset = offset2;
        } else if (typeof ctx.webkitLineDashOffset !== "undefined") {
          ctx.webkitLineDashOffset = offset2;
        } else if (typeof ctx.mozDashOffset !== "undefined") {
          ctx.mozDashOffset = offset2;
        }
      }
    }
    this.modifiedEmSizeStack = false;
    if (typeof ctx.font !== "undefined") {
      var fontStyleProp = this.getStyle("font");
      var fontStyleStyleProp = this.getStyle("font-style");
      var fontVariantStyleProp = this.getStyle("font-variant");
      var fontWeightStyleProp = this.getStyle("font-weight");
      var fontSizeStyleProp = this.getStyle("font-size");
      var fontFamilyStyleProp = this.getStyle("font-family");
      var font = new Font(fontStyleStyleProp.getString(), fontVariantStyleProp.getString(), fontWeightStyleProp.getString(), fontSizeStyleProp.hasValue() ? "".concat(fontSizeStyleProp.getPixels(true), "px") : "", fontFamilyStyleProp.getString(), Font.parse(fontStyleProp.getString(), ctx.font));
      fontStyleStyleProp.setValue(font.fontStyle);
      fontVariantStyleProp.setValue(font.fontVariant);
      fontWeightStyleProp.setValue(font.fontWeight);
      fontSizeStyleProp.setValue(font.fontSize);
      fontFamilyStyleProp.setValue(font.fontFamily);
      ctx.font = font.toString();
      if (fontSizeStyleProp.isPixels()) {
        this.document.emSize = fontSizeStyleProp.getPixels();
        this.modifiedEmSizeStack = true;
      }
    }
    if (!fromMeasure) {
      this.applyEffects(ctx);
      ctx.globalAlpha = this.calculateOpacity();
    }
  }
  clearContext(ctx) {
    super.clearContext(ctx);
    if (this.modifiedEmSizeStack) {
      this.document.popEmSize();
    }
  }
};
var PathElement = class extends RenderedElement {
  constructor(document2, node2, captureTextNodes) {
    super(document2, node2, captureTextNodes);
    this.type = "path";
    this.pathParser = null;
    this.pathParser = new PathParser(this.getAttribute("d").getString());
  }
  path(ctx) {
    var {
      pathParser
    } = this;
    var boundingBox = new BoundingBox();
    pathParser.reset();
    if (ctx) {
      ctx.beginPath();
    }
    while (!pathParser.isEnd()) {
      switch (pathParser.next().type) {
        case PathParser.MOVE_TO:
          this.pathM(ctx, boundingBox);
          break;
        case PathParser.LINE_TO:
          this.pathL(ctx, boundingBox);
          break;
        case PathParser.HORIZ_LINE_TO:
          this.pathH(ctx, boundingBox);
          break;
        case PathParser.VERT_LINE_TO:
          this.pathV(ctx, boundingBox);
          break;
        case PathParser.CURVE_TO:
          this.pathC(ctx, boundingBox);
          break;
        case PathParser.SMOOTH_CURVE_TO:
          this.pathS(ctx, boundingBox);
          break;
        case PathParser.QUAD_TO:
          this.pathQ(ctx, boundingBox);
          break;
        case PathParser.SMOOTH_QUAD_TO:
          this.pathT(ctx, boundingBox);
          break;
        case PathParser.ARC:
          this.pathA(ctx, boundingBox);
          break;
        case PathParser.CLOSE_PATH:
          this.pathZ(ctx, boundingBox);
          break;
      }
    }
    return boundingBox;
  }
  getBoundingBox(_2) {
    return this.path();
  }
  getMarkers() {
    var {
      pathParser
    } = this;
    var points = pathParser.getMarkerPoints();
    var angles = pathParser.getMarkerAngles();
    var markers = points.map((point, i2) => [point, angles[i2]]);
    return markers;
  }
  renderChildren(ctx) {
    this.path(ctx);
    this.document.screen.mouse.checkPath(this, ctx);
    var fillRuleStyleProp = this.getStyle("fill-rule");
    if (ctx.fillStyle !== "") {
      if (fillRuleStyleProp.getString("inherit") !== "inherit") {
        ctx.fill(fillRuleStyleProp.getString());
      } else {
        ctx.fill();
      }
    }
    if (ctx.strokeStyle !== "") {
      if (this.getAttribute("vector-effect").getString() === "non-scaling-stroke") {
        ctx.save();
        ctx.setTransform(1, 0, 0, 1, 0, 0);
        ctx.stroke();
        ctx.restore();
      } else {
        ctx.stroke();
      }
    }
    var markers = this.getMarkers();
    if (markers) {
      var markersLastIndex = markers.length - 1;
      var markerStartStyleProp = this.getStyle("marker-start");
      var markerMidStyleProp = this.getStyle("marker-mid");
      var markerEndStyleProp = this.getStyle("marker-end");
      if (markerStartStyleProp.isUrlDefinition()) {
        var marker = markerStartStyleProp.getDefinition();
        var [point, angle2] = markers[0];
        marker.render(ctx, point, angle2);
      }
      if (markerMidStyleProp.isUrlDefinition()) {
        var _marker = markerMidStyleProp.getDefinition();
        for (var i2 = 1; i2 < markersLastIndex; i2++) {
          var [_point, _angle] = markers[i2];
          _marker.render(ctx, _point, _angle);
        }
      }
      if (markerEndStyleProp.isUrlDefinition()) {
        var _marker2 = markerEndStyleProp.getDefinition();
        var [_point2, _angle2] = markers[markersLastIndex];
        _marker2.render(ctx, _point2, _angle2);
      }
    }
  }
  static pathM(pathParser) {
    var point = pathParser.getAsCurrentPoint();
    pathParser.start = pathParser.current;
    return {
      point
    };
  }
  pathM(ctx, boundingBox) {
    var {
      pathParser
    } = this;
    var {
      point
    } = PathElement.pathM(pathParser);
    var {
      x: x2,
      y: y2
    } = point;
    pathParser.addMarker(point);
    boundingBox.addPoint(x2, y2);
    if (ctx) {
      ctx.moveTo(x2, y2);
    }
  }
  static pathL(pathParser) {
    var {
      current
    } = pathParser;
    var point = pathParser.getAsCurrentPoint();
    return {
      current,
      point
    };
  }
  pathL(ctx, boundingBox) {
    var {
      pathParser
    } = this;
    var {
      current,
      point
    } = PathElement.pathL(pathParser);
    var {
      x: x2,
      y: y2
    } = point;
    pathParser.addMarker(point, current);
    boundingBox.addPoint(x2, y2);
    if (ctx) {
      ctx.lineTo(x2, y2);
    }
  }
  static pathH(pathParser) {
    var {
      current,
      command
    } = pathParser;
    var point = new Point((command.relative ? current.x : 0) + command.x, current.y);
    pathParser.current = point;
    return {
      current,
      point
    };
  }
  pathH(ctx, boundingBox) {
    var {
      pathParser
    } = this;
    var {
      current,
      point
    } = PathElement.pathH(pathParser);
    var {
      x: x2,
      y: y2
    } = point;
    pathParser.addMarker(point, current);
    boundingBox.addPoint(x2, y2);
    if (ctx) {
      ctx.lineTo(x2, y2);
    }
  }
  static pathV(pathParser) {
    var {
      current,
      command
    } = pathParser;
    var point = new Point(current.x, (command.relative ? current.y : 0) + command.y);
    pathParser.current = point;
    return {
      current,
      point
    };
  }
  pathV(ctx, boundingBox) {
    var {
      pathParser
    } = this;
    var {
      current,
      point
    } = PathElement.pathV(pathParser);
    var {
      x: x2,
      y: y2
    } = point;
    pathParser.addMarker(point, current);
    boundingBox.addPoint(x2, y2);
    if (ctx) {
      ctx.lineTo(x2, y2);
    }
  }
  static pathC(pathParser) {
    var {
      current
    } = pathParser;
    var point = pathParser.getPoint("x1", "y1");
    var controlPoint = pathParser.getAsControlPoint("x2", "y2");
    var currentPoint = pathParser.getAsCurrentPoint();
    return {
      current,
      point,
      controlPoint,
      currentPoint
    };
  }
  pathC(ctx, boundingBox) {
    var {
      pathParser
    } = this;
    var {
      current,
      point,
      controlPoint,
      currentPoint
    } = PathElement.pathC(pathParser);
    pathParser.addMarker(currentPoint, controlPoint, point);
    boundingBox.addBezierCurve(current.x, current.y, point.x, point.y, controlPoint.x, controlPoint.y, currentPoint.x, currentPoint.y);
    if (ctx) {
      ctx.bezierCurveTo(point.x, point.y, controlPoint.x, controlPoint.y, currentPoint.x, currentPoint.y);
    }
  }
  static pathS(pathParser) {
    var {
      current
    } = pathParser;
    var point = pathParser.getReflectedControlPoint();
    var controlPoint = pathParser.getAsControlPoint("x2", "y2");
    var currentPoint = pathParser.getAsCurrentPoint();
    return {
      current,
      point,
      controlPoint,
      currentPoint
    };
  }
  pathS(ctx, boundingBox) {
    var {
      pathParser
    } = this;
    var {
      current,
      point,
      controlPoint,
      currentPoint
    } = PathElement.pathS(pathParser);
    pathParser.addMarker(currentPoint, controlPoint, point);
    boundingBox.addBezierCurve(current.x, current.y, point.x, point.y, controlPoint.x, controlPoint.y, currentPoint.x, currentPoint.y);
    if (ctx) {
      ctx.bezierCurveTo(point.x, point.y, controlPoint.x, controlPoint.y, currentPoint.x, currentPoint.y);
    }
  }
  static pathQ(pathParser) {
    var {
      current
    } = pathParser;
    var controlPoint = pathParser.getAsControlPoint("x1", "y1");
    var currentPoint = pathParser.getAsCurrentPoint();
    return {
      current,
      controlPoint,
      currentPoint
    };
  }
  pathQ(ctx, boundingBox) {
    var {
      pathParser
    } = this;
    var {
      current,
      controlPoint,
      currentPoint
    } = PathElement.pathQ(pathParser);
    pathParser.addMarker(currentPoint, controlPoint, controlPoint);
    boundingBox.addQuadraticCurve(current.x, current.y, controlPoint.x, controlPoint.y, currentPoint.x, currentPoint.y);
    if (ctx) {
      ctx.quadraticCurveTo(controlPoint.x, controlPoint.y, currentPoint.x, currentPoint.y);
    }
  }
  static pathT(pathParser) {
    var {
      current
    } = pathParser;
    var controlPoint = pathParser.getReflectedControlPoint();
    pathParser.control = controlPoint;
    var currentPoint = pathParser.getAsCurrentPoint();
    return {
      current,
      controlPoint,
      currentPoint
    };
  }
  pathT(ctx, boundingBox) {
    var {
      pathParser
    } = this;
    var {
      current,
      controlPoint,
      currentPoint
    } = PathElement.pathT(pathParser);
    pathParser.addMarker(currentPoint, controlPoint, controlPoint);
    boundingBox.addQuadraticCurve(current.x, current.y, controlPoint.x, controlPoint.y, currentPoint.x, currentPoint.y);
    if (ctx) {
      ctx.quadraticCurveTo(controlPoint.x, controlPoint.y, currentPoint.x, currentPoint.y);
    }
  }
  static pathA(pathParser) {
    var {
      current,
      command
    } = pathParser;
    var {
      rX,
      rY,
      xRot,
      lArcFlag,
      sweepFlag
    } = command;
    var xAxisRotation = xRot * (Math.PI / 180);
    var currentPoint = pathParser.getAsCurrentPoint();
    var currp = new Point(Math.cos(xAxisRotation) * (current.x - currentPoint.x) / 2 + Math.sin(xAxisRotation) * (current.y - currentPoint.y) / 2, -Math.sin(xAxisRotation) * (current.x - currentPoint.x) / 2 + Math.cos(xAxisRotation) * (current.y - currentPoint.y) / 2);
    var l2 = Math.pow(currp.x, 2) / Math.pow(rX, 2) + Math.pow(currp.y, 2) / Math.pow(rY, 2);
    if (l2 > 1) {
      rX *= Math.sqrt(l2);
      rY *= Math.sqrt(l2);
    }
    var s2 = (lArcFlag === sweepFlag ? -1 : 1) * Math.sqrt((Math.pow(rX, 2) * Math.pow(rY, 2) - Math.pow(rX, 2) * Math.pow(currp.y, 2) - Math.pow(rY, 2) * Math.pow(currp.x, 2)) / (Math.pow(rX, 2) * Math.pow(currp.y, 2) + Math.pow(rY, 2) * Math.pow(currp.x, 2)));
    if (isNaN(s2)) {
      s2 = 0;
    }
    var cpp = new Point(s2 * rX * currp.y / rY, s2 * -rY * currp.x / rX);
    var centp = new Point((current.x + currentPoint.x) / 2 + Math.cos(xAxisRotation) * cpp.x - Math.sin(xAxisRotation) * cpp.y, (current.y + currentPoint.y) / 2 + Math.sin(xAxisRotation) * cpp.x + Math.cos(xAxisRotation) * cpp.y);
    var a1 = vectorsAngle([1, 0], [(currp.x - cpp.x) / rX, (currp.y - cpp.y) / rY]);
    var u2 = [(currp.x - cpp.x) / rX, (currp.y - cpp.y) / rY];
    var v2 = [(-currp.x - cpp.x) / rX, (-currp.y - cpp.y) / rY];
    var ad = vectorsAngle(u2, v2);
    if (vectorsRatio(u2, v2) <= -1) {
      ad = Math.PI;
    }
    if (vectorsRatio(u2, v2) >= 1) {
      ad = 0;
    }
    return {
      currentPoint,
      rX,
      rY,
      sweepFlag,
      xAxisRotation,
      centp,
      a1,
      ad
    };
  }
  pathA(ctx, boundingBox) {
    var {
      pathParser
    } = this;
    var {
      currentPoint,
      rX,
      rY,
      sweepFlag,
      xAxisRotation,
      centp,
      a1,
      ad
    } = PathElement.pathA(pathParser);
    var dir = 1 - sweepFlag ? 1 : -1;
    var ah = a1 + dir * (ad / 2);
    var halfWay = new Point(centp.x + rX * Math.cos(ah), centp.y + rY * Math.sin(ah));
    pathParser.addMarkerAngle(halfWay, ah - dir * Math.PI / 2);
    pathParser.addMarkerAngle(currentPoint, ah - dir * Math.PI);
    boundingBox.addPoint(currentPoint.x, currentPoint.y);
    if (ctx && !isNaN(a1) && !isNaN(ad)) {
      var r2 = rX > rY ? rX : rY;
      var sx = rX > rY ? 1 : rX / rY;
      var sy = rX > rY ? rY / rX : 1;
      ctx.translate(centp.x, centp.y);
      ctx.rotate(xAxisRotation);
      ctx.scale(sx, sy);
      ctx.arc(0, 0, r2, a1, a1 + ad, Boolean(1 - sweepFlag));
      ctx.scale(1 / sx, 1 / sy);
      ctx.rotate(-xAxisRotation);
      ctx.translate(-centp.x, -centp.y);
    }
  }
  static pathZ(pathParser) {
    pathParser.current = pathParser.start;
  }
  pathZ(ctx, boundingBox) {
    PathElement.pathZ(this.pathParser);
    if (ctx) {
      if (boundingBox.x1 !== boundingBox.x2 && boundingBox.y1 !== boundingBox.y2) {
        ctx.closePath();
      }
    }
  }
};
var GlyphElement = class extends PathElement {
  constructor(document2, node2, captureTextNodes) {
    super(document2, node2, captureTextNodes);
    this.type = "glyph";
    this.horizAdvX = this.getAttribute("horiz-adv-x").getNumber();
    this.unicode = this.getAttribute("unicode").getString();
    this.arabicForm = this.getAttribute("arabic-form").getString();
  }
};
var TextElement = class extends RenderedElement {
  constructor(document2, node2, captureTextNodes) {
    super(document2, node2, new.target === TextElement ? true : captureTextNodes);
    this.type = "text";
    this.x = 0;
    this.y = 0;
    this.measureCache = -1;
  }
  setContext(ctx) {
    var fromMeasure = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
    super.setContext(ctx, fromMeasure);
    var textBaseline = this.getStyle("dominant-baseline").getTextBaseline() || this.getStyle("alignment-baseline").getTextBaseline();
    if (textBaseline) {
      ctx.textBaseline = textBaseline;
    }
  }
  initializeCoordinates(ctx) {
    this.x = this.getAttribute("x").getPixels("x");
    this.y = this.getAttribute("y").getPixels("y");
    var dxAttr = this.getAttribute("dx");
    var dyAttr = this.getAttribute("dy");
    if (dxAttr.hasValue()) {
      this.x += dxAttr.getPixels("x");
    }
    if (dyAttr.hasValue()) {
      this.y += dyAttr.getPixels("y");
    }
    this.x += this.getAnchorDelta(ctx, this, 0);
  }
  getBoundingBox(ctx) {
    if (this.type !== "text") {
      return this.getTElementBoundingBox(ctx);
    }
    this.initializeCoordinates(ctx);
    var boundingBox = null;
    this.children.forEach((_2, i2) => {
      var childBoundingBox = this.getChildBoundingBox(ctx, this, this, i2);
      if (!boundingBox) {
        boundingBox = childBoundingBox;
      } else {
        boundingBox.addBoundingBox(childBoundingBox);
      }
    });
    return boundingBox;
  }
  getFontSize() {
    var {
      document: document2,
      parent
    } = this;
    var inheritFontSize = Font.parse(document2.ctx.font).fontSize;
    var fontSize2 = parent.getStyle("font-size").getNumber(inheritFontSize);
    return fontSize2;
  }
  getTElementBoundingBox(ctx) {
    var fontSize2 = this.getFontSize();
    return new BoundingBox(this.x, this.y - fontSize2, this.x + this.measureText(ctx), this.y);
  }
  getGlyph(font, text2, i2) {
    var char = text2[i2];
    var glyph = null;
    if (font.isArabic) {
      var len = text2.length;
      var prevChar = text2[i2 - 1];
      var nextChar = text2[i2 + 1];
      var arabicForm = "isolated";
      if ((i2 === 0 || prevChar === " ") && i2 < len - 2 && nextChar !== " ") {
        arabicForm = "terminal";
      }
      if (i2 > 0 && prevChar !== " " && i2 < len - 2 && nextChar !== " ") {
        arabicForm = "medial";
      }
      if (i2 > 0 && prevChar !== " " && (i2 === len - 1 || nextChar === " ")) {
        arabicForm = "initial";
      }
      if (typeof font.glyphs[char] !== "undefined") {
        var maybeGlyph = font.glyphs[char];
        glyph = maybeGlyph instanceof GlyphElement ? maybeGlyph : maybeGlyph[arabicForm];
      }
    } else {
      glyph = font.glyphs[char];
    }
    if (!glyph) {
      glyph = font.missingGlyph;
    }
    return glyph;
  }
  getText() {
    return "";
  }
  getTextFromNode(node2) {
    var textNode = node2 || this.node;
    var childNodes = Array.from(textNode.parentNode.childNodes);
    var index2 = childNodes.indexOf(textNode);
    var lastIndex = childNodes.length - 1;
    var text2 = compressSpaces(textNode.textContent || "");
    if (index2 === 0) {
      text2 = trimLeft(text2);
    }
    if (index2 === lastIndex) {
      text2 = trimRight(text2);
    }
    return text2;
  }
  renderChildren(ctx) {
    if (this.type !== "text") {
      this.renderTElementChildren(ctx);
      return;
    }
    this.initializeCoordinates(ctx);
    this.children.forEach((_2, i2) => {
      this.renderChild(ctx, this, this, i2);
    });
    var {
      mouse
    } = this.document.screen;
    if (mouse.isWorking()) {
      mouse.checkBoundingBox(this, this.getBoundingBox(ctx));
    }
  }
  renderTElementChildren(ctx) {
    var {
      document: document2,
      parent
    } = this;
    var renderText = this.getText();
    var customFont = parent.getStyle("font-family").getDefinition();
    if (customFont) {
      var {
        unitsPerEm
      } = customFont.fontFace;
      var ctxFont = Font.parse(document2.ctx.font);
      var fontSize2 = parent.getStyle("font-size").getNumber(ctxFont.fontSize);
      var fontStyle2 = parent.getStyle("font-style").getString(ctxFont.fontStyle);
      var scale2 = fontSize2 / unitsPerEm;
      var text2 = customFont.isRTL ? renderText.split("").reverse().join("") : renderText;
      var dx = toNumbers(parent.getAttribute("dx").getString());
      var len = text2.length;
      for (var i2 = 0; i2 < len; i2++) {
        var glyph = this.getGlyph(customFont, text2, i2);
        ctx.translate(this.x, this.y);
        ctx.scale(scale2, -scale2);
        var lw = ctx.lineWidth;
        ctx.lineWidth = ctx.lineWidth * unitsPerEm / fontSize2;
        if (fontStyle2 === "italic") {
          ctx.transform(1, 0, 0.4, 1, 0, 0);
        }
        glyph.render(ctx);
        if (fontStyle2 === "italic") {
          ctx.transform(1, 0, -0.4, 1, 0, 0);
        }
        ctx.lineWidth = lw;
        ctx.scale(1 / scale2, -1 / scale2);
        ctx.translate(-this.x, -this.y);
        this.x += fontSize2 * (glyph.horizAdvX || customFont.horizAdvX) / unitsPerEm;
        if (typeof dx[i2] !== "undefined" && !isNaN(dx[i2])) {
          this.x += dx[i2];
        }
      }
      return;
    }
    var {
      x: x2,
      y: y2
    } = this;
    if (ctx.fillStyle) {
      ctx.fillText(renderText, x2, y2);
    }
    if (ctx.strokeStyle) {
      ctx.strokeText(renderText, x2, y2);
    }
  }
  getAnchorDelta(ctx, parent, startI) {
    var textAnchor = this.getStyle("text-anchor").getString("start");
    if (textAnchor !== "start") {
      var {
        children
      } = parent;
      var len = children.length;
      var child = null;
      var width = 0;
      for (var i2 = startI; i2 < len; i2++) {
        child = children[i2];
        if (i2 > startI && child.getAttribute("x").hasValue() || child.getAttribute("text-anchor").hasValue()) {
          break;
        }
        width += child.measureTextRecursive(ctx);
      }
      return -1 * (textAnchor === "end" ? width : width / 2);
    }
    return 0;
  }
  adjustChildCoordinates(ctx, textParent, parent, i2) {
    var child = parent.children[i2];
    if (typeof child.measureText !== "function") {
      return child;
    }
    ctx.save();
    child.setContext(ctx, true);
    var xAttr = child.getAttribute("x");
    var yAttr = child.getAttribute("y");
    var dxAttr = child.getAttribute("dx");
    var dyAttr = child.getAttribute("dy");
    var textAnchor = child.getAttribute("text-anchor").getString("start");
    if (i2 === 0 && child.type !== "textNode") {
      if (!xAttr.hasValue()) {
        xAttr.setValue(textParent.getAttribute("x").getValue("0"));
      }
      if (!yAttr.hasValue()) {
        yAttr.setValue(textParent.getAttribute("y").getValue("0"));
      }
      if (!dxAttr.hasValue()) {
        dxAttr.setValue(textParent.getAttribute("dx").getValue("0"));
      }
      if (!dyAttr.hasValue()) {
        dyAttr.setValue(textParent.getAttribute("dy").getValue("0"));
      }
    }
    if (xAttr.hasValue()) {
      child.x = xAttr.getPixels("x") + textParent.getAnchorDelta(ctx, parent, i2);
      if (textAnchor !== "start") {
        var width = child.measureTextRecursive(ctx);
        child.x += -1 * (textAnchor === "end" ? width : width / 2);
      }
      if (dxAttr.hasValue()) {
        child.x += dxAttr.getPixels("x");
      }
    } else {
      if (textAnchor !== "start") {
        var _width = child.measureTextRecursive(ctx);
        textParent.x += -1 * (textAnchor === "end" ? _width : _width / 2);
      }
      if (dxAttr.hasValue()) {
        textParent.x += dxAttr.getPixels("x");
      }
      child.x = textParent.x;
    }
    textParent.x = child.x + child.measureText(ctx);
    if (yAttr.hasValue()) {
      child.y = yAttr.getPixels("y");
      if (dyAttr.hasValue()) {
        child.y += dyAttr.getPixels("y");
      }
    } else {
      if (dyAttr.hasValue()) {
        textParent.y += dyAttr.getPixels("y");
      }
      child.y = textParent.y;
    }
    textParent.y = child.y;
    child.clearContext(ctx);
    ctx.restore();
    return child;
  }
  getChildBoundingBox(ctx, textParent, parent, i2) {
    var child = this.adjustChildCoordinates(ctx, textParent, parent, i2);
    if (typeof child.getBoundingBox !== "function") {
      return null;
    }
    var boundingBox = child.getBoundingBox(ctx);
    if (!boundingBox) {
      return null;
    }
    child.children.forEach((_2, i3) => {
      var childBoundingBox = textParent.getChildBoundingBox(ctx, textParent, child, i3);
      boundingBox.addBoundingBox(childBoundingBox);
    });
    return boundingBox;
  }
  renderChild(ctx, textParent, parent, i2) {
    var child = this.adjustChildCoordinates(ctx, textParent, parent, i2);
    child.render(ctx);
    child.children.forEach((_2, i3) => {
      textParent.renderChild(ctx, textParent, child, i3);
    });
  }
  measureTextRecursive(ctx) {
    var width = this.children.reduce((width2, child) => width2 + child.measureTextRecursive(ctx), this.measureText(ctx));
    return width;
  }
  measureText(ctx) {
    var {
      measureCache
    } = this;
    if (~measureCache) {
      return measureCache;
    }
    var renderText = this.getText();
    var measure = this.measureTargetText(ctx, renderText);
    this.measureCache = measure;
    return measure;
  }
  measureTargetText(ctx, targetText) {
    if (!targetText.length) {
      return 0;
    }
    var {
      parent
    } = this;
    var customFont = parent.getStyle("font-family").getDefinition();
    if (customFont) {
      var fontSize2 = this.getFontSize();
      var text2 = customFont.isRTL ? targetText.split("").reverse().join("") : targetText;
      var dx = toNumbers(parent.getAttribute("dx").getString());
      var len = text2.length;
      var _measure = 0;
      for (var i2 = 0; i2 < len; i2++) {
        var glyph = this.getGlyph(customFont, text2, i2);
        _measure += (glyph.horizAdvX || customFont.horizAdvX) * fontSize2 / customFont.fontFace.unitsPerEm;
        if (typeof dx[i2] !== "undefined" && !isNaN(dx[i2])) {
          _measure += dx[i2];
        }
      }
      return _measure;
    }
    if (!ctx.measureText) {
      return targetText.length * 10;
    }
    ctx.save();
    this.setContext(ctx, true);
    var {
      width: measure
    } = ctx.measureText(targetText);
    this.clearContext(ctx);
    ctx.restore();
    return measure;
  }
};
var TSpanElement = class extends TextElement {
  constructor(document2, node2, captureTextNodes) {
    super(document2, node2, new.target === TSpanElement ? true : captureTextNodes);
    this.type = "tspan";
    this.text = this.children.length > 0 ? "" : this.getTextFromNode();
  }
  getText() {
    return this.text;
  }
};
var TextNode = class extends TSpanElement {
  constructor() {
    super(...arguments);
    this.type = "textNode";
  }
};
var SVGElement = class extends RenderedElement {
  constructor() {
    super(...arguments);
    this.type = "svg";
    this.root = false;
  }
  setContext(ctx) {
    var _this$node$parentNode;
    var {
      document: document2
    } = this;
    var {
      screen,
      window: window2
    } = document2;
    var canvas = ctx.canvas;
    screen.setDefaults(ctx);
    if (canvas.style && typeof ctx.font !== "undefined" && window2 && typeof window2.getComputedStyle !== "undefined") {
      ctx.font = window2.getComputedStyle(canvas).getPropertyValue("font");
      var fontSizeProp = new Property(document2, "fontSize", Font.parse(ctx.font).fontSize);
      if (fontSizeProp.hasValue()) {
        document2.rootEmSize = fontSizeProp.getPixels("y");
        document2.emSize = document2.rootEmSize;
      }
    }
    if (!this.getAttribute("x").hasValue()) {
      this.getAttribute("x", true).setValue(0);
    }
    if (!this.getAttribute("y").hasValue()) {
      this.getAttribute("y", true).setValue(0);
    }
    var {
      width,
      height
    } = screen.viewPort;
    if (!this.getStyle("width").hasValue()) {
      this.getStyle("width", true).setValue("100%");
    }
    if (!this.getStyle("height").hasValue()) {
      this.getStyle("height", true).setValue("100%");
    }
    if (!this.getStyle("color").hasValue()) {
      this.getStyle("color", true).setValue("black");
    }
    var refXAttr = this.getAttribute("refX");
    var refYAttr = this.getAttribute("refY");
    var viewBoxAttr = this.getAttribute("viewBox");
    var viewBox = viewBoxAttr.hasValue() ? toNumbers(viewBoxAttr.getString()) : null;
    var clip = !this.root && this.getStyle("overflow").getValue("hidden") !== "visible";
    var minX = 0;
    var minY = 0;
    var clipX = 0;
    var clipY = 0;
    if (viewBox) {
      minX = viewBox[0];
      minY = viewBox[1];
    }
    if (!this.root) {
      width = this.getStyle("width").getPixels("x");
      height = this.getStyle("height").getPixels("y");
      if (this.type === "marker") {
        clipX = minX;
        clipY = minY;
        minX = 0;
        minY = 0;
      }
    }
    screen.viewPort.setCurrent(width, height);
    if (this.node && (!this.parent || ((_this$node$parentNode = this.node.parentNode) === null || _this$node$parentNode === void 0 ? void 0 : _this$node$parentNode.nodeName) === "foreignObject") && this.getStyle("transform", false, true).hasValue() && !this.getStyle("transform-origin", false, true).hasValue()) {
      this.getStyle("transform-origin", true, true).setValue("50% 50%");
    }
    super.setContext(ctx);
    ctx.translate(this.getAttribute("x").getPixels("x"), this.getAttribute("y").getPixels("y"));
    if (viewBox) {
      width = viewBox[2];
      height = viewBox[3];
    }
    document2.setViewBox({
      ctx,
      aspectRatio: this.getAttribute("preserveAspectRatio").getString(),
      width: screen.viewPort.width,
      desiredWidth: width,
      height: screen.viewPort.height,
      desiredHeight: height,
      minX,
      minY,
      refX: refXAttr.getValue(),
      refY: refYAttr.getValue(),
      clip,
      clipX,
      clipY
    });
    if (viewBox) {
      screen.viewPort.removeCurrent();
      screen.viewPort.setCurrent(width, height);
    }
  }
  clearContext(ctx) {
    super.clearContext(ctx);
    this.document.screen.viewPort.removeCurrent();
  }
  resize(width) {
    var height = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : width;
    var preserveAspectRatio = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
    var widthAttr = this.getAttribute("width", true);
    var heightAttr = this.getAttribute("height", true);
    var viewBoxAttr = this.getAttribute("viewBox");
    var styleAttr = this.getAttribute("style");
    var originWidth = widthAttr.getNumber(0);
    var originHeight = heightAttr.getNumber(0);
    if (preserveAspectRatio) {
      if (typeof preserveAspectRatio === "string") {
        this.getAttribute("preserveAspectRatio", true).setValue(preserveAspectRatio);
      } else {
        var preserveAspectRatioAttr = this.getAttribute("preserveAspectRatio");
        if (preserveAspectRatioAttr.hasValue()) {
          preserveAspectRatioAttr.setValue(preserveAspectRatioAttr.getString().replace(/^\s*(\S.*\S)\s*$/, "$1"));
        }
      }
    }
    widthAttr.setValue(width);
    heightAttr.setValue(height);
    if (!viewBoxAttr.hasValue()) {
      viewBoxAttr.setValue("0 0 ".concat(originWidth || width, " ").concat(originHeight || height));
    }
    if (styleAttr.hasValue()) {
      var widthStyle = this.getStyle("width");
      var heightStyle = this.getStyle("height");
      if (widthStyle.hasValue()) {
        widthStyle.setValue("".concat(width, "px"));
      }
      if (heightStyle.hasValue()) {
        heightStyle.setValue("".concat(height, "px"));
      }
    }
  }
};
var RectElement = class extends PathElement {
  constructor() {
    super(...arguments);
    this.type = "rect";
  }
  path(ctx) {
    var x2 = this.getAttribute("x").getPixels("x");
    var y2 = this.getAttribute("y").getPixels("y");
    var width = this.getStyle("width", false, true).getPixels("x");
    var height = this.getStyle("height", false, true).getPixels("y");
    var rxAttr = this.getAttribute("rx");
    var ryAttr = this.getAttribute("ry");
    var rx = rxAttr.getPixels("x");
    var ry = ryAttr.getPixels("y");
    if (rxAttr.hasValue() && !ryAttr.hasValue()) {
      ry = rx;
    }
    if (ryAttr.hasValue() && !rxAttr.hasValue()) {
      rx = ry;
    }
    rx = Math.min(rx, width / 2);
    ry = Math.min(ry, height / 2);
    if (ctx) {
      var KAPPA = 4 * ((Math.sqrt(2) - 1) / 3);
      ctx.beginPath();
      if (height > 0 && width > 0) {
        ctx.moveTo(x2 + rx, y2);
        ctx.lineTo(x2 + width - rx, y2);
        ctx.bezierCurveTo(x2 + width - rx + KAPPA * rx, y2, x2 + width, y2 + ry - KAPPA * ry, x2 + width, y2 + ry);
        ctx.lineTo(x2 + width, y2 + height - ry);
        ctx.bezierCurveTo(x2 + width, y2 + height - ry + KAPPA * ry, x2 + width - rx + KAPPA * rx, y2 + height, x2 + width - rx, y2 + height);
        ctx.lineTo(x2 + rx, y2 + height);
        ctx.bezierCurveTo(x2 + rx - KAPPA * rx, y2 + height, x2, y2 + height - ry + KAPPA * ry, x2, y2 + height - ry);
        ctx.lineTo(x2, y2 + ry);
        ctx.bezierCurveTo(x2, y2 + ry - KAPPA * ry, x2 + rx - KAPPA * rx, y2, x2 + rx, y2);
        ctx.closePath();
      }
    }
    return new BoundingBox(x2, y2, x2 + width, y2 + height);
  }
  getMarkers() {
    return null;
  }
};
var CircleElement = class extends PathElement {
  constructor() {
    super(...arguments);
    this.type = "circle";
  }
  path(ctx) {
    var cx = this.getAttribute("cx").getPixels("x");
    var cy = this.getAttribute("cy").getPixels("y");
    var r2 = this.getAttribute("r").getPixels();
    if (ctx && r2 > 0) {
      ctx.beginPath();
      ctx.arc(cx, cy, r2, 0, Math.PI * 2, false);
      ctx.closePath();
    }
    return new BoundingBox(cx - r2, cy - r2, cx + r2, cy + r2);
  }
  getMarkers() {
    return null;
  }
};
var EllipseElement = class extends PathElement {
  constructor() {
    super(...arguments);
    this.type = "ellipse";
  }
  path(ctx) {
    var KAPPA = 4 * ((Math.sqrt(2) - 1) / 3);
    var rx = this.getAttribute("rx").getPixels("x");
    var ry = this.getAttribute("ry").getPixels("y");
    var cx = this.getAttribute("cx").getPixels("x");
    var cy = this.getAttribute("cy").getPixels("y");
    if (ctx && rx > 0 && ry > 0) {
      ctx.beginPath();
      ctx.moveTo(cx + rx, cy);
      ctx.bezierCurveTo(cx + rx, cy + KAPPA * ry, cx + KAPPA * rx, cy + ry, cx, cy + ry);
      ctx.bezierCurveTo(cx - KAPPA * rx, cy + ry, cx - rx, cy + KAPPA * ry, cx - rx, cy);
      ctx.bezierCurveTo(cx - rx, cy - KAPPA * ry, cx - KAPPA * rx, cy - ry, cx, cy - ry);
      ctx.bezierCurveTo(cx + KAPPA * rx, cy - ry, cx + rx, cy - KAPPA * ry, cx + rx, cy);
      ctx.closePath();
    }
    return new BoundingBox(cx - rx, cy - ry, cx + rx, cy + ry);
  }
  getMarkers() {
    return null;
  }
};
var LineElement = class extends PathElement {
  constructor() {
    super(...arguments);
    this.type = "line";
  }
  getPoints() {
    return [new Point(this.getAttribute("x1").getPixels("x"), this.getAttribute("y1").getPixels("y")), new Point(this.getAttribute("x2").getPixels("x"), this.getAttribute("y2").getPixels("y"))];
  }
  path(ctx) {
    var [{
      x: x0,
      y: y0
    }, {
      x: x1,
      y: y1
    }] = this.getPoints();
    if (ctx) {
      ctx.beginPath();
      ctx.moveTo(x0, y0);
      ctx.lineTo(x1, y1);
    }
    return new BoundingBox(x0, y0, x1, y1);
  }
  getMarkers() {
    var [p0, p12] = this.getPoints();
    var a2 = p0.angleTo(p12);
    return [[p0, a2], [p12, a2]];
  }
};
var PolylineElement = class extends PathElement {
  constructor(document2, node2, captureTextNodes) {
    super(document2, node2, captureTextNodes);
    this.type = "polyline";
    this.points = [];
    this.points = Point.parsePath(this.getAttribute("points").getString());
  }
  path(ctx) {
    var {
      points
    } = this;
    var [{
      x: x0,
      y: y0
    }] = points;
    var boundingBox = new BoundingBox(x0, y0);
    if (ctx) {
      ctx.beginPath();
      ctx.moveTo(x0, y0);
    }
    points.forEach((_ref2) => {
      var {
        x: x2,
        y: y2
      } = _ref2;
      boundingBox.addPoint(x2, y2);
      if (ctx) {
        ctx.lineTo(x2, y2);
      }
    });
    return boundingBox;
  }
  getMarkers() {
    var {
      points
    } = this;
    var lastIndex = points.length - 1;
    var markers = [];
    points.forEach((point, i2) => {
      if (i2 === lastIndex) {
        return;
      }
      markers.push([point, point.angleTo(points[i2 + 1])]);
    });
    if (markers.length > 0) {
      markers.push([points[points.length - 1], markers[markers.length - 1][1]]);
    }
    return markers;
  }
};
var PolygonElement = class extends PolylineElement {
  constructor() {
    super(...arguments);
    this.type = "polygon";
  }
  path(ctx) {
    var boundingBox = super.path(ctx);
    var [{
      x: x2,
      y: y2
    }] = this.points;
    if (ctx) {
      ctx.lineTo(x2, y2);
      ctx.closePath();
    }
    return boundingBox;
  }
};
var PatternElement = class extends Element$1 {
  constructor() {
    super(...arguments);
    this.type = "pattern";
  }
  createPattern(ctx, _2, parentOpacityProp) {
    var width = this.getStyle("width").getPixels("x", true);
    var height = this.getStyle("height").getPixels("y", true);
    var patternSvg = new SVGElement(this.document, null);
    patternSvg.attributes.viewBox = new Property(this.document, "viewBox", this.getAttribute("viewBox").getValue());
    patternSvg.attributes.width = new Property(this.document, "width", "".concat(width, "px"));
    patternSvg.attributes.height = new Property(this.document, "height", "".concat(height, "px"));
    patternSvg.attributes.transform = new Property(this.document, "transform", this.getAttribute("patternTransform").getValue());
    patternSvg.children = this.children;
    var patternCanvas = this.document.createCanvas(width, height);
    var patternCtx = patternCanvas.getContext("2d");
    var xAttr = this.getAttribute("x");
    var yAttr = this.getAttribute("y");
    if (xAttr.hasValue() && yAttr.hasValue()) {
      patternCtx.translate(xAttr.getPixels("x", true), yAttr.getPixels("y", true));
    }
    if (parentOpacityProp.hasValue()) {
      this.styles["fill-opacity"] = parentOpacityProp;
    } else {
      Reflect.deleteProperty(this.styles, "fill-opacity");
    }
    for (var x2 = -1; x2 <= 1; x2++) {
      for (var y2 = -1; y2 <= 1; y2++) {
        patternCtx.save();
        patternSvg.attributes.x = new Property(this.document, "x", x2 * patternCanvas.width);
        patternSvg.attributes.y = new Property(this.document, "y", y2 * patternCanvas.height);
        patternSvg.render(patternCtx);
        patternCtx.restore();
      }
    }
    var pattern = ctx.createPattern(patternCanvas, "repeat");
    return pattern;
  }
};
var MarkerElement = class extends Element$1 {
  constructor() {
    super(...arguments);
    this.type = "marker";
  }
  render(ctx, point, angle2) {
    if (!point) {
      return;
    }
    var {
      x: x2,
      y: y2
    } = point;
    var orient = this.getAttribute("orient").getString("auto");
    var markerUnits = this.getAttribute("markerUnits").getString("strokeWidth");
    ctx.translate(x2, y2);
    if (orient === "auto") {
      ctx.rotate(angle2);
    }
    if (markerUnits === "strokeWidth") {
      ctx.scale(ctx.lineWidth, ctx.lineWidth);
    }
    ctx.save();
    var markerSvg = new SVGElement(this.document, null);
    markerSvg.type = this.type;
    markerSvg.attributes.viewBox = new Property(this.document, "viewBox", this.getAttribute("viewBox").getValue());
    markerSvg.attributes.refX = new Property(this.document, "refX", this.getAttribute("refX").getValue());
    markerSvg.attributes.refY = new Property(this.document, "refY", this.getAttribute("refY").getValue());
    markerSvg.attributes.width = new Property(this.document, "width", this.getAttribute("markerWidth").getValue());
    markerSvg.attributes.height = new Property(this.document, "height", this.getAttribute("markerHeight").getValue());
    markerSvg.attributes.overflow = new Property(this.document, "overflow", this.getAttribute("overflow").getValue());
    markerSvg.attributes.fill = new Property(this.document, "fill", this.getAttribute("fill").getColor("black"));
    markerSvg.attributes.stroke = new Property(this.document, "stroke", this.getAttribute("stroke").getValue("none"));
    markerSvg.children = this.children;
    markerSvg.render(ctx);
    ctx.restore();
    if (markerUnits === "strokeWidth") {
      ctx.scale(1 / ctx.lineWidth, 1 / ctx.lineWidth);
    }
    if (orient === "auto") {
      ctx.rotate(-angle2);
    }
    ctx.translate(-x2, -y2);
  }
};
var DefsElement = class extends Element$1 {
  constructor() {
    super(...arguments);
    this.type = "defs";
  }
  render() {
  }
};
var GElement = class extends RenderedElement {
  constructor() {
    super(...arguments);
    this.type = "g";
  }
  getBoundingBox(ctx) {
    var boundingBox = new BoundingBox();
    this.children.forEach((child) => {
      boundingBox.addBoundingBox(child.getBoundingBox(ctx));
    });
    return boundingBox;
  }
};
var GradientElement = class extends Element$1 {
  constructor(document2, node2, captureTextNodes) {
    super(document2, node2, captureTextNodes);
    this.attributesToInherit = ["gradientUnits"];
    this.stops = [];
    var {
      stops,
      children
    } = this;
    children.forEach((child) => {
      if (child.type === "stop") {
        stops.push(child);
      }
    });
  }
  getGradientUnits() {
    return this.getAttribute("gradientUnits").getString("objectBoundingBox");
  }
  createGradient(ctx, element, parentOpacityProp) {
    var stopsContainer = this;
    if (this.getHrefAttribute().hasValue()) {
      stopsContainer = this.getHrefAttribute().getDefinition();
      this.inheritStopContainer(stopsContainer);
    }
    var {
      stops
    } = stopsContainer;
    var gradient = this.getGradient(ctx, element);
    if (!gradient) {
      return this.addParentOpacity(parentOpacityProp, stops[stops.length - 1].color);
    }
    stops.forEach((stop) => {
      gradient.addColorStop(stop.offset, this.addParentOpacity(parentOpacityProp, stop.color));
    });
    if (this.getAttribute("gradientTransform").hasValue()) {
      var {
        document: document2
      } = this;
      var {
        MAX_VIRTUAL_PIXELS,
        viewPort
      } = document2.screen;
      var [rootView] = viewPort.viewPorts;
      var rect = new RectElement(document2, null);
      rect.attributes.x = new Property(document2, "x", -MAX_VIRTUAL_PIXELS / 3);
      rect.attributes.y = new Property(document2, "y", -MAX_VIRTUAL_PIXELS / 3);
      rect.attributes.width = new Property(document2, "width", MAX_VIRTUAL_PIXELS);
      rect.attributes.height = new Property(document2, "height", MAX_VIRTUAL_PIXELS);
      var group = new GElement(document2, null);
      group.attributes.transform = new Property(document2, "transform", this.getAttribute("gradientTransform").getValue());
      group.children = [rect];
      var patternSvg = new SVGElement(document2, null);
      patternSvg.attributes.x = new Property(document2, "x", 0);
      patternSvg.attributes.y = new Property(document2, "y", 0);
      patternSvg.attributes.width = new Property(document2, "width", rootView.width);
      patternSvg.attributes.height = new Property(document2, "height", rootView.height);
      patternSvg.children = [group];
      var patternCanvas = document2.createCanvas(rootView.width, rootView.height);
      var patternCtx = patternCanvas.getContext("2d");
      patternCtx.fillStyle = gradient;
      patternSvg.render(patternCtx);
      return patternCtx.createPattern(patternCanvas, "no-repeat");
    }
    return gradient;
  }
  inheritStopContainer(stopsContainer) {
    this.attributesToInherit.forEach((attributeToInherit) => {
      if (!this.getAttribute(attributeToInherit).hasValue() && stopsContainer.getAttribute(attributeToInherit).hasValue()) {
        this.getAttribute(attributeToInherit, true).setValue(stopsContainer.getAttribute(attributeToInherit).getValue());
      }
    });
  }
  addParentOpacity(parentOpacityProp, color2) {
    if (parentOpacityProp.hasValue()) {
      var colorProp = new Property(this.document, "color", color2);
      return colorProp.addOpacity(parentOpacityProp).getColor();
    }
    return color2;
  }
};
var LinearGradientElement = class extends GradientElement {
  constructor(document2, node2, captureTextNodes) {
    super(document2, node2, captureTextNodes);
    this.type = "linearGradient";
    this.attributesToInherit.push("x1", "y1", "x2", "y2");
  }
  getGradient(ctx, element) {
    var isBoundingBoxUnits = this.getGradientUnits() === "objectBoundingBox";
    var boundingBox = isBoundingBoxUnits ? element.getBoundingBox(ctx) : null;
    if (isBoundingBoxUnits && !boundingBox) {
      return null;
    }
    if (!this.getAttribute("x1").hasValue() && !this.getAttribute("y1").hasValue() && !this.getAttribute("x2").hasValue() && !this.getAttribute("y2").hasValue()) {
      this.getAttribute("x1", true).setValue(0);
      this.getAttribute("y1", true).setValue(0);
      this.getAttribute("x2", true).setValue(1);
      this.getAttribute("y2", true).setValue(0);
    }
    var x1 = isBoundingBoxUnits ? boundingBox.x + boundingBox.width * this.getAttribute("x1").getNumber() : this.getAttribute("x1").getPixels("x");
    var y1 = isBoundingBoxUnits ? boundingBox.y + boundingBox.height * this.getAttribute("y1").getNumber() : this.getAttribute("y1").getPixels("y");
    var x2 = isBoundingBoxUnits ? boundingBox.x + boundingBox.width * this.getAttribute("x2").getNumber() : this.getAttribute("x2").getPixels("x");
    var y2 = isBoundingBoxUnits ? boundingBox.y + boundingBox.height * this.getAttribute("y2").getNumber() : this.getAttribute("y2").getPixels("y");
    if (x1 === x2 && y1 === y2) {
      return null;
    }
    return ctx.createLinearGradient(x1, y1, x2, y2);
  }
};
var RadialGradientElement = class extends GradientElement {
  constructor(document2, node2, captureTextNodes) {
    super(document2, node2, captureTextNodes);
    this.type = "radialGradient";
    this.attributesToInherit.push("cx", "cy", "r", "fx", "fy", "fr");
  }
  getGradient(ctx, element) {
    var isBoundingBoxUnits = this.getGradientUnits() === "objectBoundingBox";
    var boundingBox = element.getBoundingBox(ctx);
    if (isBoundingBoxUnits && !boundingBox) {
      return null;
    }
    if (!this.getAttribute("cx").hasValue()) {
      this.getAttribute("cx", true).setValue("50%");
    }
    if (!this.getAttribute("cy").hasValue()) {
      this.getAttribute("cy", true).setValue("50%");
    }
    if (!this.getAttribute("r").hasValue()) {
      this.getAttribute("r", true).setValue("50%");
    }
    var cx = isBoundingBoxUnits ? boundingBox.x + boundingBox.width * this.getAttribute("cx").getNumber() : this.getAttribute("cx").getPixels("x");
    var cy = isBoundingBoxUnits ? boundingBox.y + boundingBox.height * this.getAttribute("cy").getNumber() : this.getAttribute("cy").getPixels("y");
    var fx = cx;
    var fy = cy;
    if (this.getAttribute("fx").hasValue()) {
      fx = isBoundingBoxUnits ? boundingBox.x + boundingBox.width * this.getAttribute("fx").getNumber() : this.getAttribute("fx").getPixels("x");
    }
    if (this.getAttribute("fy").hasValue()) {
      fy = isBoundingBoxUnits ? boundingBox.y + boundingBox.height * this.getAttribute("fy").getNumber() : this.getAttribute("fy").getPixels("y");
    }
    var r2 = isBoundingBoxUnits ? (boundingBox.width + boundingBox.height) / 2 * this.getAttribute("r").getNumber() : this.getAttribute("r").getPixels();
    var fr = this.getAttribute("fr").getPixels();
    return ctx.createRadialGradient(fx, fy, fr, cx, cy, r2);
  }
};
var StopElement = class extends Element$1 {
  constructor(document2, node2, captureTextNodes) {
    super(document2, node2, captureTextNodes);
    this.type = "stop";
    var offset2 = Math.max(0, Math.min(1, this.getAttribute("offset").getNumber()));
    var stopOpacity = this.getStyle("stop-opacity");
    var stopColor = this.getStyle("stop-color", true);
    if (stopColor.getString() === "") {
      stopColor.setValue("#000");
    }
    if (stopOpacity.hasValue()) {
      stopColor = stopColor.addOpacity(stopOpacity);
    }
    this.offset = offset2;
    this.color = stopColor.getColor();
  }
};
var AnimateElement = class extends Element$1 {
  constructor(document2, node2, captureTextNodes) {
    super(document2, node2, captureTextNodes);
    this.type = "animate";
    this.duration = 0;
    this.initialValue = null;
    this.initialUnits = "";
    this.removed = false;
    this.frozen = false;
    document2.screen.animations.push(this);
    this.begin = this.getAttribute("begin").getMilliseconds();
    this.maxDuration = this.begin + this.getAttribute("dur").getMilliseconds();
    this.from = this.getAttribute("from");
    this.to = this.getAttribute("to");
    this.values = new Property(document2, "values", null);
    var valuesAttr = this.getAttribute("values");
    if (valuesAttr.hasValue()) {
      this.values.setValue(valuesAttr.getString().split(";"));
    }
  }
  getProperty() {
    var attributeType = this.getAttribute("attributeType").getString();
    var attributeName = this.getAttribute("attributeName").getString();
    if (attributeType === "CSS") {
      return this.parent.getStyle(attributeName, true);
    }
    return this.parent.getAttribute(attributeName, true);
  }
  calcValue() {
    var {
      initialUnits
    } = this;
    var {
      progress,
      from,
      to
    } = this.getProgress();
    var newValue = from.getNumber() + (to.getNumber() - from.getNumber()) * progress;
    if (initialUnits === "%") {
      newValue *= 100;
    }
    return "".concat(newValue).concat(initialUnits);
  }
  update(delta) {
    var {
      parent
    } = this;
    var prop = this.getProperty();
    if (!this.initialValue) {
      this.initialValue = prop.getString();
      this.initialUnits = prop.getUnits();
    }
    if (this.duration > this.maxDuration) {
      var fill = this.getAttribute("fill").getString("remove");
      if (this.getAttribute("repeatCount").getString() === "indefinite" || this.getAttribute("repeatDur").getString() === "indefinite") {
        this.duration = 0;
      } else if (fill === "freeze" && !this.frozen) {
        this.frozen = true;
        parent.animationFrozen = true;
        parent.animationFrozenValue = prop.getString();
      } else if (fill === "remove" && !this.removed) {
        this.removed = true;
        prop.setValue(parent.animationFrozen ? parent.animationFrozenValue : this.initialValue);
        return true;
      }
      return false;
    }
    this.duration += delta;
    var updated = false;
    if (this.begin < this.duration) {
      var newValue = this.calcValue();
      var typeAttr = this.getAttribute("type");
      if (typeAttr.hasValue()) {
        var type = typeAttr.getString();
        newValue = "".concat(type, "(").concat(newValue, ")");
      }
      prop.setValue(newValue);
      updated = true;
    }
    return updated;
  }
  getProgress() {
    var {
      document: document2,
      values: values2
    } = this;
    var result = {
      progress: (this.duration - this.begin) / (this.maxDuration - this.begin)
    };
    if (values2.hasValue()) {
      var p5 = result.progress * (values2.getValue().length - 1);
      var lb = Math.floor(p5);
      var ub = Math.ceil(p5);
      result.from = new Property(document2, "from", parseFloat(values2.getValue()[lb]));
      result.to = new Property(document2, "to", parseFloat(values2.getValue()[ub]));
      result.progress = (p5 - lb) / (ub - lb);
    } else {
      result.from = this.from;
      result.to = this.to;
    }
    return result;
  }
};
var AnimateColorElement = class extends AnimateElement {
  constructor() {
    super(...arguments);
    this.type = "animateColor";
  }
  calcValue() {
    var {
      progress,
      from,
      to
    } = this.getProgress();
    var colorFrom = new rgbcolor(from.getColor());
    var colorTo = new rgbcolor(to.getColor());
    if (colorFrom.ok && colorTo.ok) {
      var r2 = colorFrom.r + (colorTo.r - colorFrom.r) * progress;
      var g2 = colorFrom.g + (colorTo.g - colorFrom.g) * progress;
      var b2 = colorFrom.b + (colorTo.b - colorFrom.b) * progress;
      return "rgb(".concat(Math.floor(r2), ", ").concat(Math.floor(g2), ", ").concat(Math.floor(b2), ")");
    }
    return this.getAttribute("from").getColor();
  }
};
var AnimateTransformElement = class extends AnimateElement {
  constructor() {
    super(...arguments);
    this.type = "animateTransform";
  }
  calcValue() {
    var {
      progress,
      from,
      to
    } = this.getProgress();
    var transformFrom = toNumbers(from.getString());
    var transformTo = toNumbers(to.getString());
    var newValue = transformFrom.map((from2, i2) => {
      var to2 = transformTo[i2];
      return from2 + (to2 - from2) * progress;
    }).join(" ");
    return newValue;
  }
};
var FontElement = class extends Element$1 {
  constructor(document2, node2, captureTextNodes) {
    super(document2, node2, captureTextNodes);
    this.type = "font";
    this.glyphs = {};
    this.horizAdvX = this.getAttribute("horiz-adv-x").getNumber();
    var {
      definitions
    } = document2;
    var {
      children
    } = this;
    for (var child of children) {
      switch (child.type) {
        case "font-face": {
          this.fontFace = child;
          var fontFamilyStyle = child.getStyle("font-family");
          if (fontFamilyStyle.hasValue()) {
            definitions[fontFamilyStyle.getString()] = this;
          }
          break;
        }
        case "missing-glyph":
          this.missingGlyph = child;
          break;
        case "glyph": {
          var glyph = child;
          if (glyph.arabicForm) {
            this.isRTL = true;
            this.isArabic = true;
            if (typeof this.glyphs[glyph.unicode] === "undefined") {
              this.glyphs[glyph.unicode] = {};
            }
            this.glyphs[glyph.unicode][glyph.arabicForm] = glyph;
          } else {
            this.glyphs[glyph.unicode] = glyph;
          }
          break;
        }
      }
    }
  }
  render() {
  }
};
var FontFaceElement = class extends Element$1 {
  constructor(document2, node2, captureTextNodes) {
    super(document2, node2, captureTextNodes);
    this.type = "font-face";
    this.ascent = this.getAttribute("ascent").getNumber();
    this.descent = this.getAttribute("descent").getNumber();
    this.unitsPerEm = this.getAttribute("units-per-em").getNumber();
  }
};
var MissingGlyphElement = class extends PathElement {
  constructor() {
    super(...arguments);
    this.type = "missing-glyph";
    this.horizAdvX = 0;
  }
};
var TRefElement = class extends TextElement {
  constructor() {
    super(...arguments);
    this.type = "tref";
  }
  getText() {
    var element = this.getHrefAttribute().getDefinition();
    if (element) {
      var firstChild = element.children[0];
      if (firstChild) {
        return firstChild.getText();
      }
    }
    return "";
  }
};
var AElement = class extends TextElement {
  constructor(document2, node2, captureTextNodes) {
    super(document2, node2, captureTextNodes);
    this.type = "a";
    var {
      childNodes
    } = node2;
    var firstChild = childNodes[0];
    var hasText = childNodes.length > 0 && Array.from(childNodes).every((node3) => node3.nodeType === 3);
    this.hasText = hasText;
    this.text = hasText ? this.getTextFromNode(firstChild) : "";
  }
  getText() {
    return this.text;
  }
  renderChildren(ctx) {
    if (this.hasText) {
      super.renderChildren(ctx);
      var {
        document: document2,
        x: x2,
        y: y2
      } = this;
      var {
        mouse
      } = document2.screen;
      var fontSize2 = new Property(document2, "fontSize", Font.parse(document2.ctx.font).fontSize);
      if (mouse.isWorking()) {
        mouse.checkBoundingBox(this, new BoundingBox(x2, y2 - fontSize2.getPixels("y"), x2 + this.measureText(ctx), y2));
      }
    } else if (this.children.length > 0) {
      var g2 = new GElement(this.document, null);
      g2.children = this.children;
      g2.parent = this;
      g2.render(ctx);
    }
  }
  onClick() {
    var {
      window: window2
    } = this.document;
    if (window2) {
      window2.open(this.getHrefAttribute().getString());
    }
  }
  onMouseMove() {
    var ctx = this.document.ctx;
    ctx.canvas.style.cursor = "pointer";
  }
};
function ownKeys$2(object, enumerableOnly) {
  var keys3 = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly)
      symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      });
    keys3.push.apply(keys3, symbols);
  }
  return keys3;
}
function _objectSpread$2(target) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source = arguments[i2] != null ? arguments[i2] : {};
    if (i2 % 2) {
      ownKeys$2(Object(source), true).forEach(function(key) {
        _defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys$2(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }
  return target;
}
var TextPathElement = class extends TextElement {
  constructor(document2, node2, captureTextNodes) {
    super(document2, node2, captureTextNodes);
    this.type = "textPath";
    this.textWidth = 0;
    this.textHeight = 0;
    this.pathLength = -1;
    this.glyphInfo = null;
    this.letterSpacingCache = [];
    this.measuresCache = /* @__PURE__ */ new Map([["", 0]]);
    var pathElement = this.getHrefAttribute().getDefinition();
    this.text = this.getTextFromNode();
    this.dataArray = this.parsePathData(pathElement);
  }
  getText() {
    return this.text;
  }
  path(ctx) {
    var {
      dataArray
    } = this;
    if (ctx) {
      ctx.beginPath();
    }
    dataArray.forEach((_ref2) => {
      var {
        type,
        points
      } = _ref2;
      switch (type) {
        case PathParser.LINE_TO:
          if (ctx) {
            ctx.lineTo(points[0], points[1]);
          }
          break;
        case PathParser.MOVE_TO:
          if (ctx) {
            ctx.moveTo(points[0], points[1]);
          }
          break;
        case PathParser.CURVE_TO:
          if (ctx) {
            ctx.bezierCurveTo(points[0], points[1], points[2], points[3], points[4], points[5]);
          }
          break;
        case PathParser.QUAD_TO:
          if (ctx) {
            ctx.quadraticCurveTo(points[0], points[1], points[2], points[3]);
          }
          break;
        case PathParser.ARC: {
          var [cx, cy, rx, ry, theta, dTheta, psi, fs] = points;
          var r2 = rx > ry ? rx : ry;
          var scaleX = rx > ry ? 1 : rx / ry;
          var scaleY = rx > ry ? ry / rx : 1;
          if (ctx) {
            ctx.translate(cx, cy);
            ctx.rotate(psi);
            ctx.scale(scaleX, scaleY);
            ctx.arc(0, 0, r2, theta, theta + dTheta, Boolean(1 - fs));
            ctx.scale(1 / scaleX, 1 / scaleY);
            ctx.rotate(-psi);
            ctx.translate(-cx, -cy);
          }
          break;
        }
        case PathParser.CLOSE_PATH:
          if (ctx) {
            ctx.closePath();
          }
          break;
      }
    });
  }
  renderChildren(ctx) {
    this.setTextData(ctx);
    ctx.save();
    var textDecoration = this.parent.getStyle("text-decoration").getString();
    var fontSize2 = this.getFontSize();
    var {
      glyphInfo
    } = this;
    var fill = ctx.fillStyle;
    if (textDecoration === "underline") {
      ctx.beginPath();
    }
    glyphInfo.forEach((glyph, i2) => {
      var {
        p0,
        p1: p12,
        rotation,
        text: partialText
      } = glyph;
      ctx.save();
      ctx.translate(p0.x, p0.y);
      ctx.rotate(rotation);
      if (ctx.fillStyle) {
        ctx.fillText(partialText, 0, 0);
      }
      if (ctx.strokeStyle) {
        ctx.strokeText(partialText, 0, 0);
      }
      ctx.restore();
      if (textDecoration === "underline") {
        if (i2 === 0) {
          ctx.moveTo(p0.x, p0.y + fontSize2 / 8);
        }
        ctx.lineTo(p12.x, p12.y + fontSize2 / 5);
      }
    });
    if (textDecoration === "underline") {
      ctx.lineWidth = fontSize2 / 20;
      ctx.strokeStyle = fill;
      ctx.stroke();
      ctx.closePath();
    }
    ctx.restore();
  }
  getLetterSpacingAt() {
    var idx = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;
    return this.letterSpacingCache[idx] || 0;
  }
  findSegmentToFitChar(ctx, anchor, textFullWidth, fullPathWidth, spacesNumber, inputOffset, dy, c2, charI) {
    var offset2 = inputOffset;
    var glyphWidth = this.measureText(ctx, c2);
    if (c2 === " " && anchor === "justify" && textFullWidth < fullPathWidth) {
      glyphWidth += (fullPathWidth - textFullWidth) / spacesNumber;
    }
    if (charI > -1) {
      offset2 += this.getLetterSpacingAt(charI);
    }
    var splineStep = this.textHeight / 20;
    var p0 = this.getEquidistantPointOnPath(offset2, splineStep, 0);
    var p12 = this.getEquidistantPointOnPath(offset2 + glyphWidth, splineStep, 0);
    var segment = {
      p0,
      p1: p12
    };
    var rotation = p0 && p12 ? Math.atan2(p12.y - p0.y, p12.x - p0.x) : 0;
    if (dy) {
      var dyX = Math.cos(Math.PI / 2 + rotation) * dy;
      var dyY = Math.cos(-rotation) * dy;
      segment.p0 = _objectSpread$2(_objectSpread$2({}, p0), {}, {
        x: p0.x + dyX,
        y: p0.y + dyY
      });
      segment.p1 = _objectSpread$2(_objectSpread$2({}, p12), {}, {
        x: p12.x + dyX,
        y: p12.y + dyY
      });
    }
    offset2 += glyphWidth;
    return {
      offset: offset2,
      segment,
      rotation
    };
  }
  measureText(ctx, text2) {
    var {
      measuresCache
    } = this;
    var targetText = text2 || this.getText();
    if (measuresCache.has(targetText)) {
      return measuresCache.get(targetText);
    }
    var measure = this.measureTargetText(ctx, targetText);
    measuresCache.set(targetText, measure);
    return measure;
  }
  setTextData(ctx) {
    if (this.glyphInfo) {
      return;
    }
    var renderText = this.getText();
    var chars2 = renderText.split("");
    var spacesNumber = renderText.split(" ").length - 1;
    var dx = this.parent.getAttribute("dx").split().map((_2) => _2.getPixels("x"));
    var dy = this.parent.getAttribute("dy").getPixels("y");
    var anchor = this.parent.getStyle("text-anchor").getString("start");
    var thisSpacing = this.getStyle("letter-spacing");
    var parentSpacing = this.parent.getStyle("letter-spacing");
    var letterSpacing2 = 0;
    if (!thisSpacing.hasValue() || thisSpacing.getValue() === "inherit") {
      letterSpacing2 = parentSpacing.getPixels();
    } else if (thisSpacing.hasValue()) {
      if (thisSpacing.getValue() !== "initial" && thisSpacing.getValue() !== "unset") {
        letterSpacing2 = thisSpacing.getPixels();
      }
    }
    var letterSpacingCache = [];
    var textLen = renderText.length;
    this.letterSpacingCache = letterSpacingCache;
    for (var i2 = 0; i2 < textLen; i2++) {
      letterSpacingCache.push(typeof dx[i2] !== "undefined" ? dx[i2] : letterSpacing2);
    }
    var dxSum = letterSpacingCache.reduce((acc, cur, i3) => i3 === 0 ? 0 : acc + cur || 0, 0);
    var textWidth = this.measureText(ctx);
    var textFullWidth = Math.max(textWidth + dxSum, 0);
    this.textWidth = textWidth;
    this.textHeight = this.getFontSize();
    this.glyphInfo = [];
    var fullPathWidth = this.getPathLength();
    var startOffset = this.getStyle("startOffset").getNumber(0) * fullPathWidth;
    var offset2 = 0;
    if (anchor === "middle" || anchor === "center") {
      offset2 = -textFullWidth / 2;
    }
    if (anchor === "end" || anchor === "right") {
      offset2 = -textFullWidth;
    }
    offset2 += startOffset;
    chars2.forEach((char, i3) => {
      var {
        offset: nextOffset,
        segment,
        rotation
      } = this.findSegmentToFitChar(ctx, anchor, textFullWidth, fullPathWidth, spacesNumber, offset2, dy, char, i3);
      offset2 = nextOffset;
      if (!segment.p0 || !segment.p1) {
        return;
      }
      this.glyphInfo.push({
        text: chars2[i3],
        p0: segment.p0,
        p1: segment.p1,
        rotation
      });
    });
  }
  parsePathData(path) {
    this.pathLength = -1;
    if (!path) {
      return [];
    }
    var pathCommands = [];
    var {
      pathParser
    } = path;
    pathParser.reset();
    while (!pathParser.isEnd()) {
      var {
        current
      } = pathParser;
      var startX = current ? current.x : 0;
      var startY = current ? current.y : 0;
      var command = pathParser.next();
      var nextCommandType = command.type;
      var points = [];
      switch (command.type) {
        case PathParser.MOVE_TO:
          this.pathM(pathParser, points);
          break;
        case PathParser.LINE_TO:
          nextCommandType = this.pathL(pathParser, points);
          break;
        case PathParser.HORIZ_LINE_TO:
          nextCommandType = this.pathH(pathParser, points);
          break;
        case PathParser.VERT_LINE_TO:
          nextCommandType = this.pathV(pathParser, points);
          break;
        case PathParser.CURVE_TO:
          this.pathC(pathParser, points);
          break;
        case PathParser.SMOOTH_CURVE_TO:
          nextCommandType = this.pathS(pathParser, points);
          break;
        case PathParser.QUAD_TO:
          this.pathQ(pathParser, points);
          break;
        case PathParser.SMOOTH_QUAD_TO:
          nextCommandType = this.pathT(pathParser, points);
          break;
        case PathParser.ARC:
          points = this.pathA(pathParser);
          break;
        case PathParser.CLOSE_PATH:
          PathElement.pathZ(pathParser);
          break;
      }
      if (command.type !== PathParser.CLOSE_PATH) {
        pathCommands.push({
          type: nextCommandType,
          points,
          start: {
            x: startX,
            y: startY
          },
          pathLength: this.calcLength(startX, startY, nextCommandType, points)
        });
      } else {
        pathCommands.push({
          type: PathParser.CLOSE_PATH,
          points: [],
          pathLength: 0
        });
      }
    }
    return pathCommands;
  }
  pathM(pathParser, points) {
    var {
      x: x2,
      y: y2
    } = PathElement.pathM(pathParser).point;
    points.push(x2, y2);
  }
  pathL(pathParser, points) {
    var {
      x: x2,
      y: y2
    } = PathElement.pathL(pathParser).point;
    points.push(x2, y2);
    return PathParser.LINE_TO;
  }
  pathH(pathParser, points) {
    var {
      x: x2,
      y: y2
    } = PathElement.pathH(pathParser).point;
    points.push(x2, y2);
    return PathParser.LINE_TO;
  }
  pathV(pathParser, points) {
    var {
      x: x2,
      y: y2
    } = PathElement.pathV(pathParser).point;
    points.push(x2, y2);
    return PathParser.LINE_TO;
  }
  pathC(pathParser, points) {
    var {
      point,
      controlPoint,
      currentPoint
    } = PathElement.pathC(pathParser);
    points.push(point.x, point.y, controlPoint.x, controlPoint.y, currentPoint.x, currentPoint.y);
  }
  pathS(pathParser, points) {
    var {
      point,
      controlPoint,
      currentPoint
    } = PathElement.pathS(pathParser);
    points.push(point.x, point.y, controlPoint.x, controlPoint.y, currentPoint.x, currentPoint.y);
    return PathParser.CURVE_TO;
  }
  pathQ(pathParser, points) {
    var {
      controlPoint,
      currentPoint
    } = PathElement.pathQ(pathParser);
    points.push(controlPoint.x, controlPoint.y, currentPoint.x, currentPoint.y);
  }
  pathT(pathParser, points) {
    var {
      controlPoint,
      currentPoint
    } = PathElement.pathT(pathParser);
    points.push(controlPoint.x, controlPoint.y, currentPoint.x, currentPoint.y);
    return PathParser.QUAD_TO;
  }
  pathA(pathParser) {
    var {
      rX,
      rY,
      sweepFlag,
      xAxisRotation,
      centp,
      a1,
      ad
    } = PathElement.pathA(pathParser);
    if (sweepFlag === 0 && ad > 0) {
      ad -= 2 * Math.PI;
    }
    if (sweepFlag === 1 && ad < 0) {
      ad += 2 * Math.PI;
    }
    return [centp.x, centp.y, rX, rY, a1, ad, xAxisRotation, sweepFlag];
  }
  calcLength(x2, y2, commandType, points) {
    var len = 0;
    var p12 = null;
    var p22 = null;
    var t3 = 0;
    switch (commandType) {
      case PathParser.LINE_TO:
        return this.getLineLength(x2, y2, points[0], points[1]);
      case PathParser.CURVE_TO:
        len = 0;
        p12 = this.getPointOnCubicBezier(0, x2, y2, points[0], points[1], points[2], points[3], points[4], points[5]);
        for (t3 = 0.01; t3 <= 1; t3 += 0.01) {
          p22 = this.getPointOnCubicBezier(t3, x2, y2, points[0], points[1], points[2], points[3], points[4], points[5]);
          len += this.getLineLength(p12.x, p12.y, p22.x, p22.y);
          p12 = p22;
        }
        return len;
      case PathParser.QUAD_TO:
        len = 0;
        p12 = this.getPointOnQuadraticBezier(0, x2, y2, points[0], points[1], points[2], points[3]);
        for (t3 = 0.01; t3 <= 1; t3 += 0.01) {
          p22 = this.getPointOnQuadraticBezier(t3, x2, y2, points[0], points[1], points[2], points[3]);
          len += this.getLineLength(p12.x, p12.y, p22.x, p22.y);
          p12 = p22;
        }
        return len;
      case PathParser.ARC: {
        len = 0;
        var start2 = points[4];
        var dTheta = points[5];
        var end = points[4] + dTheta;
        var inc = Math.PI / 180;
        if (Math.abs(start2 - end) < inc) {
          inc = Math.abs(start2 - end);
        }
        p12 = this.getPointOnEllipticalArc(points[0], points[1], points[2], points[3], start2, 0);
        if (dTheta < 0) {
          for (t3 = start2 - inc; t3 > end; t3 -= inc) {
            p22 = this.getPointOnEllipticalArc(points[0], points[1], points[2], points[3], t3, 0);
            len += this.getLineLength(p12.x, p12.y, p22.x, p22.y);
            p12 = p22;
          }
        } else {
          for (t3 = start2 + inc; t3 < end; t3 += inc) {
            p22 = this.getPointOnEllipticalArc(points[0], points[1], points[2], points[3], t3, 0);
            len += this.getLineLength(p12.x, p12.y, p22.x, p22.y);
            p12 = p22;
          }
        }
        p22 = this.getPointOnEllipticalArc(points[0], points[1], points[2], points[3], end, 0);
        len += this.getLineLength(p12.x, p12.y, p22.x, p22.y);
        return len;
      }
    }
    return 0;
  }
  getPointOnLine(dist, p1x, p1y, p2x, p2y) {
    var fromX = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : p1x;
    var fromY = arguments.length > 6 && arguments[6] !== void 0 ? arguments[6] : p1y;
    var m2 = (p2y - p1y) / (p2x - p1x + PSEUDO_ZERO);
    var run2 = Math.sqrt(dist * dist / (1 + m2 * m2));
    if (p2x < p1x) {
      run2 *= -1;
    }
    var rise = m2 * run2;
    var pt2 = null;
    if (p2x === p1x) {
      pt2 = {
        x: fromX,
        y: fromY + rise
      };
    } else if ((fromY - p1y) / (fromX - p1x + PSEUDO_ZERO) === m2) {
      pt2 = {
        x: fromX + run2,
        y: fromY + rise
      };
    } else {
      var ix = 0;
      var iy = 0;
      var len = this.getLineLength(p1x, p1y, p2x, p2y);
      if (len < PSEUDO_ZERO) {
        return null;
      }
      var u2 = (fromX - p1x) * (p2x - p1x) + (fromY - p1y) * (p2y - p1y);
      u2 /= len * len;
      ix = p1x + u2 * (p2x - p1x);
      iy = p1y + u2 * (p2y - p1y);
      var pRise = this.getLineLength(fromX, fromY, ix, iy);
      var pRun = Math.sqrt(dist * dist - pRise * pRise);
      run2 = Math.sqrt(pRun * pRun / (1 + m2 * m2));
      if (p2x < p1x) {
        run2 *= -1;
      }
      rise = m2 * run2;
      pt2 = {
        x: ix + run2,
        y: iy + rise
      };
    }
    return pt2;
  }
  getPointOnPath(distance2) {
    var fullLen = this.getPathLength();
    var cumulativePathLength = 0;
    var p5 = null;
    if (distance2 < -5e-5 || distance2 - 5e-5 > fullLen) {
      return null;
    }
    var {
      dataArray
    } = this;
    for (var command of dataArray) {
      if (command && (command.pathLength < 5e-5 || cumulativePathLength + command.pathLength + 5e-5 < distance2)) {
        cumulativePathLength += command.pathLength;
        continue;
      }
      var delta = distance2 - cumulativePathLength;
      var currentT = 0;
      switch (command.type) {
        case PathParser.LINE_TO:
          p5 = this.getPointOnLine(delta, command.start.x, command.start.y, command.points[0], command.points[1], command.start.x, command.start.y);
          break;
        case PathParser.ARC: {
          var start2 = command.points[4];
          var dTheta = command.points[5];
          var end = command.points[4] + dTheta;
          currentT = start2 + delta / command.pathLength * dTheta;
          if (dTheta < 0 && currentT < end || dTheta >= 0 && currentT > end) {
            break;
          }
          p5 = this.getPointOnEllipticalArc(command.points[0], command.points[1], command.points[2], command.points[3], currentT, command.points[6]);
          break;
        }
        case PathParser.CURVE_TO:
          currentT = delta / command.pathLength;
          if (currentT > 1) {
            currentT = 1;
          }
          p5 = this.getPointOnCubicBezier(currentT, command.start.x, command.start.y, command.points[0], command.points[1], command.points[2], command.points[3], command.points[4], command.points[5]);
          break;
        case PathParser.QUAD_TO:
          currentT = delta / command.pathLength;
          if (currentT > 1) {
            currentT = 1;
          }
          p5 = this.getPointOnQuadraticBezier(currentT, command.start.x, command.start.y, command.points[0], command.points[1], command.points[2], command.points[3]);
          break;
      }
      if (p5) {
        return p5;
      }
      break;
    }
    return null;
  }
  getLineLength(x1, y1, x2, y2) {
    return Math.sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1));
  }
  getPathLength() {
    if (this.pathLength === -1) {
      this.pathLength = this.dataArray.reduce((length, command) => command.pathLength > 0 ? length + command.pathLength : length, 0);
    }
    return this.pathLength;
  }
  getPointOnCubicBezier(pct, p1x, p1y, p2x, p2y, p3x, p3y, p4x, p4y) {
    var x2 = p4x * CB1(pct) + p3x * CB2(pct) + p2x * CB3(pct) + p1x * CB4(pct);
    var y2 = p4y * CB1(pct) + p3y * CB2(pct) + p2y * CB3(pct) + p1y * CB4(pct);
    return {
      x: x2,
      y: y2
    };
  }
  getPointOnQuadraticBezier(pct, p1x, p1y, p2x, p2y, p3x, p3y) {
    var x2 = p3x * QB1(pct) + p2x * QB2(pct) + p1x * QB3(pct);
    var y2 = p3y * QB1(pct) + p2y * QB2(pct) + p1y * QB3(pct);
    return {
      x: x2,
      y: y2
    };
  }
  getPointOnEllipticalArc(cx, cy, rx, ry, theta, psi) {
    var cosPsi = Math.cos(psi);
    var sinPsi = Math.sin(psi);
    var pt2 = {
      x: rx * Math.cos(theta),
      y: ry * Math.sin(theta)
    };
    return {
      x: cx + (pt2.x * cosPsi - pt2.y * sinPsi),
      y: cy + (pt2.x * sinPsi + pt2.y * cosPsi)
    };
  }
  buildEquidistantCache(inputStep, inputPrecision) {
    var fullLen = this.getPathLength();
    var precision = inputPrecision || 0.25;
    var step = inputStep || fullLen / 100;
    if (!this.equidistantCache || this.equidistantCache.step !== step || this.equidistantCache.precision !== precision) {
      this.equidistantCache = {
        step,
        precision,
        points: []
      };
      var s2 = 0;
      for (var l2 = 0; l2 <= fullLen; l2 += precision) {
        var p0 = this.getPointOnPath(l2);
        var p12 = this.getPointOnPath(l2 + precision);
        if (!p0 || !p12) {
          continue;
        }
        s2 += this.getLineLength(p0.x, p0.y, p12.x, p12.y);
        if (s2 >= step) {
          this.equidistantCache.points.push({
            x: p0.x,
            y: p0.y,
            distance: l2
          });
          s2 -= step;
        }
      }
    }
  }
  getEquidistantPointOnPath(targetDistance, step, precision) {
    this.buildEquidistantCache(step, precision);
    if (targetDistance < 0 || targetDistance - this.getPathLength() > 5e-5) {
      return null;
    }
    var idx = Math.round(targetDistance / this.getPathLength() * (this.equidistantCache.points.length - 1));
    return this.equidistantCache.points[idx] || null;
  }
};
var dataUriRegex = /^\s*data:(([^/,;]+\/[^/,;]+)(?:;([^,;=]+=[^,;=]+))?)?(?:;(base64))?,(.*)$/i;
var ImageElement = class extends RenderedElement {
  constructor(document2, node2, captureTextNodes) {
    super(document2, node2, captureTextNodes);
    this.type = "image";
    this.loaded = false;
    var href = this.getHrefAttribute().getString();
    if (!href) {
      return;
    }
    var isSvg = href.endsWith(".svg") || /^\s*data:image\/svg\+xml/i.test(href);
    document2.images.push(this);
    if (!isSvg) {
      void this.loadImage(href);
    } else {
      void this.loadSvg(href);
    }
    this.isSvg = isSvg;
  }
  loadImage(href) {
    var _this = this;
    return _asyncToGenerator(function* () {
      try {
        var image2 = yield _this.document.createImage(href);
        _this.image = image2;
      } catch (err) {
        console.error('Error while loading image "'.concat(href, '":'), err);
      }
      _this.loaded = true;
    })();
  }
  loadSvg(href) {
    var _this2 = this;
    return _asyncToGenerator(function* () {
      var match2 = dataUriRegex.exec(href);
      if (match2) {
        var data2 = match2[5];
        if (match2[4] === "base64") {
          _this2.image = atob(data2);
        } else {
          _this2.image = decodeURIComponent(data2);
        }
      } else {
        try {
          var response = yield _this2.document.fetch(href);
          var svg2 = yield response.text();
          _this2.image = svg2;
        } catch (err) {
          console.error('Error while loading image "'.concat(href, '":'), err);
        }
      }
      _this2.loaded = true;
    })();
  }
  renderChildren(ctx) {
    var {
      document: document2,
      image: image2,
      loaded
    } = this;
    var x2 = this.getAttribute("x").getPixels("x");
    var y2 = this.getAttribute("y").getPixels("y");
    var width = this.getStyle("width").getPixels("x");
    var height = this.getStyle("height").getPixels("y");
    if (!loaded || !image2 || !width || !height) {
      return;
    }
    ctx.save();
    ctx.translate(x2, y2);
    if (this.isSvg) {
      var subDocument = document2.canvg.forkString(ctx, this.image, {
        ignoreMouse: true,
        ignoreAnimation: true,
        ignoreDimensions: true,
        ignoreClear: true,
        offsetX: 0,
        offsetY: 0,
        scaleWidth: width,
        scaleHeight: height
      });
      subDocument.document.documentElement.parent = this;
      void subDocument.render();
    } else {
      var _image = this.image;
      document2.setViewBox({
        ctx,
        aspectRatio: this.getAttribute("preserveAspectRatio").getString(),
        width,
        desiredWidth: _image.width,
        height,
        desiredHeight: _image.height
      });
      if (this.loaded) {
        if (typeof _image.complete === "undefined" || _image.complete) {
          ctx.drawImage(_image, 0, 0);
        }
      }
    }
    ctx.restore();
  }
  getBoundingBox() {
    var x2 = this.getAttribute("x").getPixels("x");
    var y2 = this.getAttribute("y").getPixels("y");
    var width = this.getStyle("width").getPixels("x");
    var height = this.getStyle("height").getPixels("y");
    return new BoundingBox(x2, y2, x2 + width, y2 + height);
  }
};
var SymbolElement = class extends RenderedElement {
  constructor() {
    super(...arguments);
    this.type = "symbol";
  }
  render(_2) {
  }
};
var SVGFontLoader = class {
  constructor(document2) {
    this.document = document2;
    this.loaded = false;
    document2.fonts.push(this);
  }
  load(fontFamily2, url) {
    var _this = this;
    return _asyncToGenerator(function* () {
      try {
        var {
          document: document2
        } = _this;
        var svgDocument = yield document2.canvg.parser.load(url);
        var fonts = svgDocument.getElementsByTagName("font");
        Array.from(fonts).forEach((fontNode) => {
          var font = document2.createElement(fontNode);
          document2.definitions[fontFamily2] = font;
        });
      } catch (err) {
        console.error('Error while loading font "'.concat(url, '":'), err);
      }
      _this.loaded = true;
    })();
  }
};
var StyleElement = class extends Element$1 {
  constructor(document2, node2, captureTextNodes) {
    super(document2, node2, captureTextNodes);
    this.type = "style";
    var css = compressSpaces(Array.from(node2.childNodes).map((_2) => _2.textContent).join("").replace(/(\/\*([^*]|[\r\n]|(\*+([^*/]|[\r\n])))*\*+\/)|(^[\s]*\/\/.*)/gm, "").replace(/@import.*;/g, ""));
    var cssDefs = css.split("}");
    cssDefs.forEach((_2) => {
      var def = _2.trim();
      if (!def) {
        return;
      }
      var cssParts = def.split("{");
      var cssClasses = cssParts[0].split(",");
      var cssProps = cssParts[1].split(";");
      cssClasses.forEach((_3) => {
        var cssClass = _3.trim();
        if (!cssClass) {
          return;
        }
        var props = document2.styles[cssClass] || {};
        cssProps.forEach((cssProp) => {
          var prop = cssProp.indexOf(":");
          var name = cssProp.substr(0, prop).trim();
          var value = cssProp.substr(prop + 1, cssProp.length - prop).trim();
          if (name && value) {
            props[name] = new Property(document2, name, value);
          }
        });
        document2.styles[cssClass] = props;
        document2.stylesSpecificity[cssClass] = getSelectorSpecificity(cssClass);
        if (cssClass === "@font-face") {
          var fontFamily2 = props["font-family"].getString().replace(/"|'/g, "");
          var srcs = props.src.getString().split(",");
          srcs.forEach((src) => {
            if (src.indexOf('format("svg")') > 0) {
              var url = parseExternalUrl(src);
              if (url) {
                void new SVGFontLoader(document2).load(fontFamily2, url);
              }
            }
          });
        }
      });
    });
  }
};
StyleElement.parseExternalUrl = parseExternalUrl;
var UseElement = class extends RenderedElement {
  constructor() {
    super(...arguments);
    this.type = "use";
  }
  setContext(ctx) {
    super.setContext(ctx);
    var xAttr = this.getAttribute("x");
    var yAttr = this.getAttribute("y");
    if (xAttr.hasValue()) {
      ctx.translate(xAttr.getPixels("x"), 0);
    }
    if (yAttr.hasValue()) {
      ctx.translate(0, yAttr.getPixels("y"));
    }
  }
  path(ctx) {
    var {
      element
    } = this;
    if (element) {
      element.path(ctx);
    }
  }
  renderChildren(ctx) {
    var {
      document: document2,
      element
    } = this;
    if (element) {
      var tempSvg = element;
      if (element.type === "symbol") {
        tempSvg = new SVGElement(document2, null);
        tempSvg.attributes.viewBox = new Property(document2, "viewBox", element.getAttribute("viewBox").getString());
        tempSvg.attributes.preserveAspectRatio = new Property(document2, "preserveAspectRatio", element.getAttribute("preserveAspectRatio").getString());
        tempSvg.attributes.overflow = new Property(document2, "overflow", element.getAttribute("overflow").getString());
        tempSvg.children = element.children;
        element.styles.opacity = new Property(document2, "opacity", this.calculateOpacity());
      }
      if (tempSvg.type === "svg") {
        var widthStyle = this.getStyle("width", false, true);
        var heightStyle = this.getStyle("height", false, true);
        if (widthStyle.hasValue()) {
          tempSvg.attributes.width = new Property(document2, "width", widthStyle.getString());
        }
        if (heightStyle.hasValue()) {
          tempSvg.attributes.height = new Property(document2, "height", heightStyle.getString());
        }
      }
      var oldParent = tempSvg.parent;
      tempSvg.parent = this;
      tempSvg.render(ctx);
      tempSvg.parent = oldParent;
    }
  }
  getBoundingBox(ctx) {
    var {
      element
    } = this;
    if (element) {
      return element.getBoundingBox(ctx);
    }
    return null;
  }
  elementTransform() {
    var {
      document: document2,
      element
    } = this;
    return Transform.fromElement(document2, element);
  }
  get element() {
    if (!this.cachedElement) {
      this.cachedElement = this.getHrefAttribute().getDefinition();
    }
    return this.cachedElement;
  }
};
function imGet(img, x2, y2, width, _height, rgba) {
  return img[y2 * width * 4 + x2 * 4 + rgba];
}
function imSet(img, x2, y2, width, _height, rgba, val) {
  img[y2 * width * 4 + x2 * 4 + rgba] = val;
}
function m(matrix2, i2, v2) {
  var mi = matrix2[i2];
  return mi * v2;
}
function c(a2, m1, m2, m3) {
  return m1 + Math.cos(a2) * m2 + Math.sin(a2) * m3;
}
var FeColorMatrixElement = class extends Element$1 {
  constructor(document2, node2, captureTextNodes) {
    super(document2, node2, captureTextNodes);
    this.type = "feColorMatrix";
    var matrix2 = toNumbers(this.getAttribute("values").getString());
    switch (this.getAttribute("type").getString("matrix")) {
      case "saturate": {
        var s2 = matrix2[0];
        matrix2 = [0.213 + 0.787 * s2, 0.715 - 0.715 * s2, 0.072 - 0.072 * s2, 0, 0, 0.213 - 0.213 * s2, 0.715 + 0.285 * s2, 0.072 - 0.072 * s2, 0, 0, 0.213 - 0.213 * s2, 0.715 - 0.715 * s2, 0.072 + 0.928 * s2, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1];
        break;
      }
      case "hueRotate": {
        var a2 = matrix2[0] * Math.PI / 180;
        matrix2 = [c(a2, 0.213, 0.787, -0.213), c(a2, 0.715, -0.715, -0.715), c(a2, 0.072, -0.072, 0.928), 0, 0, c(a2, 0.213, -0.213, 0.143), c(a2, 0.715, 0.285, 0.14), c(a2, 0.072, -0.072, -0.283), 0, 0, c(a2, 0.213, -0.213, -0.787), c(a2, 0.715, -0.715, 0.715), c(a2, 0.072, 0.928, 0.072), 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1];
        break;
      }
      case "luminanceToAlpha":
        matrix2 = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0.2125, 0.7154, 0.0721, 0, 0, 0, 0, 0, 0, 1];
        break;
    }
    this.matrix = matrix2;
    this.includeOpacity = this.getAttribute("includeOpacity").hasValue();
  }
  apply(ctx, _x, _y, width, height) {
    var {
      includeOpacity,
      matrix: matrix2
    } = this;
    var srcData = ctx.getImageData(0, 0, width, height);
    for (var y2 = 0; y2 < height; y2++) {
      for (var x2 = 0; x2 < width; x2++) {
        var r2 = imGet(srcData.data, x2, y2, width, height, 0);
        var g2 = imGet(srcData.data, x2, y2, width, height, 1);
        var b2 = imGet(srcData.data, x2, y2, width, height, 2);
        var a2 = imGet(srcData.data, x2, y2, width, height, 3);
        var nr = m(matrix2, 0, r2) + m(matrix2, 1, g2) + m(matrix2, 2, b2) + m(matrix2, 3, a2) + m(matrix2, 4, 1);
        var ng = m(matrix2, 5, r2) + m(matrix2, 6, g2) + m(matrix2, 7, b2) + m(matrix2, 8, a2) + m(matrix2, 9, 1);
        var nb = m(matrix2, 10, r2) + m(matrix2, 11, g2) + m(matrix2, 12, b2) + m(matrix2, 13, a2) + m(matrix2, 14, 1);
        var na = m(matrix2, 15, r2) + m(matrix2, 16, g2) + m(matrix2, 17, b2) + m(matrix2, 18, a2) + m(matrix2, 19, 1);
        if (includeOpacity) {
          nr = 0;
          ng = 0;
          nb = 0;
          na *= a2 / 255;
        }
        imSet(srcData.data, x2, y2, width, height, 0, nr);
        imSet(srcData.data, x2, y2, width, height, 1, ng);
        imSet(srcData.data, x2, y2, width, height, 2, nb);
        imSet(srcData.data, x2, y2, width, height, 3, na);
      }
    }
    ctx.clearRect(0, 0, width, height);
    ctx.putImageData(srcData, 0, 0);
  }
};
var MaskElement = class extends Element$1 {
  constructor() {
    super(...arguments);
    this.type = "mask";
  }
  apply(ctx, element) {
    var {
      document: document2
    } = this;
    var x2 = this.getAttribute("x").getPixels("x");
    var y2 = this.getAttribute("y").getPixels("y");
    var width = this.getStyle("width").getPixels("x");
    var height = this.getStyle("height").getPixels("y");
    if (!width && !height) {
      var boundingBox = new BoundingBox();
      this.children.forEach((child) => {
        boundingBox.addBoundingBox(child.getBoundingBox(ctx));
      });
      x2 = Math.floor(boundingBox.x1);
      y2 = Math.floor(boundingBox.y1);
      width = Math.floor(boundingBox.width);
      height = Math.floor(boundingBox.height);
    }
    var ignoredStyles = this.removeStyles(element, MaskElement.ignoreStyles);
    var maskCanvas = document2.createCanvas(x2 + width, y2 + height);
    var maskCtx = maskCanvas.getContext("2d");
    document2.screen.setDefaults(maskCtx);
    this.renderChildren(maskCtx);
    new FeColorMatrixElement(document2, {
      nodeType: 1,
      childNodes: [],
      attributes: [{
        nodeName: "type",
        value: "luminanceToAlpha"
      }, {
        nodeName: "includeOpacity",
        value: "true"
      }]
    }).apply(maskCtx, 0, 0, x2 + width, y2 + height);
    var tmpCanvas = document2.createCanvas(x2 + width, y2 + height);
    var tmpCtx = tmpCanvas.getContext("2d");
    document2.screen.setDefaults(tmpCtx);
    element.render(tmpCtx);
    tmpCtx.globalCompositeOperation = "destination-in";
    tmpCtx.fillStyle = maskCtx.createPattern(maskCanvas, "no-repeat");
    tmpCtx.fillRect(0, 0, x2 + width, y2 + height);
    ctx.fillStyle = tmpCtx.createPattern(tmpCanvas, "no-repeat");
    ctx.fillRect(0, 0, x2 + width, y2 + height);
    this.restoreStyles(element, ignoredStyles);
  }
  render(_2) {
  }
};
MaskElement.ignoreStyles = ["mask", "transform", "clip-path"];
var noop = () => {
};
var ClipPathElement = class extends Element$1 {
  constructor() {
    super(...arguments);
    this.type = "clipPath";
  }
  apply(ctx) {
    var {
      document: document2
    } = this;
    var contextProto = Reflect.getPrototypeOf(ctx);
    var {
      beginPath,
      closePath
    } = ctx;
    if (contextProto) {
      contextProto.beginPath = noop;
      contextProto.closePath = noop;
    }
    Reflect.apply(beginPath, ctx, []);
    this.children.forEach((child) => {
      if (typeof child.path === "undefined") {
        return;
      }
      var transform2 = typeof child.elementTransform !== "undefined" ? child.elementTransform() : null;
      if (!transform2) {
        transform2 = Transform.fromElement(document2, child);
      }
      if (transform2) {
        transform2.apply(ctx);
      }
      child.path(ctx);
      if (contextProto) {
        contextProto.closePath = closePath;
      }
      if (transform2) {
        transform2.unapply(ctx);
      }
    });
    Reflect.apply(closePath, ctx, []);
    ctx.clip();
    if (contextProto) {
      contextProto.beginPath = beginPath;
      contextProto.closePath = closePath;
    }
  }
  render(_2) {
  }
};
var FilterElement = class extends Element$1 {
  constructor() {
    super(...arguments);
    this.type = "filter";
  }
  apply(ctx, element) {
    var {
      document: document2,
      children
    } = this;
    var boundingBox = element.getBoundingBox(ctx);
    if (!boundingBox) {
      return;
    }
    var px = 0;
    var py = 0;
    children.forEach((child) => {
      var efd = child.extraFilterDistance || 0;
      px = Math.max(px, efd);
      py = Math.max(py, efd);
    });
    var width = Math.floor(boundingBox.width);
    var height = Math.floor(boundingBox.height);
    var tmpCanvasWidth = width + 2 * px;
    var tmpCanvasHeight = height + 2 * py;
    if (tmpCanvasWidth < 1 || tmpCanvasHeight < 1) {
      return;
    }
    var x2 = Math.floor(boundingBox.x);
    var y2 = Math.floor(boundingBox.y);
    var ignoredStyles = this.removeStyles(element, FilterElement.ignoreStyles);
    var tmpCanvas = document2.createCanvas(tmpCanvasWidth, tmpCanvasHeight);
    var tmpCtx = tmpCanvas.getContext("2d");
    document2.screen.setDefaults(tmpCtx);
    tmpCtx.translate(-x2 + px, -y2 + py);
    element.render(tmpCtx);
    children.forEach((child) => {
      if (typeof child.apply === "function") {
        child.apply(tmpCtx, 0, 0, tmpCanvasWidth, tmpCanvasHeight);
      }
    });
    ctx.drawImage(tmpCanvas, 0, 0, tmpCanvasWidth, tmpCanvasHeight, x2 - px, y2 - py, tmpCanvasWidth, tmpCanvasHeight);
    this.restoreStyles(element, ignoredStyles);
  }
  render(_2) {
  }
};
FilterElement.ignoreStyles = ["filter", "transform", "clip-path"];
var FeDropShadowElement = class extends Element$1 {
  constructor(document2, node2, captureTextNodes) {
    super(document2, node2, captureTextNodes);
    this.type = "feDropShadow";
    this.addStylesFromStyleDefinition();
  }
  apply(_2, _x, _y, _width, _height) {
  }
};
var FeMorphologyElement = class extends Element$1 {
  constructor() {
    super(...arguments);
    this.type = "feMorphology";
  }
  apply(_2, _x, _y, _width, _height) {
  }
};
var FeCompositeElement = class extends Element$1 {
  constructor() {
    super(...arguments);
    this.type = "feComposite";
  }
  apply(_2, _x, _y, _width, _height) {
  }
};
var FeGaussianBlurElement = class extends Element$1 {
  constructor(document2, node2, captureTextNodes) {
    super(document2, node2, captureTextNodes);
    this.type = "feGaussianBlur";
    this.blurRadius = Math.floor(this.getAttribute("stdDeviation").getNumber());
    this.extraFilterDistance = this.blurRadius;
  }
  apply(ctx, x2, y2, width, height) {
    var {
      document: document2,
      blurRadius
    } = this;
    var body = document2.window ? document2.window.document.body : null;
    var canvas = ctx.canvas;
    canvas.id = document2.getUniqueId();
    if (body) {
      canvas.style.display = "none";
      body.appendChild(canvas);
    }
    processCanvasRGBA(canvas, x2, y2, width, height, blurRadius);
    if (body) {
      body.removeChild(canvas);
    }
  }
};
var TitleElement = class extends Element$1 {
  constructor() {
    super(...arguments);
    this.type = "title";
  }
};
var DescElement = class extends Element$1 {
  constructor() {
    super(...arguments);
    this.type = "desc";
  }
};
var elements = {
  "svg": SVGElement,
  "rect": RectElement,
  "circle": CircleElement,
  "ellipse": EllipseElement,
  "line": LineElement,
  "polyline": PolylineElement,
  "polygon": PolygonElement,
  "path": PathElement,
  "pattern": PatternElement,
  "marker": MarkerElement,
  "defs": DefsElement,
  "linearGradient": LinearGradientElement,
  "radialGradient": RadialGradientElement,
  "stop": StopElement,
  "animate": AnimateElement,
  "animateColor": AnimateColorElement,
  "animateTransform": AnimateTransformElement,
  "font": FontElement,
  "font-face": FontFaceElement,
  "missing-glyph": MissingGlyphElement,
  "glyph": GlyphElement,
  "text": TextElement,
  "tspan": TSpanElement,
  "tref": TRefElement,
  "a": AElement,
  "textPath": TextPathElement,
  "image": ImageElement,
  "g": GElement,
  "symbol": SymbolElement,
  "style": StyleElement,
  "use": UseElement,
  "mask": MaskElement,
  "clipPath": ClipPathElement,
  "filter": FilterElement,
  "feDropShadow": FeDropShadowElement,
  "feMorphology": FeMorphologyElement,
  "feComposite": FeCompositeElement,
  "feColorMatrix": FeColorMatrixElement,
  "feGaussianBlur": FeGaussianBlurElement,
  "title": TitleElement,
  "desc": DescElement
};
function ownKeys$1(object, enumerableOnly) {
  var keys3 = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly)
      symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      });
    keys3.push.apply(keys3, symbols);
  }
  return keys3;
}
function _objectSpread$1(target) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source = arguments[i2] != null ? arguments[i2] : {};
    if (i2 % 2) {
      ownKeys$1(Object(source), true).forEach(function(key) {
        _defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys$1(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }
  return target;
}
function createCanvas(width, height) {
  var canvas = document.createElement("canvas");
  canvas.width = width;
  canvas.height = height;
  return canvas;
}
function createImage(_x) {
  return _createImage.apply(this, arguments);
}
function _createImage() {
  _createImage = _asyncToGenerator(function* (src) {
    var anonymousCrossOrigin = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
    var image2 = document.createElement("img");
    if (anonymousCrossOrigin) {
      image2.crossOrigin = "Anonymous";
    }
    return new Promise((resolve2, reject2) => {
      image2.onload = () => {
        resolve2(image2);
      };
      image2.onerror = (_event, _source, _lineno, _colno, error) => {
        reject2(error);
      };
      image2.src = src;
    });
  });
  return _createImage.apply(this, arguments);
}
var Document = class {
  constructor(canvg) {
    var {
      rootEmSize = 12,
      emSize = 12,
      createCanvas: createCanvas2 = Document.createCanvas,
      createImage: createImage2 = Document.createImage,
      anonymousCrossOrigin
    } = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    this.canvg = canvg;
    this.definitions = {};
    this.styles = {};
    this.stylesSpecificity = {};
    this.images = [];
    this.fonts = [];
    this.emSizeStack = [];
    this.uniqueId = 0;
    this.screen = canvg.screen;
    this.rootEmSize = rootEmSize;
    this.emSize = emSize;
    this.createCanvas = createCanvas2;
    this.createImage = this.bindCreateImage(createImage2, anonymousCrossOrigin);
    this.screen.wait(this.isImagesLoaded.bind(this));
    this.screen.wait(this.isFontsLoaded.bind(this));
  }
  bindCreateImage(createImage2, anonymousCrossOrigin) {
    if (typeof anonymousCrossOrigin === "boolean") {
      return (source, forceAnonymousCrossOrigin) => createImage2(source, typeof forceAnonymousCrossOrigin === "boolean" ? forceAnonymousCrossOrigin : anonymousCrossOrigin);
    }
    return createImage2;
  }
  get window() {
    return this.screen.window;
  }
  get fetch() {
    return this.screen.fetch;
  }
  get ctx() {
    return this.screen.ctx;
  }
  get emSize() {
    var {
      emSizeStack
    } = this;
    return emSizeStack[emSizeStack.length - 1];
  }
  set emSize(value) {
    var {
      emSizeStack
    } = this;
    emSizeStack.push(value);
  }
  popEmSize() {
    var {
      emSizeStack
    } = this;
    emSizeStack.pop();
  }
  getUniqueId() {
    return "canvg".concat(++this.uniqueId);
  }
  isImagesLoaded() {
    return this.images.every((_2) => _2.loaded);
  }
  isFontsLoaded() {
    return this.fonts.every((_2) => _2.loaded);
  }
  createDocumentElement(document2) {
    var documentElement = this.createElement(document2.documentElement);
    documentElement.root = true;
    documentElement.addStylesFromStyleDefinition();
    this.documentElement = documentElement;
    return documentElement;
  }
  createElement(node2) {
    var elementType = node2.nodeName.replace(/^[^:]+:/, "");
    var ElementType = Document.elementTypes[elementType];
    if (typeof ElementType !== "undefined") {
      return new ElementType(this, node2);
    }
    return new UnknownElement(this, node2);
  }
  createTextNode(node2) {
    return new TextNode(this, node2);
  }
  setViewBox(config) {
    this.screen.setViewBox(_objectSpread$1({
      document: this
    }, config));
  }
};
Document.createCanvas = createCanvas;
Document.createImage = createImage;
Document.elementTypes = elements;
function ownKeys2(object, enumerableOnly) {
  var keys3 = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly)
      symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      });
    keys3.push.apply(keys3, symbols);
  }
  return keys3;
}
function _objectSpread(target) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source = arguments[i2] != null ? arguments[i2] : {};
    if (i2 % 2) {
      ownKeys2(Object(source), true).forEach(function(key) {
        _defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys2(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }
  return target;
}
var Canvg = class {
  constructor(ctx, svg2) {
    var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    this.parser = new Parser(options);
    this.screen = new Screen(ctx, options);
    this.options = options;
    var document2 = new Document(this, options);
    var documentElement = document2.createDocumentElement(svg2);
    this.document = document2;
    this.documentElement = documentElement;
  }
  static from(ctx, svg2) {
    var _arguments = arguments;
    return _asyncToGenerator(function* () {
      var options = _arguments.length > 2 && _arguments[2] !== void 0 ? _arguments[2] : {};
      var parser = new Parser(options);
      var svgDocument = yield parser.parse(svg2);
      return new Canvg(ctx, svgDocument, options);
    })();
  }
  static fromString(ctx, svg2) {
    var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    var parser = new Parser(options);
    var svgDocument = parser.parseFromString(svg2);
    return new Canvg(ctx, svgDocument, options);
  }
  fork(ctx, svg2) {
    var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return Canvg.from(ctx, svg2, _objectSpread(_objectSpread({}, this.options), options));
  }
  forkString(ctx, svg2) {
    var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return Canvg.fromString(ctx, svg2, _objectSpread(_objectSpread({}, this.options), options));
  }
  ready() {
    return this.screen.ready();
  }
  isReady() {
    return this.screen.isReady();
  }
  render() {
    var _arguments2 = arguments, _this = this;
    return _asyncToGenerator(function* () {
      var options = _arguments2.length > 0 && _arguments2[0] !== void 0 ? _arguments2[0] : {};
      _this.start(_objectSpread({
        enableRedraw: true,
        ignoreAnimation: true,
        ignoreMouse: true
      }, options));
      yield _this.ready();
      _this.stop();
    })();
  }
  start() {
    var options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    var {
      documentElement,
      screen,
      options: baseOptions
    } = this;
    screen.start(documentElement, _objectSpread(_objectSpread({
      enableRedraw: true
    }, baseOptions), options));
  }
  stop() {
    this.screen.stop();
  }
  resize(width) {
    var height = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : width;
    var preserveAspectRatio = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
    this.documentElement.resize(width, height, preserveAspectRatio);
  }
};
var index_es = Object.freeze(Object.defineProperty({
  __proto__: null,
  "default": Canvg,
  AElement,
  AnimateColorElement,
  AnimateElement,
  AnimateTransformElement,
  BoundingBox,
  CB1,
  CB2,
  CB3,
  CB4,
  Canvg,
  CircleElement,
  ClipPathElement,
  DefsElement,
  DescElement,
  Document,
  Element: Element$1,
  EllipseElement,
  FeColorMatrixElement,
  FeCompositeElement,
  FeDropShadowElement,
  FeGaussianBlurElement,
  FeMorphologyElement,
  FilterElement,
  Font,
  FontElement,
  FontFaceElement,
  GElement,
  GlyphElement,
  GradientElement,
  ImageElement,
  LineElement,
  LinearGradientElement,
  MarkerElement,
  MaskElement,
  Matrix,
  MissingGlyphElement,
  Mouse,
  PSEUDO_ZERO,
  Parser,
  PathElement,
  PathParser,
  PatternElement,
  Point,
  PolygonElement,
  PolylineElement,
  Property,
  QB1,
  QB2,
  QB3,
  RadialGradientElement,
  RectElement,
  RenderedElement,
  Rotate,
  SVGElement,
  SVGFontLoader,
  Scale,
  Screen,
  Skew,
  SkewX,
  SkewY,
  StopElement,
  StyleElement,
  SymbolElement,
  TRefElement,
  TSpanElement,
  TextElement,
  TextPathElement,
  TitleElement,
  Transform,
  Translate,
  UnknownElement,
  UseElement,
  ViewPort,
  compressSpaces,
  getSelectorSpecificity,
  normalizeAttributeName,
  normalizeColor,
  parseExternalUrl,
  presets: index,
  toNumbers,
  trimLeft,
  trimRight,
  vectorMagnitude,
  vectorsAngle,
  vectorsRatio
}, Symbol.toStringTag, { value: "Module" }));
export {
  Animations,
  Geometries,
  Interactions,
  Layers,
  Map$1 as Map,
  MapControls,
  Sources,
  Styles,
  install as default,
  install
};
/*!
  * ol-contextmenu - v4.1.0
  * https://github.com/jonataswalker/ol-contextmenu
  * Built: Sat Aug 15 2020 10:43:26 GMT-0300 (Brasilia Standard Time)
  */
/*!
 * html2canvas 1.4.1 <https://html2canvas.hertzen.com>
 * Copyright (c) 2022 Niklas von Hertzen <https://hertzen.com>
 * Released under MIT License
 */
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
/*! @license DOMPurify 2.3.5 | (c) Cure53 and other contributors | Released under the Apache license 2.0 and Mozilla Public License 2.0 | github.com/cure53/DOMPurify/blob/2.3.5/LICENSE */
/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
/**
 * @license
  Copyright (c) 2008, Adobe Systems Incorporated
  All rights reserved.

  Redistribution and use in source and binary forms, with or without 
  modification, are permitted provided that the following conditions are
  met:

  * Redistributions of source code must retain the above copyright notice, 
    this list of conditions and the following disclaimer.
  
  * Redistributions in binary form must reproduce the above copyright
    notice, this list of conditions and the following disclaimer in the 
    documentation and/or other materials provided with the distribution.
  
  * Neither the name of Adobe Systems Incorporated nor the names of its 
    contributors may be used to endorse or promote products derived from 
    this software without specific prior written permission.

  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
  IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
  THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
  PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR 
  CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
  EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
  PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/
/**
 * @license
 *
 * Copyright (c) 2014 James Robb, https://github.com/jamesbrobb
 *
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
 * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
 * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
 * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 * ====================================================================
 */
/**
 * @license
 * (c) Dean McNamee <dean@gmail.com>, 2013.
 *
 * https://github.com/deanm/omggif
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to
 * deal in the Software without restriction, including without limitation the
 * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
 * sell copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
 * IN THE SOFTWARE.
 *
 * omggif is a JavaScript implementation of a GIF 89a encoder and decoder,
 * including animation and compression.  It does not rely on any specific
 * underlying system, so should run in the browser, Node, or Plask.
 */
/**
 * @license
 * Copyright (c) 2017 Aras Abbasi
 *
 * Licensed under the MIT License.
 * http://opensource.org/licenses/mit-license
 */
/**
 * @license
 * FPDF is released under a permissive license: there is no usage restriction.
 * You may embed it freely in your application (commercial or not), with or
 * without modifications.
 *
 * Reference: http://www.fpdf.org/en/script/script37.php
 */
/**
 * @license
 * Joseph Myers does not specify a particular license for his work.
 *
 * Author: Joseph Myers
 * Accessed from: http://www.myersdaily.org/joseph/javascript/md5.js
 *
 * Modified by: Owen Leong
 */
/**
 * @license
 * Licensed under the MIT License.
 * http://opensource.org/licenses/mit-license
 * Author: Owen Leong (@owenl131)
 * Date: 15 Oct 2020
 * References:
 * https://www.cs.cmu.edu/~dst/Adobe/Gallery/anon21jul01-pdf-encryption.txt
 * https://github.com/foliojs/pdfkit/blob/master/lib/security.js
 * http://www.fpdf.org/en/script/script37.php
 */
/**
 * A class to parse color values
 * @author Stoyan Stefanov <sstoo@gmail.com>
 * {@link   http://www.phpied.com/rgb-color-parser-in-javascript/}
 * @license Use it if you like it
 */
/** @license
 *
 * jsPDF - PDF Document creation from JavaScript
 * Version 2.5.0 Built on 2021-12-21T09:44:51.866Z
 *                      CommitID 00000000
 *
 * Copyright (c) 2010-2021 James Hall <james@parall.ax>, https://github.com/MrRio/jsPDF
 *               2015-2021 yWorks GmbH, http://www.yworks.com
 *               2015-2021 Lukas Hollnder <lukas.hollaender@yworks.com>, https://github.com/HackbrettXXX
 *               2016-2018 Aras Abbasi <aras.abbasi@gmail.com>
 *               2010 Aaron Spike, https://github.com/acspike
 *               2012 Willow Systems Corporation, https://github.com/willowsystems
 *               2012 Pablo Hess, https://github.com/pablohess
 *               2012 Florian Jenett, https://github.com/fjenett
 *               2013 Warren Weckesser, https://github.com/warrenweckesser
 *               2013 Youssef Beddad, https://github.com/lifof
 *               2013 Lee Driscoll, https://github.com/lsdriscoll
 *               2013 Stefan Slonevskiy, https://github.com/stefslon
 *               2013 Jeremy Morel, https://github.com/jmorel
 *               2013 Christoph Hartmann, https://github.com/chris-rock
 *               2014 Juan Pablo Gaviria, https://github.com/juanpgaviria
 *               2014 James Makes, https://github.com/dollaruw
 *               2014 Diego Casorran, https://github.com/diegocr
 *               2014 Steven Spungin, https://github.com/Flamenco
 *               2014 Kenneth Glassey, https://github.com/Gavvers
 *
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
 * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
 * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
 * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 *
 * Contributor(s):
 *    siefkenj, ahwolf, rickygu, Midnith, saintclair, eaparango,
 *    kim3er, mfo, alnorth, Flamenco
 */
//# sourceMappingURL=vue3-openlayers.js.map
